{"task_id": "tsvc_s000", "prompt": "/*\nThis function takes a destination float array 'a', a source float array 'b', and their length 'n'.\nIt performs the element-wise operation: a[i] = b[i] + 1.0f;\nImplement this .\n*/\nvoid s000(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s000_scalar(float *a, const float *b, size_t n) {\n    for (size_t i = 0; i < n; i++) {\n        a[i] = b[i] + 1.0f;\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n// Assume Random.h and allclose.h are available in the include path\n#include \"Random.h\"\n#include \"allclose.h\"\n\n// Define constants from common.h\n#define LEN_1D 32000\n#define ITERATIONS 1 // For correctness, one iteration is enough\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s000_scalar(float *a, const float *b, size_t n);\nvoid s000_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    std::vector<float> b_input(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s000 from initialise_arrays()\n        for (size_t i = 0; i < length; ++i) {\n            b_input[i] = 2.0f + static_cast<float>(i);\n        }\n        // Initialize output arrays to a known-bad value\n        std::fill(a_scalar.begin(), a_scalar.end(), std::nanf(\"\"));\n        std::fill(a_simd.begin(), a_simd.end(), std::nanf(\"\"));\n\n        s000_scalar(a_scalar.data(), b_input.data(), length);\n        s000_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s000!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n// Assume Random.h is available\n#include \"Random.h\"\n\n// Define constants\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s000_scalar(float *a, const float *b, size_t n);\nvoid s000_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s000(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n\n    // Ported Initialization Logic for s000\n    for (size_t i = 0; i < length; ++i) {\n         b_input[i] = 2.0f + static_cast<float>(i);\n    }\n\n    for (auto _ : state) {\n        Func(a_output.data(), b_input.data(), length);\n        benchmark::DoNotOptimize(a_output.data());\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s000, s000_scalar)->Name(\"Scalar_s000\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s000, s000_simd)->Name(\"SIMD_s000\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s000", "entrypoint_scalar": "s000_scalar", "entrypoint_simd": "s000"}
{"task_id": "tsvc_s111", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs an element-wise operation with a stride of 2: a[i] = a[i - 1] + b[i];\nThis loop has a read-after-write dependency that is broken by the stride.\nImplement this .\n*/\nvoid s111(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s111_scalar(float *a, const float *b, size_t n) {\n    for (size_t i = 1; i < n; i += 2) {\n        a[i] = a[i - 1] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s111_scalar(float *a, const float *b, size_t n);\nvoid s111_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s111\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n        }\n        // Copy initial state for both runs\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s111_scalar(a_scalar.data(), b_input.data(), length);\n        s111_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s111!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s111_scalar(float *a, const float *b, size_t n);\nvoid s111_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s111(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s111\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n    }\n\n    for (auto _ : state) {\n        // Reset 'a' to initial state for each run\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory(); // Ensure writes are committed\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // Approx 1 read (b), 1 read/write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s111, s111_scalar)->Name(\"Scalar_s111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s111, s111_simd)->Name(\"SIMD_s111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s111", "entrypoint_scalar": "s111_scalar", "entrypoint_simd": "s111"}
{"task_id": "tsvc_s1111", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a strided write: a[2*i] = c[i]*b[i] + d[i]*b[i] + c[i]*c[i] + d[i]*b[i] + d[i]*c[i];\nIt loops 'n/2' times.\nImplement this .\n*/\nvoid s1111(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        a[2*i] = c[i] * b[i] + d[i] * b[i] + c[i] * c[i] + d[i] * b[i] + d[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1111 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s1111_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n        s1111_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1111!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1111(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s1111 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length/2) * sizeof(float) * 4); // 3 reads, 1 write (approx)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1111, s1111_scalar)->Name(\"Scalar_s1111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1111, s1111_simd)->Name(\"SIMD_s1111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1111", "entrypoint_scalar": "s1111_scalar", "entrypoint_simd": "s1111"}
{"task_id": "tsvc_s112", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs an operation in a reverse loop: a[i+1] = a[i] + b[i];\nThis tests dependency analysis in a backwards loop.\nImplement this .\n*/\nvoid s112(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s112_scalar(float *a, const float *b, size_t n) {\n    for (long long i = (long long)n - 2; i >= 0; --i) {\n        a[i+1] = a[i] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s112_scalar(float *a, const float *b, size_t n);\nvoid s112_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s112\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s112_scalar(a_scalar.data(), b_input.data(), length);\n        s112_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s112!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s112_scalar(float *a, const float *b, size_t n);\nvoid s112_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s112(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s112\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 3); // 1 read (b), 1 read/write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s112, s112_scalar)->Name(\"Scalar_s112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s112, s112_simd)->Name(\"SIMD_s112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s112", "entrypoint_scalar": "s112_scalar", "entrypoint_simd": "s112"}
{"task_id": "tsvc_s1112", "prompt": "/*\nThis function takes a destination float array 'a', a source float array 'b', and their length 'n'.\nIt performs an element-wise operation in a reverse loop: a[i] = b[i] + 1.0f;\nImplement this .\n*/\nvoid s1112(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s1112_scalar(float *a, const float *b, size_t n) {\n    for (long long i = (long long)n - 1; i >= 0; --i) {\n        a[i] = b[i] + 1.0f;\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s1112_scalar(float *a, const float *b, size_t n);\nvoid s1112_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    std::vector<float> b_input(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1112 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            b_input[i] = 1.0f;\n        }\n        std::fill(a_scalar.begin(), a_scalar.end(), std::nanf(\"\"));\n        std::fill(a_simd.begin(), a_simd.end(), std::nanf(\"\"));\n\n        s1112_scalar(a_scalar.data(), b_input.data(), length);\n        s1112_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1112!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s1112_scalar(float *a, const float *b, size_t n);\nvoid s1112_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1112(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n\n    // Ported Initialization Logic for s1112 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n         b_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        Func(a_output.data(), b_input.data(), length);\n        benchmark::DoNotOptimize(a_output.data());\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1112, s1112_scalar)->Name(\"Scalar_s1112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1112, s1112_simd)->Name(\"SIMD_s1112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1112", "entrypoint_scalar": "s1112_scalar", "entrypoint_simd": "s1112"}
{"task_id": "tsvc_s113", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[0] + b[i];\nThis tests dependency on a single broadcasted value (a[0]).\nImplement this .\n*/\nvoid s113(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s113_scalar(float *a, const float *b, size_t n) {\n\u00a0 \u00a0 float a0 = a[0];\n\u00a0 \u00a0 for (size_t i = 1; i < n; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = a0 + b[i];\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s113_scalar(float *a, const float *b, size_t n);\nvoid s113_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t length = Small_Arg_1D;\n\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_scalar(length);\n\u00a0 \u00a0 std::vector<float> a_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s113\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 a_scalar = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 a_simd = a_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s113_scalar(a_scalar.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 s113_simd(a_simd.data(), b_input.data(), length);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(a_scalar, a_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s113!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s113_scalar(float *a, const float *b, size_t n);\nvoid s113_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s113(benchmark::State& state) {\n\u00a0 \u00a0 size_t length = state.range(0);\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> a_output(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s113\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_output = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(a_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(b_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(a_output.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length - 1) * sizeof(float) * 2); // 1 read (b), 1 read/write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s113, s113_scalar)->Name(\"Scalar_s113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s113, s113_simd)->Name(\"SIMD_s113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s113", "entrypoint_scalar": "s113_scalar", "entrypoint_simd": "s113"}
{"task_id": "tsvc_s1113", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[n/2] + b[i];\nThis tests dependency on a single broadcasted value (a[n/2]).\nImplement this .\n*/\nvoid s1113(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s1113_scalar(float *a, const float *b, size_t n) {\n\u00a0 \u00a0 float a_mid = a[n/2];\n\u00a0 \u00a0 for (size_t i = 0; i < n; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = a_mid + b[i];\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1113_scalar(float *a, const float *b, size_t n);\nvoid s1113_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t length = Small_Arg_1D;\n\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_scalar(length);\n\u00a0 \u00a0 std::vector<float> a_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s1113 (uses default init())\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 a_scalar = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 a_simd = a_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s1113_scalar(a_scalar.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 s1113_simd(a_simd.data(), b_input.data(), length);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(a_scalar, a_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1113!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1113_scalar(float *a, const float *b, size_t n);\nvoid s1113_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1113(benchmark::State& state) {\n\u00a0 \u00a0 size_t length = state.range(0);\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> a_output(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s1113 (uses default init())\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f;\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_output = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(a_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(b_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(a_output.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1113, s1113_scalar)->Name(\"Scalar_s1113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1113, s1113_simd)->Name(\"SIMD_s1113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1113", "entrypoint_scalar": "s1113_scalar", "entrypoint_simd": "s1113"}
{"task_id": "tsvc_s114", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop operation: aa[i][j] = aa[j][i] + bb[i][j]; for j < i.\nThis tests complex dependencies (transpose vectorization).\nImplement this .\n*/\nvoid s114(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n\u00a0 \u00a0 for (size_t i = 0; i < n_2d; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t j = 0; j < i; j++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_flat[i * n_2d + j] = aa_flat[j * n_2d + i] + bb_flat[i * n_2d + j];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t n_2d = Small_Arg_2D;\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 \u00a0 std::vector<float> aa_scalar(length);\n\u00a0 \u00a0 std::vector<float> aa_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s114\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_initial[i] = 1.0f / (float)(i+1); // frac\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\nt \u00a0 \u00a0 \u00a0  }\n\u00a0 \u00a0 \u00a0 \u00a0 aa_scalar = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 aa_simd = aa_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s114_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 s114_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(aa_scalar, aa_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s114!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s114(benchmark::State& state) {\n\u00a0 \u00a0 size_t n_2d = state.range(0);\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> aa_output(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s114\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_initial[i] = 1.0f / (float)(i+1); // frac\n\u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_output = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(aa_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(bb_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(aa_output.data(), bb_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // Ops = (n_2d * (n_2d - 1) / 2) * (2 reads + 1 write)\n\u00a0 \u00a0 size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s114, s114_scalar)->Name(\"Scalar_s114\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s114, s114_simd)->Name(\"SIMD_s114\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s114", "entrypoint_scalar": "s114_scalar", "entrypoint_simd": "s114"}
{"task_id": "tsvc_s115", "prompt": "/*\nThis function takes a 1D float array 'a' (size n_1d) and a flattened 2D float array 'aa' (size n_2d * n_2d).\nIt performs a triangular saxpy loop: a[i] -= aa[j][i] * a[j];\nThis tests complex dependencies.\nImplement this .\n*/\nvoid s115(float *a, const float* aa_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d) {\n\u00a0 \u00a0 // n_2d = LEN_2D, n_1d = LEN_1D\n\u00a0 \u00a0 for (size_t j = 0; j < n_2d; j++) {\n\u00a0 \u00a0 \u00a0 \u00a0 float a_j = a[j];\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = j + 1; i < n_2d; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a[i] -= aa_flat[j * n_2d + i] * a_j;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n#define Small_Arg_1D LEN_1D\n\nvoid s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t n_2d = Small_Arg_2D;\n\u00a0 \u00a0 size_t length_2d = n_2d * n_2d;\n\u00a0 \u00a0 size_t length_1d = Small_Arg_1D;\n\n\u00a0 \u00a0 std::vector<float> a_initial(length_1d);\n\u00a0 \u00a0 std::vector<float> aa_input(length_2d);\n\u00a0 \u00a0 std::vector<float> a_scalar(length_1d);\n\u00a0 \u00a0 std::vector<float> a_simd(length_1d);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s115\n\u00a0 \u00a0 \u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length_1d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length_2d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 a_scalar = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 a_simd = a_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s115_scalar(a_scalar.data(), aa_input.data(), n_2d, length_1d);\n\u00a0 \u00a0 \u00a0 \u00a0 s115_simd(a_simd.data(), aa_input.data(), n_2d, length_1d);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(a_scalar, a_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s115!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, size_t, size_t)>\nstatic void BM_s115(benchmark::State& state) {\n\u00a0 \u00a0 size_t n_2d = state.range(0);\n\u00a0 \u00a0 size_t length_2d = n_2d * n_2d;\n\u00a0 \u00a0 size_t length_1d = LEN_1D;\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> a_output(length_1d);\n\u00a0 \u00a0 std::vector<float> aa_input(length_2d);\n\u00a0 \u00a0 std::vector<float> a_initial(length_1d);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s115\n\u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 for (size_t i = 0; i < length_1d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 for (size_t i = 0; i < length_2d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_input[i] = small_val;\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_output = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(a_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(aa_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(a_output.data(), aa_input.data(), n_2d, length_1d);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // Ops = (n_2d * (n_2d - 1) / 2) * (1 read + 1 read/write)\n\u00a0 \u00a0 size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s115, s115_scalar)->Name(\"Scalar_s115\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s115, s115_simd)->Name(\"SIMD_s115\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s115", "entrypoint_scalar": "s115_scalar", "entrypoint_simd": "s115"}
{"task_id": "tsvc_s1115", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', and 'cc' (row-major) of size n_2d * n_2d.\nIt performs the operation: aa[i][j] = aa[i][j]*cc[j][i] + bb[i][j];\nThis tests matrix multiplication with mixed indexing.\nImplement this .\n*/\nvoid s1115(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n\u00a0 \u00a0 for (size_t i = 0; i < n_2d; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t j = 0; j < n_2d; j++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 size_t idx_ij = i * n_2d + j;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 size_t idx_ji = j * n_2d + i;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_flat[idx_ij] = aa_flat[idx_ij] * cc_flat[idx_ji] + bb_flat[idx_ij];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t n_2d = Small_Arg_2D;\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 C \u00a0 std::vector<float> cc_input(length);\n\u00a0 \u00a0 std::vector<float> aa_scalar(length);\n\u00a0 \u00a0 std::vector<float> aa_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 g \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s1115\n\u00a0 \u00a0 \u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\nci \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cc_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 aa_scalar = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 aa_simd = aa_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s1115_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 s1115_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(aa_scalar, aa_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1115!\" << std::endl;\nA \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s1115(benchmark::State& state) {\nD \u00a0 size_t n_2d = state.range(0);\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> aa_output(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 \u00a0 std::vector<float> cc_input(length);\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s1115\n\u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_initial[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 cc_input[i] = small_val;\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_output = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(aa_output.data());\nThis is an executable test containing a number of loops to measure\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(bb_input.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(cc_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // Ops = (n_2d * n_2d) * (1 read/write + 2 reads)\nA \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1115, s1115_scalar)->Name(\"Scalar_s1115\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1115, s1115_simd)->Name(\"SIMD_s1115\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1115", "entrypoint_scalar": "s1115_scalar", "entrypoint_simd": "s1115"}
{"task_id": "tsvc_s116", "prompt": "/*\nThis function takes a float array 'a' and its length 'n'.\nIt performs an unrolled loop with dependencies: a[i] = a[i+1] * a[i]; ... 5 times.\nThis tests dependency analysis in unrolled loops.\nImplement this .\n*/\nvoid s116(float *a, size_t n) {\n}\n", "solution_scalar": "void s116_scalar(float *a, size_t n) {\n \u00a0 \u00a0for (size_t i = 0; i < n - 5; i += 5) {\n \u00a0 \u00a0 \u00a0 \u00a0a[i] = a[i + 1] * a[i];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 1] = a[i + 2] * a[i + 1];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 2] = a[i + 3] * a[i + 2];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 3] = a[i + 4] * a[i + 3];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 4] = a[i + 5] * a[i + 4];\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s116_scalar(float *a, size_t n);\nvoid s116_simd(float *a, size_t n);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t length = Small_Arg_1D;\n\n \u00a0 \u00a0std::vector<float> a_initial(length);\n \u00a0 \u00a0std::vector<float> a_scalar(length);\n \u00a0 \u00a0std::vector<float> a_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s116\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0a_scalar = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0a_simd = a_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s116_scalar(a_scalar.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0s116_simd(a_simd.data(), length);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(a_scalar, a_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s116!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s116_scalar(float *a, size_t n);\nvoid s116_simd(float *a, size_t n);\n\ntemplate<void (*Func)(float *, size_t)>\nstatic void BM_s116(benchmark::State& state) {\n \u00a0 \u00a0size_t length = state.range(0);\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> a_output(length);\n \u00a0 \u00a0std::vector<float> a_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s116\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0a_output = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(a_output.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(a_output.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// 5 ops per block (2 reads, 1 write) = 15 accesses. (length / 5) blocks.\n \u00a0 \u00a0size_t num_ops = (length - 5) / 5;\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * 15 * sizeof(float));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s116, s116_scalar)->Name(\"Scalar_s116\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s116, s116_simd)->Name(\"SIMD_s116\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s116", "entrypoint_scalar": "s116_scalar", "entrypoint_simd": "s116"}
{"task_id": "tsvc_s118", "prompt": "/*\nThis function takes a 1D float array 'a' (size n_1d) and a flattened 2D float array 'bb' (size n_2d * n_2d).\nIt performs a complex recursive operation: a[i] += bb[j][i] * a[i-j-1];\nThis tests potential dot product recursion.\nImplement this .\n*/\nvoid s118(float *a, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d) {\n \u00a0 \u00a0// n_1d is LEN_1D, n_2d is LEN_2D\n \u00a0 \u00a0for (size_t i = 1; i < n_2d; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t j = 0; j <= i - 1; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a[i] += bb_flat[j * n_2d + i] * a[i-j-1];\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n#define Small_Arg_1D LEN_1D\n\nvoid s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t n_2d = Small_Arg_2D;\n \u00a0 \u00a0size_t length_2d = n_2d * n_2d;\n \u00a0 \u00a0size_t length_1d = Small_Arg_1D;\n\n \u00a0 \u00a0std::vector<float> a_initial(length_1d);\n \u00a0 \u00a0std::vector<float> bb_input(length_2d);\n \u00a0 \u00a0std::vector<float> a_scalar(length_1d);\n \u00a0 \u00a0std::vector<float> a_simd(length_1d);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s118\n \u00a0 \u00a0 \u00a0 \u00a0float small_val = 0.000001f;\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length_1d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length_2d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = small_val;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0a_scalar = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0a_simd = a_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s118_scalar(a_scalar.data(), bb_input.data(), n_2d, length_1d);\n \u00a0 \u00a0 \u00a0 \u00a0s118_simd(a_simd.data(), bb_input.data(), n_2d, length_1d);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(a_scalar, a_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s118!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, size_t, size_t)>\nstatic void BM_s118(benchmark::State& state) {\n \u00a0 \u00a0size_t n_2d = state.range(0);\n \u00a0 \u00a0size_t length_2d = n_2d * n_2d;\n \u00a0 \u00a0size_t length_1d = LEN_1D;\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> a_output(length_1d);\n \u00a0 \u00a0std::vector<float> bb_input(length_2d);\n \u00a0 \u00a0std::vector<float> a_initial(length_1d);\n\n \u00a0 \u00a0// Ported Initialization Logic for s118\n \u00a0 \u00a0float small_val = 0.000001f;\n \u00a0 \u00a0for (size_t i = 0; i < length_1d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0}\n \u00a0 \u00a0for (size_t i = 0; i < length_2d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = small_val;\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0a_output = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(a_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(bb_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(a_output.data(), bb_input.data(), n_2d, length_1d);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (n_2d * (n_2d - 1) / 2). Each op: 1 R/W(a), 1 R(bb), 1 R(a)\n \u00a0 \u00a0size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s118, s118_scalar)->Name(\"Scalar_s118\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s118, s118_simd)->Name(\"SIMD_s118\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s118", "entrypoint_scalar": "s118_scalar", "entrypoint_simd": "s118"}
{"task_id": "tsvc_s119", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs the operation: aa[i][j] = aa[i-1][j-1] + bb[i][j];\nThis tests a dependency on a diagonal element.\nImplement this .\n*/\nvoid s119(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n \u00a0 \u00a0for (size_t i = 1; i < n_2d; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t j = 1; j < n_2d; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_flat[i * n_2d + j] = aa_flat[(i-1) * n_2d + (j-1)] + bb_flat[i * n_2d + j];\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t n_2d = Small_Arg_2D;\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_scalar(length);\n \u00a0 \u00a0std::vector<float> aa_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s119\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0aa_scalar = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0aa_simd = aa_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s119_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0s119_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(aa_scalar, aa_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s119!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s119(benchmark::State& state) {\n \u00a0 \u00a0size_t n_2d = state.range(0);\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> aa_output(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s119\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_output = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(aa_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(bb_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(aa_output.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (n_2d - 1) * (n_2d - 1). Each op: 1 W(aa), 2 R(aa, bb)\n \u00a0 \u00a0size_t num_ops = (n_2d - 1) * (n_2d - 1);\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s119, s119_scalar)->Name(\"Scalar_s119\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s119, s119_simd)->Name(\"SIMD_s119\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s119", "entrypoint_scalar": "s119_scalar", "entrypoint_simd": "s119"}
{"task_id": "tsvc_s1119", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs the operation: aa[i][j] = aa[i-1][j] + bb[i][j];\nThis tests a dependency on the element directly above.\nImplement this .\n*/\nvoid s1119(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n \u00a0 \u00a0for (size_t i = 1; i < n_2d; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t j = 0; j < n_2d; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_flat[i * n_2d + j] = aa_flat[(i-1) * n_2d + j] + bb_flat[i * n_2d + j];\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t n_2d = Small_Arg_2D;\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_scalar(length);\n \u00a0 \u00a0std::vector<float> aa_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s1119\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0aa_scalar = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0aa_simd = aa_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s1119_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0s1119_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(aa_scalar, aa_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1119!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s1119(benchmark::State& state) {\n \u00a0 \u00a0size_t n_2d = state.range(0);\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> aa_output(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s1119\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_output = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(aa_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(bb_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(aa_output.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (n_2d - 1) * n_2d. Each op: 1 W(aa), 2 R(aa, bb)\n \u00a0 \u00a0size_t num_ops = (n_2d - 1) * n_2d;\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1119, s1119_scalar)->Name(\"Scalar_s1119\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1119, s1119_simd)->Name(\"SIMD_s1119\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1119", "entrypoint_scalar": "s1119_scalar", "entrypoint_simd": "s1119"}
{"task_id": "tsvc_s121", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[i+1] + b[i];\nThis tests a simple loop-carried dependency (a[i] depends on a[i+1]).\nImplement this .\n*/\nvoid s121(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s121_scalar(float *a, const float *b, size_t n) {\n \u00a0 \u00a0int j;\n \u00a0 \u00a0for (size_t i = 0; i < n - 1; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0j = i + 1;\n \u00a0 \u00a0 \u00a0 \u00a0a[i] = a[j] + b[i];\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s121_scalar(float *a, const float *b, size_t n);\nvoid s121_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t length = Small_Arg_1D;\n\n \u00a0 \u00a0std::vector<float> a_initial(length);\n \u00a0 \u00a0std::vector<float> b_input(length);\n \u00a0 \u00a0std::vector<float> a_scalar(length);\n \u00a0 \u00a0std::vector<float> a_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s121\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0a_scalar = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0a_simd = a_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s121_scalar(a_scalar.data(), b_input.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0s121_simd(a_simd.data(), b_input.data(), length);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(a_scalar, a_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s121!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s121_scalar(float *a, const float *b, size_t n);\nvoid s121_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s121(benchmark::State& state) {\n \u00a0 \u00a0size_t length = state.range(0);\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> a_output(length);\n \u00a0 \u00a0std::vector<float> b_input(length);\n \u00a0 \u00a0std::vector<float> a_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s121\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0a_output = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(a_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(b_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(a_output.data(), b_input.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (length - 1). Each op: 1 W(a), 2 R(a, b)\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length - 1) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s121, s121_scalar)->Name(\"Scalar_s121\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s121, s121_simd)->Name(\"SIMD_s121\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s121", "entrypoint_scalar": "s121_scalar", "entrypoint_simd": "s121"}
{"task_id": "tsvc_s122", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and two integers 'n1' and 'n3'.\nIt performs a complex strided and indexed operation: a[i] += b[n - k];\nThis tests induction variables and irregular access.\nImplement this .\n*/\nvoid s122(float *a, const float *b, size_t n, int n1, int n3) {\n}\n", "solution_scalar": "void s122_scalar(float *a, const float *b, size_t n, int n1, int n3) {\n    int j, k;\n    j = 1;\n    k = 0;\n    for (size_t i = (size_t)n1 - 1; i < n; i += n3) {\n        k += j;\n        a[i] += b[n - k];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s122_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s122_simd(float *a, const float *b, size_t n, int n1, int n3);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s122\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s122_scalar(a_scalar.data(), b_input.data(), length, n1, n3);\n        s122_simd(a_simd.data(), b_input.data(), length, n1, n3);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s122!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s122_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s122_simd(float *a, const float *b, size_t n, int n1, int n3);\n\ntemplate<void (*Func)(float *, const float *, size_t, int, int)>\nstatic void BM_s122(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    // Ported Initialization Logic for s122\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, n1, n3);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop runs approx (length - n1) / n3 times. Each op: 1 R/W(a), 1 R(b)\n    size_t num_ops = (length - n1) / n3;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s122, s122_scalar)->Name(\"Scalar_s122\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s122, s122_simd)->Name(\"SIMD_s122\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s122", "entrypoint_scalar": "s122_scalar", "entrypoint_simd": "s122"}
{"task_id": "tsvc_s123", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional write: a[j] = ... where 'j' is incremented conditionally.\nThis tests conditional induction variables (a pack/compress pattern).\nImplement this .\n*/\nvoid s123(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    int j = -1;\n    for (size_t i = 0; i < (n / 2); i++) {\n        j++;\n        a[j] = b[i] + d[i] * e[i];\n        if (c[i] > 0.0f) {\n            j++;\n            a[j] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s123\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f; // Original test data is all 1.0f, so 'if' is always true\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s123_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s123_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s123!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s123(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s123\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_input[i] = 1.0f;\n        c_input[i] = 1.0f; // Original test data is all 1.0f\n        d_input[i] = 1.0f / (float)(i+1);\n        e_input[i] = 1.0f / (float)(i+1);\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n/2). Since c[i] is always true: 6 R (b,d,e,c,d,e), 2 W(a,a)\n    size_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s123, s123_scalar)->Name(\"Scalar_s123\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s123, s123_simd)->Name(\"SIMD_s123\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s123", "entrypoint_scalar": "s123_scalar", "entrypoint_simd": "s123"}
{"task_id": "tsvc_s124", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional write based on b[i]: a[j] = ... where 'j' is incremented in both paths.\nThis tests induction variables in if-then-else.\nImplement this .\n*/\nvoid s124(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    int j = -1;\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] > 0.0f) {\n            j++;\n            a[j] = b[i] + d[i] * e[i];\n        } else {\n            j++;\n            a[j] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s124\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f; // Original test data is all 1.0f, so 'if' is always true\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s124_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s124_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s124!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s124(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s124\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_input[i] = 1.0f; // Original test data is all 1.0f\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f / (float)(i+1);\n        e_input[i] = 1.0f / (float)(i+1);\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n). Each op: 4 R (b,c,d,e), 1 W(a). (Blend pattern)\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s124, s124_scalar)->Name(\"Scalar_s124\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s124, s124_simd)->Name(\"SIMD_s124\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s124", "entrypoint_scalar": "s124_scalar", "entrypoint_simd": "s124"}
{"task_id": "tsvc_s125", "prompt": "/*\nThis function flattens a 2D array operation into a 1D array 'flat_2d_array'.\nIt takes 4 flattened 2D arrays and size n_2d.\nOperation: flat_2d_array[k] = aa[i][j] + bb[i][j] * cc[i][j];\nImplement this .\n*/\nvoid s125(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    int k = -1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            k++;\n            size_t idx_ij = i * n_2d + j;\n            flat_2d_array[k] = aa_flat[idx_ij] + bb_flat[idx_ij] * cc_flat[idx_ij];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t length = n_2d * n_2d;\n\n    std::vector<float> flat_initial(length);\n    std::vector<float> aa_input(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> flat_scalar(length);\n    std::vector<float> flat_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s125\n        for (size_t i = 0; i < length; ++i) {\n            flat_initial[i] = 0.0f;\n            aa_input[i] = 1.0f;\n            bb_input[i] = 0.5f;\n            cc_input[i] = 2.0f;\n        }\n        flat_scalar = flat_initial;\n        flat_simd = flat_initial;\n\n        s125_scalar(flat_scalar.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);\n        s125_simd(flat_simd.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);\n\n        if (!allclose(flat_scalar, flat_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s125!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, const float*, size_t)>\nstatic void BM_s125(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t length = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> flat_output(length);\n    std::vector<float> aa_input(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> flat_initial(length);\n\n    // Ported Initialization Logic for s125\n    for (size_t i = 0; i < length; ++i) {\n        flat_initial[i] = 0.0f;\n        aa_input[i] = 1.0f;\n        bb_input[i] = 0.5f;\n        cc_input[i] = 2.0f;\n    }\n\n    for (auto _ : state) {\n        flat_output = flat_initial;\n        benchmark::DoNotOptimize(flat_output.data());\n        benchmark::DoNotOptimize(aa_input.data());\n        benchmark::DoNotOptimize(bb_input.data());\n        benchmark::DoNotOptimize(cc_input.data());\n\n        Func(flat_output.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n_2d * n_2d). Each op: 3 R (aa,bb,cc), 1 W(flat)\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s125, s125_scalar)->Name(\"Scalar_s125\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s125, s125_simd)->Name(\"SIMD_s125\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s125", "entrypoint_scalar": "s125_scalar", "entrypoint_simd": "s125"}
{"task_id": "tsvc_s126", "prompt": "/*\nThis function takes three flattened 2D float arrays 'bb', 'flat_2d_array', 'cc' and size n_2d.\nIt performs a complex recursive op: bb[j][i] = bb[j-1][i] + flat_2d_array[k-1] * cc[j][i];\nThis tests induction variables and recurrence.\nImplement this .\n*/\nvoid s126(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {\n    int k = 1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 1; j < n_2d; j++) {\n            bb_flat[j * n_2d + i] = bb_flat[(j-1) * n_2d + i] + flat_2d_array[k-1] * cc_flat[j * n_2d + i];\n            ++k;\n        }\n        ++k;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\nvoid s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t length = n_2d * n_2d;\n\n    std::vector<float> bb_initial(length);\n    std::vector<float> flat_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> bb_scalar(length);\n    std::vector<float> bb_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s126\n        for (size_t i = 0; i < length; ++i) {\n            bb_initial[i] = 1.0f;\n            flat_input[i] = 1.0f / (float)(i+1); // frac\n            cc_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        bb_scalar = bb_initial;\n        bb_simd = bb_initial;\n\n        s126_scalar(bb_scalar.data(), flat_input.data(), cc_input.data(), n_2d);\n        s126_simd(bb_simd.data(), flat_input.data(), cc_input.data(), n_2d);\n\n        if (!allclose(bb_scalar, bb_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s126!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\nvoid s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s126(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t length = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> bb_output(length);\n    std::vector<float> flat_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> bb_initial(length);\n\n    // Ported Initialization Logic for s126\n    for (size_t i = 0; i < length; ++i) {\n        bb_initial[i] = 1.0f;\n   \t    flat_input[i] = 1.0f / (float)(i+1); // frac\n        cc_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        bb_output = bb_initial;\n        benchmark::DoNotOptimize(bb_output.data());\n        benchmark::DoNotOptimize(flat_input.data());\n        benchmark::DoNotOptimize(cc_input.data());\n\n        Func(bb_output.data(), flat_input.data(), cc_input.data(), n_2d);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop n_2d * (n_2d - 1). Each op: 3 R (bb, flat, cc), 1 W(bb)\n    size_t num_ops = n_2d * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s126, s126_scalar)->Name(\"Scalar_s126\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s126, s126_simd)->Name(\"SIMD_s126\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s126", "entrypoint_scalar": "s126_scalar", "entrypoint_simd": "s126"}
{"task_id": "tsvc_s127", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs an operation with multiple increments to the index 'j': a[j++] = ...; a[j++] = ...;\nThis tests induction variables with multiple increments.\nImplement this .\n*/\nvoid s127(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    int j = -1;\n    for (size_t i = 0; i < n / 2; i++) {\n        j++;\n        a[j] = b[i] + c[i] * d[i];\n        j++;\n        a[j] = b[i] + d[i] * e[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s127\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s127_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s127_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s127!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s127(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s127\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_input[i] = 1.0f;\n        c_input[i] = 1.0f / (float)(i+1);\n        d_input[i] = 1.0f / (float)(i+1);\n        e_input[i] = 1.0f / (float)(i+1);\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n/2). Each op: 5 R (b,c,d,b,e), 2 W(a,a)\n ->  size_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s127, s127_scalar)->Name(\"Scalar_s127\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s127, s127_simd)->Name(\"SIMD_s127\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s127", "entrypoint_scalar": "s127_scalar", "entrypoint_simd": "s127"}
{"task_id": "tsvc_s128", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a coupled induction variable update: a[i] = b[k] - d[i]; b[k] = a[i] + c[k];\nThis tests dependency analysis in coupled loops.\nImplement this .\n*/\nvoid s128(float *a, float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s128_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    int j = -1;\n    int k;\n    for (size_t i = 0; i < n / 2; i++) {\n        k = j + 1;\n        a[i] = b[k] - d[i];\n        j = k + 1;\n        b[k] = a[i] + c[k];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s128_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s128_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    std::vector<float> b_scalar(length);\n    std::vector<float> b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s128\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_initial[i] = 2.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s128_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s128_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        // Must check both 'a' and 'b' arrays as they are both modified\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n Team          if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s128!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s128_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s128_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s128(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s128\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_initial[i] = 2.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f;\n   ci}\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n       \tbenchmark::ClobberMemory();\n    }\n    // Loop (n/2). Each op: 4 R (b,d,a,c), 2 W (a,b)\n   \tsize_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s128, s128_scalar)->Name(\"Scalar_s128\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s128, s128_simd)->Name(\"SIMD_s128\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s128", "entrypoint_scalar": "s128_scalar", "entrypoint_simd": "s128"}
{"task_id": "tsvc_s131", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[i + 1] + b[i]; (with m=1 hardcoded).\nThis tests forward substitution dependency.\nImplement this .\n*/\nvoid s131(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s131_scalar(float *a, const float *b, size_t n) {\n    int m  = 1;\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = a[i + m] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s131_scalar(float *a, const float *b, size_t n);\nvoid s131_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s131\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s131_scalar(a_scalar.data(), b_input.data(), length);\n        s131_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s131!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s131_scalar(float *a, const float *b, size_t n);\nvoid s131_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s131(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s131\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s131, s131_scalar)->Name(\"Scalar_s131\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s131, s131_simd)->Name(\"SIMD_s131\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s131", "entrypoint_scalar": "s131_scalar", "entrypoint_simd": "s131"}
{"task_id": "tsvc_s132", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major), 1D arrays 'b' and 'c', and the 2D dimension 'n_2d'.\nIt performs the operation: aa[0][i] = aa[1][i-1] + b[i] * c[1]; (with j=0, k=1 hardcoded).\nImplement this .\n*/\nvoid s132(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d) {\n    // n_2d = LEN_2D, n_1d = LEN_1D\n    int m = 0;\n    int j = m;   // j = 0\n    int k = m+1; // k = 1\n    float c1 = c[1]; // Hoist c[1]\n    for (size_t i = 1; i < n_2d; i++) {\n        // aa[j][i] = aa[k][i-1] + b[i] * c[1];\n        aa_flat[j * n_2d + i] = aa_flat[k * n_2d + (i-1)] + b[i] * c1;\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n#define Small_Arg_1D LEN_1D\n\nvoid s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\nvoid s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t n_1d = Small_Arg_1D;\n    size_t length_2d = n_2d * n_2d;\n\n    std::vector<float> aa_initial(length_2d);\n    std::vector<float> b_input(n_1d);\n    std::vector<float> c_input(n_1d);\n    std::vector<float> aa_scalar(length_2d);\n    std::vector<float> aa_simd(length_2d);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s132\n        for (size_t i = 0; i < length_2d; ++i) {\n            aa_initial[i] = 1.0f;\n        }\n        for (size_t i = 0; i < n_1d; ++i) {\n            b_input[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        aa_scalar = aa_initial;\n        aa_simd = aa_initial;\n\n        s132_scalar(aa_scalar.data(), b_input.data(), c_input.data(), n_2d, n_1d);\n        s132_simd(aa_simd.data(), b_input.data(), c_input.data(), n_2d, n_1d);\n\n        if (!allclose(aa_scalar, aa_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s132!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\nvoid s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t, size_t)>\nstatic void BM_s132(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t n_1d = LEN_1D;\n    size_t length_2d = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> aa_output(length_2d);\n    std::vector<float> b_input(n_1d);\n    std::vector<float> c_input(n_1d);\n    std::vector<float> aa_initial(length_2d);\n\n    // Ported Initialization Logic for s132\n    for (size_t i = 0; i < length_2d; ++i) {\n        aa_initial[i] = 1.0f;\n    }\n    for (size_t i = 0; i < n_1d; ++i) {\n        b_input[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        aa_output = aa_initial;\n        benchmark::DoNotOptimize(aa_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n\n        Func(aa_output.data(), b_input.data(), c_input.data(), n_2d, n_1d);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s132, s132_scalar)->Name(\"Scalar_s132\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s132, s132_simd)->Name(\"SIMD_s132\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s132", "entrypoint_scalar": "s132_scalar", "entrypoint_simd": "s132"}
{"task_id": "tsvc_s141", "prompt": "/*\nThis function takes a 1D float array 'flat_2d_array' and a flattened 2D float array 'bb' (row-major) of size n_2d * n_2d.\nIt performs a complex non-linear operation, walking a row in a symmetric packed array.\nImplement this .\n*/\nvoid s141(float* flat_2d_array, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d) {\n    int k;\n    for (size_t i = 0; i < n_2d; i++) {\n        k = (i+1) * (i) / 2 + i;\n        for (size_t j = i; j < n_2d; j++) {\n            // flat_2d_array[k] += bb[j][i];\n            flat_2d_array[k] += bb_flat[j * n_2d + i];\n            k += j+1;\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d);\nvoid s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t length = n_2d * n_2d;\n\n    std::vector<float> flat_initial(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> flat_scalar(length);\n    std::vector<float> flat_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s141\n        for (size_t i = 0; i < length; ++i) {\n            flat_initial[i] = 1.0f;\n            bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        flat_scalar = flat_initial;\n        flat_simd = flat_initial;\n\n        s141_scalar(flat_scalar.data(), bb_input.data(), n_2d);\n        s141_simd(flat_simd.data(), bb_input.data(), n_2d);\n\n        if (!allclose(flat_scalar, flat_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s141!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d);\nvoid s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s141(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t length = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> flat_output(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> flat_initial(length);\n\n    // Ported Initialization Logic for s141\n    for (size_t i = 0; i < length; ++i) {\n        flat_initial[i] = 1.0f;\n        bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        flat_output = flat_initial;\n        benchmark::DoNotOptimize(flat_output.data());\n        benchmark::DoNotOptimize(bb_input.data());\n\n        Func(flat_output.data(), bb_input.data(), n_2d);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s141, s141_scalar)->Name(\"Scalar_s141\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s141, s141_simd)->Name(\"SIMD_s141\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s141", "entrypoint_scalar": "s141_scalar", "entrypoint_simd": "s141"}
{"task_id": "tsvc_s151", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[i + 1] + b[i]; (with m=1 hardcoded).\nThis is an interprocedural test, but the core logic is what matters.\nImplement this .\n*/\nvoid s151(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "// This scalar solution is the inlined logic of s151s(a, b, 1)\nvoid s151_scalar(float *a, const float *b, size_t n) {\n    int m = 1;\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = a[i + m] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s151_scalar(float *a, const float *b, size_t n);\nvoid s151_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s151\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s151_scalar(a_scalar.data(), b_input.data(), length);\n        s151_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s151!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s151_scalar(float *a, const float *b, size_t n);\nvoid s151_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s151(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s151\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s151, s151_scalar)->Name(\"Scalar_s151\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s151, s151_simd)->Name(\"SIMD_s151\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s151", "entrypoint_scalar": "s151_scalar", "entrypoint_simd": "s151"}
{"task_id": "tsvc_s152", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs two inlined operations: \n1. b[i] = d[i] * e[i];\n2. a[i] += b[i] * c[i];\nImplement this .\n*/\nvoid s152(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Inlined logic from s152 and s152s\n    for (size_t i = 0; i < n; i++) {\n        b[i] = d[i] * e[i];\n        a[i] += b[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s152\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 0.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s152_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s152_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s152!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s152(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s152\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 0.0f;\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n        e_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s152, s152_scalar)->Name(\"Scalar_s152\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s152, s152_simd)->Name(\"SIMD_s152\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s152", "entrypoint_scalar": "s152_scalar", "entrypoint_simd": "s152"}
{"task_id": "tsvc_s161", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional operation based on b[i]:\nIf b[i] < 0, it calculates: c[i+1] = a[i] + d[i] * d[i];\nOtherwise, it calculates: a[i] = c[i] + d[i] * e[i];\nImplement this .\n*/\nvoid s161(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n    for (size_t i = 0; i < n - 1; ++i) {\n        if (b[i] < 0.0f) {\n            c[i+1] = a[i] + d[i] * d[i];\n        } else {\n            a[i] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_initial(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> c_scalar(length), c_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s161\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Alternating 1.0 and -1.0\n            c_initial[i] = 1.0f;\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        c_scalar = c_initial;\n        c_simd = c_initial;\n\n        s161_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n        s161_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s161!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, const float *, size_t)>\nstatic void BM_s161(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_output(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> c_initial(length);\n\n    // Ported Initialization Logic for s161\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = (i % 2 == 0) ? 1.0f : -1.0f;\n        c_initial[i] = 1.0f;\n        d_input[i] = 1.0f / (float)(i+1); // frac\n        e_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        c_output = c_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_output.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_output.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s161, s161_scalar)->Name(\"Scalar_s161\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s161, s161_simd)->Name(\"SIMD_s161\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s161", "entrypoint_scalar": "s161_scalar", "entrypoint_simd": "s161"}
{"task_id": "tsvc_s1161", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional operation based on c[i]:\nIf c[i] < 0, it calculates: b[i] = a[i] + d[i] * d[i];\nOtherwise, it calculates: a[i] = c[i] + d[i] * e[i];\nImplement this .\n*/\nvoid s1161(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    for (size_t i = 0; i < n - 1; ++i) {\n        if (c[i] < 0.0f) {\n            b[i] = a[i] + d[i] * d[i];\n        } else {\n            a[i] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1161 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f;\n            c_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Mix for condition\n            d_input[i] = 1.0f;\n            e_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s1161_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s1161_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1161!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1161(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s1161 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f;\n        c_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Mix for condition\n        d_input[i] = 1.0f;\n        e_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1161, s1161_scalar)->Name(\"Scalar_s1161\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1161, s1161_simd)->Name(\"SIMD_s1161\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1161", "entrypoint_scalar": "s1161_scalar", "entrypoint_simd": "s1161"}
{"task_id": "tsvc_s162", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', length 'n', and an integer 'k'.\nIf k > 0, it performs the operation: a[i] = a[i + k] + b[i] * c[i];\nThis tests conditional execution based on a scalar argument.\nImplement this .\n*/\nvoid s162(float *a, const float *b, const float *c, size_t n, int k) {\n}\n", "solution_scalar": "void s162_scalar(float *a, const float *b, const float *c, size_t n, int k) {\n    if (k > 0) {\n        for (size_t i = 0; i < n - 1; i++) {\n            a[i] = a[i + k] + b[i] * c[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s162_scalar(float *a, const float *b, const float *c, size_t n, int k);\nvoid s162_simd(float *a, const float *b, const float *c, size_t n, int k);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int k = 1; // From tsvc.c main(), n1 is 1\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s162\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s162_scalar(a_scalar.data(), b_input.data(), c_input.data(), length, k);\n        s162_simd(a_simd.data(), b_input.data(), c_input.data(), length, k);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s162!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s162_scalar(float *a, const float *b, const float *c, size_t n, int k);\nvoid s162_simd(float *a, const float *b, const float *c, size_t n, int k);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t, int)>\nstatic void BM_s162(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_initial(length);\n    int k = 1; // From tsvc.c main(), n1 is 1\n\n    // Ported Initialization Logic for s162\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), length, k);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s162, s162_scalar)->Name(\"Scalar_s162\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s162, s162_simd)->Name(\"SIMD_s162\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s162", "entrypoint_scalar": "s162_scalar", "entrypoint_simd": "s162"}
{"task_id": "tsvc_s171", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and an integer 'inc'.\nIt performs a strided write operation: a[i * inc] += b[i];\nThis tests symbolic dependence and strided access.\nImplement this .\n*/\nvoid s171(float *a, const float *b, size_t n, int inc) {\n}\n", "solution_scalar": "void s171_scalar(float *a, const float *b, size_t n, int inc) {\n    for (size_t i = 0; i < n; i++) {\n        a[i * inc] += b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s171_scalar(float *a, const float *b, size_t n, int inc);\nvoid s171_simd(float *a, const float *b, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s171\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s171_scalar(a_scalar.data(), b_input.data(), length, inc);\n        s171_simd(a_simd.data(), b_input.data(), length, inc);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s171!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s171_scalar(float *a, const float *b, size_t n, int inc);\nvoid s171_simd(float *a, const float *b, size_t n, int inc);\n\ntemplate<void (*Func)(float *, const float *, size_t, int)>\nstatic void BM_s171(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    // Ported Initialization Logic for s171\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, inc);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s171, s171_scalar)->Name(\"Scalar_s171\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s171, s171_simd)->Name(\"SIMD_s171\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s171", "entrypoint_scalar": "s171_scalar", "entrypoint_simd": "s171"}
{"task_id": "tsvc_s172", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and two integers 'n1' and 'n3'.\nIt performs a strided operation: a[i] += b[i];\nThe loop starts at n1-1 and increments by n3.\nImplement this .\n*/\nvoid s172(float *a, const float *b, size_t n, int n1, int n3) {\n}\n", "solution_scalar": "void s172_scalar(float *a, const float *b, size_t n, int n1, int n3) {\n    // n = LEN_1D\n    for (size_t i = n1 - 1; i < n; i += n3) {\n        a[i] += b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s172_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s172_simd(float *a, const float *b, size_t n, int n1, int n3);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s172\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s172_scalar(a_scalar.data(), b_input.data(), length, n1, n3);\n        s172_simd(a_simd.data(), b_input.data(), length, n1, n3);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s172!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s172_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s172_simd(float *a, const float *b, size_t n, int n1, int n3);\n\ntemplate<void (*Func)(float *, const float *, size_t, int, int)>\nstatic void BM_s172(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    // Ported Initialization Logic for s172\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, n1, n3);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s172, s172_scalar)->Name(\"Scalar_s172\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s172, s172_simd)->Name(\"SIMD_s172\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s172", "entrypoint_scalar": "s172_scalar", "entrypoint_simd": "s172"}
{"task_id": "tsvc_s173", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and length 'n'.\nIt performs the operation: a[i+k] = a[i] + b[i]; where k = n/2.\nThis tests expressions in loop bounds and subscripts.\nImplement this .\n*/\nvoid s173(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s173_scalar(float *a, const float *b, size_t n) {\n    // n = LEN_1D\n    int k = n / 2;\n    for (size_t i = 0; i < n / 2; i++) {\n        a[i+k] = a[i] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s173_scalar(float *a, const float *b, size_t n);\nvoid s173_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s173\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s173_scalar(a_scalar.data(), b_input.data(), length);\n        s173_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s173!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s173_scalar(float *a, const float *b, size_t n);\nvoid s173_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s173(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s173\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s173, s173_scalar)->Name(\"Scalar_s173\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s173, s173_simd)->Name(\"SIMD_s173\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s173", "entrypoint_scalar": "s173_scalar", "entrypoint_simd": "s173"}
{"task_id": "tsvc_s174", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and an integer 'M'.\nIt performs the operation: a[i+M] = a[i] + b[i]; for i < M.\nThis tests symbolic subscripts.\nImplement this .\n*/\nvoid s174(float *a, const float *b, size_t n, int M) {\n}\n", "solution_scalar": "void s174_scalar(float *a, const float *b, size_t n, int M) {\n    // n = LEN_1D. M = n/2 from main().\n    for (size_t i = 0; i < M; i++) {\n        a[i+M] = a[i] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s174_scalar(float *a, const float *b, size_t n, int M);\nvoid s174_simd(float *a, const float *b, size_t n, int M);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int M = length / 2; // From tsvc.c main()\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s174\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s174_scalar(a_scalar.data(), b_input.data(), length, M);\n        s174_simd(a_simd.data(), b_input.data(), length, M);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s174!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s174_scalar(float *a, const float *b, size_t n, int M);\nvoid s174_simd(float *a, const float *b, size_t n, int M);\n\ntemplate<void (*Func)(float *, const float *, size_t, int)>\nstatic void BM_s174(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int M = length / 2; // From tsvc.c main()\n\n    // Ported Initialization Logic for s174\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, M);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s174, s174_scalar)->Name(\"Scalar_s174\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s174, s174_simd)->Name(\"SIMD_s174\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s174", "entrypoint_scalar": "s174_scalar", "entrypoint_simd": "s174"}
{"task_id": "tsvc_s175", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and an integer 'inc'.\nIt performs a strided operation: a[i] = a[i + inc] + b[i];\nThis tests symbolic dependence.\nImplement this .\n*/\nvoid s175(float *a, const float *b, size_t n, int inc) {\n}\n", "solution_scalar": "void s175_scalar(float *a, const float *b, size_t n, int inc) {\n    // n = LEN_1D\n    for (size_t i = 0; i < n - inc; i += inc) {\n        a[i] = a[i + inc] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s175_scalar(float *a, const float *b, size_t n, int inc);\nvoid s175_simd(float *a, const float *b, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s175\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s175_scalar(a_scalar.data(), b_input.data(), length, inc);\n        s175_simd(a_simd.data(), b_input.data(), length, inc);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s175!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s175_scalar(float *a, const float *b, size_t n, int inc);\nvoid s175_simd(float *a, const float *b, size_t n, int inc);\n\ntemplate<void (*Func)(float *, const float *, size_t, int)>\nstatic void BM_s175(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    // Ported Initialization Logic for s175\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, inc);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s175, s175_scalar)->Name(\"Scalar_s175\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s175, s175_simd)->Name(\"SIMD_s175\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s175", "entrypoint_scalar": "s175_scalar", "entrypoint_simd": "s175"}
{"task_id": "tsvc_s176", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a 2D convolution operation: a[i] += b[i+m-j-1] * c[j]; where m = n/2.\nThis tests a complex dependency pattern (convolution).\nImplement this .\n*/\nvoid s176(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s176_scalar(float *a, const float *b, const float *c, size_t n) {\n    // n = LEN_1D\n    int m = n / 2;\n    for (size_t j = 0; j < (n / 2); j++) {\n        for (size_t i = 0; i < m; i++) {\n            a[i] += b[i+m-j-1] * c[j];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s176_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s176_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s176\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s176_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n        s176_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s176!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s176_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s176_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s176(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s176\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s176, s176_scalar)->Name(\"Scalar_s176\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s176, s176_simd)->Name(\"SIMD_s176\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s176", "entrypoint_scalar": "s176_scalar", "entrypoint_simd": "s176"}
{"task_id": "tsvc_s211", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a statement reordering task with dependencies:\n1. a[i] = b[i - 1] + c[i] * d[i];\n2. b[i] = b[i + 1] - e[i] * d[i];\nImplement this .\n*/\nvoid s211(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    for (size_t i = 1; i < n - 1; i++) {\n        a[i] = b[i - 1] + c[i] * d[i];\n        b[i] = b[i + 1] - e[i] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s211\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_initial[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s211_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s211_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s211!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s211(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s211\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_initial[i] = 1.0f;\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n        e_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-2). Each op: 6R (b,c,d,b,e,d), 2W (a,b)\n    size_t num_ops = length - 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s211, s211_scalar)->Name(\"Scalar_s211\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s211, s211_simd)->Name(\"SIMD_s211\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s211", "entrypoint_scalar": "s211_scalar", "entrypoint_simd": "s211"}
{"task_id": "tsvc_s212", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a task with dependency needing a temporary variable:\n1. a[i] *= c[i];\n2. b[i] += a[i + 1] * d[i];\nImplement this .\n*/\nvoid s212(float *a, float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s212_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] *= c[i];\n        b[i] += a[i + 1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s212_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s212_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s212\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f / (float)(i+1); // frac\n            b_initial[i] = 1.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s212_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s212_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s212!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s212_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s212_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s212(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s212\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f / (float)(i+1); // frac\n        b_initial[i] = 1.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-1). Each op: 5R (a,c,b,a,d), 2W (a,b)\n    size_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s212, s212_scalar)->Name(\"Scalar_s212\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s212, s212_simd)->Name(\"SIMD_s212\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s212", "entrypoint_scalar": "s212_scalar", "entrypoint_simd": "s212"}
{"task_id": "tsvc_s1213", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a dependency needing a temporary variable:\n1. a[i] = b[i-1] + c[i];\n2. b[i] = a[i+1] * d[i];\nImplement this .\n*/\nvoid s1213(float *a, float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 1; i < n - 1; i++) {\n        a[i] = b[i-1] + c[i];\n        b[i] = a[i+1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s1213_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1213 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s1213_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s1213_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1213!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s1213_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s1213(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s1213 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-2). Each op: 4R (b,c,a,d), 2W (a,b)\n    size_t num_ops = length - 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1213, s1213_scalar)->Name(\"Scalar_s1213\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1213, s1213_simd)->Name(\"SIMD_s1213\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1213", "entrypoint_scalar": "s1213_scalar", "entrypoint_simd": "s1213"}
{"task_id": "tsvc_s221", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a partially recursive operation (loop distribution):\n1. a[i] += c[i] * d[i];\n2. b[i] = b[i - 1] + a[i] + d[i];\nImplement this .\n*/\nvoid s221(float *a, float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s221_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        a[i] += c[i] * d[i];\n        b[i] = b[i - 1] + a[i] + d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s221_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s221\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s221_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s221_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s221!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s221_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s221(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s221\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-1). Each op: 6R (a,c,d,b,a,d), 2W (a,b)\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s221, s221_scalar)->Name(\"Scalar_s221\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s221, s221_simd)->Name(\"SIMD_s221\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s221", "entrypoint_scalar": "s221_scalar", "entrypoint_simd": "s221"}
{"task_id": "tsvc_s1221", "prompt": "/*\nThis function takes float arrays 'a' and 'b' and length 'n'.\nIt performs a recurrence: b[i] = b[i - 4] + a[i];\nThis tests loop-carried dependencies with a fixed stride.\nImplement this .\n*/\nvoid s1221(const float *a, float *b, size_t n) {\n}\n", "solution_scalar": "void s1221_scalar(const float *a, float *b, size_t n) {\n    for (size_t i = 4; i < n; i++) {\n        b[i] = b[i - 4] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1221_scalar(const float *a, float *b, size_t n);\nvoid s1221_simd(const float *a, float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_input(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> b_scalar(length);\n    std::vector<float> b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1221 (uses default init())\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1221_scalar(a_input.data(), b_scalar.data(), length);\n       \ts1221_simd(a_input.data(), b_simd.data(), length);\n\n       \tif (!allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1221!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1221_scalar(const float *a, float *b, size_t n);\nvoid s1221_simd(const float *a, float *b, size_t n);\n\ntemplate<void (*Func)(const float *, float *, size_t)>\nstatic void BM_s1221(benchmark::State& state) {\n -> \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1221 (uses default init())\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n\n       \tFunc(a_input.data(), b_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n -> \t// Loop (n-4). Each op: 2R (b,a), 1W (b)\n   \tsize_t num_ops = length - 4;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1221, s1221_scalar)->Name(\"Scalar_s1221\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1221, s1221_simd)->Name(\"SIMD_s1221\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1221", "entrypoint_scalar": "s1221_scalar", "entrypoint_simd": "s1221"}
{"task_id": "tsvc_s222", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'e' and length 'n'.\nIt performs a partially recursive operation:\n1. a[i] += b[i] * c[i];\n2. e[i] = e[i - 1] * e[i - 1]; // Recurrence\n3. a[i] -= b[i] * c[i];\nImplement this . The 'e' loop has a dependency.\n*/\nvoid s222(float *a, const float *b, const float *c, float *e, size_t n) {\n}\n", "solution_scalar": "void s222_scalar(float *a, const float *b, const float *c, float *e, size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        a[i] += b[i] * c[i];\n        e[i] = e[i - 1] * e[i - 1];\n        a[i] -= b[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s222_scalar(float *a, const float *b, const float *c, float *e, size_t n);\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> e_initial(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> e_scalar(length), e_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s222\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            e_initial[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n       \ta_simd = a_initial;\n       \te_scalar = e_initial;\n       \te_simd = e_initial;\n\n       \ts222_scalar(a_scalar.data(), b_input.data(), c_input.data(), e_scalar.data(), length);\n       \ts222_simd(a_simd.data(), b_input.data(), c_input.data(), e_simd.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(e_scalar, e_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s222!\" << std::endl;\n            return false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s222_scalar(float *a, const float *b, const float *c, float *e, size_t n);\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, float *, size_t)>\nstatic void BM_s222(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> e_output(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> e_initial(length);\n\n   \t// Ported Initialization Logic for s222\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \te_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \te_output = e_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(e_output.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), e_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2 R/W(a), 4 R(b,c,b,c), 1 R/W(e), 1 R(e). Total: 10 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s222, s222_scalar)->Name(\"Scalar_s222\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s222, s222_simd)->Name(\"SIMD_s222\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s222", "entrypoint_scalar": "s222_scalar", "entrypoint_simd": "s222"}
{"task_id": "tsvc_s231", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a column-wise recurrence: aa[j][i] = aa[j - 1][i] + bb[j][i];\nThis tests dependencies in the inner loop with non-unit stride.\nImplement this .\n*/\nvoid s231(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; ++i) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + bb[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_scalar(length);\n   \tstd::vector<float> aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s231\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f;\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts231_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n       \ts231_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s231!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s231(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s231\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f;\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop n_2d * (n_2d - 1). Each op: 2R (aa, bb), 1W (aa)\n   \tsize_t num_ops = n_2d * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s231, s231_scalar)->Name(\"Scalar_s231\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s231, s231_simd)->Name(\"SIMD_s231\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s231", "entrypoint_scalar": "s231_scalar", "entrypoint_simd": "s231"}
{"task_id": "tsvc_s232", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop with recurrence: aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i];\nThis tests recurrence in the inner loop.\nImplement this .\n*/\nvoid s232(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n   \tfor (size_t j = 1; j < n_2d; j++) {\n       \tfor (size_t i = 1; i <= j; i++) {\n           \t// aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_i_1 = j * n_2d + (i - 1);\n           \tfloat temp = aa_flat[idx_j_i_1];\n           \taa_flat[idx_ji] = temp * temp + bb_flat[idx_ji];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_scalar(length);\n   \tstd::vector<float> aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s232\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts232_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n       \ts232_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s232!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s232(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s232\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d * (n_2d - 1)) / 2. Each op: 3R (aa, aa, bb), 1W (aa)\n   \tsize_t num_ops = (n_2d * (n_2d - 1)) / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s232, s232_scalar)->Name(\"Scalar_s232\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s232, s232_simd)->Name(\"SIMD_s232\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s232", "entrypoint_scalar": "s232_scalar", "entrypoint_simd": "s232"}
{"task_id": "tsvc_s1232", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop, column-wise: aa[i][j] = bb[i][j] + cc[i][j];\nThis tests non-unit stride (strided) memory access.\nImplement this .\n*/\nvoid s1232(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t j = 0; j < n_2d; j++) {\n       \tfor (size_t i = j; i < n_2d; i++) {\n           \t// aa[i][j] = bb[i][j] + cc[i][j]\n           \tsize_t idx_ij = i * n_2d + j;\n           \taa_flat[idx_ij] = bb_flat[idx_ij] + cc_flat[idx_ij];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length);\n   \tstd::vector<float> aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1232\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 0.0f;\n           \tbb_input[i] = 1.0f / (float)(i+1); // frac\n           \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts1232_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       \ts1232_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1232!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s1232(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s1232\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 0.0f;\n       \tbb_input[i] = 1.0f / (float)(i+1); // frac\n       \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d * (n_2d + 1)) / 2. Each op: 2R (bb, cc), 1W (aa)\n   \tsize_t num_ops = (n_2d * (n_2d + 1)) / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1232, s1232_scalar)->Name(\"Scalar_s1232\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1232, s1232_simd)->Name(\"SIMD_s1232\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1232", "entrypoint_scalar": "s1232_scalar", "entrypoint_simd": "s1232"}
{"task_id": "tsvc_s233", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt contains two inner loops with different dependencies:\n1. aa[j][i] = aa[j-1][i] + cc[j][i]; (Column-wise recurrence)\n2. bb[j][i] = bb[j][i-1] + cc[j][i]; (Column-wise recurrence)\nImplement this .\n*/\nvoid s233(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 1; i < n_2d; i++) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + cc[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + cc_flat[idx_ji];\n       \t}\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// bb[j][i] = bb[j][i-1] + cc[j][i]  -- NOTE: TSVC source has bb[j][i-1], this is column-wise\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_i_1 = j * n_2d + (i - 1);\n           \tbb_flat[idx_ji] = bb_flat[idx_j_i_1] + cc_flat[idx_ji];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n   \tstd::vector<float> bb_scalar(length), bb_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s233\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n       \tbb_scalar = bb_initial;\n       \tbb_simd = bb_initial;\n\n       \ts233_scalar(aa_scalar.data(), bb_scalar.data(), cc_input.data(), n_2d);\n       \ts233_simd(aa_simd.data(), bb_simd.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd) || !allclose(bb_scalar, bb_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s233!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t)>\nstatic void BM_s233(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_output(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n\n   \t// Ported Initialization Logic for s233\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbb_output = bb_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_output.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_output.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// (n_2d - 1) * (n_2d - 1) ops for each loop. Each op = 2R, 1W. Total = 6 accesses.\n   \tsize_t num_ops = (n_2d - 1) * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s233, s233_scalar)->Name(\"Scalar_s233\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s233, s233_simd)->Name(\"SIMD_s233\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s233", "entrypoint_scalar": "s233_scalar", "entrypoint_simd": "s233"}
{"task_id": "tsvc_s2233", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt contains two inner loops with different dependencies:\n1. aa[j][i] = aa[j-1][i] + cc[j][i]; (Column-wise recurrence)\n2. bb[i][j] = bb[i-1][j] + cc[i][j]; (Row-wise recurrence)\nImplement this .\n*/\nvoid s2233(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 1; i < n_2d; i++) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + cc[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + cc_flat[idx_ji];\n       \t}\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// bb[i][j] = bb[i-1][j] + cc[i][j]\n           \tsize_t idx_ij = i * n_2d + j;\n           \tsize_t idx_i_1_j = (i - 1) * n_2d + j;\n           \tbb_flat[idx_ij] = bb_flat[idx_i_1_j] + cc_flat[idx_ij];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n   \tstd::vector<float> bb_scalar(length), bb_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2233 (same as s233)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n       \tbb_scalar = bb_initial;\n       \tbb_simd = bb_initial;\n\n       \ts2233_scalar(aa_scalar.data(), bb_scalar.data(), cc_input.data(), n_2d);\n       \ts2233_simd(aa_simd.data(), bb_simd.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd) || !allclose(bb_scalar, bb_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2233!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t)>\nstatic void BM_s2233(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_output(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n\n   \t// Ported Initialization Logic for s2233 (same as s233)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbb_output = bb_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_output.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_output.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// (n_2d - 1) * (n_2d - 1) ops for each loop. Each op = 2R, 1W. Total = 6 accesses.\n   \tsize_t num_ops = (n_2d - 1) * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2233, s2233_scalar)->Name(\"Scalar_s2233\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2233, s2233_simd)->Name(\"SIMD_s2233\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2233", "entrypoint_scalar": "s2233_scalar", "entrypoint_simd": "s2233"}
{"task_id": "tsvc_s235", "prompt": "/*\nThis function is imperfectly nested. It takes 1D arrays 'a', 'b', 'c' and 2D arrays 'aa', 'bb'.\n1. a[i] += b[i] * c[i];\n2. Inner loop: aa[j][i] = aa[j-1][i] + bb[j][i] * a[i];\nThis tests loop interchange on imperfectly nested loops.\nImplement this .\n*/\nvoid s235(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \ta[i] += b[i] * c[i];\n       \tfloat a_i = a[i]; // Hoist for inner loop\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + bb[j][i] * a_i\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji] * a_i;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s235\n       \tfor(size_t i = 0; i < n_1d; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \tfor(size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts235_scalar(a_scalar.data(), b_input.data(), c_input.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n       \ts235_simd(a_simd.data(), b_input.data(), c_input.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s235!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, float*, const float*, size_t, size_t)>\nstatic void BM_s235(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s235\n   \tfor(size_t i = 0; i < n_1d; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n   \tfor(size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n Z     \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Ops: n_2d * (3 accesses) + n_2d * (n_2d - 1) * (4 accesses)\n   \tsize_t outer_ops = n_2d;\n   \tsize_t inner_ops = n_2d * (n_2d - 1);\n   \tint64_t bytes = (int64_t(outer_ops) * 3 + int64_t(inner_ops) * 4) * sizeof(float);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s235, s235_scalar)->Name(\"Scalar_s235\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s235, s235_simd)->Name(\"SIMD_s235\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s235", "entrypoint_scalar": "s235_scalar", "entrypoint_simd": "s235"}
{"task_id": "tsvc_s241", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a node-splitting task with dependencies:\n1. a[i] = b[i] * c[i] * d[i];\n2. b[i] = a[i] * a[i+1] * d[i];\nImplement this .\n*/\nvoid s241(float *a, float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s241_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = b[i] * c[i] * d[i];\n        b[i] = a[i] * a[i + 1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s241_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s241\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts241_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n       \ts241_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s241!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s241_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s241(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s241\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 5R (b,c,d,a[i+1],d), 1 R/W (a), 1W (b). Total: 8 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s241, s241_scalar)->Name(\"Scalar_s241\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s241, s241_simd)->Name(\"SIMD_s241\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s241", "entrypoint_scalar": "s241_scalar", "entrypoint_simd": "s241"}
{"task_id": "tsvc_s242", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', length 'n', and two scalars 's1', 's2'.\nIt performs a recurrence: a[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\nImplement this .\n*/\nvoid s242(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n}\n", "solution_scalar": "void s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n   \tfor (size_t i = 1; i < n; ++i) {\n       \ta[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tfloat s1 = 1.2f;\n   \tfloat s2 = 2.1f;\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s242 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts242_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n       \ts242_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s242!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t, float, float)>\nstatic void BM_s242(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tfloat s1 = 1.2f;\n   \tfloat s2 = 2.1f;\n\n   \t// Ported Initialization Logic for s242 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 4R (a[i-1], b, c, d), 1W (a[i]). Total: 5 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s242, s242_scalar)->Name(\"Scalar_s242\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s242, s242_simd)->Name(\"SIMD_s242\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s242", "entrypoint_scalar": "s242_scalar", "entrypoint_simd": "s242"}
{"task_id": "tsvc_s243", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a node-splitting task with false dependencies:\n1. a[i] = b[i] + c[i] * d[i];\n2. b[i] = a[i] + d[i] * e[i];\n3. a[i] = b[i] + a[i+1] * d[i];\nImplement this .\n*/\nvoid s243(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i] = b[i] + c[i] * d[i];\n       \tb[i] = a[i] + d[i] * e[i];\n       \ta[i] = b[i] + a[i + 1] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s243 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts243_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts243_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s243!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s243(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s243 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 5R (b,c,d,e,a[i+1]), 2 R/W (a,b). Total: 9 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s243, s243_scalar)->Name(\"Scalar_s243\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s243, s243_simd)->Name(\"SIMD_s243\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s243", "entrypoint_scalar": "s243_scalar", "entrypoint_simd": "s243"}
{"task_id": "tsvc_s244", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a node-splitting task with false dependencies:\n1. a[i] = b[i] + c[i] * d[i];\n2. b[i] = c[i] + b[i];\n3. a[i+1] = b[i] + a[i+1] * d[i];\nImplement this .\n*/\nvoid s244(float *a, float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s244_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; ++i) {\n       \ta[i] = b[i] + c[i] * d[i];\n       \tb[i] = c[i] + b[i];\n       \ta[i + 1] = b[i] + a[i + 1] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s244_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s244 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts244_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n       \ts244_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s244!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s244_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s244(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s244 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (c,d), 2 R/W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s244, s244_scalar)->Name(\"Scalar_s244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s244, s244_simd)->Name(\"SIMD_s244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s244", "entrypoint_scalar": "s244_scalar", "entrypoint_simd": "s244"}
{"task_id": "tsvc_s1244", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a task with true and anti-dependencies:\n1. a[i] = b[i] + c[i] * c[i] + b[i]*b[i] + c[i];\n2. d[i] = a[i] + a[i+1];\nImplement this .\n*/\nvoid s1244(float *a, const float *b, const float *c, float *d, size_t n) {\n}\n", "solution_scalar": "void s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i] = b[i] + c[i] * c[i] + b[i] * b[i] + c[i];\n       \td[i] = a[i] + a[i + 1];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n);\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_initial(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> d_scalar(length), d_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1244 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_initial[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \td_scalar = d_initial;\n       \td_simd = d_initial;\n\n       \ts1244_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_scalar.data(), length);\n       \ts1244_simd(a_simd.data(), b_input.data(), c_input.data(), d_simd.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(d_scalar, d_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1244!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n);\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, float *, size_t)>\nstatic void BM_s1244(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_output(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> d_initial(length);\n\n   \t// Ported Initialization Logic for s1244 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \td_output = d_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_output.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 7R (b,c,c,b,c, a[i], a[i+1]), 2W (a,d). Total: 9 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1244, s1244_scalar)->Name(\"Scalar_s1244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1244, s1244_simd)->Name(\"SIMD_s1244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1244", "entrypoint_scalar": "s1244_scalar", "entrypoint_simd": "s1244"}
{"task_id": "tsvc_s2244", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'e' and length 'n'.\nIt performs a node-splitting task:\n1. a[i+1] = b[i] + e[i];\n2. a[i] = b[i] + c[i];\nImplement this .\n*/\nvoid s2244(float *a, const float *b, const float *c, const float *e, size_t n) {\n}\n", "solution_scalar": "void s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i + 1] = b[i] + e[i];\n       \ta[i] = b[i] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n);\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2244 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts2244_scalar(a_scalar.data(), b_input.data(), c_input.data(), e_input.data(), length);\n       \ts2244_simd(a_simd.data(), b_input.data(), c_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2244!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n);\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s2244(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s2244 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 4R (b,e,b,c), 2W (a,a). Total: 6 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2244, s2244_scalar)->Name(\"Scalar_s2244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2244, s2244_simd)->Name(\"SIMD_s2244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2244", "entrypoint_scalar": "s2244_scalar", "entrypoint_simd": "s2244"}
{"task_id": "tsvc_s251", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a scalar expansion task:\n1. s = b[i] + c[i] * d[i];\n2. a[i] = s * s;\nImplement this .\n*/\nvoid s251(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat s = b[i] + c[i] * d[i];\n       \ta[i] = s * s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s251\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts251_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts251_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s251\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,c,d), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s251, s251_scalar)->Name(\"Scalar_s251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s251, s251_simd)->Name(\"SIMD_s251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s251", "entrypoint_scalar": "s251_scalar", "entrypoint_simd": "s251"}
{"task_id": "tsvc_s1251", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task:\n1. s = b[i]+c[i];\n2. b[i] = a[i]+d[i];\n3. a[i] = s*e[i];\nImplement this .\n*/\nvoid s1251(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat s = b[i] + c[i];\n       \tb[i] = a[i] + d[i];\n       \ta[i] = s * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1251\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts1251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n s  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1251\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (b,c,a,d,e), 2W (b,a). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1251, s1251_scalar)->Name(\"Scalar_s1251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1251, s1251_simd)->Name(\"SIMD_s1251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1251", "entrypoint_scalar": "s1251_scalar", "entrypoint_simd": "s1251"}
{"task_id": "tsvc_s2251", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task with a loop-carried dependency:\n1. a[i] = s*e[i];\n2. s = b[i]+c[i];\n3. b[i] = a[i]+d[i];\nImplement this .\n*/\nvoid s2251(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfloat s = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = s * e[i];\n       \ts = b[i] + c[i];\n       \tb[i] = a[i] + d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2251\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts2251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts2251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s2251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s2251\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (e,b,c,a,d), 2W (a,b). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2251, s2251_scalar)->Name(\"Scalar_s2251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2251, s2251_simd)->Name(\"SIMD_s2251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2251", "entrypoint_scalar": "s2251_scalar", "entrypoint_simd": "s2251"}
{"task_id": "tsvc_s3251", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task with dependencies:\n1. a[i+1] = b[i]+c[i];\n2. b[i] = c[i]*e[i];\n3. d[i] = a[i]*e[i];\nImplement this .\n*/\nvoid s3251(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i + 1] = b[i] + c[i];\n       \tb[i] = c[i] * e[i];\n       \td[i] = a[i] * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n);\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_initial(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> d_scalar(length), d_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3251 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_initial[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \td_scalar = d_initial;\n       \td_simd = d_initial;\n\n       \ts3251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_scalar.data(), e_input.data(), length);\n       \ts3251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_simd.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(d_scalar, d_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n);\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, float *, const float *, size_t)>\nstatic void BM_s3251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_output(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> d_initial(length);\n\n   \t// Ported Initialization Logic for s3251 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_initial[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \td_output = d_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_output.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_output.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 6R (b,c,c,e,a,e), 3W (a,b,d). Total: 9 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3251, s3251_scalar)->Name(\"Scalar_s3251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3251, s3251_simd)->Name(\"SIMD_s3251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s3251", "entrypoint_scalar": "s3251_scalar", "entrypoint_simd": "s3251"}
{"task_id": "tsvc_s252", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a scalar expansion with a loop-carried dependency:\n1. s = b[i] * c[i];\n2. a[i] = s + t; (where t = s from previous iteration)\n3. t = s;\nImplement this .\n*/\nvoid s252(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s252_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfloat t = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat s = b[i] * c[i];\n       \ta[i] = s + t;\n       \tt = s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s252_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s252_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s252 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts252_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts252_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s252!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s252_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s252_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s252(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s252 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s252, s252_scalar)->Name(\"Scalar_s252\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s252, s252_simd)->Name(\"SIMD_s252\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s252", "entrypoint_scalar": "s252_scalar", "entrypoint_simd": "s252"}
{"task_id": "tsvc_s253", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a conditional scalar expansion and update:\nif (a[i] > b[i]) { s = a[i] - b[i] * d[i]; c[i] += s; a[i] = s; }\nImplement this .\n*/\nvoid s253(float *a, const float *b, float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s253_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > b[i]) {\n           \tfloat s = a[i] - b[i] * d[i];\n           \tc[i] += s;\n           \ta[i] = s;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s253_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s253\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts253_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), length);\n       \ts253_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s253!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s253_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, size_t)>\nstatic void BM_s253(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s253\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_output.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 4R (a,b,c,d), 2W (c,a). Total: 6 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s253, s253_scalar)->Name(\"Scalar_s253\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s253, s253_simd)->Name(\"SIMD_s253\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s253", "entrypoint_scalar": "s253_scalar", "entrypoint_simd": "s253"}
{"task_id": "tsvc_s254", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a scalar expansion with a carry-around variable:\na[i] = (b[i] + x) * 0.5f; (where x = b[i-1])\nx = b[i];\nImplement this .\n*/\nvoid s254(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s254_scalar(float *a, const float *b, size_t n) {\n   \tfloat x = b[n - 1];\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + x) * 0.5f;\n       \tx = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s254_scalar(float *a, const float *b, size_t n);\nvoid s254_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s254\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts254_scalar(a_scalar.data(), b_input.data(), length);\n       \ts254_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s254!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s254_scalar(float *a, const float *b, size_t n);\nvoid s254_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s254(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s254\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b[i], x=b[i-1]), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s254, s254_scalar)->Name(\"Scalar_s254\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s254, s254_simd)->Name(\"SIMD_s254\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s254", "entrypoint_scalar": "s254_scalar", "entrypoint_simd": "s254"}
{"task_id": "tsvc_s255", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a scalar expansion with 2-level carry-around variables:\na[i] = (b[i] + x + y) * 0.333f; (where x=b[i-1], y=b[i-2])\ny = x; x = b[i];\nImplement this .\n*/\nvoid s255(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s255_scalar(float *a, const float *b, size_t n) {\n   \tfloat x = b[n - 1];\n   \tfloat y = b[n - 2];\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + x + y) * 0.333f;\n       \ty = x;\n       \tx = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s255_scalar(float *a, const float *b, size_t n);\nvoid s255_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s255\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts255_scalar(a_scalar.data(), b_input.data(), length);\n       \ts255_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s255!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s255_scalar(float *a, const float *b, size_t n);\nvoid s255_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s255(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s255\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b[i], x=b[i-1], y=b[i-2]), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s255, s255_scalar)->Name(\"Scalar_s255\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s255, s255_simd)->Name(\"SIMD_s255\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s255", "entrypoint_scalar": "s255_scalar", "entrypoint_simd": "s255"}
{"task_id": "tsvc_s256", "prompt": "/*\nThis function tests array expansion. It takes 1D arrays 'a', 'd' and 2D arrays 'aa', 'bb'.\nInner loop: \n1. a[j] = 1.0f - a[j - 1];\n2. aa[j][i] = a[j] + bb[j][i] * d[j];\nImplement this .\n*/\nvoid s256(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \ta[j] = 1.0f - a[j - 1];\n           \t// aa[j][i] = a[j] + bb[j][i]*d[j]\n           \taa_flat[j * n_2d + i] = a[j] + bb_flat[j * n_2d + i] * d[j];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s256\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts256_scalar(a_scalar.data(), d_input.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n       \ts256_simd(a_simd.data(), d_input.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s256!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float *, const float *, float*, const float*, size_t, size_t)>\nstatic void BM_s256(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s256\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(a_output.data(), d_input.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop n_2d * (n_2d - 1). Ops: 1R/W(a), 1R(a[j-1]), 2R(bb,d), 1W(aa). Total: 5 accesses.\n   \tsize_t num_ops = n_2d * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s256, s256_scalar)->Name(\"Scalar_s256\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s256, s256_simd)->Name(\"SIMD_s256\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s256", "entrypoint_scalar": "s256_scalar", "entrypoint_simd": "s256"}
{"task_id": "tsvc_s257", "prompt": "/*\nThis function tests array expansion. It takes 1D array 'a' and 2D arrays 'aa', 'bb'.\nInner loop: \n1. a[i] = aa[j][i] - a[i-1];\n2. aa[j][i] = a[i] + bb[j][i];\nImplement this .\n*/\nvoid s257(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 1; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \t// a[i] = aa[j][i] - a[i-1]\n           \ta[i] = aa_flat[j * n_2d + i] - a[i - 1];\n           \t// aa[j][i] = a[i] + bb[j][i]\n           \taa_flat[j * n_2d + i] = a[i] + bb_flat[j * n_2d + i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s257\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts257_scalar(a_scalar.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n g     \ts257_simd(a_simd.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s257!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t, size_t)>\nstatic void BM_s257(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s257\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(a_output.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d - 1) * n_2d. Ops: 1R/W(aa), 1R(a[i-1]), 1R(bb), 1R/W(a). Total: 5 accesses.\n   \tsize_t num_ops = (n_2d - 1) * n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s257, s257_scalar)->Name(\"Scalar_s257\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s257, s257_simd)->Name(\"SIMD_s257\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s257", "entrypoint_scalar": "s257_scalar", "entrypoint_simd": "s257"}
{"task_id": "tsvc_s258", "prompt": "/*\nThis function tests a wrap-around scalar dependency under an if.\nScalar 's' is updated conditionally and used in subsequent iterations.\n1. if (a[i] > 0.) { s = d[i] * d[i]; }\n2. b[i] = s * c[i] + d[i];\n3. e[i] = (s + 1.0f) * aa[0][i];\nImplement this .\n*/\nvoid s258(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D. Loop is to n_2d\n   \tfloat s = 0.0f;\n   \tfor (size_t i = 0; i < n_2d; ++i) {\n       \tif (a[i] > 0.0f) {\n           \ts = d[i] * d[i];\n       \t}\n       \tb[i] = s * c[i] + d[i];\n       \te[i] = (s + 1.0f) * aa_flat[0 * n_2d + i]; // aa[0][i]\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> b_initial(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> e_initial(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<float> b_scalar(length_1d), b_simd(length_1d);\n   \tstd::vector<float> e_scalar(length_1d), e_simd(length_1d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s258\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_initial[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \te_scalar = e_initial;\n       \te_simd = e_initial;\n\n       \ts258_scalar(a_input.data(), b_scalar.data(), c_input.data(), d_input.data(), e_scalar.data(), aa_input.data(), n_2d, n_1d);\n       \ts258_simd(a_input.data(), b_simd.data(), c_input.data(), d_input.data(), e_simd.data(), aa_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(b_scalar, b_simd) || !allclose(e_scalar, e_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s258!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n T  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(const float *, float *, const float *, const float *, float *, const float*, size_t, size_t)>\nstatic void BM_s258(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> b_output(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> e_output(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<float> b_initial(length_1d);\n   \tstd::vector<float> e_initial(length_1d);\n\n   \t// Ported Initialization Logic for s258\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_initial[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \te_output = e_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_output.data());\n       \tbenchmark::DoNotOptimize(aa_input.data());\n\n       \tFunc(a_input.data(), b_output.data(), c_input.data(), d_input.data(), e_output.data(), aa_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d). Ops: 5R (a, d, c, d, aa), 2W (b, e). Total: 7 accesses.\n   \tsize_t num_ops = n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s258, s258_scalar)->Name(\"Scalar_s258\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s258, s258_simd)->Name(\"SIMD_s258\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s258", "entrypoint_scalar": "s258_scalar", "entrypoint_simd": "s258"}
{"task_id": "tsvc_s261", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt tests scalar variable reuse:\n1. t = a[i] + b[i];\n2. a[i] = t + c[i-1];\n3. t = c[i] * d[i];\n4. c[i] = t;\nImplement this .\n*/\nvoid s261(float *a, const float *b, float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s261_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n   \tfor (size_t i = 1; i < n; ++i) {\n       \tfloat t = a[i] + b[i];\n       \ta[i] = t + c[i - 1];\n       \tt = c[i] * d[i];\n       \tc[i] = t;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s261_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s261\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts261_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), length);\n       \ts261_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s261!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s261_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, size_t)>\nstatic void BM_s261(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s261\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_output.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 3R (b,c[i-1],d), 2 R/W (a,c). Total: 7 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s261, s261_scalar)->Name(\"Scalar_s261\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s261, s261_simd)->Name(\"SIMD_s261\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s261", "entrypoint_scalar": "s261_scalar", "entrypoint_simd": "s261"}
{"task_id": "tsvc_s271", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple conditional operation (masked write):\nif (b[i] > 0.0f) { a[i] += b[i] * c[i]; }\nImplement this .\n*/\nvoid s271(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s271_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] > 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s271_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s271_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s271\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts271_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts271_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s271!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s271_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s271_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s271(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s271\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,a,c), 1W (a). Total: 4 accesses. (b[i] > 0 always true)\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s271, s271_scalar)->Name(\"Scalar_s271\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s271, s271_simd)->Name(\"SIMD_s271\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s271", "entrypoint_scalar": "s271_scalar", "entrypoint_simd": "s271"}
{"task_id": "tsvc_s272", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', length 'n' and an int 't'.\nIt performs two conditional operations under a single check:\nif (e[i] >= t) { a[i] += c[i] * d[i]; b[i] += c[i] * c[i]; }\nImplement this .\n*/\nvoid s272(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int) {\n}\n", "solution_scalar": "void s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int) {\n   \tfloat t = (float)t_int;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (e[i] >= t) {\n           \ta[i] += c[i] * d[i];\n           \tb[i] += c[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint t = 1; // From tsvc.c\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n -> \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s272\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f; // e[i] >= t (1.0) is always true\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts272_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n       \ts272_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s272!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t, int)>\nstatic void BM_s272(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n   \tint t = 1; // From tsvc.c\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s272\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f; // e[i] >= t (1.0) is always true\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 6R (e,a,c,d,b,c), 2W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s272, s272_scalar)->Name(\"Scalar_s272\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s272, s272_simd)->Name(\"SIMD_s272\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s272", "entrypoint_scalar": "s272_scalar", "entrypoint_simd": "s272"}
{"task_id": "tsvc_s273", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a dependent conditional operation:\n1. a[i] += d[i] * e[i];\n2. if (a[i] < 0.0f) { b[i] += d[i] * e[i]; }\n3. c[i] += a[i] * d[i];\nImplement this .\n*/\nvoid s273(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += d[i] * e[i];\n       \tif (a[i] < 0.0f)\n           \tb[i] += d[i] * e[i];\n       \tc[i] += a[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s273\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? (1.0f / (float)(i+1)) : (-1.0f / (float)(i+1)); // frac, alternating sign\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts273_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts273_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s273!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s273(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s273\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? (1.0f / (float)(i+1)) : (-1.0f / (float)(i+1)); // frac, alternating sign\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 4R(d,e,d,a), 1R/W(a), 1R/W(b), 1R/W(c) + 2R(d,e) in 'if'. ~10 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s273, s273_scalar)->Name(\"Scalar_s273\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s273, s273_simd)->Name(\"SIMD_s273\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s273", "entrypoint_scalar": "s273_scalar", "entrypoint_simd": "s273"}
{"task_id": "tsvc_s274", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a complex conditional (if-then-else) operation:\n1. a[i] = c[i] + e[i] * d[i];\n2. if (a[i] > 0.0f) { b[i] = a[i] + b[i]; } else { a[i] = d[i] * e[i]; }\nImplement this .\n*/\nvoid s274(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = c[i] + e[i] * d[i];\n       \tif (a[i] > 0.0f) {\n           \tb[i] = a[i] + b[i];\n       \t} else {\n           \ta[i] = d[i] * e[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s274\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts274_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts274_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s274!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n Type  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s274(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s274\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R(c,e,d). Blend: 2R(a,b),1W(b) OR 2R(d,e),1W(a). R/W(a), R/W(b). Total ~7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s274, s274_scalar)->Name(\"Scalar_s274\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s274, s274_simd)->Name(\"SIMD_s274\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s274", "entrypoint_scalar": "s274_scalar", "entrypoint_simd": "s274"}
{"task_id": "tsvc_s275", "prompt": "/*\nThis function takes 2D float arrays 'aa', 'bb', 'cc' (flattened, row-major) of size n_2d * n_2d.\nIt performs a conditional inner loop (if around inner loop):\nif (aa[0][i] > 0.0f) { for (j=1..n_2d-1) aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i]; }\nImplement this .\n*/\nvoid s275(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tif (aa_flat[0 * n_2d + i] > 0.0f) { // aa[0][i]\n           \tfor (size_t j = 1; j < n_2d; j++) {\n             \t// aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i]\n             \tsize_t idx_ji = j * n_2d + i;\n             \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n             \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji] * cc_flat[idx_ji];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s275\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tcc_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts275_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       \ts275_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s275!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s275(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s275\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tcc_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop n_2d * (n_2d - 1). Each op: 3R (aa,bb,cc), 1W (aa). (if is always true)\n   \tsize_t num_ops = n_2d * (n_2d - 1);\n   \tint64_t bytes = (int64_t(num_ops) * 4 + int64_t(n_2d)) * sizeof(float); // 4 accesses in inner, 1 in outer 'if'\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s275, s275_scalar)->Name(\"Scalar_s275\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s275, s275_simd)->Name(\"SIMD_s275\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s275", "entrypoint_scalar": "s275_scalar", "entrypoint_simd": "s275"}
{"task_id": "tsvc_s2275", "prompt": "/*\nThis function is imperfectly nested. It takes 1D arrays 'a', 'b', 'c', 'd' and 2D 'aa', 'bb', 'cc'.\n1. Inner: aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i];\n2. Outer: a[i] = b[i] + c[i] * d[i];\nImplement this .\n*/\nvoid s2275(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d) {\n}\n", "solution_scalar": "void s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_ji] + bb_flat[idx_ji] * cc_flat[idx_ji];\n       \t}\n       \ta[i] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> cc_input(length_2d);\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2275\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tcc_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2275_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n       \ts2275_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), aa_simd.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2275!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, const float*, float*, const float*, const float*, size_t, size_t)>\nstatic void BM_s2275(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> cc_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s2275\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tcc_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), aa_output.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Inner: n_2d*n_2d ops * 3 accesses. Outer: n_2d ops * 4 accesses.\n   \tsize_t inner_ops = n_2d * n_2d;\n   \tsize_t outer_ops = n_2d;\n   \tint64_t bytes = (int64_t(inner_ops) * 3 + int64_t(outer_ops) * 4) * sizeof(float);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2275, s2275_scalar)->Name(\"Scalar_s2275\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2275, s2275_simd)->Name(\"SIMD_s2275\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2275", "entrypoint_scalar": "s2275_scalar", "entrypoint_simd": "s2275"}
{"task_id": "tsvc_s276", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a conditional operation based on the loop index 'i':\nif (i+1 < mid) { a[i] += b[i] * c[i]; } else { a[i] += b[i] * d[i]; }\nImplement this .\n*/\nvoid s276(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tsize_t mid = n / 2;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (i + 1 < mid) {\n           \ta[i] += b[i] * c[i];\n       \t} else {\n           \ta[i] += b[i] * d[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s276\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts276_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts276_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s276!\" << std::endl;\n t       \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s276(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s276\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,c,d), 1 R/W(a). Total: 5 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s276, s276_scalar)->Name(\"Scalar_s276\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s276, s276_simd)->Name(\"SIMD_s276\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s276", "entrypoint_scalar": "s276_scalar", "entrypoint_simd": "s276"}
{"task_id": "tsvc_s277", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs conditional operations with goto statements:\nif (a[i] >= 0.0f) goto L20;\nif (b[i] >= 0.0f) goto L30;\na[i] += c[i] * d[i];\nL30: b[i+1] = c[i] + d[i] * e[i];\nL20: ;\nImplement this .\n*/\nvoid s277(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tif (a[i] >= 0.0f) {\n           \tgoto L20;\n       \t}\n       \tif (b[i] >= 0.0f) {\n           \tgoto L30;\n       \t}\n       \ta[i] += c[i] * d[i];\nL30:\n       \tb[i + 1] = c[i] + d[i] * e[i];\nL20:\n       \t;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s277\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = -1.0f; // Force first 'if' to fail\n           \tb_initial[i] = -1.0f; // Force second 'if' to fail\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts277_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts277_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s277!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s277(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s277\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = -1.0f; // Force first 'if' to fail\n       \tb_initial[i] = -1.0f; // Force second 'if' to fail\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Worst case (both 'if's fail): 7R (a,b,a,c,d,c,d,e), 1W (b), 1R/W(a). Total 10 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s277, s277_scalar)->Name(\"Scalar_s277\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s277, s277_simd)->Name(\"SIMD_s277\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s277", "entrypoint_scalar": "s277_scalar", "entrypoint_simd": "s277"}
{"task_id": "tsvc_s278", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs an if-then-else pattern using goto:\nif (a[i] > 0.0f) goto L20;\nb[i] = -b[i] + d[i] * e[i];\ngoto L30;\nL20: c[i] = -c[i] + d[i] * e[i];\nL30: a[i] = b[i] + c[i] * d[i];\nImplement this .\n*/\nvoid s278(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tgoto L20;\n       \t}\n       \tb[i] = -b[i] + d[i] * e[i];\n       \tgoto L30;\nL20:\n       \tc[i] = -c[i] + d[i] * e[i];\nL30:\n       \ta[i] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s278\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts278_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts278_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s278!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s278(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s278\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 6R(a,b,d,e,b,c,d) 1W(b or c) 1R/W(a). Total ~9 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s278, s278_scalar)->Name(\"Scalar_s278\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s278, s278_simd)->Name(\"SIMD_s278\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s278", "entrypoint_scalar": "s278_scalar", "entrypoint_simd": "s278"}
{"task_id": "tsvc_s279", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs complex conditional logic with gotos:\nif (a[i] > 0.0f) goto L20;\nb[i] = -b[i] + d[i] * d[i];\nif (b[i] <= a[i]) goto L30;\nc[i] += d[i] * e[i];\ngoto L30;\nL20: c[i] = -c[i] + e[i] * e[i];\nL30: a[i] = b[i] + c[i] * d[i];\nImplement this .\n*/\nvoid s279(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tgoto L20;\n       \t}\n       \tb[i] = -b[i] + d[i] * d[i];\n       \tif (b[i] <= a[i]) {\n           \tgoto L30;\n       \t}\n       \tc[i] += d[i] * e[i];\n       \tgoto L30;\nL20:\n       \tc[i] = -c[i] + e[i] * e[i];\nL30:\n       \ta[i] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s279\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts279_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts279_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s279!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s279(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s279\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n ->   \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Very complex, worst case ~10-12 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 12);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s279, s279_scalar)->Name(\"Scalar_s279\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s279, s279_simd)->Name(\"SIMD_s279\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s279", "entrypoint_scalar": "s279_scalar", "entrypoint_simd": "s279"}
{"task_id": "tsvc_s1279", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a nested conditional operation:\nif (a[i] < 0.0f) { if (b[i] > a[i]) { c[i] += d[i] * e[i]; } }\nImplement this .\n*/\nvoid s1279(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] < 0.0f) {\n           \tif (b[i] > a[i]) {\n             \tc[i] += d[i] * e[i];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1279\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = -1.0f / (float)(i+1); // frac neg\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 pos\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts1279_scalar(a_input.data(), b_input.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts1279_simd(a_input.data(), b_input.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1279!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(const float *, const float *, float *, const float *, const float *, size_t)>\nstatic void BM_s1279(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s1279\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = -1.0f / (float)(i+1); // frac neg\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 pos\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_input.data(), b_input.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (a,b,a,d,e), 1 R/W(c). Total: 7 accesses. (all ifs true)\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1279, s1279_scalar)->Name(\"Scalar_s1279\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1279, s1279_simd)->Name(\"SIMD_s1279\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1279", "entrypoint_scalar": "s1279_scalar", "entrypoint_simd": "s1279"}
{"task_id": "tsvc_s2710", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', length 'n' and a scalar int 'x'.\nIt performs complex nested conditional logic:\nif (a[i] > b[i]) {\n  a[i] += b[i] * d[i];\n  if (n > 10) c[i] += d[i] * d[i]; else c[i] = d[i] * e[i] + 1.0f;\n} else {\n  b[i] = a[i] + e[i] * e[i];\n  if (x > 0) c[i] = a[i] + d[i] * d[i]; else c[i] += e[i] * e[i];\n}\nImplement this .\n*/\nvoid s2710(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x) {\n}\n", "solution_scalar": "void s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > b[i]) {\n           \ta[i] += b[i] * d[i];\n           \tif (n > 10) { // This will be true for benchmark runs\n             \tc[i] += d[i] * d[i];\n           \t} else {\n             \tc[i] = d[i] * e[i] + 1.0f;\n           \t}\n       \t} else {\n           \tb[i] = a[i] + e[i] * e[i];\n           \tif (x > 0) { // This is true for the test case\n             \tc[i] = a[i] + d[i] * d[i];\n           \t} else {\n             \tc[i] += e[i] * e[i];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint x = 1; // From tsvc.c\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2710\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? 1.0f : 0.5f; // Test both paths\n           \tb_initial[i] = 0.8f;\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts2710_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length, x);\n       \ts2710_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length, x);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2710!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t, int)>\nstatic void BM_s2710(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n   \tint x = 1; // From tsvc.c\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s2710\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? 1.0f : 0.5f; // Test both paths\n       \tb_initial[i] = 0.8f;\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length, x);\n g     \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Complex blend. ~10 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2710, s2710_scalar)->Name(\"Scalar_s2710\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2710, s2710_simd)->Name(\"SIMD_s2710\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2710", "entrypoint_scalar": "s2710_scalar", "entrypoint_simd": "s2710"}
{"task_id": "tsvc_s2711", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a conditional operation (masked write):\nif (b[i] != 0.0f) { a[i] += b[i] * c[i]; }\nImplement this .\n*/\nvoid s2711(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s2711_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] != 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2711_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2711\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = (float)(i % 2); // Mix of 0.0 and 1.0\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts2711_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts2711_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2711!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2711_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s2711(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s2711\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = (float)(i % 2); // Mix of 0.0 and 1.0\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,a,c), 1W (a). Total: 4 accesses (worst case).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2711, s2711_scalar)->Name(\"Scalar_s2711\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2711, s2711_simd)->Name(\"SIMD_s2711\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2711", "entrypoint_scalar": "s2711_scalar", "entrypoint_simd": "s2711"}
{"task_id": "tsvc_s2712", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple conditional operation (masked write):\nif (a[i] > b[i]) { a[i] += b[i] * c[i]; }\nImplement this .\n*/\nvoid s2712(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s2712_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > b[i]) {\n           \ta[i] += b[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2712_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2712 (same as s271 init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 (a > b is true for i > 0)\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts2712_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts2712_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2712!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2712_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s2712(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s2712\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (a,b,c), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2712, s2712_scalar)->Name(\"Scalar_s2712\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2712, s2712_simd)->Name(\"SIMD_s2712\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2712", "entrypoint_scalar": "s2712_scalar", "entrypoint_simd": "s2712"}
{"task_id": "tsvc_s281", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs an operation with a reverse-index read:\n1. x = a[n-i-1] + b[i] * c[i];\n2. a[i] = x - 1.0f;\n3. b[i] = x;\nImplement this .\n*/\nvoid s281(float *a, float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s281_scalar(float *a, float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat x = a[n - i - 1] + b[i] * c[i];\n       \ta[i] = x - 1.0f;\n       \tb[i] = x;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s281_scalar(float *a, float *b, const float *c, size_t n);\nvoid s281_simd(float *a, float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s281\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts281_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), length);\n       \ts281_simd(a_simd.data(), b_simd.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s281!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s281_scalar(float *a, float *b, const float *c, size_t n);\nvoid s281_simd(float *a, float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, size_t)>\nstatic void BM_s281(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s281\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (a_rev, b, c), 2W (a, b). Total: 5 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s281, s281_scalar)->Name(\"Scalar_s281\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s281, s281_simd)->Name(\"SIMD_s281\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s281", "entrypoint_scalar": "s281_scalar", "entrypoint_simd": "s281"}
{"task_id": "tsvc_s1281", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion:\n1. x = b[i]*c[i] + a[i]*d[i] + e[i];\n2. a[i] = x - 1.0f;\n3. b[i] = x;\nImplement this .\n*/\nvoid s1281(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat x = b[i] * c[i] + a[i] * d[i] + e[i];\n       \ta[i] = x - 1.0f;\n       \tb[i] = x;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1281 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1281_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts1281_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1281!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1281(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1281 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (b,c,a,d,e), 2W (a,b). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1281, s1281_scalar)->Name(\"Scalar_s1281\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1281, s1281_simd)->Name(\"SIMD_s1281\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1281", "entrypoint_scalar": "s1281_scalar", "entrypoint_simd": "s1281"}
{"task_id": "tsvc_s291", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a loop peeling / wrap-around variable task:\na[i] = (b[i] + b[im1]) * 0.5f; (where im1 = i-1, and b[-1] = b[n-1])\nim1 = i;\nImplement this .\n*/\nvoid s291(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s291_scalar(float *a, const float *b, size_t n) {\n   \tsize_t im1 = n - 1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + b[im1]) * 0.5f;\n       \tim1 = i;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s291_scalar(float *a, const float *b, size_t n);\nvoid s291_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s291 (same as s254)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts291_scalar(a_scalar.data(), b_input.data(), length);\n       \ts291_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s291!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s291_scalar(float *a, const float *b, size_t n);\nvoid s291_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s291(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s291\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b[i], b[im1]), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s291, s291_scalar)->Name(\"Scalar_s291\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s291, s291_simd)->Name(\"SIMD_s291\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s291", "entrypoint_scalar": "s291_scalar", "entrypoint_simd": "s291"}
{"task_id": "tsvc_s292", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a 2-level wrap-around variable task:\na[i] = (b[i] + b[im1] + b[im2]) * 0.333f; (im1 = i-1, im2 = i-2)\nim2 = im1; im1 = i;\nImplement this .\n*/\nvoid s292(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s292_scalar(float *a, const float *b, size_t n) {\n   \tsize_t im1 = n - 1;\n   \tsize_t im2 = n - 2;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + b[im1] + b[im2]) * 0.333f;\n       \tim2 = im1;\n       \tim1 = i;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s292_scalar(float *a, const float *b, size_t n);\nvoid s292_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s292 (same as s255)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts292_scalar(a_scalar.data(), b_input.data(), length);\n       \ts292_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s292!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s292_scalar(float *a, const float *b, size_t n);\nvoid s292_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s292(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s292\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b[i], b[im1], b[im2]), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s292, s292_scalar)->Name(\"Scalar_s292\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s292, s292_simd)->Name(\"SIMD_s292\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s292", "entrypoint_scalar": "s292_scalar", "entrypoint_simd": "s292"}
{"task_id": "tsvc_s293", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a broadcast operation: a[i] = a[0];\nImplement this .\n*/\nvoid s293(float *a, size_t n) {\n}\n", "solution_scalar": "void s293_scalar(float *a, size_t n) {\n   \tfloat a0 = a[0];\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = a0;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s293_scalar(float *a, size_t n);\nvoid s293_simd(float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s293 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts293_scalar(a_scalar.data(), length);\n       \ts293_simd(a_simd.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s293!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s293_scalar(float *a, size_t n);\nvoid s293_simd(float *a, size_t n);\n\ntemplate<void (*Func)(float *, size_t)>\nstatic void BM_s293(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s293 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n\n       \tFunc(a_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (a[0] - hoisted), 1W (a[i]). Total: 2 accesses (or 1 in loop).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s293, s293_scalar)->Name(\"Scalar_s293\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s293, s293_simd)->Name(\"SIMD_s293\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s293", "entrypoint_scalar": "s293_scalar", "entrypoint_simd": "s293"}
{"task_id": "tsvc_s2101", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt performs a main diagonal operation: aa[i][i] += bb[i][i] * cc[i][i];\nThis tests strided memory access.\nImplement this .\n*/\nvoid s2101(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tsize_t idx_ii = i * n_2d + i;\n       \taa_flat[idx_ii] += bb_flat[idx_ii] * cc_flat[idx_ii];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2101\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tcc_input[i] = 1.0f;\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2101_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       \ts2101_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2101!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s2101(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s2101\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tcc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d). Ops: 1 R/W(aa), 2R(bb,cc). Total: 4 accesses.\n   \tsize_t num_ops = n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2101, s2101_scalar)->Name(\"Scalar_s2101\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2101, s2101_simd)->Name(\"SIMD_s2101\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2101", "entrypoint_scalar": "s2101_scalar", "entrypoint_simd": "s2101"}
{"task_id": "tsvc_s2102", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt creates an identity matrix by first zeroing columns, then setting the diagonal.\n1. Inner loop: aa[j][i] = 0.0f;\n2. Outer loop: aa[i][i] = 1.0f;\nImplement this .\n*/\nvoid s2102(float* aa_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s2102_scalar(float* aa_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \taa_flat[j * n_2d + i] = 0.0f;\n       \t}\n       \taa_flat[i * n_2d + i] = 1.0f;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2102_scalar(float* aa_flat, size_t n_2d);\nvoid s2102_simd(float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2102\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 123.0f; // Fill with non-zero/one\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2102_scalar(aa_scalar.data(), n_2d);\n       \ts2102_simd(aa_simd.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2102!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2102_scalar(float* aa_flat, size_t n_2d);\nvoid s2102_simd(float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, size_t)>\nstatic void BM_s2102(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s2102\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 123.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n\n       \tFunc(aa_output.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d * n_2d) writes + n_2d writes. Total (n_2d^2 + n_2d) writes.\n   \tsize_t num_ops = (n_2d * n_2d) + n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2102, s2102_scalar)->Name(\"Scalar_s2102\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2102, s2102_simd)->Name(\"SIMD_s2102\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2102", "entrypoint_scalar": "s2102_scalar", "entrypoint_simd": "s2102"}
{"task_id": "tsvc_s2111", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt performs a wavefront computation (2D recurrence):\naa[j][i] = (aa[j][i-1] + aa[j-1][i]) / 1.9f;\nImplement this .\n*/\nvoid s2111(float* aa_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s2111_scalar(float* aa_flat, size_t n_2d) {\n   \tfor (size_t j = 1; j < n_2d; j++) {\n       \tfor (size_t i = 1; i < n_2d; i++) {\n           \taa_flat[j * n_2d + i] = (aa_flat[j * n_2d + (i - 1)] + aa_flat[(j - 1) * n_2d + i]) / 1.9f;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2111_scalar(float* aa_flat, size_t n_2d);\nvoid s2111_simd(float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2111 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f;\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2111_scalar(aa_scalar.data(), n_2d);\n       \ts2111_simd(aa_simd.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2111!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2111_scalar(float* aa_flat, size_t n_2d);\nvoid s2111_simd(float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, size_t)>\nstatic void BM_s2111(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s2111 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n\n       \tFunc(aa_output.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d-1) * (n_2d-1). Ops: 2R(aa), 1W(aa). Total: 3 accesses.\n   \tsize_t num_ops = (n_2d - 1) * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2111, s2111_scalar)->Name(\"Scalar_s2111\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2111, s2111_simd)->Name(\"SIMD_s2111\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s2111", "entrypoint_scalar": "s2111_scalar", "entrypoint_simd": "s2111"}
{"task_id": "tsvc_s311", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a sum reduction: sum += a[i];\nImplement this . The function should return the sum.\n*/\nfloat s311(const float *a, size_t n) {\n}\n", "solution_scalar": "float s311_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s311_scalar(const float *a, size_t n);\nfloat s311_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s311\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat sum_scalar = s311_scalar(a_input.data(), length);\n       \tfloat sum_simd = s311_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s311!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s311_scalar(const float *a, size_t n);\nfloat s311_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s311(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s311\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s311, s311_scalar)->Name(\"Scalar_s311\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s311, s311_simd)->Name(\"SIMD_s311\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s311", "entrypoint_scalar": "s311_scalar", "entrypoint_simd": "s311"}
{"task_id": "tsvc_s31111", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a sum reduction over the first 32 elements of 'a' using a helper.\nImplement this . The function should return the sum.\n*/\nfloat s31111(const float *a, size_t n) {\n}\n", "solution_scalar": "static float test_scalar(const float* A) {\n   \tfloat s = 0.0f;\n   \tfor (int i = 0; i < 4; i++)\n     \ts += A[i];\n   \treturn s;\n}\n\nfloat s31111_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tsum += test_scalar(a);\n   \tsum += test_scalar(&a[4]);\n   \tsum += test_scalar(&a[8]);\n   \tsum += test_scalar(&a[12]);\n   \tsum += test_scalar(&a[16]);\n   \tsum += test_scalar(&a[20]);\n   \tsum += test_scalar(&a[24]);\n   \tsum += test_scalar(&a[28]);\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstatic float test_scalar(const float* A) {\n   \tfloat s = 0.0f;\n   \tfor (int i = 0; i < 4; i++)\n     \ts += A[i];\n   \treturn s;\n}\nfloat s31111_scalar(const float *a, size_t n);\nfloat s31111_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s31111\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat sum_scalar = s31111_scalar(a_input.data(), length);\n       \tfloat sum_simd = s31111_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s31111!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s31111_scalar(const float *a, size_t n);\nfloat s31111_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s31111(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s31111\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Ops: 32 Reads (8 calls * 4 reads/call)\n   \tsize_t num_ops = 32;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s31111, s31111_scalar)->Name(\"Scalar_s31111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s31111, s31111_simd)->Name(\"SIMD_s31111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s31111", "entrypoint_scalar": "s31111_scalar", "entrypoint_simd": "s31111"}
{"task_id": "tsvc_s312", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a product reduction: prod *= a[i];\nImplement this . The function should return the product.\n*/\nfloat s312(const float *a, size_t n) {\n}\n", "solution_scalar": "float s312_scalar(const float *a, size_t n) {\n   \tfloat prod = 1.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tprod *= a[i];\n   \t}\n   \treturn prod;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s312_scalar(const float *a, size_t n);\nfloat s312_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s312\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f + 1.0f / (float)(i+1); // 1 + frac to avoid zero/denormal\n       \t}\n\n       \tfloat prod_scalar = s312_scalar(a_input.data(), length);\n       \tfloat prod_simd = s312_simd(a_input.data(), length);\n\n       \tif (!allclose(prod_scalar, prod_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s312!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s312_scalar(const float *a, size_t n);\nfloat s312_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s312(benchmark::State& state) {\n g  \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s312\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f + 1.0f / (float)(i+1); // 1 + frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat prod = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(prod);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s312, s312_scalar)->Name(\"Scalar_s312\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s312, s312_simd)->Name(\"SIMD_s312\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s312", "entrypoint_scalar": "s312_scalar", "entrypoint_simd": "s312"}
{"task_id": "tsvc_s313", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a dot product reduction: dot += a[i] * b[i];\nImplement this . The function should return the dot product.\n*/\nfloat s313(const float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "float s313_scalar(const float *a, const float *b, size_t n) {\n   \tfloat dot = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tdot += a[i] * b[i];\n   \t}\n   \treturn dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s313_scalar(const float *a, const float *b, size_t n);\nfloat s313_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s313\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat dot_scalar = s313_scalar(a_input.data(), b_input.data(), length);\n       \tfloat dot_simd = s313_simd(a_input.data(), b_input.data(), length);\n\n       \tif (!allclose(dot_scalar, dot_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s313!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s313_scalar(const float *a, const float *b, size_t n);\nfloat s313_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_s313(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \t// Ported Initialization Logic for s313\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tfloat dot = Func(a_input.data(), b_input.data(), length);\n       \tbenchmark::DoNotOptimize(dot);\n   \t}\n   \t// Loop (n). Ops: 2R (a, b).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s313, s313_scalar)->Name(\"Scalar_s313\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s313, s313_simd)->Name(\"SIMD_s313\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s313", "entrypoint_scalar": "s313_scalar", "entrypoint_simd": "s313"}
{"task_id": "tsvc_s314", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a max reduction: x = max(x, a[i]);\nImplement this . The function should return the max value.\n*/\n#include <limits>\nfloat s314(const float *a, size_t n) {\n}\n", "solution_scalar": "float s314_scalar(const float *a, size_t n) {\n   \tfloat x = a[0];\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > x) {\n           \tx = a[i];\n       \t}\n   \t}\n   \treturn x;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s314_scalar(const float *a, size_t n);\nfloat s314_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s314\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat max_scalar = s314_scalar(a_input.data(), length);\n       \tfloat max_simd = s314_simd(a_input.data(), length);\n\n       \tif (!allclose(max_scalar, max_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s314!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s314_scalar(const float *a, size_t n);\nfloat s314_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s314(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s314\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat max_val = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(max_val);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s314, s314_scalar)->Name(\"Scalar_s314\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s314, s314_simd)->Name(\"SIMD_s314\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s314", "entrypoint_scalar": "s314_scalar", "entrypoint_simd": "s314"}
{"task_id": "tsvc_s315", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt finds the max value and the index of that max value.\nImplement this . The function should return a pair of {max_value, index}.\n*/\n#include <limits>\n#include <utility>\nstd::pair<float, int> s315(const float *a, size_t n) {\n}\n", "solution_scalar": "#include <utility>\nstd::pair<float, int> s315_scalar(const float *a, size_t n) {\n   \tfloat x = a[0];\n   \tint index = 0;\n   \tfor (size_t i = 0; i < n; ++i) {\n       \tif (a[i] > x) {\n           \tx = a[i];\n           \tindex = (int)i;\n       \t}\n   \t}\n   \treturn {x, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s315_scalar(const float *a, size_t n);\nstd::pair<float, int> s315_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s315\n       \tfor (size_t i = 0; i < length; ++i)\n           \ta_input[i] = (float)((i * 7) % length);\n\n       \tstd::pair<float, int> res_scalar = s315_scalar(a_input.data(), length);\n       \tstd::pair<float, int> res_simd = s315_simd(a_input.data(), length);\n\n       \tif (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s315!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s315_scalar(const float *a, size_t n);\nstd::pair<float, int> s315_simd(const float *a, size_t n);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t)>\nstatic void BM_s315(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s315\n   \tfor (size_t i = 0; i < length; ++i)\n       \ta_input[i] = (float)((i * 7) % length);\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tstd::pair<float, int> res = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s315, s315_scalar)->Name(\"Scalar_s315\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s315, s315_simd)->Name(\"SIMD_s315\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s315", "entrypoint_scalar": "s315_scalar", "entrypoint_simd": "s315"}
{"task_id": "tsvc_s316", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a min reduction: x = min(x, a[i]);\nImplement this . The function should return the min value.\n*/\n#include <limits>\nfloat s316(const float *a, size_t n) {\n}\n", "solution_scalar": "float s316_scalar(const float *a, size_t n) {\n   \tfloat x = a[0];\n   \tfor (size_t i = 1; i < n; ++i) {\n       \tif (a[i] < x) {\n           \tx = a[i];\n       \t}\n   \t}\n   \treturn x;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s316_scalar(const float *a, size_t n);\nfloat s316_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s316 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat min_scalar = s316_scalar(a_input.data(), length);\n       \tfloat min_simd = s316_simd(a_input.data(), length);\n\n       \tif (!allclose(min_scalar, min_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s316!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s316_scalar(const float *a, size_t n);\nfloat s316_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s316(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s316 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat min_val = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(min_val);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s316, s316_scalar)->Name(\"Scalar_s316\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s316, s316_simd)->Name(\"SIMD_s316\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s316", "entrypoint_scalar": "s316_scalar", "entrypoint_simd": "s316"}
{"task_id": "tsvc_s317", "prompt": "/*\nThis function takes length 'n' (n/2 iterations).\nIt performs a product reduction of a constant: q *= 0.99f;\nImplement this . The function should return the product.\n*/\n#include <cmath>\nfloat s317(size_t n) {\n}\n", "solution_scalar": "float s317_scalar(size_t n) {\n   \tfloat q = 1.0f;\n   \tfor (size_t i = 0; i < n / 2; i++) {\n       \tq *= 0.99f;\n   \t}\n   \treturn q;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s317_scalar(size_t n);\nfloat s317_simd(size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \tfloat prod_scalar = s317_scalar(length);\n       \tfloat prod_simd = s317_simd(length);\n\n       \tif (!allclose(prod_scalar, prod_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s317!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s317_scalar(size_t n);\nfloat s317_simd(size_t n);\n\ntemplate<float (*Func)(size_t)>\nstatic void BM_s317(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tfor (auto _ : state) {\n       \tfloat prod = Func(length);\n       \tbenchmark::DoNotOptimize(prod);\n   \t}\n   \t// Loop (n/2). No memory ops.\n   \tstate.SetBytesProcessed(0);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s317, s317_scalar)->Name(\"Scalar_s317\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s317, s317_simd)->Name(\"SIMD_s317\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s317", "entrypoint_scalar": "s317_scalar", "entrypoint_simd": "s317"}
{"task_id": "tsvc_s318", "prompt": "/*\nThis function takes a float array 'a', length 'n', and an increment 'inc'.\nIt performs an ISAMAX (index of max absolute value) reduction with a stride 'inc'.\nImplement this . The function should return a pair of {max_abs_value, index}.\n*/\n#include <limits>\n#include <cmath>\n#include <utility>\nstd::pair<float, int> s318(const float *a, size_t n, int inc) {\n}\n", "solution_scalar": "#include <cmath>\n#include <utility>\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc) {\n   \tint k = 0;\n   \tint index = 0;\n   \tfloat max = std::abs(a[0]);\n   \tk += inc;\n   \tfor (size_t i = 1; i < n; i++) {\n       \tif (std::abs(a[k]) > max) {\n           \tindex = (int)i;\n           \tmax = std::abs(a[k]);\n       \t}\n       \tk += inc;\n   \t}\n   \treturn {max, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc);\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint inc = 1; // From tsvc.c\n\n   \tstd::vector<float> a_input(length * inc); // Ensure enough space for max index\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s318\n       \tfor (size_t i = 0; i < a_input.size(); ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \t// Ensure a negative value is present\n       \tif (length > 10) a_input[10] = -2.0f;\n\n       \tstd::pair<float, int> res_scalar = s318_scalar(a_input.data(), length, inc);\n       \tstd::pair<float, int> res_simd = s318_simd(a_input.data(), length, inc);\n\n       \tif (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s318!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc);\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t, int)>\nstatic void BM_s318(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint inc = 1; // From tsvc.c\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length * inc + 1);\n\n   \t// Ported Initialization Logic for s318\n   \tfor (size_t i = 0; i < a_input.size(); ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (length > 10) a_input[10] = -2.0f;\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tstd::pair<float, int> res = Func(a_input.data(), length, inc);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n-1). Ops: 1R (a[k]).\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s318, s318_scalar)->Name(\"Scalar_s318\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s318, s318_simd)->Name(\"SIMD_s318\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s318", "entrypoint_scalar": "s318_scalar", "entrypoint_simd": "s318"}
{"task_id": "tsvc_s319", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a coupled reduction:\n1. a[i] = c[i] + d[i];\n2. sum += a[i];\n3. b[i] = c[i] + e[i];\n4. sum += b[i];\nImplement this . The function should return the final sum.\n*/\nfloat s319(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "float s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = c[i] + d[i];\n       \tsum += a[i];\n       \tb[i] = c[i] + e[i];\n       \tsum += b[i];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s319\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_initial[i] = 0.0f;\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \tfloat sum_scalar = s319_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \tfloat sum_simd = s319_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd) || !allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s319!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<float (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s319(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s319\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_initial[i] = 0.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tfloat sum = Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 6R (c,d,a,c,e,b), 2W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s319, s319_scalar)->Name(\"Scalar_s319\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s319, s319_simd)->Name(\"SIMD_s319\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s319", "entrypoint_scalar": "s319_scalar", "entrypoint_simd": "s319"}
{"task_id": "tsvc_s3110", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt finds the max value and its 2D indices (xindex, yindex).\nImplement this . The function should return a tuple of {max_value, x_index, y_index}.\n*/\n#include <limits>\n#include <tuple>\nstd::tuple<float, int, int> s3110(const float* aa_flat, size_t n_2d) {\n}\n", "solution_scalar": "#include <tuple>\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d) {\n   \tfloat max = aa_flat[0]; // aa[0][0]\n   \tint xindex = 0;\n   \tint yindex = 0;\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \tfloat val = aa_flat[i * n_2d + j];\n           \tif (val > max) {\n             \tmax = val;\n             \txindex = (int)i;\n             \tyindex = (int)j;\n           \t}\n       \t}\n   \t}\n   \treturn std::make_tuple(max, xindex, yindex);\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3110 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \t// Ensure a specific max value\n       \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n \n       \tstd::tuple<float, int, int> res_scalar = s3110_scalar(aa_input.data(), n_2d);\n       \tstd::tuple<float, int, int> res_simd = s3110_simd(aa_input.data(), n_2d);\n\n       \tif (!allclose(std::get<0>(res_scalar), std::get<0>(res_simd)) || \n           \tstd::get<1>(res_scalar) != std::get<1>(res_simd) || \n           \tstd::get<2>(res_scalar) != std::get<2>(res_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3110!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <tuple>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d);\n\ntemplate<std::tuple<float, int, int> (*Func)(const float*, size_t)>\nstatic void BM_s3110(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_input(length);\n\n   \t// Ported Initialization Logic for s3110 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tstd::tuple<float, int, int> res = Func(aa_input.data(), n_2d);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n_2d * n_2d). Ops: 1R (aa).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s3110, s3110_scalar)->Name(\"Scalar_s3110\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s3110, s3110_simd)->Name(\"SIMD_s3110\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s3110", "entrypoint_scalar": "s3110_scalar", "entrypoint_simd": "s3110"}
{"task_id": "tsvc_s13110", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt finds the max value and its 2D indices (xindex, yindex). (Identical to s3110)\nImplement this . The function should return a tuple of {max_value, x_index, y_index}.\n*/\n#include <limits>\n#include <tuple>\nstd::tuple<float, int, int> s13110(const float* aa_flat, size_t n_2d) {\n}\n", "solution_scalar": "#include <tuple>\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d) {\n   \tfloat max = aa_flat[0]; // aa[0][0]\n   \tint xindex = 0;\n   \tint yindex = 0;\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \tfloat val = aa_flat[i * n_2d + j];\n           \tif (val > max) {\n             \tmax = val;\n             \txindex = (int)i;\n             \tyindex = (int)j;\n           \t}\n       \t}\n   \t}\n   \treturn std::make_tuple(max, xindex, yindex);\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s13110 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \t// Ensure a specific max value\n       \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n \n       \tstd::tuple<float, int, int> res_scalar = s13110_scalar(aa_input.data(), n_2d);\n       \tstd::tuple<float, int, int> res_simd = s13110_simd(aa_input.data(), n_2d);\n\n       \tif (!allclose(std::get<0>(res_scalar), std::get<0>(res_simd)) || \n           \tstd::get<1>(res_scalar) != std::get<1>(res_simd) || \n           \tstd::get<2>(res_scalar) != std::get<2>(res_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s13110!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <tuple>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d);\n\ntemplate<std::tuple<float, int, int> (*Func)(const float*, size_t)>\nstatic void BM_s13110(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_input(length);\n\n   \t// Ported Initialization Logic for s13110 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tstd::tuple<float, int, int> res = Func(aa_input.data(), n_2d);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n_2d * n_2d). Ops: 1R (aa).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s13110, s13110_scalar)->Name(\"Scalar_s13110\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s13110, s13110_simd)->Name(\"SIMD_s13110\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s13110", "entrypoint_scalar": "s13110_scalar", "entrypoint_simd": "s13110"}
{"task_id": "tsvc_s3111", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a conditional sum reduction: if (a[i] > 0.0f) { sum += a[i]; }\nImplement this . The function should return the sum.\n*/\nfloat s3111(const float *a, size_t n) {\n}\n", "solution_scalar": "float s3111_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tsum += a[i];\n       \t}\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3111_scalar(const float *a, size_t n);\nfloat s3111_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3111\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \t}\n\n       \tfloat sum_scalar = s3111_scalar(a_input.data(), length);\n       \tfloat sum_simd = s3111_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3111!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3111_scalar(const float *a, size_t n);\nfloat s3111_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s3111(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s3111\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3111, s3111_scalar)->Name(\"Scalar_s3111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3111, s3111_simd)->Name(\"SIMD_s3111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s3111", "entrypoint_scalar": "s3111_scalar", "entrypoint_simd": "s3111"}
{"task_id": "tsvc_s3112", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a sum reduction while saving the running sum to 'b':\n1. sum += a[i];\n2. b[i] = sum;\nImplement this . The function should return the final sum.\n*/\nfloat s3112(const float *a, float *b, size_t n) {\n}\n", "solution_scalar": "float s3112_scalar(const float *a, float *b, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i];\n       \tb[i] = sum;\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3112_scalar(const float *a, float *b, size_t n);\nfloat s3112_simd(const float *a, float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3112\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 0.0f;\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \tfloat sum_scalar = s3112_scalar(a_input.data(), b_scalar.data(), length);\n       \tfloat sum_simd = s3112_simd(a_input.data(), b_simd.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3112!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3112_scalar(const float *a, float *b, size_t n);\nfloat s3112_simd(const float *a, float *b, size_t n);\n\ntemplate<float (*Func)(const float *, float *, size_t)>\nstatic void BM_s3112(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s3112\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 0.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n\n       \tfloat sum = Func(a_input.data(), b_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a), 1W (b).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3112, s3112_scalar)->Name(\"Scalar_s3112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3112, s3112_simd)->Name(\"SIMD_s3112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s3112", "entrypoint_scalar": "s3112_scalar", "entrypoint_simd": "s3112"}
{"task_id": "tsvc_s3113", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a max absolute value reduction: max = max(max, abs(a[i]));\nImplement this . The function should return the max absolute value.\n*/\n#include <limits>\n#include <cmath>\nfloat s3113(const float *a, size_t n) {\n}\n", "solution_scalar": "#include <cmath>\nfloat s3113_scalar(const float *a, size_t n) {\n   \tfloat max = std::abs(a[0]);\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (std::abs(a[i]) > max) {\n           \tmax = std::abs(a[i]);\n       \t}\n   \t}\n   \treturn max;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3113_scalar(const float *a, size_t n);\nfloat s3113_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3113 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tif (length > 10) a_input[10] = -2.0f; // Add a negative value\n\n       \tfloat max_scalar = s3113_scalar(a_input.data(), length);\n       \tfloat max_simd = s3113_simd(a_input.data(), length);\n\n       \tif (!allclose(max_scalar, max_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3113!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3113_scalar(const float *a, size_t n);\nfloat s3113_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s3113(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s3113 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (length > 10) a_input[10] = -2.0f; // Add a negative value\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat max_val = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(max_val);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3113, s3113_scalar)->Name(\"Scalar_s3113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3113, s3113_simd)->Name(\"SIMD_s3113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s3113", "entrypoint_scalar": "s3113_scalar", "entrypoint_simd": "s3113"}
{"task_id": "tsvc_s321", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a first-order linear recurrence: a[i] += a[i-1] * b[i];\nImplement this .\n*/\nvoid s321(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s321_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 1; i < n; i++) {\n       \ta[i] += a[i - 1] * b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s321_scalar(float *a, const float *b, size_t n);\nvoid s321_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s321\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts321_scalar(a_scalar.data(), b_input.data(), length);\n       \ts321_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s321!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s321_scalar(float *a, const float *b, size_t n);\nvoid s321_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s321(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s321\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 1 R/W(a), 1R(a[i-1]), 1R(b). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s321, s321_scalar)->Name(\"Scalar_s321\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s321, s321_simd)->Name(\"SIMD_s321\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s321", "entrypoint_scalar": "s321_scalar", "entrypoint_simd": "s321"}
{"task_id": "tsvc_s322", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a second-order linear recurrence:\na[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\nImplement this .\n*/\nvoid s322(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s322_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 2; i < n; i++) {\n       \ta[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s322_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s322_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s322\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts322_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts322_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s322!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s322_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s322_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s322(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s322\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-2). Ops: 1 R/W(a), 2R(a), 2R(b,c). Total: 5 accesses.\n   \tsize_t num_ops = length - 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s322, s322_scalar)->Name(\"Scalar_s322\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s322, s322_simd)->Name(\"SIMD_s322\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s322", "entrypoint_scalar": "s322_scalar", "entrypoint_simd": "s322"}
{"task_id": "tsvc_s323", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a coupled recurrence:\n1. a[i] = b[i-1] + c[i] * d[i];\n2. b[i] = a[i] + c[i] * e[i];\nImplement this .\n*/\nvoid s323(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 1; i < n; i++) {\n       \ta[i] = b[i - 1] + c[i] * d[i];\n       \tb[i] = a[i] + c[i] * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s323\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts323_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts323_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s323!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s323(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s323\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 6R (b,c,d,a,c,e), 2W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s323, s323_scalar)->Name(\"Scalar_s323\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s323, s323_simd)->Name(\"SIMD_s323\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s323", "entrypoint_scalar": "s323_scalar", "entrypoint_simd": "s323"}
{"task_id": "tsvc_s331", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a search loop to find the *last* index i where a[i] < 0.\nImplement this . The function should return the last index found, or -1.\n*/\n#include <limits>\nint s331(const float *a, size_t n) {\n}\n", "solution_scalar": "int s331_scalar(const float *a, size_t n) {\n   \tint j = -1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] < 0.0f) {\n           \tj = (int)i;\n       \t}\n   \t}\n   \treturn j;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nint s331_scalar(const float *a, size_t n);\nint s331_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s331\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 0.5f - (float)i; // Will be negative for i > 0\n       \t}\n       \tif (length > 0) a_input[0] = 1.0f; // Ensure first is not negative\n\n       \tint j_scalar = s331_scalar(a_input.data(), length);\n       \tint j_simd = s331_simd(a_input.data(), length);\n\n       \tif (j_scalar != j_simd) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s331!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nint s331_scalar(const float *a, size_t n);\nint s331_simd(const float *a, size_t n);\n\ntemplate<int (*Func)(const float *, size_t)>\nstatic void BM_s331(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s331\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 0.5f - (float)i; // Will be negative for i > 0\n   \t}\n   \tif (length > 0) a_input[0] = 1.0f;\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tint j = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(j);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s331, s331_scalar)->Name(\"Scalar_s331\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s331, s331_simd)->Name(\"SIMD_s331\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s331", "entrypoint_scalar": "s331_scalar", "entrypoint_simd": "s331"}
{"task_id": "tsvc_s332", "prompt": "/*\nThis function takes a float array 'a', length 'n', and a threshold 't'.\nIt finds the *first* value and index where a[i] > t.\nImplement this . The function should return a pair of {value, index}.\nReturns {-1.0f, -2} if not found.\n*/\n#include <limits>\n#include <utility>\nstd::pair<float, int> s332(const float *a, size_t n, int t_int) {\n}\n", "solution_scalar": "#include <utility>\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int) {\n   \tfloat t = (float)t_int;\n   \tint index = -2;\n   \tfloat value = -1.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > t) {\n           \tindex = (int)i;\n           \tvalue = a[i];\n           \tbreak;\n       \t}\n   \t}\n   \treturn {value, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int);\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint t = (int)(length / 2); // Set threshold t\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s332\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = (float)i;\n       \t}\n\n       \tstd::pair<float, int> res_scalar = s332_scalar(a_input.data(), length, t);\n       \tstd::pair<float, int> res_simd = s332_simd(a_input.data(), length, t);\n\n       \tif (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s332!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int);\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t, int)>\nstatic void BM_s332(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint t = (int)(length / 2);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s332\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = (float)i;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tstd::pair<float, int> res = Func(a_input.data(), length, t);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n). Ops: 1R (a). (Breaks early, but n is worst-case).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s332, s332_scalar)->Name(\"Scalar_s332\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s332, s332_simd)->Name(\"SIMD_s332\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s332", "entrypoint_scalar": "s332_scalar", "entrypoint_simd": "s332"}
{"task_id": "tsvc_s341", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a pack operation (compresses 'b' into 'a'):\nif (b[i] > 0.0f) { a[j++] = b[i]; }\nImplement this .\n*/\nvoid s341(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s341_scalar(float *a, const float *b, size_t n) {\n   \tint j = -1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] > 0.0f) {\n           \tj++;\n           \ta[j] = b[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s341_scalar(float *a, const float *b, size_t n);\nvoid s341_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s341\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts341_scalar(a_scalar.data(), b_input.data(), length);\n       \ts341_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s341!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s341_scalar(float *a, const float *b, size_t n);\nvoid s341_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s341(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s341\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (b), 1W (a) (since if is always true). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s341, s341_scalar)->Name(\"Scalar_s341\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s341, s341_simd)->Name(\"SIMD_s341\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s341", "entrypoint_scalar": "s341_scalar", "entrypoint_simd": "s341"}
{"task_id": "tsvc_s342", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an unpack operation (scatters 'b' into 'a'):\nif (a[i] > 0.0f) { a[i] = b[j++]; }\nImplement this .\n*/\nvoid s342(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s342_scalar(float *a, const float *b, size_t n) {\n   \tint j = -1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tj++;\n           \ta[i] = b[j];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s342_scalar(float *a, const float *b, size_t n);\nvoid s342_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s342\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts342_scalar(a_scalar.data(), b_input.data(), length);\n       \ts342_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s342!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s342_scalar(float *a, const float *b, size_t n);\nvoid s342_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s342(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s342\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(a), 1R(b), 1W(a) (since if is always true). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s342, s342_scalar)->Name(\"Scalar_s342\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s342, s342_simd)->Name(\"SIMD_s342\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s342", "entrypoint_scalar": "s342_scalar", "entrypoint_simd": "s342"}
{"task_id": "tsvc_s343", "prompt": "/*\nThis function packs a 2D array 'aa' into a 1D array 'flat_2d_array'.\nIt packs elements from 'aa' where 'bb' is positive.\nif (bb[j][i] > 0.0f) { flat_2d_array[k++] = aa[j][i]; }\nImplement this .\n*/\nvoid s343(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n}\n", "solution_scalar": "void s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n   \tint k = -1;\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \tif (bb_flat[j * n_2d + i] > 0.0f) {\n             \tk++;\n             \tflat_2d_array[k] = aa_flat[j * n_2d + i];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> flat_initial(length);\n   \tstd::vector<float> aa_input(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> flat_scalar(length), flat_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s343\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tflat_initial[i] = 0.0f;\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts343_scalar(flat_scalar.data(), aa_input.data(), bb_input.data(), n_2d);\n       \ts343_simd(flat_simd.data(), aa_input.data(), bb_input.data(), n_2d);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s343!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s343(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length);\n   \tstd::vector<float> aa_input(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> flat_initial(length);\n\n   \t// Ported Initialization Logic for s343\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tflat_initial[i] = 0.0f;\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(flat_output.data(), aa_input.data(), bb_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d*n_2d). Ops: 2R(bb,aa), 1W(flat) (since if is always true). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s343, s343_scalar)->Name(\"Scalar_s343\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s343, s343_simd)->Name(\"SIMD_s343\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s343", "entrypoint_scalar": "s343_scalar", "entrypoint_simd": "s343"}
{"task_id": "tsvc_s351", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs an unrolled SAXPY operation (loop rerolling).\na[i+k] += alpha * b[i+k]; for k=0..4\nImplement this .\n*/\nvoid s351(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s351_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfloat alpha = c[0];\n   \tfor (size_t i = 0; i < n; i += 5) {\n       \ta[i] += alpha * b[i];\n       \ta[i + 1] += alpha * b[i + 1];\n       \ta[i + 2] += alpha * b[i + 2];\n       \ta[i + 3] += alpha * b[i + 3];\n       \ta[i + 4] += alpha * b[i + 4];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s351_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s351\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts351_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts351_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s351!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s351_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s351(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s351\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n/5) blocks. 5 ops * (1R/W(a), 1R(b)) = 15 accesses. Total n*3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s351, s351_scalar)->Name(\"Scalar_s351\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s351, s351_simd)->Name(\"SIMD_s351\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s351", "entrypoint_scalar": "s351_scalar", "entrypoint_simd": "s351"}
{"task_id": "tsvc_s1351", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple vector add: a[i] = b[i] + c[i];\nThis tests induction pointer recognition (A++, B++, C++).\nImplement this .\n*/\nvoid s1351(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s1351_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1351\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts1351_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts1351_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1351!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s1351(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s1351\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1351, s1351_scalar)->Name(\"Scalar_s1351\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1351, s1351_simd)->Name(\"SIMD_s1351\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1351", "entrypoint_scalar": "s1351_scalar", "entrypoint_simd": "s1351"}
{"task_id": "tsvc_s352", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an unrolled dot product reduction (loop rerolling).\ndot += a[i]*b[i] + ... + a[i+4]*b[i+4];\nImplement this . The function should return the dot product.\n*/\nfloat s352(const float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "float s352_scalar(const float *a, const float *b, size_t n) {\n   \tfloat dot = 0.0f;\n   \tfor (size_t i = 0; i < n; i += 5) {\n       \tdot = dot + a[i] * b[i] + a[i + 1] * b[i + 1] + a[i + 2]\n             * b[i + 2] + a[i + 3] * b[i + 3] + a[i + 4] * b[i + 4];\n   \t}\n   \treturn dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s352_scalar(const float *a, const float *b, size_t n);\nfloat s352_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s352 (same as s313)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat dot_scalar = s352_scalar(a_input.data(), b_input.data(), length);\n       \tfloat dot_simd = s352_simd(a_input.data(), b_input.data(), length);\n\n       \tif (!allclose(dot_scalar, dot_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s352!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s352_scalar(const float *a, const float *b, size_t n);\nfloat s352_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_s352(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \t// Ported Initialization Logic for s352 (same as s313)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tfloat dot = Func(a_input.data(), b_input.data(), length);\n       \tbenchmark::DoNotOptimize(dot);\n   \t}\n   \t// Loop (n/5) blocks. 5 ops * 2R = 10R per block. Total n*2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s352, s352_scalar)->Name(\"Scalar_s352\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s352, s352_simd)->Name(\"SIMD_s352\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s352", "entrypoint_scalar": "s352_scalar", "entrypoint_simd": "s352"}
{"task_id": "tsvc_s353", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and an int array 'ip' (indices).\nIt performs an unrolled sparse SAXPY (a gather operation).\na[i+k] += alpha * b[ip[i+k]]; for k=0..4\nImplement this .\n*/\nvoid s353(float *a, const float *b, const float *c, const int *ip, size_t n) {\n}\n", "solution_scalar": "void s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n) {\n   \tfloat alpha = c[0];\n   \tfor (size_t i = 0; i < n; i += 5) {\n       \ta[i] += alpha * b[ip[i]];\n       \ta[i + 1] += alpha * b[ip[i + 1]];\n       \ta[i + 2] += alpha * b[ip[i + 2]];\n       \ta[i + 3] += alpha * b[ip[i + 3]];\n       \ta[i + 4] += alpha * b[ip[i + 4]];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n);\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s353\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts353_scalar(a_scalar.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       \ts353_simd(a_simd.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s353!\" << std::endl;\n Next         \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n);\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const int *, size_t)>\nstatic void BM_s353(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s353\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n _simd     \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n/5) blocks. 5 ops * (1R/W(a) + 1R(b) + 1R(ip)) = 15 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * (sizeof(float)*2 + sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s353, s353_scalar)->Name(\"Scalar_s353\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s353, s353_simd)->Name(\"SIMD_s353\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s353", "entrypoint_scalar": "s353_scalar", "entrypoint_simd": "s353"}
{"task_id": "tsvc_s421", "prompt": "/*\nThis function takes a 1D float array 'a' and a 1D float array 'flat_2d_array'.\nIt performs a recurrence: flat_2d_array[i] = flat_2d_array[i+1] + a[i];\n(Based on xx = flat_2d_array, yy = xx, xx[i] = yy[i+1] + a[i])\nImplement this .\n*/\nvoid s421(float* flat_2d_array, const float* a, size_t n) {\n}\n", "solution_scalar": "void s421_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \t// Original: xx = flat_2d_array, yy = xx. Loop: xx[i] = yy[i+1] + a[i]\n   \t// This simplifies to: flat_2d_array[i] = flat_2d_array[i+1] + a[i]\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tflat_2d_array[i] = flat_2d_array[i + 1] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s421_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> flat_initial(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length), flat_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s421\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tflat_initial[i] = 1.0f;\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts421_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts421_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s421!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s421_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s421(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length);\n\n   \t// Ported Initialization Logic for s421\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tflat_initial[i] = 1.0f;\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (flat[i+1], a[i]), 1W (flat[i]). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s421, s421_scalar)->Name(\"Scalar_s421\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s421, s421_simd)->Name(\"SIMD_s421\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s421", "entrypoint_scalar": "s421_scalar", "entrypoint_simd": "s421"}
{"task_id": "tsvc_s1421", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an operation with aliased pointers:\nb[i] = xx[i] + a[i]; (where xx = &b[n/2])\nThis simplifies to: b[i] = b[n/2 + i] + a[i];\nImplement this .\n*/\nvoid s1421(float *b, const float *a, size_t n) {\n}\n", "solution_scalar": "void s1421_scalar(float *b, const float *a, size_t n) {\n   \t// Original: xx = &b[n/2]. Loop: b[i] = xx[i] + a[i]\n   \tsize_t half_n = n / 2;\n   \tfor (size_t i = 0; i < half_n; i++) {\n       \tb[i] = b[half_n + i] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1421_scalar(float *b, const float *a, size_t n);\nvoid s1421_simd(float *b, const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1421\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1421_scalar(b_scalar.data(), a_input.data(), length);\n       \ts1421_simd(b_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1421!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1421_scalar(float *b, const float *a, size_t n);\nvoid s1421_simd(float *b, const float *a, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1421(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1421\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n\n       \tFunc(b_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n/2). Ops: 2R (b[half+i], a[i]), 1W (b[i]). Total: 3 accesses.\n   \tsize_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1421, s1421_scalar)->Name(\"Scalar_s1421\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1421, s1421_simd)->Name(\"SIMD_s1421\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s1421", "entrypoint_scalar": "s1421_scalar", "entrypoint_simd": "s1421"}
{"task_id": "tsvc_s422", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', and length 'n'.\nIt performs an operation with aliased pointers and offsets:\nxx = flat_2d_array + 4; xx[i] = flat_2d_array[i + 8] + a[i];\nThis simplifies to: flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\nImplement this .\n*/\nvoid s422(float* flat_2d_array, const float* a, size_t n) {\n}\n", "solution_scalar": "void s422_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \t// Original: xx = flat_2d_array + 4. Loop: xx[i] = flat_2d_array[i + 8] + a[i]\n   \t// This simplifies to: flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i]\n   \tfor (size_t i = 0; i < n; i++) {\n       \tflat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s422_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> flat_initial(length + 8); // Ensure space for offsets\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length + 8), flat_simd(length + 8);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s422\n       \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n           \tflat_initial[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts422_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts422_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s422!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s422_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s422(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length + 8);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length + 8);\n\n   \t// Ported Initialization Logic for s422\n   \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n       \tflat_initial[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (flat[i+8], a[i]), 1W (flat[i+4]). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s422, s422_scalar)->Name(\"Scalar_s422\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s422, s422_simd)->Name(\"SIMD_s422\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s422", "entrypoint_scalar": "s422_scalar", "entrypoint_simd": "s422"}
{"task_id": "tsvc_s423", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', length 'n', and 'vl' (offset).\nIt performs an operation with aliased pointers and offsets:\nxx = flat_2d_array + vl; flat_2d_array[i+1] = xx[i] + a[i]; (vl=64)\nThis simplifies to: flat_2d_array[i+1] = flat_2d_array[i + 64] + a[i];\nImplement this .\n*/\nvoid s423(float* flat_2d_array, const float* a, size_t n) {\n}\n", "solution_scalar": "void s423_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \tint vl = 64;\n   \t// Original: xx = flat_2d_array + vl. Loop: flat_2d_array[i+1] = xx[i] + a[i]\n   \t// This simplifies to: flat_2d_array[i + 1] = flat_2d_array[i + vl] + a[i]\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tflat_2d_array[i + 1] = flat_2d_array[i + vl] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s423_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint vl = 64;\n\n   \tstd::vector<float> flat_initial(length + vl); // Ensure space for offsets\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length + vl), flat_simd(length + vl);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s423\n       \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n           \tflat_initial[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts423_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts423_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s423!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s423_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s423(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint vl = 64;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length + vl);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length + vl);\n\n   \t// Ported Initialization Logic for s423\n   \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n       \tflat_initial[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (flat[i+vl], a[i]), 1W (flat[i+1]). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s423, s423_scalar)->Name(\"Scalar_s423\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s423, s423_simd)->Name(\"SIMD_s423\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s423", "entrypoint_scalar": "s423_scalar", "entrypoint_simd": "s423"}
{"task_id": "tsvc_s424", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', length 'n', and 'vl' (offset).\nIt performs a recurrence with aliased pointers:\nxx = flat_2d_array + vl; xx[i+1] = flat_2d_array[i] + a[i]; (vl=63)\nThis simplifies to: flat_2d_array[i + 64] = flat_2d_array[i] + a[i];\nImplement this .\n*/\nvoid s424(float* flat_2d_array, const float* a, size_t n) {\n}\n", "solution_scalar": "void s424_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \tint vl = 63;\n   \t// Original: xx = flat_2d_array + vl. Loop: xx[i+1] = flat_2d_array[i] + a[i]\n   \t// This simplifies to: flat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i]\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tflat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s424_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint vl = 63;\n\n   \tstd::vector<float> flat_initial(length + vl + 1); // Ensure space for offsets\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length + vl + 1), flat_simd(length + vl + 1);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s424\n       \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n           \tflat_initial[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts424_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts424_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s424!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s424_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s424(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint vl = 63;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length + vl + 1);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length + vl + 1);\n\n   \t// Ported Initialization Logic for s424\n   \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n       \tflat_initial[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (flat[i], a[i]), 1W (flat[i+1+vl]). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s424, s424_scalar)->Name(\"Scalar_s424\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s424, s424_simd)->Name(\"SIMD_s424\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s424", "entrypoint_scalar": "s424_scalar", "entrypoint_simd": "s424"}
{"task_id": "tsvc_s431", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs: a[i] = a[i+k] + b[i]; (where k=0)\nThis simplifies to: a[i] += b[i];\nImplement this .\n*/\nvoid s431(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s431_scalar(float *a, const float *b, size_t n) {\n   \tint k = 0;\n   \tfor (size_t i = 0; i < n; i++) {\n       \t// a[i] = a[i+k] + b[i] simplifies to a[i] = a[i] + b[i]\n       \ta[i] += b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s431_scalar(float *a, const float *b, size_t n);\nvoid s431_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s431\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts431_scalar(a_scalar.data(), b_input.data(), length);\n       \ts431_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s431!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s431_scalar(float *a, const float *b, size_t n);\nvoid s431_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s431(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s431\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1 R/W (a), 1R (b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s431, s431_scalar)->Name(\"Scalar_s431\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s431, s431_simd)->Name(\"SIMD_s431\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s431", "entrypoint_scalar": "s431_scalar", "entrypoint_simd": "s431"}
{"task_id": "tsvc_s441", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a 3-way conditional operation (arithmetic if):\nif (d[i] < 0) a[i] += b[i] * c[i];\nelse if (d[i] == 0) a[i] += b[i] * b[i];\nelse a[i] += c[i] * c[i];\nImplement this .\n*/\nvoid s441(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (d[i] < 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t} else if (d[i] == 0.0f) {\n           \ta[i] += b[i] * b[i];\n       \t} else {\n           \ta[i] += c[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s441\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = (float)(i % 3) - 1.0f; // -1, 0, 1\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts441_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts441_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s441!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s441(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s441\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = (float)(i % 3) - 1.0f; // -1, 0, 1\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (d), 1 R/W (a), 2R (b/c). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s441, s441_scalar)->Name(\"Scalar_s441\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s441, s441_simd)->Name(\"SIMD_s441\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s441", "entrypoint_scalar": "s441_scalar", "entrypoint_simd": "s441"}
{"task_id": "tsvc_s442", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', 'indx' and length 'n'.\nIt performs a computed goto (switch-case) operation:\nswitch (indx[i]) {\n  case 1: a[i] += b[i] * b[i]; break;\n  case 2: a[i] += c[i] * c[i]; break;\n  case 3: a[i] += d[i] * d[i]; break;\n  case 4: a[i] += e[i] * e[i]; break;\n}\nImplement this .\n*/\nvoid s442(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n) {\n}\n", "solution_scalar": "void s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tswitch (indx[i]) {\n           \tcase 1:\n             \ta[i] += b[i] * b[i];\n             \tbreak;\n           \tcase 2:\n             \ta[i] += c[i] * c[i];\n             \tbreak;\n           \tcase 3:\n             \ta[i] += d[i] * d[i];\n             \tbreak;\n           \tcase 4:\n             \ta[i] += e[i] * e[i];\n             \tbreak;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<int> indx_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s442\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f;\n           \tindx_input[i] = (int)(i % 4) + 1; // 1, 2, 3, 4\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts442_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n       \ts442_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s442!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s442(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<int> indx_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s442\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f;\n       \tindx_input[i] = (int)(i % 4) + 1; // 1, 2, 3, 4\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n       \tbenchmark::DoNotOptimize(indx_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(indx), 1 R/W(a), 2R(b/c/d/e). Total: 4 accesses (3 float, 1 int).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 3 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s442, s442_scalar)->Name(\"Scalar_s442\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s442, s442_simd)->Name(\"SIMD_s442\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s442", "entrypoint_scalar": "s442_scalar", "entrypoint_simd": "s442"}
{"task_id": "tsvc_s443", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a 2-way conditional (arithmetic if):\nif (d[i] <= 0) { a[i] += b[i] * c[i]; }\nelse { a[i] += b[i] * b[i]; }\nImplement this .\n*/\nvoid s443(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (d[i] <= 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t} else {\n           \ta[i] += b[i] * b[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s443\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = (float)(i % 2) - 0.5f; // -0.5, 0.5\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts443_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts443_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s443!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s443(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s443\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = (float)(i % 2) - 0.5f; // -0.5, 0.5\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(d), 1R/W(a), 2R(b,c). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s443, s443_scalar)->Name(\"Scalar_s443\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s443, s443_simd)->Name(\"SIMD_s443\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s443", "entrypoint_scalar": "s443_scalar", "entrypoint_simd": "s443"}
{"task_id": "tsvc_s451", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs intrinsic math functions: a[i] = sinf(b[i]) + cosf(c[i]);\nImplement this .\n*/\n#include <cmath>\nvoid s451(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "#include <cmath>\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = std::sin(b[i]) + std::cos(c[i]);\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s451_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s451\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts451_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts451_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s451!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s451_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s451(benchmark::State& state) {\n g  \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s451\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s451, s451_scalar)->Name(\"Scalar_s451\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s451, s451_simd)->Name(\"SIMD_s451\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s451", "entrypoint_scalar": "s451_scalar", "entrypoint_simd": "s451"}
{"task_id": "tsvc_s452", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] = b[i] + c[i] * (float)(i + 1);\nImplement this .\n*/\nvoid s452(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s452_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i] + c[i] * (float)(i + 1);\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s452_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s452_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s452\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts452_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts452_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s452!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s452_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s452_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s452(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n i  // Ported Initialization Logic for s452\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n A   \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s452, s452_scalar)->Name(\"Scalar_s452\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s452, s452_simd)->Name(\"SIMD_s452\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s452", "entrypoint_scalar": "s452_scalar", "entrypoint_simd": "s452"}
{"task_id": "tsvc_s453", "prompt": "/* This function takes float arrays 'a', 'b' and length 'n'.\nIt performs an operation using an induction variable 's':s = 0.0f;\nfor (i=0..n) { s += 2.0f; a[i] = s * b[i]; }\nImplement this .\n*/void s453(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void s453_scalar(float *a, const float *b, size_t n) {\n   \tfloat s = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ts += 2.0f;\n       \ta[i] = s * b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s453_scalar(float *a, const float *b, size_t n);\nvoid s453_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s453 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts453_scalar(a_scalar.data(), b_input.data(), length);\n       \ts453_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s453!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s453_scalar(float *a, const float *b, size_t n);\nvoid s453_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s453(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s453 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (b), 1W (a). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s453, s453_scalar)->Name(\"Scalar_s453\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s453, s453_simd)->Name(\"SIMD_s453\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s453", "entrypoint_scalar": "s453_scalar", "entrypoint_simd": "s453"}
{"task_id": "tsvc_s471", "prompt": "/*\nThis function takes float arrays 'x', 'b', 'c', 'd', 'e' and length 'n'.\nIt tests loop distribution dependencies:\n1. x[i] = b[i] + d[i] * d[i];\n2. b[i] = c[i] + d[i] * e[i];\n(Original code had a dummy s471s() call between lines).\nImplement this .\n*/\nvoid s471(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n}\n", "solution_scalar": "void s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tx[i] = b[i] + d[i] * d[i];\n       \t// s471s() dummy call removed\n       \tb[i] = c[i] + d[i] * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> x_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> x_scalar(length), x_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s471\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tx_initial[i] = 0.0f;\n           \tb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \tx_scalar = x_initial;\n       \tx_simd = x_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts471_scalar(x_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts471_simd(x_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(x_scalar, x_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s471!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n D  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s471(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> x_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> x_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s471\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tx_initial[i] = 0.0f;\n       \tb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tx_output = x_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(x_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(x_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b), 2R(d), 1W(x), 1R(c), 1R(e), 1W(b). Total: 5R, 2W = 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s471, s471_scalar)->Name(\"Scalar_s471\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s471, s471_simd)->Name(\"SIMD_s471\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s471", "entrypoint_scalar": "s471_scalar", "entrypoint_simd": "s471"}
{"task_id": "tsvc_s481", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs: if (d[i] < 0) break; a[i] += b[i] * c[i];\n(Original code had exit(0), translated to break).\nImplement this .\n*/\nvoid s481(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (d[i] < 0.0f) {\n           \tbreak;\n       \t}\n       \ta[i] += b[i] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s481\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac (all positive, no break)\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts481_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts481_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s481!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s481(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s481\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac (all positive, no break)\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(d), 1R/W(a), 2R(b,c). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s481, s481_scalar)->Name(\"Scalar_s481\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s481, s481_simd)->Name(\"SIMD_s481\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s481", "entrypoint_scalar": "s481_scalar", "entrypoint_simd": "s481"}
{"task_id": "tsvc_s482", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] += b[i] * c[i]; if (c[i] > b[i]) break;\nImplement this .\n*/\nvoid s482(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void s482_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] * c[i];\n       \tif (c[i] > b[i]) break;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s482_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s482_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s482\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \t// c[i] > b[i] will be true for i > 0, so loop breaks at i=1\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts482_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts482_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s482!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s482_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s482_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s482(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s482\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n   \t// c[i] > b[i] will be true for i > 0, so loop breaks at i=1\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop breaks early, but worst case is (n). Ops: 1R/W(a), 3R(b,c,c,b). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s482, s482_scalar)->Name(\"Scalar_s482\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s482, s482_simd)->Name(\"SIMD_s482\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s482", "entrypoint_scalar": "s482_scalar", "entrypoint_simd": "s482"}
{"task_id": "tsvc_s491", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'ip' and length 'n'.\nIt performs a scatter operation: a[ip[i]] = b[i] + c[i] * d[i];\nImplement this .\n*/\nvoid s491(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n) {\n}\n", "solution_scalar": "void s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[ip[i]] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s491\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts491_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n       \ts491_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s491!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s491(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s491\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R(b,c,d), 1R(ip), 1W(a). Total: 4 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 4 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s491, s491_scalar)->Name(\"Scalar_s491\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s491, s491_simd)->Name(\"SIMD_s491\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s491", "entrypoint_scalar": "s491_scalar", "entrypoint_simd": "s491"}
{"task_id": "tsvc_s4112", "prompt": "/*\nThis function takes float arrays 'a', 'b', an int array 'ip', float 's' and length 'n'.\nIt performs a sparse SAXPY (gather operation): a[i] += b[ip[i]] * s;\nImplement this .\n*/\nvoid s4112(float *a, const float *b, const int* ip, float s, size_t n) {\n}\n", "solution_scalar": "void s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[ip[i]] * s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n);\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tfloat s = 2.0f;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4112\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4112_scalar(a_scalar.data(), b_input.data(), ip_input.data(), s, length);\n       \ts4112_simd(a_simd.data(), b_input.data(), ip_input.data(), s, length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4112!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n);\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, float, size_t)>\nstatic void BM_s4112(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tfloat s = 2.0f;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4112\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), ip_input.data(), s, length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4112, s4112_scalar)->Name(\"Scalar_s4112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4112, s4112_simd)->Name(\"SIMD_s4112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4112", "entrypoint_scalar": "s4112_scalar", "entrypoint_simd": "s4112"}
{"task_id": "tsvc_s4113", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'ip' and length 'n'.\nIt performs a gather-scatter operation: a[ip[i]] = b[ip[i]] + c[i];\nImplement this .\n*/\nvoid s4113(float *a, const float *b, const float *c, const int* ip, size_t n) {\n}\n", "solution_scalar": "void s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[ip[i]] = b[ip[i]] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n);\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4113\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       S   \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4113_scalar(a_scalar.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       \ts4113_simd(a_simd.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4113!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n);\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s4113(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4113\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b via ip), 1R(c), 1R(ip), 1W(a via ip). Total: 3 float, 2 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 3 + int64_t(num_ops) * sizeof(int) * 2));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4113, s4113_scalar)->Name(\"Scalar_s4113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4113, s4113_simd)->Name(\"SIMD_s4113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4113", "entrypoint_scalar": "s4113_scalar", "entrypoint_simd": "s4113"}
{"task_id": "tsvc_s4114", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'ip' and length 'n', 'n1'.\nIt performs a gather operation with complex indexing:\na[i] = b[i] + c[n - k - 1] * d[i]; (k = ip[i])\nImplement this .\n*/\nvoid s4114(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1) {\n}\n", "solution_scalar": "void s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1) {\n   \tfor (size_t i = (size_t)n1 - 1; i < n; i++) {\n       \tint k = ip[i];\n       \t// Original: c[LEN_1D-k+1-2] -> c[n-k-1]\n       \ta[i] = b[i] + c[n - k - 1] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint n1 = 1;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4114\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \tip_input[i] = (int)((i * 7) % (length / 2)); // Scrambled indices, ensure n-k-1 is valid\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4114_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n       \ts4114_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4114!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const int*, size_t, int)>\nstatic void BM_s4114(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint n1 = 1;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4114\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \tip_input[i] = (int)((i * 7) % (length / 2)); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-n1+1). Ops: 3R(b,c via ip,d), 1R(ip), 1W(a). Total: 4 float, 1 int access.\n   \tsize_t num_ops = length - n1 + 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 4 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4114, s4114_scalar)->Name(\"Scalar_s4114\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4114, s4114_simd)->Name(\"SIMD_s4114\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4114", "entrypoint_scalar": "s4114_scalar", "entrypoint_simd": "s4114"}
{"task_id": "tsvc_s4115", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'ip' and length 'n'.\nIt performs a sparse dot product (gather): sum += a[i] * b[ip[i]];\nImplement this . The function should return the sum.\n*/\nfloat s4115(const float *a, const float *b, const int* ip, size_t n) {\n}\n", "solution_scalar": "float s4115_scalar(const float *a, const float *b, const int* ip, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i] * b[ip[i]];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s4115_scalar(const float *a, const float *b, const int* ip, size_t n);\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4115\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n\n       \tfloat sum_scalar = s4115_scalar(a_input.data(), b_input.data(), ip_input.data(), length);\n       \tfloat sum_simd = s4115_simd(a_input.data(), b_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4115!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s4115_scalar(const float *a, const float *b, const int* ip, size_t n);\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, const int*, size_t)>\nstatic void BM_s4115(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n\n   \t// Ported Initialization Logic for s4115\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tfloat sum = Func(a_input.data(), b_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R(a), 1R(b via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4115, s4115_scalar)->Name(\"Scalar_s4115\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4115, s4115_simd)->Name(\"SIMD_s4115\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4115", "entrypoint_scalar": "s4115_scalar", "entrypoint_simd": "s4115"}
{"task_id": "tsvc_s4116", "prompt": "/*\nThis function takes float array 'a', flattened 2D array 'aa', 'ip', 'n_2d', 'j', 'inc'.\nIt performs a sparse dot product (gather): sum += a[i+inc] * aa[j-1][ip[i]];\nImplement this . The function should return the sum.\n*/\nfloat s4116(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc) {\n}\n", "solution_scalar": "float s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n_2d - 1; i++) {\n       \tint off = inc + (int)i;\n       \tsum += a[off] * aa_flat[(j - 1) * n_2d + ip[i]];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nfloat s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tint j = 1; \n   \tint inc = 1;\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<int> ip_input(length_1d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4116\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tip_input[i] = (int)((i * 7) % n_2d); // Scrambled indices within one row\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat sum_scalar = s4116_scalar(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n       \tfloat sum_simd = s4116_simd(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4116!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nfloat s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\n\ntemplate<float (*Func)(const float *, const float*, const int*, size_t, int, int)>\nstatic void BM_s4116(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length_1d = LEN_1D;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tint j = 1; \n   \tint inc = 1;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<int> ip_input(length_1d);\n\n   \t// Ported Initialization Logic for s4116\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tip_input[i] = (int)((i * 7) % n_2d); // Scrambled indices\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tfloat sum = Func(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n       \t\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n_2d-1). Ops: 1R(a), 1R(aa via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = n_2d - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s4116, s4116_scalar)->Name(\"Scalar_s4116\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s4116, s4116_simd)->Name(\"SIMD_s4116\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4116", "entrypoint_scalar": "s4116_scalar", "entrypoint_simd": "s4116"}
{"task_id": "tsvc_s4117", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs: a[i] = b[i] + c[i / 2] * d[i];\nImplement this .\n*/\nvoid s4117(float *a, const float *b, const float *c, const float *d, size_t n) {\n}\n", "solution_scalar": "void s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i] + c[i / 2] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4117\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4117_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n S   \ts4117_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4117!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n S \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s4117(benchmark::State& state) {\n I \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4117\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n C   \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,c,d), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4117, s4117_scalar)->Name(\"Scalar_s4117\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4117, s4117_simd)->Name(\"SIMD_s4117\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4117", "entrypoint_scalar": "s4117_scalar", "entrypoint_simd": "s4117"}
{"task_id": "tsvc_s4121", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] += f(b[i], c[i]); where f(a,b) is a*b.\nThis tests statement functions (inlined).\nImplement this .\n*/\n// Helper function\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += f(b[i], c[i]);\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4121\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4121_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts4121_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4121!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s4121(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4121\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4121, s4121_scalar)->Name(\"Scalar_s4121\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4121, s4121_simd)->Name(\"SIMD_s4121\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "s4121", "entrypoint_scalar": "s4121_scalar", "entrypoint_simd": "s4121"}
{"task_id": "tsvc_va", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector assignment: a[i] = b[i];\nImplement this .\n*/\nvoid va(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void va_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid va_scalar(float *a, const float *b, size_t n);\nvoid va_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for va\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tva_scalar(a_scalar.data(), b_input.data(), length);\n       \tva_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_va!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid va_scalar(float *a, const float *b, size_t n);\nvoid va_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_va(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for va\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b), 1W(a). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_va, va_scalar)->Name(\"Scalar_va\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_va, va_simd)->Name(\"SIMD_va\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "va", "entrypoint_scalar": "va_scalar", "entrypoint_simd": "va"}
{"task_id": "tsvc_vag", "prompt": "/*\nThis function takes float arrays 'a', 'b', int array 'ip' and length 'n'.\nIt performs a vector assignment (gather): a[i] = b[ip[i]];\nImplement this .\n*/\nvoid vag(float *a, const float *b, const int* ip, size_t n) {\n}\n", "solution_scalar": "void vag_scalar(float *a, const float *b, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[ip[i]];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vag_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vag\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvag_scalar(a_scalar.data(), b_input.data(), ip_input.data(), length);\n       \tvag_simd(a_simd.data(), b_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vag!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vag_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, size_t)>\nstatic void BM_vag(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vag\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b via ip), 1W(a), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vag, vag_scalar)->Name(\"Scalar_vag\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vag, vag_simd)->Name(\"SIMD_vag\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vag", "entrypoint_scalar": "vag_scalar", "entrypoint_simd": "vag"}
{"task_id": "tsvc_vas", "prompt": "/*\nThis function takes float arrays 'a', 'b', int array 'ip' and length 'n'.\nIt performs a vector assignment (scatter): a[ip[i]] = b[i];\nImplement this .\n*/\nvoid vas(float *a, const float *b, const int* ip, size_t n) {\n}\n", "solution_scalar": "void vas_scalar(float *a, const float *b, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[ip[i]] = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vas_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vas\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvas_scalar(a_scalar.data(), b_input.data(), ip_input.data(), length);\n       \tvas_simd(a_simd.data(), b_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vas!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vas_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, size_t)>\nstatic void BM_vas(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vas\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b), 1W(a via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vas, vas_scalar)->Name(\"Scalar_vas\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vas, vas_simd)->Name(\"SIMD_vas\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vas", "entrypoint_scalar": "vas_scalar", "entrypoint_simd": "vas"}
{"task_id": "tsvc_vif", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a conditional vector assignment: if (b[i] > 0.0f) a[i] = b[i];\nImplement this .\n*/\nvoid vif(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void vif_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] > 0.0f) {\n           \ta[i] = b[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vif_scalar(float *a, const float *b, size_t n);\nvoid vif_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vif\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = (float)(i % 10) - 5.0f; // Mix of positive and negative\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvif_scalar(a_scalar.data(), b_input.data(), length);\n       \tvif_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vif!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vif_scalar(float *a, const float *b, size_t n);\nvoid vif_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vif(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vif\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = (float)(i % 10) - 5.0f; // Mix of positive and negative\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R(b,b), 1W(a). Total: 3 accesses (worst case).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vif, vif_scalar)->Name(\"Scalar_vif\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vif, vif_simd)->Name(\"SIMD_vif\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vif", "entrypoint_scalar": "vif_scalar", "entrypoint_simd": "vif"}
{"task_id": "tsvc_vpv", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector plus vector: a[i] += b[i];\nImplement this .\n*/\nvoid vpv(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void vpv_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpv_scalar(float *a, const float *b, size_t n);\nvoid vpv_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpv_scalar(a_scalar.data(), b_input.data(), length);\n       \tvpv_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpv_scalar(float *a, const float *b, size_t n);\nvoid vpv_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vpv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpv, vpv_scalar)->Name(\"Scalar_vpv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpv, vpv_simd)->Name(\"SIMD_vpv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vpv", "entrypoint_scalar": "vpv_scalar", "entrypoint_simd": "vpv"}
{"task_id": "tsvc_vtv", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector times vector: a[i] *= b[i];\nImplement this .\n*/\nvoid vtv(float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "void vtv_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] *= b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vtv_scalar(float *a, const float *b, size_t n);\nvoid vtv_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vtv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvtv_scalar(a_scalar.data(), b_input.data(), length);\n       \tvtv_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vtv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vtv_scalar(float *a, const float *b, size_t n);\nvoid vtv_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vtv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vtv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n s \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vtv, vtv_scalar)->Name(\"Scalar_vtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vtv, vtv_simd)->Name(\"SIMD_vtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vtv", "entrypoint_scalar": "vtv_scalar", "entrypoint_simd": "vtv"}
{"task_id": "tsvc_vpvtv", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector plus vector times vector: a[i] += b[i] * c[i];\nImplement this .\n*/\nvoid vpvtv(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void vpvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpvtv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpvtv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \tvpvtv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvtv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vpvtv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpvtv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvtv, vpvtv_scalar)->Name(\"Scalar_vpvtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvtv, vpvtv_simd)->Name(\"SIMD_vpvtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vpvtv", "entrypoint_scalar": "vpvtv_scalar", "entrypoint_simd": "vpvtv"}
{"task_id": "tsvc_vpvts", "prompt": "/*\nThis function takes float arrays 'a', 'b', a scalar 's' and length 'n'.\nIt performs a vector plus vector times scalar: a[i] += b[i] * s;\nImplement this .\n*/\nvoid vpvts(float *a, const float *b, float s, size_t n) {\n}\n", "solution_scalar": "void vpvts_scalar(float *a, const float *b, float s, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] * s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvts_scalar(float *a, const float *b, float s, size_t n);\nvoid vpvts_simd(float *a, const float *b, float s, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tfloat s = 2.0f;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpvts\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpvts_scalar(a_scalar.data(), b_input.data(), s, length);\n       \tvpvts_simd(a_simd.data(), b_input.data(), s, length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvts!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvts_scalar(float *a, const float *b, float s, size_t n);\nvoid vpvts_simd(float *a, const float *b, float s, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float, size_t)>\nstatic void BM_vpvts(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tfloat s = 2.0f;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpvts\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), s, length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvts, vpvts_scalar)->Name(\"Scalar_vpvts\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvts, vpvts_simd)->Name(\"SIMD_vpvts\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vpvts", "entrypoint_scalar": "vpvts_scalar", "entrypoint_simd": "vpvts"}
{"task_id": "tsvc_vpvpv", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector plus vector plus vector: a[i] += b[i] + c[i];\nImplement this .\n*/\nvoid vpvpv(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void vpvpv_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvpv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpvpv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpvpv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \tvpvpv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvpv!\" << std::endl;\n S     \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvpv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vpvpv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpvpv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvpv, vpvpv_scalar)->Name(\"Scalar_vpvpv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvpv, vpvpv_simd)->Name(\"SIMD_vpvpv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vpvpv", "entrypoint_scalar": "vpvpv_scalar", "entrypoint_simd": "vpvpv"}
{"task_id": "tsvc_vtvtv", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector times vector times vector: a[i] = a[i] * b[i] * c[i];\nImplement this .\n*/\nvoid vtvtv(float *a, const float *b, const float *c, size_t n) {\n}\n", "solution_scalar": "void vtvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = a[i] * b[i] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vtvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vtvtv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvtvtv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \tvtvtv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vtvtv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vtvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vtvtv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vtvtv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vtvtv, vtvtv_scalar)->Name(\"Scalar_vtvtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vtvtv, vtvtv_simd)->Name(\"SIMD_vtvtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vtvtv", "entrypoint_scalar": "vtvtv_scalar", "entrypoint_simd": "vtvtv"}
{"task_id": "tsvc_vsumr", "prompt": "/*\nThis function takes float array 'a' and length 'n'.\nIt performs a vector sum reduction: sum += a[i];\nImplement this . The function should return the sum.\n*/\nfloat vsumr(const float *a, size_t n) {\n}\n", "solution_scalar": "float vsumr_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat vsumr_scalar(const float *a, size_t n);\nfloat vsumr_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vsumr\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat sum_scalar = vsumr_scalar(a_input.data(), length);\n       \tfloat sum_simd = vsumr_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vsumr!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat vsumr_scalar(const float *a, size_t n);\nfloat vsumr_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_vsumr(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for vsumr\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vsumr, vsumr_scalar)->Name(\"Scalar_vsumr\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vsumr, vsumr_simd)->Name(\"SIMD_vsumr\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vsumr", "entrypoint_scalar": "vsumr_scalar", "entrypoint_simd": "vsumr"}
{"task_id": "tsvc_vdotr", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector dot product reduction: dot += a[i] * b[i];\nImplement this . The function should return the dot product.\n*/\nfloat vdotr(const float *a, const float *b, size_t n) {\n}\n", "solution_scalar": "float vdotr_scalar(const float *a, const float *b, size_t n) {\n   \tfloat dot = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tdot += a[i] * b[i];\n   \t}\n   \treturn dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat vdotr_scalar(const float *a, const float *b, size_t n);\nfloat vdotr_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vdotr\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat dot_scalar = vdotr_scalar(a_input.data(), b_input.data(), length);\n       \tfloat dot_simd = vdotr_simd(a_input.data(), b_input.data(), length);\n\n       \tif (!allclose(dot_scalar, dot_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vdotr!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n t \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat vdotr_scalar(const float *a, const float *b, size_t n);\nfloat vdotr_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_vdotr(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \t// Ported Initialization Logic for vdotr\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tfloat dot = Func(a_input.data(), b_input.data(), length);\n       \tbenchmark::DoNotOptimize(dot);\n   \t}\n   \t// Loop (n). Ops: 2R (a, b).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vdotr, vdotr_scalar)->Name(\"Scalar_vdotr\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vdotr, vdotr_simd)->Name(\"SIMD_vdotr\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vdotr", "entrypoint_scalar": "vdotr_scalar", "entrypoint_simd": "vdotr"}
{"task_id": "tsvc_vbor", "prompt": "/*\nThis function takes float arrays 'x', 'a', 'b', 'c', 'd', 'e', 'aa_flat' and length 'n_2d'.\nIt performs a complex series of arithmetic operations (basic operations rates).\nImplement this .\n*/\nvoid vbor(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n}\n", "solution_scalar": "void vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfloat a1 = a[i];\n       \tfloat b1 = b[i];\n       \tfloat c1 = c[i];\n       \tfloat d1 = d[i];\n       \tfloat e1 = e[i];\n       \tfloat f1 = aa_flat[i]; // Original was aa[0][i]\n       \ta1 = a1 * b1 * c1 + a1 * b1 * d1 + a1 * b1 * e1 + a1 * b1 * f1 +\n             \ta1 * c1 * d1 + a1 * c1 * e1 + a1 * c1 * f1 + a1 * d1 * e1\n             \t+ a1 * d1 * f1 + a1 * e1 * f1;\n       \tb1 = b1 * c1 * d1 + b1 * c1 * e1 + b1 * c1 * f1 + b1 * d1 * e1 +\n             \tb1 * d1 * f1 + b1 * e1 * f1;\n       \tc1 = c1 * d1 * e1 + c1 * d1 * f1 + c1 * e1 * f1;\n g   \td1 = d1 * e1 * f1;\n       \tx[i] = a1 * b1 * c1 * d1;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_2D;\n\n   \tstd::vector<float> x_initial(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> aa_flat_input(length);\n   \tstd::vector<float> x_scalar(length), x_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vbor\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tx_initial[i] = 0.0f;\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n           \taa_flat_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tx_scalar = x_initial;\n       \tx_simd = x_initial;\n\n       \tvbor_scalar(x_scalar.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n       \tvbor_simd(x_simd.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n\n       \tif (!allclose(x_scalar, x_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vbor!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, const float *, const float*, size_t)>\nstatic void BM_vbor(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> x_output(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> aa_flat_input(length);\n   \tstd::vector<float> x_initial(length);\n\n   \t// Ported Initialization Logic for vbor\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tx_initial[i] = 0.0f;\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n       \taa_flat_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tx_output = x_initial;\n       \tbenchmark::DoNotOptimize(x_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n D   \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n       \tbenchmark::DoNotOptimize(aa_flat_input.data());\n\n       \tFunc(x_output.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d). Ops: 6R(a,b,c,d,e,aa_flat), 1W(x). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_vbor, vbor_scalar)->Name(\"Scalar_vbor\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_vbor, vbor_simd)->Name(\"SIMD_vbor\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "scalar", "task": "generation", "type": "TSVC", "subtype": "vbor", "entrypoint_scalar": "vbor_scalar", "entrypoint_simd": "vbor"}

{"task_id": "tsvc_s000", "prompt": "", "solution_scalar": "void s000_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n; i++) {\n        a[i] = b[i] + 1.0f;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s000", "entrypoint_scalar": "s000_scalar", "entrypoint_simd": "s000_simd"}
{"task_id": "tsvc_s111", "prompt": "", "solution_scalar": "void s111_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 1; i < n; i += 2) {\n        a[i] = a[i - 1] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s111", "entrypoint_scalar": "s111_scalar", "entrypoint_simd": "s111_simd"}
{"task_id": "tsvc_s1111", "prompt": "", "solution_scalar": "void s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        a[2*i] = c[i] * b[i] + d[i] * b[i] + c[i] * c[i] + d[i] * b[i] + d[i] * c[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1111", "entrypoint_scalar": "s1111_scalar", "entrypoint_simd": "s1111_simd"}
{"task_id": "tsvc_s112", "prompt": "", "solution_scalar": "void s112_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (long long i = (long long)n - 2; i >= 0; --i) {\n        a[i+1] = a[i] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s112", "entrypoint_scalar": "s112_scalar", "entrypoint_simd": "s112_simd"}
{"task_id": "tsvc_s1112", "prompt": "", "solution_scalar": "void s1112_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (long long i = (long long)n - 1; i >= 0; --i) {\n        a[i] = b[i] + 1.0f;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1112", "entrypoint_scalar": "s1112_scalar", "entrypoint_simd": "s1112_simd"}
{"task_id": "tsvc_s113", "prompt": "", "solution_scalar": "void s113_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    float a0 = a[0]; // Capture initial value\n    for (size_t i = 1; i < n; i++) {\n        a[i] = a0 + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s113", "entrypoint_scalar": "s113_scalar", "entrypoint_simd": "s113_simd"}
{"task_id": "tsvc_s1113", "prompt": "", "solution_scalar": "void s1113_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    float a_mid = a[n/2]; // Capture initial value\n    for (size_t i = 0; i < n; i++) {\n        a[i] = a_mid + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1113", "entrypoint_scalar": "s1113_scalar", "entrypoint_simd": "s1113_simd"}
{"task_id": "tsvc_s114", "prompt": "", "solution_scalar": "// Assuming aa and bb are pointers to flattened 2D arrays (row-major)\nvoid s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < i; j++) {\n            // aa[i][j] = aa[j][i] + bb[i][j];\n            aa_flat[i * n_2d + j] = aa_flat[j * n_2d + i] + bb_flat[i * n_2d + j];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s114", "entrypoint_scalar": "s114_scalar", "entrypoint_simd": "s114_simd"}
{"task_id": "tsvc_s115", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nvoid s115_scalar(float *a, const float* aa_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t j = 0; j < n_2d; j++) {\n        float a_j = a[j]; // Load a[j] once per outer loop iteration\n        for (size_t i = j + 1; i < n_2d; i++) {\n            // a[i] -= aa[j][i] * a[j];\n            a[i] -= aa_flat[j * n_2d + i] * a_j;\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s115", "entrypoint_scalar": "s115_scalar", "entrypoint_simd": "s115_simd"}
{"task_id": "tsvc_s1115", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            // aa[i][j] = aa[i][j]*cc[j][i] + bb[i][j];\n            size_t idx_ij = i * n_2d + j;\n            size_t idx_ji = j * n_2d + i;\n            aa_flat[idx_ij] = aa_flat[idx_ij] * cc_flat[idx_ji] + bb_flat[idx_ij];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1115", "entrypoint_scalar": "s1115_scalar", "entrypoint_simd": "s1115_simd"}
{"task_id": "tsvc_s116", "prompt": "", "solution_scalar": "void s116_scalar(float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n - 5; i += 5) {\n        a[i] = a[i + 1] * a[i];\n        a[i + 1] = a[i + 2] * a[i + 1];\n        a[i + 2] = a[i + 3] * a[i + 2];\n        a[i + 3] = a[i + 4] * a[i + 3];\n        a[i + 4] = a[i + 5] * a[i + 4];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s116", "entrypoint_scalar": "s116_scalar", "entrypoint_simd": "s116_simd"}
{"task_id": "tsvc_s118", "prompt": "", "solution_scalar": "// Assuming bb is a pointer to a flattened 2D array (row-major)\nvoid s118_scalar(float *a, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 1; i < n_2d; i++) {\n        for (size_t j = 0; j <= i - 1; j++) {\n            // a[i] += bb[j][i] * a[i-j-1];\n            a[i] += bb_flat[j * n_2d + i] * a[i - j - 1];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s118", "entrypoint_scalar": "s118_scalar", "entrypoint_simd": "s118_simd"}
{"task_id": "tsvc_s119", "prompt": "", "solution_scalar": "// Assuming aa and bb are pointers to flattened 2D arrays (row-major)\nvoid s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 1; i < n_2d; i++) {\n        for (size_t j = 1; j < n_2d; j++) {\n            // aa[i][j] = aa[i-1][j-1] + bb[i][j];\n            aa_flat[i * n_2d + j] = aa_flat[(i - 1) * n_2d + (j - 1)] + bb_flat[i * n_2d + j];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s119", "entrypoint_scalar": "s119_scalar", "entrypoint_simd": "s119_simd"}
{"task_id": "tsvc_s1119", "prompt": "", "solution_scalar": "// Assuming aa and bb are pointers to flattened 2D arrays (row-major)\nvoid s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 1; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            // aa[i][j] = aa[i-1][j] + bb[i][j];\n            aa_flat[i * n_2d + j] = aa_flat[(i - 1) * n_2d + j] + bb_flat[i * n_2d + j];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1119", "entrypoint_scalar": "s1119_scalar", "entrypoint_simd": "s1119_simd"}
{"task_id": "tsvc_s121", "prompt": "", "solution_scalar": "void s121_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int j;\n    for (size_t i = 0; i < n - 1; i++) {\n        j = i + 1;\n        a[i] = a[j] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s121", "entrypoint_scalar": "s121_scalar", "entrypoint_simd": "s121_simd"}
{"task_id": "tsvc_s122", "prompt": "", "solution_scalar": "void s122_scalar(float *a, const float *b, size_t n, int n1, int n3) {\n    // Assuming n corresponds to LEN_1D\n    int j = 1;\n    int k = 0;\n    for (int i = n1 - 1; i < (int)n; i += n3) {\n        k += j;\n        a[i] += b[n - k]; // Potential out-of-bounds if k > n\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s122", "entrypoint_scalar": "s122_scalar", "entrypoint_simd": "s122_simd"}
{"task_id": "tsvc_s123", "prompt": "", "solution_scalar": "void s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int j = -1;\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        j++;\n        a[j] = b[i] + d[i] * e[i];\n        if (c[i] > 0.0f) {\n            j++;\n            a[j] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s123", "entrypoint_scalar": "s123_scalar", "entrypoint_simd": "s123_simd"}
{"task_id": "tsvc_s124", "prompt": "", "solution_scalar": "void s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int j = -1;\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] > 0.0f) {\n            j++;\n            a[j] = b[i] + d[i] * e[i];\n        } else {\n            j++;\n            a[j] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s124", "entrypoint_scalar": "s124_scalar", "entrypoint_simd": "s124_simd"}
{"task_id": "tsvc_s125", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s125_scalar(float *flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    int k = -1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            k++;\n            // flat_2d_array[k] = aa[i][j] + bb[i][j] * cc[i][j];\n            size_t idx_ij = i * n_2d + j;\n            flat_2d_array[k] = aa_flat[idx_ij] + bb_flat[idx_ij] * cc_flat[idx_ij];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s125", "entrypoint_scalar": "s125_scalar", "entrypoint_simd": "s125_simd"}
{"task_id": "tsvc_s126", "prompt": "", "solution_scalar": "// Assuming bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    int k = 1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 1; j < n_2d; j++) {\n            // bb[j][i] = bb[j-1][i] + flat_2d_array[k-1] * cc[j][i];\n            size_t idx_ji = j * n_2d + i;\n            size_t idx_jminus1_i = (j - 1) * n_2d + i;\n            bb_flat[idx_ji] = bb_flat[idx_jminus1_i] + flat_2d_array[k - 1] * cc_flat[idx_ji];\n            ++k;\n        }\n        ++k;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s126", "entrypoint_scalar": "s126_scalar", "entrypoint_simd": "s126_simd"}
{"task_id": "tsvc_s127", "prompt": "", "solution_scalar": "void s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int j = -1;\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        j++;\n        a[j] = b[i] + c[i] * d[i];\n        j++;\n        a[j] = b[i] + d[i] * e[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s127", "entrypoint_scalar": "s127_scalar", "entrypoint_simd": "s127_simd"}
{"task_id": "tsvc_s128", "prompt": "", "solution_scalar": "void s128_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int j = -1;\n    int k;\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        k = j + 1;\n        a[i] = b[k] - d[i];\n        j = k + 1;\n        b[k] = a[i] + c[k];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s128", "entrypoint_scalar": "s128_scalar", "entrypoint_simd": "s128_simd"}
{"task_id": "tsvc_s131", "prompt": "", "solution_scalar": "void s131_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int m = 1;\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = a[i + m] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s131", "entrypoint_scalar": "s131_scalar", "entrypoint_simd": "s131_simd"}
{"task_id": "tsvc_s132", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nvoid s132_scalar(float* aa_flat, const float *b, const float *c, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    int m = 0;\n    int j = m;\n    int k = m + 1;\n    float c1 = c[1]; // Assuming c[1] is constant for the loop duration\n    for (size_t i = 1; i < n_2d; i++) {\n        // aa[j][i] = aa[k][i-1] + b[i] * c[1];\n        aa_flat[j * n_2d + i] = aa_flat[k * n_2d + (i - 1)] + b[i] * c1;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s132", "entrypoint_scalar": "s132_scalar", "entrypoint_simd": "s132_simd"}
{"task_id": "tsvc_s141", "prompt": "", "solution_scalar": "// Assuming bb is a pointer to a flattened 2D array (row-major)\nvoid s141_scalar(float *flat_2d_array, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    int k;\n    for (size_t i = 0; i < n_2d; i++) {\n        k = (i + 1) * i / 2 + i; // Simplified index calculation for j=i\n        for (size_t j = i; j < n_2d; j++) {\n            // flat_2d_array[k] += bb[j][i];\n            flat_2d_array[k] += bb_flat[j * n_2d + i];\n            k += j + 1;\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s141", "entrypoint_scalar": "s141_scalar", "entrypoint_simd": "s141_simd"}
{"task_id": "tsvc_s151", "prompt": "", "solution_scalar": "// Inlining the logic from s151s directly\nvoid s151_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    int m = 1;\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = a[i + m] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s151", "entrypoint_scalar": "s151_scalar", "entrypoint_simd": "s151_simd"}
{"task_id": "tsvc_s152", "prompt": "", "solution_scalar": "// Inlining the logic from s152s directly\nvoid s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n; i++) {\n        b[i] = d[i] * e[i];\n        // s152s(a, b, c, i); -> a[i] += b[i] * c[i];\n        a[i] += b[i] * c[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s152", "entrypoint_scalar": "s152_scalar", "entrypoint_simd": "s152_simd"}
{"task_id": "tsvc_s161", "prompt": "", "solution_scalar": "void s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n - 1; ++i) {\n        if (b[i] < 0.0f) {\n            // L20:\n            c[i+1] = a[i] + d[i] * d[i];\n        } else {\n            // Original path before L20\n            a[i] = c[i] + d[i] * e[i];\n            // L10: (empty)\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s161", "entrypoint_scalar": "s161_scalar", "entrypoint_simd": "s161_simd"}
{"task_id": "tsvc_s1161", "prompt": "", "solution_scalar": "void s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n - 1; ++i) {\n        if (c[i] < 0.0f) {\n            // L20:\n            b[i] = a[i] + d[i] * d[i];\n        } else {\n            // Original path before L20\n            a[i] = c[i] + d[i] * e[i];\n            // L10: (empty)\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1161", "entrypoint_scalar": "s1161_scalar", "entrypoint_simd": "s1161_simd"}
{"task_id": "tsvc_s162", "prompt": "", "solution_scalar": "void s162_scalar(float *a, const float *b, const float *c, size_t n, int k) {\n    // Assuming n corresponds to LEN_1D\n    if (k > 0) {\n        // Ensure k is within bounds or handle appropriately\n        size_t effective_limit = (k < (int)n) ? n - (size_t)k : 0;\n        for (size_t i = 0; i < effective_limit; i++) { \n            a[i] = a[i + k] + b[i] * c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s162", "entrypoint_scalar": "s162_scalar", "entrypoint_simd": "s162_simd"}
{"task_id": "tsvc_s171", "prompt": "", "solution_scalar": "void s171_scalar(float *a, const float *b, size_t n, int inc) {\n    // Assuming n corresponds to LEN_1D\n    // WARNING: Potential out-of-bounds write if inc is large or zero.\n    // Vectorization depends on compiler knowing 'inc'.\n    if (inc != 0) { // Avoid infinite loop or division by zero issues\n        for (size_t i = 0; i < n; i++) {\n            size_t index = i * (size_t)inc; // Use size_t for index\n            if (index < n) { // Basic bounds check\n                a[index] += b[i];\n            }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s171", "entrypoint_scalar": "s171_scalar", "entrypoint_simd": "s171_simd"}
{"task_id": "tsvc_s172", "prompt": "", "solution_scalar": "void s172_scalar(float *a, const float *b, size_t n, int n1, int n3) {\n    // Assuming n corresponds to LEN_1D\n    if (n3 != 0) { // Avoid infinite loop\n       for (int i = n1 - 1; i < (int)n; i += n3) {\n            // Add bounds check for safety if n1 or n3 can be negative\n            if (i >= 0) { \n                a[i] += b[i];\n            }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s172", "entrypoint_scalar": "s172_scalar", "entrypoint_simd": "s172_simd"}
{"task_id": "tsvc_s173", "prompt": "", "solution_scalar": "void s173_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    size_t k = n / 2;\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        a[i+k] = a[i] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s173", "entrypoint_scalar": "s173_scalar", "entrypoint_simd": "s173_simd"}
{"task_id": "tsvc_s174", "prompt": "", "solution_scalar": "void s174_scalar(float *a, const float *b, size_t n, int M) {\n    // Assuming n corresponds to LEN_1D\n    // M is typically n/2 in the original call\n    size_t effective_M = (size_t)M;\n    // Basic check to prevent out-of-bounds access\n    if (effective_M > 0 && effective_M * 2 <= n) {\n        for (size_t i = 0; i < effective_M; i++) {\n            a[i + effective_M] = a[i] + b[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s174", "entrypoint_scalar": "s174_scalar", "entrypoint_simd": "s174_simd"}
{"task_id": "tsvc_s175", "prompt": "", "solution_scalar": "void s175_scalar(float *a, const float *b, size_t n, int inc) {\n    // Assuming n corresponds to LEN_1D\n    // Vectorization depends on compiler knowing 'inc'.\n    if (inc > 0) { // Ensure positive increment to avoid issues\n       for (size_t i = 0; i < n - (size_t)inc; i += (size_t)inc) {\n            a[i] = a[i + (size_t)inc] + b[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s175", "entrypoint_scalar": "s175_scalar", "entrypoint_simd": "s175_simd"}
{"task_id": "tsvc_s176", "prompt": "", "solution_scalar": "// Convolution loop\nvoid s176_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    size_t m = n / 2;\n    for (size_t j = 0; j < n / 2; j++) {\n        for (size_t i = 0; i < m; i++) {\n            // Ensure index is not out of bounds\n            if (i + m - j - 1 < n) {\n                a[i] += b[i + m - j - 1] * c[j];\n            }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s176", "entrypoint_scalar": "s176_scalar", "entrypoint_simd": "s176_simd"}
{"task_id": "tsvc_s211", "prompt": "", "solution_scalar": "void s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 1; i < n - 1; i++) {\n        a[i] = b[i - 1] + c[i] * d[i];\n        b[i] = b[i + 1] - e[i] * d[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s211", "entrypoint_scalar": "s211_scalar", "entrypoint_simd": "s211_simd"}
{"task_id": "tsvc_s212", "prompt": "", "solution_scalar": "void s212_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Dependency needing temporary storage if vectorized naively\n    for (size_t i = 0; i < n - 1; i++) {\n        float temp_a = a[i] * c[i]; // Use temp to break dependency for vectorization\n        b[i] += a[i + 1] * d[i];\n        a[i] = temp_a;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s212", "entrypoint_scalar": "s212_scalar", "entrypoint_simd": "s212_simd"}
{"task_id": "tsvc_s1213", "prompt": "", "solution_scalar": "void s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Dependency needing temporary storage if vectorized naively\n    for (size_t i = 1; i < n - 1; i++) {\n        float temp_a = b[i-1] + c[i]; // Use temp\n        b[i] = a[i+1] * d[i];\n        a[i] = temp_a;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1213", "entrypoint_scalar": "s1213_scalar", "entrypoint_simd": "s1213_simd"}
{"task_id": "tsvc_s221", "prompt": "", "solution_scalar": "void s221_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Partially recursive loop, requires loop distribution for vectorization\n    for (size_t i = 1; i < n; i++) {\n        a[i] += c[i] * d[i];\n        b[i] = b[i - 1] + a[i] + d[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s221", "entrypoint_scalar": "s221_scalar", "entrypoint_simd": "s221_simd"}
{"task_id": "tsvc_s1221", "prompt": "", "solution_scalar": "void s1221_scalar(const float *a, float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Simple recurrence\n    for (size_t i = 4; i < n; i++) {\n        b[i] = b[i - 4] + a[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1221", "entrypoint_scalar": "s1221_scalar", "entrypoint_simd": "s1221_simd"}
{"task_id": "tsvc_s222", "prompt": "", "solution_scalar": "void s222_scalar(float *a, const float *b, const float *c, float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Recurrence in the middle, requires loop distribution\n    for (size_t i = 1; i < n; i++) {\n        a[i] += b[i] * c[i];\n        e[i] = e[i - 1] * e[i - 1];\n        a[i] -= b[i] * c[i]; // This seems potentially redundant with the first line\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s222", "entrypoint_scalar": "s222_scalar", "entrypoint_simd": "s222_simd"}
{"task_id": "tsvc_s231", "prompt": "", "solution_scalar": "// Assuming aa and bb are pointers to flattened 2D arrays (row-major)\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Loop interchange opportunity, but inner loop has dependency\n    for (size_t i = 0; i < n_2d; ++i) {\n        for (size_t j = 1; j < n_2d; j++) {\n            // aa[j][i] = aa[j - 1][i] + bb[j][i];\n            aa_flat[j * n_2d + i] = aa_flat[(j - 1) * n_2d + i] + bb_flat[j * n_2d + i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s231", "entrypoint_scalar": "s231_scalar", "entrypoint_simd": "s231_simd"}
{"task_id": "tsvc_s232", "prompt": "", "solution_scalar": "// Assuming aa and bb are pointers to flattened 2D arrays (row-major)\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Triangular loops with dependencies\n    for (size_t j = 1; j < n_2d; j++) {\n        for (size_t i = 1; i <= j; i++) {\n            // aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i];\n            float prev_aa = aa_flat[j * n_2d + (i - 1)];\n            aa_flat[j * n_2d + i] = prev_aa * prev_aa + bb_flat[j * n_2d + i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s232", "entrypoint_scalar": "s232_scalar", "entrypoint_simd": "s232_simd"}
{"task_id": "tsvc_s1232", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Triangular loops\n    for (size_t j = 0; j < n_2d; j++) {\n        for (size_t i = j; i < n_2d; i++) {\n            // aa[i][j] = bb[i][j] + cc[i][j];\n            size_t idx_ij = i * n_2d + j;\n            aa_flat[idx_ij] = bb_flat[idx_ij] + cc_flat[idx_ij];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1232", "entrypoint_scalar": "s1232_scalar", "entrypoint_simd": "s1232_simd"}
{"task_id": "tsvc_s233", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 1; i < n_2d; i++) {\n        // Inner loop 1 (dependency on j)\n        for (size_t j = 1; j < n_2d; j++) {\n            // aa[j][i] = aa[j-1][i] + cc[j][i];\n             aa_flat[j * n_2d + i] = aa_flat[(j - 1) * n_2d + i] + cc_flat[j * n_2d + i];\n        }\n        // Inner loop 2 (dependency on i)\n        for (size_t j = 1; j < n_2d; j++) {\n            // bb[j][i] = bb[j][i-1] + cc[j][i];\n            bb_flat[j * n_2d + i] = bb_flat[j * n_2d + (i - 1)] + cc_flat[j * n_2d + i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s233", "entrypoint_scalar": "s233_scalar", "entrypoint_simd": "s233_simd"}
{"task_id": "tsvc_s2233", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    for (size_t i = 1; i < n_2d; i++) {\n        // Inner loop 1 (dependency on j)\n        for (size_t j = 1; j < n_2d; j++) {\n            // aa[j][i] = aa[j-1][i] + cc[j][i];\n             aa_flat[j * n_2d + i] = aa_flat[(j - 1) * n_2d + i] + cc_flat[j * n_2d + i];\n        }\n        // Inner loop 2 (dependency on i)\n        for (size_t j = 1; j < n_2d; j++) {\n            // bb[i][j] = bb[i-1][j] + cc[i][j]; // Note original index order\n            bb_flat[i * n_2d + j] = bb_flat[(i - 1) * n_2d + j] + cc_flat[i * n_2d + j];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2233", "entrypoint_scalar": "s2233_scalar", "entrypoint_simd": "s2233_simd"}
{"task_id": "tsvc_s235", "prompt": "", "solution_scalar": "// Assuming aa, bb are pointers to flattened 2D arrays (row-major)\nvoid s235_scalar(float *a, const float *b, const float *c, float* aa_flat, const float* bb_flat, size_t n, size_t n_2d) {\n    // Assuming n=LEN_1D, n_2d=LEN_2D\n    // Imperfectly nested loops\n    for (size_t i = 0; i < n_2d; i++) { // Outer loop likely corresponds to n_2d based on array access\n        if (i < n) { // Protect a, b, c access\n             a[i] += b[i] * c[i];\n        }\n        float current_a_i = (i < n) ? a[i] : 0.0f; // Handle case if loop goes beyond 'a' size\n        for (size_t j = 1; j < n_2d; j++) {\n            // aa[j][i] = aa[j-1][i] + bb[j][i] * a[i];\n             aa_flat[j * n_2d + i] = aa_flat[(j - 1) * n_2d + i] + bb_flat[j * n_2d + i] * current_a_i;\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s235", "entrypoint_scalar": "s235_scalar", "entrypoint_simd": "s235_simd"}
{"task_id": "tsvc_s241", "prompt": "", "solution_scalar": "void s241_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Requires preloading / temporary storage\n    for (size_t i = 0; i < n - 1; i++) {\n        float temp_a = b[i] * c[i] * d[i]; // Calculate new 'a' first\n        b[i] = temp_a * a[i+1] * d[i];     // Use new 'a' value for 'b' calculation\n        a[i] = temp_a;                     // Store new 'a' value\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s241", "entrypoint_scalar": "s241_scalar", "entrypoint_simd": "s241_simd"}
{"task_id": "tsvc_s242", "prompt": "", "solution_scalar": "void s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n    // Assuming n corresponds to LEN_1D\n    // Simple recurrence\n    for (size_t i = 1; i < n; ++i) {\n        a[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s242", "entrypoint_scalar": "s242_scalar", "entrypoint_simd": "s242_simd"}
{"task_id": "tsvc_s243", "prompt": "", "solution_scalar": "void s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // False dependence cycle breaking with temporary storage\n    for (size_t i = 0; i < n - 1; i++) {\n        float temp_a1 = b[i] + c[i] * d[i];\n        float temp_b = temp_a1 + d[i] * e[i];\n        float temp_a2 = temp_b + a[i+1] * d[i];\n        a[i] = temp_a2; // Update a[i] last\n        b[i] = temp_b;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s243", "entrypoint_scalar": "s243_scalar", "entrypoint_simd": "s243_simd"}
{"task_id": "tsvc_s244", "prompt": "", "solution_scalar": "void s244_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // False dependence cycle breaking\n    for (size_t i = 0; i < n - 1; ++i) {\n        float temp_a = b[i] + c[i] * d[i]; // Calculate a[i] first based on old b[i]\n        float temp_b = c[i] + b[i];         // Calculate new b[i]\n        a[i+1] = temp_b + a[i+1] * d[i];   // Update a[i+1] using new b[i]\n        a[i] = temp_a;                     // Store new a[i]\n        b[i] = temp_b;                     // Store new b[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s244", "entrypoint_scalar": "s244_scalar", "entrypoint_simd": "s244_simd"}
{"task_id": "tsvc_s1244", "prompt": "", "solution_scalar": "void s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Cycle with true and anti dependency\n    for (size_t i = 0; i < n - 1; i++) {\n        float temp_a = b[i] + c[i] * c[i] + b[i]*b[i] + c[i]; // Calculate new a[i] value\n        d[i] = temp_a + a[i+1]; // Use new a[i] and old a[i+1]\n        a[i] = temp_a;        // Store new a[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1244", "entrypoint_scalar": "s1244_scalar", "entrypoint_simd": "s1244_simd"}
{"task_id": "tsvc_s2244", "prompt": "", "solution_scalar": "void s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Cycle with true and anti dependency, requires temporary storage or reordering\n    for (size_t i = 0; i < n - 1; i++) {\n        float temp_a_iplus1 = b[i] + e[i]; // Calculate new a[i+1] first\n        a[i] = b[i] + c[i];                // Calculate and store new a[i]\n        a[i+1] = temp_a_iplus1;           // Store new a[i+1]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2244", "entrypoint_scalar": "s2244_scalar", "entrypoint_simd": "s2244_simd"}
{"task_id": "tsvc_s251", "prompt": "", "solution_scalar": "void s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Scalar expansion\n    for (size_t i = 0; i < n; i++) {\n        float s = b[i] + c[i] * d[i];\n        a[i] = s * s;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s251", "entrypoint_scalar": "s251_scalar", "entrypoint_simd": "s251_simd"}
{"task_id": "tsvc_s1251", "prompt": "", "solution_scalar": "void s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Scalar expansion\n    for (size_t i = 0; i < n; i++) {\n        float s = b[i]+c[i];\n        b[i] = a[i]+d[i];\n        a[i] = s*e[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1251", "entrypoint_scalar": "s1251_scalar", "entrypoint_simd": "s1251_simd"}
{"task_id": "tsvc_s2251", "prompt": "", "solution_scalar": "void s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Scalar expansion with dependency\n    float s = 0.0f; // Initial value from original code context\n    for (size_t i = 0; i < n; i++) {\n        a[i] = s * e[i]; // Uses s from *previous* iteration\n        s = b[i] + c[i]; // Calculates s for *next* iteration\n        b[i] = a[i] + d[i]; // Uses *new* a[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2251", "entrypoint_scalar": "s2251_scalar", "entrypoint_simd": "s2251_simd"}
{"task_id": "tsvc_s3251", "prompt": "", "solution_scalar": "void s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Scalar expansion with dependencies across statements\n    for (size_t i = 0; i < n - 1; i++){\n        float temp_a_iplus1 = b[i] + c[i]; // Calculate assignment for a[i+1]\n        b[i] = c[i] * e[i];\n        d[i] = a[i] * e[i];\n        a[i+1] = temp_a_iplus1;         // Store assignment for a[i+1]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3251", "entrypoint_scalar": "s3251_scalar", "entrypoint_simd": "s3251_simd"}
{"task_id": "tsvc_s252", "prompt": "", "solution_scalar": "void s252_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Ambiguous scalar temporary (dependency through 't')\n    float t = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        float s = b[i] * c[i];\n        a[i] = s + t; // Use 't' from previous iteration\n        t = s;       // Update 't' for next iteration\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s252", "entrypoint_scalar": "s252_scalar", "entrypoint_simd": "s252_simd"}
{"task_id": "tsvc_s253", "prompt": "", "solution_scalar": "void s253_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Scalar assigned under 'if'\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > b[i]) {\n            float s = a[i] - b[i] * d[i];\n            c[i] += s;\n            a[i] = s; // Update a[i] only if condition met\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s253", "entrypoint_scalar": "s253_scalar", "entrypoint_simd": "s253_simd"}
{"task_id": "tsvc_s254", "prompt": "", "solution_scalar": "void s254_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Carry around variable 'x'\n    if (n == 0) return;\n    float x = b[n-1]; // Initial value from the end\n    for (size_t i = 0; i < n; i++) {\n        a[i] = (b[i] + x) * 0.5f; // Use 'x' from previous step\n        x = b[i];                // Update 'x' for next step\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s254", "entrypoint_scalar": "s254_scalar", "entrypoint_simd": "s254_simd"}
{"task_id": "tsvc_s255", "prompt": "", "solution_scalar": "void s255_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Carry around variables 'x', 'y' (2 levels)\n    if (n < 2) {\n        if (n == 1) a[0] = (b[0] + b[0] + b[0]) * (1.0f/3.0f); // Handle edge case\n        return;\n    }\n    float x = b[n-1];\n    float y = b[n-2];\n    for (size_t i = 0; i < n; i++) {\n        a[i] = (b[i] + x + y) * (1.0f / 3.0f); // Use x, y from previous steps\n        y = x;       // Update y\n        x = b[i];    // Update x\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s255", "entrypoint_scalar": "s255_scalar", "entrypoint_simd": "s255_simd"}
{"task_id": "tsvc_s256", "prompt": "", "solution_scalar": "// Assuming aa, bb are pointers to flattened 2D arrays (row-major)\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_1d, size_t n_2d) {\n    // Assuming n_1d=LEN_1D, n_2d=LEN_2D\n    // Array expansion\n    for (size_t i = 0; i < n_2d; i++) {\n        // Inner loop modifies 'a' array, which is then used by the assignment to aa\n        // This structure is complex for vectorization\n        for (size_t j = 1; j < n_2d; j++) {\n             if (j < n_1d) { // Bounds check for 'a'\n                 a[j] = 1.0f - a[j - 1];\n                 aa_flat[j * n_2d + i] = a[j] + bb_flat[j * n_2d + i] * d[j];\n             } else if (j-1 < n_1d) { // Case where a[j] is out but a[j-1] is in\n                 // Potentially undefined behavior or needs clarification on intent\n             }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s256", "entrypoint_scalar": "s256_scalar", "entrypoint_simd": "s256_simd"}
{"task_id": "tsvc_s257", "prompt": "", "solution_scalar": "// Assuming aa, bb are pointers to flattened 2D arrays (row-major)\nvoid s257_scalar(float *a, float* aa_flat, const float* bb_flat, size_t n_1d, size_t n_2d) {\n    // Assuming n_1d=LEN_1D, n_2d=LEN_2D\n    // Array expansion with complex dependencies\n    for (size_t i = 1; i < n_2d; i++) { // Outer loop likely corresponds to n_1d based on a[i] access\n        if (i >= n_1d) continue; // Basic bounds check for 'a'\n        for (size_t j = 0; j < n_2d; j++) {\n            a[i] = aa_flat[j * n_2d + i] - a[i-1]; // Problem: a[i] is overwritten multiple times\n                                                     // Assuming the last write is intended?\n            aa_flat[j * n_2d + i] = a[i] + bb_flat[j * n_2d + i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s257", "entrypoint_scalar": "s257_scalar", "entrypoint_simd": "s257_simd"}
{"task_id": "tsvc_s258", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_1d, size_t n_2d) {\n    // Assuming n_1d=LEN_1D, n_2d=LEN_2D\n    // Wrap-around scalar under an if\n    float s = 0.0f; // Initialized outside the loop in original context\n    for (size_t i = 0; i < n_2d; ++i) { // Loop limit seems related to n_2d based on aa access\n        if (i >= n_1d) continue; // Bounds check for a,b,c,d,e\n        if (a[i] > 0.0f) {\n            s = d[i] * d[i];\n        } // 's' retains its value from previous iteration if condition is false\n        b[i] = s * c[i] + d[i];\n        e[i] = (s + 1.0f) * aa_flat[0 * n_2d + i]; // Accessing aa[0][i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s258", "entrypoint_scalar": "s258_scalar", "entrypoint_simd": "s258_simd"}
{"task_id": "tsvc_s261", "prompt": "", "solution_scalar": "void s261_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Renaming scalar temporary 't'\n    for (size_t i = 1; i < n; ++i) {\n        float t1 = a[i] + b[i]; // Value using old a[i]\n        a[i] = t1 + c[i-1];    // Update a[i] using t1 and old c[i-1]\n        float t2 = c[i] * d[i]; // Value using old c[i]\n        c[i] = t2;             // Update c[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s261", "entrypoint_scalar": "s261_scalar", "entrypoint_simd": "s261_simd"}
{"task_id": "tsvc_s271", "prompt": "", "solution_scalar": "void s271_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Simple conditional update\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] > 0.0f) {\n            a[i] += b[i] * c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s271", "entrypoint_scalar": "s271_scalar", "entrypoint_simd": "s271_simd"}
{"task_id": "tsvc_s272", "prompt": "", "solution_scalar": "void s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, float t) {\n    // Assuming n corresponds to LEN_1D\n    // Independent conditional\n    for (size_t i = 0; i < n; i++) {\n        if (e[i] >= t) {\n            a[i] += c[i] * d[i];\n            b[i] += c[i] * c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s272", "entrypoint_scalar": "s272_scalar", "entrypoint_simd": "s272_simd"}
{"task_id": "tsvc_s273", "prompt": "", "solution_scalar": "void s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Dependent conditional\n    for (size_t i = 0; i < n; i++) {\n        a[i] += d[i] * e[i];\n        if (a[i] < 0.0f) { // Condition depends on updated a[i]\n            b[i] += d[i] * e[i];\n        }\n        c[i] += a[i] * d[i]; // Uses potentially updated a[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s273", "entrypoint_scalar": "s273_scalar", "entrypoint_simd": "s273_simd"}
{"task_id": "tsvc_s274", "prompt": "", "solution_scalar": "void s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Complex dependent conditional\n    for (size_t i = 0; i < n; i++) {\n        float temp_a = c[i] + e[i] * d[i]; // Calculate potential new a[i]\n        if (temp_a > 0.0f) {\n            b[i] = temp_a + b[i];\n            a[i] = temp_a; // Store if condition met\n        } else {\n            a[i] = d[i] * e[i]; // Store different value if condition not met\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s274", "entrypoint_scalar": "s274_scalar", "entrypoint_simd": "s274_simd"}
{"task_id": "tsvc_s275", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // If around inner loop\n    for (size_t i = 0; i < n_2d; i++) {\n        if (aa_flat[0 * n_2d + i] > 0.0f) { // Check aa[0][i]\n            for (size_t j = 1; j < n_2d; j++) {\n                // aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i];\n                 aa_flat[j * n_2d + i] = aa_flat[(j - 1) * n_2d + i] + bb_flat[j * n_2d + i] * cc_flat[j * n_2d + i];\n            }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s275", "entrypoint_scalar": "s275_scalar", "entrypoint_simd": "s275_simd"}
{"task_id": "tsvc_s2275", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s2275_scalar(float *a, const float *b, const float *c, const float *d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n, size_t n_2d) {\n    // Assuming n=LEN_1D, n_2d=LEN_2D\n    // Loop distribution needed for interchange\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            // aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i];\n            aa_flat[j * n_2d + i] = aa_flat[j * n_2d + i] + bb_flat[j * n_2d + i] * cc_flat[j * n_2d + i];\n        }\n        if (i < n) { // Bounds check\n             a[i] = b[i] + c[i] * d[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2275", "entrypoint_scalar": "s2275_scalar", "entrypoint_simd": "s2275_simd"}
{"task_id": "tsvc_s276", "prompt": "", "solution_scalar": "void s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // If test using loop index\n    size_t mid = n / 2;\n    for (size_t i = 0; i < n; i++) {\n        if (i + 1 < mid) {\n            a[i] += b[i] * c[i];\n        } else {\n            a[i] += b[i] * d[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s276", "entrypoint_scalar": "s276_scalar", "entrypoint_simd": "s276_simd"}
{"task_id": "tsvc_s277", "prompt": "", "solution_scalar": "void s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Control flow with goto\n    for (size_t i = 0; i < n - 1; i++) {\n        if (a[i] >= 0.0f) {\n            // goto L20; -> skip updates\n        } else {\n            if (b[i] >= 0.0f) {\n                // goto L30; -> only update b[i+1]\n                b[i+1] = c[i] + d[i] * e[i];\n            } else {\n                // No goto, update both a[i] and b[i+1]\n                a[i] += c[i] * d[i];\n                b[i+1] = c[i] + d[i] * e[i];\n            }\n        }\n        // L20: (label after the block)\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s277", "entrypoint_scalar": "s277_scalar", "entrypoint_simd": "s277_simd"}
{"task_id": "tsvc_s278", "prompt": "", "solution_scalar": "void s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // If/goto mimicking if-then-else\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > 0.0f) {\n            // L20:\n            c[i] = -c[i] + d[i] * e[i];\n        } else {\n            // Path before L20\n            b[i] = -b[i] + d[i] * e[i];\n            // goto L30 implied\n        }\n        // L30:\n        a[i] = b[i] + c[i] * d[i]; // Uses updated b[i] or c[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s278", "entrypoint_scalar": "s278_scalar", "entrypoint_simd": "s278_simd"}
{"task_id": "tsvc_s279", "prompt": "", "solution_scalar": "void s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector if/gotos\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > 0.0f) {\n            // L20:\n            c[i] = -c[i] + e[i] * e[i];\n        } else {\n            // Path before L20\n            b[i] = -b[i] + d[i] * d[i];\n            if (b[i] <= a[i]) {\n                // goto L30;\n            } else {\n                c[i] += d[i] * e[i];\n                // goto L30 implied\n            }\n        }\n        // L30:\n        a[i] = b[i] + c[i] * d[i]; // Uses updated values\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s279", "entrypoint_scalar": "s279_scalar", "entrypoint_simd": "s279_simd"}
{"task_id": "tsvc_s1279", "prompt": "", "solution_scalar": "void s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Nested vector ifs\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] < 0.0f) {\n            if (b[i] > a[i]) {\n                c[i] += d[i] * e[i];\n            }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1279", "entrypoint_scalar": "s1279_scalar", "entrypoint_simd": "s1279_simd"}
{"task_id": "tsvc_s2710", "prompt": "", "solution_scalar": "void s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, float x) {\n    // Assuming n corresponds to LEN_1D\n    // Scalar and vector ifs\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > b[i]) {\n            a[i] += b[i] * d[i];\n            if (n > 10) { // Condition based on overall size 'n'\n                c[i] += d[i] * d[i];\n            } else {\n                c[i] = d[i] * e[i] + 1.0f;\n            }\n        } else {\n            b[i] = a[i] + e[i] * e[i];\n            if (x > 0.0f) { // Condition based on external scalar 'x'\n                c[i] = a[i] + d[i] * d[i];\n            } else {\n                c[i] += e[i] * e[i];\n            }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2710", "entrypoint_scalar": "s2710_scalar", "entrypoint_simd": "s2710_simd"}
{"task_id": "tsvc_s2711", "prompt": "", "solution_scalar": "void s2711_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Semantic if removal (equivalent to masked assignment)\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] != 0.0f) {\n            a[i] += b[i] * c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2711", "entrypoint_scalar": "s2711_scalar", "entrypoint_simd": "s2711_simd"}
{"task_id": "tsvc_s2712", "prompt": "", "solution_scalar": "void s2712_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // If condition, but update only happens if condition is met\n    // Equivalent to a[i] = (a[i] > b[i]) ? a[i] + b[i] * c[i] : a[i];\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > b[i]) {\n            a[i] += b[i] * c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2712", "entrypoint_scalar": "s2712_scalar", "entrypoint_simd": "s2712_simd"}
{"task_id": "tsvc_s281", "prompt": "", "solution_scalar": "void s281_scalar(float *a, float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Crossing thresholds / Index set splitting / Reverse data access\n    for (size_t i = 0; i < n; i++) {\n        float x = a[n - i - 1] + b[i] * c[i]; // Read from reversed 'a'\n        a[i] = x - 1.0f;                      // Write to forward 'a'\n        b[i] = x;                             // Write to forward 'b'\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s281", "entrypoint_scalar": "s281_scalar", "entrypoint_simd": "s281_simd"}
{"task_id": "tsvc_s1281", "prompt": "", "solution_scalar": "void s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Simple element-wise operations\n    for (size_t i = 0; i < n; i++) {\n        float x = b[i]*c[i] + a[i]*d[i] + e[i];\n        a[i] = x - 1.0f;\n        b[i] = x;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1281", "entrypoint_scalar": "s1281_scalar", "entrypoint_simd": "s1281_simd"}
{"task_id": "tsvc_s291", "prompt": "", "solution_scalar": "void s291_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Loop peeling / Wrap around variable (1 level)\n    if (n == 0) return;\n    int im1 = n - 1;\n    for (size_t i = 0; i < n; i++) {\n        a[i] = (b[i] + b[im1]) * 0.5f;\n        im1 = i; // Update index for *next* iteration\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s291", "entrypoint_scalar": "s291_scalar", "entrypoint_simd": "s291_simd"}
{"task_id": "tsvc_s292", "prompt": "", "solution_scalar": "void s292_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Loop peeling / Wrap around variable (2 levels)\n    if (n < 2) {\n       if (n == 1) a[0] = (b[0] + b[0] + b[0]) * (1.0f/3.0f); // Handle edge case n=1\n       return;\n    }\n    int im1 = n - 1;\n    int im2 = n - 2;\n    for (size_t i = 0; i < n; i++) {\n        a[i] = (b[i] + b[im1] + b[im2]) * (1.0f / 3.0f);\n        im2 = im1; // Update index for next iteration\n        im1 = i;   // Update index for next iteration\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s292", "entrypoint_scalar": "s292_scalar", "entrypoint_simd": "s292_simd"}
{"task_id": "tsvc_s293", "prompt": "", "solution_scalar": "void s293_scalar(float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Loop peeling - dependence on a[0]\n    float a0 = a[0]; // Read initial value\n    for (size_t i = 0; i < n; i++) { // Original loop started at i=0\n        a[i] = a0;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s293", "entrypoint_scalar": "s293_scalar", "entrypoint_simd": "s293_simd"}
{"task_id": "tsvc_s2101", "prompt": "", "solution_scalar": "// Assuming aa, bb, cc are pointers to flattened 2D arrays (row-major)\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Main diagonal calculation (stride access)\n    for (size_t i = 0; i < n_2d; i++) {\n        // aa[i][i] += bb[i][i] * cc[i][i];\n        size_t idx_ii = i * n_2d + i;\n        aa_flat[idx_ii] += bb_flat[idx_ii] * cc_flat[idx_ii];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2101", "entrypoint_scalar": "s2101_scalar", "entrypoint_simd": "s2101_simd"}
{"task_id": "tsvc_s2102", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nvoid s2102_scalar(float* aa_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Create identity matrix\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            // aa[j][i] = 0.0f;\n            aa_flat[j * n_2d + i] = 0.0f;\n        }\n        // aa[i][i] = 1.0f;\n        aa_flat[i * n_2d + i] = 1.0f;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2102", "entrypoint_scalar": "s2102_scalar", "entrypoint_simd": "s2102_simd"}
{"task_id": "tsvc_s2111", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nvoid s2111_scalar(float* aa_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Wavefront computation (dependencies prevent simple vectorization)\n    for (size_t j = 1; j < n_2d; j++) {\n        for (size_t i = 1; i < n_2d; i++) {\n            // aa[j][i] = (aa[j][i-1] + aa[j-1][i]) / 1.9f;\n            aa_flat[j * n_2d + i] = (aa_flat[j * n_2d + (i - 1)] + aa_flat[(j - 1) * n_2d + i]) / 1.9f;\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2111", "entrypoint_scalar": "s2111_scalar", "entrypoint_simd": "s2111_simd"}
{"task_id": "tsvc_s311", "prompt": "", "solution_scalar": "float s311_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Sum reduction\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s311", "entrypoint_scalar": "s311_scalar", "entrypoint_simd": "s311_simd"}
{"task_id": "tsvc_s31111", "prompt": "", "solution_scalar": "// Helper function (can be defined locally or assumed available)\nfloat test_helper(const float* A) { \n    float s = 0.0f;\n    for (int i = 0; i < 4; i++)\n        s += A[i];\n    return s;\n}\n\nfloat s31111_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D and is >= 32\n    // Unrolled sum reduction using helper\n    float sum = 0.0f;\n    sum += test_helper(&a[0]);\n    sum += test_helper(&a[4]);\n    sum += test_helper(&a[8]);\n    sum += test_helper(&a[12]);\n    sum += test_helper(&a[16]);\n    sum += test_helper(&a[20]);\n    sum += test_helper(&a[24]);\n    sum += test_helper(&a[28]);\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s31111", "entrypoint_scalar": "s31111_scalar", "entrypoint_simd": "s31111_simd"}
{"task_id": "tsvc_s312", "prompt": "", "solution_scalar": "float s312_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Product reduction\n    float prod = 1.0f;\n    for (size_t i = 0; i < n; i++) {\n        prod *= a[i];\n    }\n    return prod;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s312", "entrypoint_scalar": "s312_scalar", "entrypoint_simd": "s312_simd"}
{"task_id": "tsvc_s313", "prompt": "", "solution_scalar": "float s313_scalar(const float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Dot product reduction\n    float dot = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        dot += a[i] * b[i];\n    }\n    return dot;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s313", "entrypoint_scalar": "s313_scalar", "entrypoint_simd": "s313_simd"}
{"task_id": "tsvc_s314", "prompt": "", "solution_scalar": "float s314_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Max reduction\n    if (n == 0) return -INFINITY; // Or appropriate default\n    float x = a[0];\n    for (size_t i = 1; i < n; i++) { // Start from 1\n        if (a[i] > x) {\n            x = a[i];\n        }\n    }\n    return x;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s314", "entrypoint_scalar": "s314_scalar", "entrypoint_simd": "s314_simd"}
{"task_id": "tsvc_s315", "prompt": "", "solution_scalar": "// Returns index, value found in output struct or separate pointers\nstruct MaxInfo { float max_val; int index; };\nMaxInfo s315_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Max reduction with index\n    MaxInfo result = {-INFINITY, -1};\n    if (n == 0) return result;\n    \n    result.max_val = a[0];\n    result.index = 0;\n    for (size_t i = 1; i < n; ++i) { // Start from 1\n        if (a[i] > result.max_val) {\n            result.max_val = a[i];\n            result.index = (int)i;\n        }\n    }\n    return result;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s315", "entrypoint_scalar": "s315_scalar", "entrypoint_simd": "s315_simd"}
{"task_id": "tsvc_s316", "prompt": "", "solution_scalar": "float s316_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Min reduction\n    if (n == 0) return INFINITY; // Or appropriate default\n    float x = a[0];\n    for (size_t i = 1; i < n; ++i) {\n        if (a[i] < x) {\n            x = a[i];\n        }\n    }\n    return x;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s316", "entrypoint_scalar": "s316_scalar", "entrypoint_simd": "s316_simd"}
{"task_id": "tsvc_s317", "prompt": "", "solution_scalar": "#include <cmath> // For powf\nfloat s317_scalar(size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Product reduction (closed form possible)\n    // The loop calculates 0.99^(n/2)\n    // Direct calculation is likely faster than loop vectorization\n    float factor = 0.99f;\n    size_t num_iterations = n / 2;\n    // Can be calculated directly: return powf(factor, (float)num_iterations);\n    // Or simulate the loop for testing:\n    float q = 1.0f;\n    for (size_t i = 0; i < num_iterations; i++) {\n        q *= factor;\n    }\n    return q;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s317", "entrypoint_scalar": "s317_scalar", "entrypoint_simd": "s317_simd"}
{"task_id": "tsvc_s318", "prompt": "", "solution_scalar": "#include <cmath> // For fabsf\n// Returns index, value found in output struct or separate pointers\nstruct MaxAbsInfo { float max_abs_val; int index; };\nMaxAbsInfo s318_scalar(const float *a, size_t n, int inc) {\n    // Assuming n corresponds to LEN_1D\n    // ISAMAX (max absolute value index) with stride\n    MaxAbsInfo result = {0.0f, -1};\n    if (n == 0 || inc <= 0) return result; // Invalid input\n\n    size_t k = 0;\n    result.index = 0;\n    if (k < n) { // Check initial index\n       result.max_abs_val = fabsf(a[0]);\n    }\n    k += (size_t)inc;\n\n    for (size_t i = 1; i < n; i++) { // Check remaining elements based on loop count 'i'\n         if (k >= n) break; // Stop if index goes out of bounds\n         float current_abs = fabsf(a[k]);\n         if (current_abs > result.max_abs_val) {\n             result.index = (int)i; // Store loop counter 'i', not index 'k'\n             result.max_abs_val = current_abs;\n         }\n         k += (size_t)inc;\n    }\n    return result;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s318", "entrypoint_scalar": "s318_scalar", "entrypoint_simd": "s318_simd"}
{"task_id": "tsvc_s319", "prompt": "", "solution_scalar": "// Returns sum, modifies a and b\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Coupled reductions\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        a[i] = c[i] + d[i];\n        sum += a[i];\n        b[i] = c[i] + e[i];\n        sum += b[i];\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s319", "entrypoint_scalar": "s319_scalar", "entrypoint_simd": "s319_simd"}
{"task_id": "tsvc_s3110", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nstruct MaxInfo2D { float max_val; int xindex; int yindex; };\nMaxInfo2D s3110_scalar(const float* aa_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Max reduction with index (2D)\n    MaxInfo2D result = {-INFINITY, -1, -1};\n    if (n_2d == 0) return result;\n\n    result.max_val = aa_flat[0]; // aa[0][0]\n    result.xindex = 0;\n    result.yindex = 0;\n\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            float current_val = aa_flat[i * n_2d + j];\n            if (current_val > result.max_val) {\n                result.max_val = current_val;\n                result.xindex = (int)i;\n                result.yindex = (int)j;\n            }\n        }\n    }\n    return result;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3110", "entrypoint_scalar": "s3110_scalar", "entrypoint_simd": "s3110_simd"}
{"task_id": "tsvc_s13110", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\n// Identical to s3110\nstruct MaxInfo2D { float max_val; int xindex; int yindex; };\nMaxInfo2D s13110_scalar(const float* aa_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Max reduction with index (2D)\n    MaxInfo2D result = {-INFINITY, -1, -1};\n    if (n_2d == 0) return result;\n\n    result.max_val = aa_flat[0]; // aa[0][0]\n    result.xindex = 0;\n    result.yindex = 0;\n\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            float current_val = aa_flat[i * n_2d + j];\n            if (current_val > result.max_val) {\n                result.max_val = current_val;\n                result.xindex = (int)i;\n                result.yindex = (int)j;\n            }\n        }\n    }\n    return result;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s13110", "entrypoint_scalar": "s13110_scalar", "entrypoint_simd": "s13110_simd"}
{"task_id": "tsvc_s3111", "prompt": "", "solution_scalar": "float s3111_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Conditional sum reduction\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > 0.0f) {\n            sum += a[i];\n        }\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3111", "entrypoint_scalar": "s3111_scalar", "entrypoint_simd": "s3111_simd"}
{"task_id": "tsvc_s3112", "prompt": "", "solution_scalar": "// Returns final sum, modifies b\nfloat s3112_scalar(const float *a, float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Sum reduction saving running sums (prefix sum)\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        sum += a[i];\n        b[i] = sum;\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3112", "entrypoint_scalar": "s3112_scalar", "entrypoint_simd": "s3112_simd"}
{"task_id": "tsvc_s3113", "prompt": "", "solution_scalar": "#include <cmath> // For fabsf\nfloat s3113_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Maximum of absolute value reduction\n    if (n == 0) return 0.0f; // Or appropriate default\n    float max_abs = fabsf(a[0]);\n    for (size_t i = 1; i < n; i++) {\n        float current_abs = fabsf(a[i]);\n        if (current_abs > max_abs) {\n            max_abs = current_abs;\n        }\n    }\n    return max_abs;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3113", "entrypoint_scalar": "s3113_scalar", "entrypoint_simd": "s3113_simd"}
{"task_id": "tsvc_s321", "prompt": "", "solution_scalar": "void s321_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // First order linear recurrence\n    for (size_t i = 1; i < n; i++) {\n        a[i] += a[i-1] * b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s321", "entrypoint_scalar": "s321_scalar", "entrypoint_simd": "s321_simd"}
{"task_id": "tsvc_s322", "prompt": "", "solution_scalar": "void s322_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Second order linear recurrence\n    for (size_t i = 2; i < n; i++) {\n        a[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s322", "entrypoint_scalar": "s322_scalar", "entrypoint_simd": "s322_simd"}
{"task_id": "tsvc_s323", "prompt": "", "solution_scalar": "void s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Coupled recurrence\n    for (size_t i = 1; i < n; i++) {\n        a[i] = b[i-1] + c[i] * d[i];\n        b[i] = a[i] + c[i] * e[i]; // Uses updated a[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s323", "entrypoint_scalar": "s323_scalar", "entrypoint_simd": "s323_simd"}
{"task_id": "tsvc_s331", "prompt": "", "solution_scalar": "// Returns last index found, or -1\nint s331_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Search loop: find last index where a[i] < 0\n    int j = -1;\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] < 0.0f) {\n            j = (int)i;\n        }\n    }\n    return j;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s331", "entrypoint_scalar": "s331_scalar", "entrypoint_simd": "s331_simd"}
{"task_id": "tsvc_s332", "prompt": "", "solution_scalar": "// Returns index and value of first element > t\nstruct SearchResult { float value; int index; };\nSearchResult s332_scalar(const float *a, size_t n, float t) {\n    // Assuming n corresponds to LEN_1D\n    // Search loop: find first value > threshold 't'\n    SearchResult result = {-1.0f, -2};\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > t) {\n            result.index = (int)i;\n            result.value = a[i];\n            // goto L20; -> equivalent to break\n            break; \n        }\n    }\n    // L20:\n    return result;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s332", "entrypoint_scalar": "s332_scalar", "entrypoint_simd": "s332_simd"}
{"task_id": "tsvc_s341", "prompt": "", "solution_scalar": "// Returns number of elements packed\nint s341_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Packing positive values\n    int j = -1;\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] > 0.0f) {\n            j++;\n            a[j] = b[i];\n        }\n    }\n    return j + 1; // Return count of packed elements\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s341", "entrypoint_scalar": "s341_scalar", "entrypoint_simd": "s341_simd"}
{"task_id": "tsvc_s342", "prompt": "", "solution_scalar": "void s342_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Unpacking based on condition in 'a'\n    int j = -1;\n    for (size_t i = 0; i < n; i++) {\n        if (a[i] > 0.0f) {\n            j++;\n            // Potential out-of-bounds read from b if number of positive a[i] > size of b\n            // Assuming 'b' is large enough or j is bounded\n            a[i] = b[j]; \n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s342", "entrypoint_scalar": "s342_scalar", "entrypoint_simd": "s342_simd"}
{"task_id": "tsvc_s343", "prompt": "", "solution_scalar": "// Assuming aa, bb are pointers to flattened 2D arrays (row-major)\n// Returns number of elements packed\nint s343_scalar(float *flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n    // n_2d = LEN_2D (e.g., 256)\n    // Pack 2D array into 1D based on condition in bb\n    int k = -1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            if (bb_flat[j * n_2d + i] > 0.0f) {\n                k++;\n                // Potential out-of-bounds write if k >= size of flat_2d_array\n                flat_2d_array[k] = aa_flat[j * n_2d + i];\n            }\n        }\n    }\n    return k + 1; // Return count of packed elements\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s343", "entrypoint_scalar": "s343_scalar", "entrypoint_simd": "s343_simd"}
{"task_id": "tsvc_s351", "prompt": "", "solution_scalar": "void s351_scalar(float *a, const float *b, float alpha, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Unrolled SAXPY (can be rerolled)\n    size_t limit = (n / 5) * 5; // Process bulk in steps of 5\n    for (size_t i = 0; i < limit; i += 5) {\n        a[i] += alpha * b[i];\n        a[i + 1] += alpha * b[i + 1];\n        a[i + 2] += alpha * b[i + 2];\n        a[i + 3] += alpha * b[i + 3];\n        a[i + 4] += alpha * b[i + 4];\n    }\n    // Handle remainder\n    for (size_t i = limit; i < n; ++i) {\n         a[i] += alpha * b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s351", "entrypoint_scalar": "s351_scalar", "entrypoint_simd": "s351_simd"}
{"task_id": "tsvc_s1351", "prompt": "", "solution_scalar": "// Uses restrict pointers, standard C++ equivalent is direct pointer args\nvoid s1351_scalar(float * __restrict__ A, const float * __restrict__ B, const float * __restrict__ C, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Pointer-based element-wise addition\n    for (size_t i = 0; i < n; i++) {\n        A[i] = B[i] + C[i]; // Array notation is equivalent and often clearer\n        // Original pointer version:\n        // *A = *B + *C;\n        // A++; B++; C++;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1351", "entrypoint_scalar": "s1351_scalar", "entrypoint_simd": "s1351_simd"}
{"task_id": "tsvc_s352", "prompt": "", "solution_scalar": "float s352_scalar(const float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Unrolled dot product reduction (can be rerolled)\n    float dot = 0.0f;\n    size_t limit = (n / 5) * 5;\n    for (size_t i = 0; i < limit; i += 5) {\n        dot += a[i] * b[i] + a[i + 1] * b[i + 1] + a[i + 2] * b[i + 2] +\n               a[i + 3] * b[i + 3] + a[i + 4] * b[i + 4];\n    }\n    // Handle remainder\n    for (size_t i = limit; i < n; ++i) {\n        dot += a[i] * b[i];\n    }\n    return dot;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s352", "entrypoint_scalar": "s352_scalar", "entrypoint_simd": "s352_simd"}
{"task_id": "tsvc_s353", "prompt": "", "solution_scalar": "void s353_scalar(float *a, const float *b, const int *ip, float alpha, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Unrolled sparse SAXPY (gather required)\n    size_t limit = (n / 5) * 5;\n    for (size_t i = 0; i < limit; i += 5) {\n        // Need bounds check for ip[i] accesses if indices can be out of range for b\n        a[i] += alpha * b[ip[i]];\n        a[i + 1] += alpha * b[ip[i + 1]];\n        a[i + 2] += alpha * b[ip[i + 2]];\n        a[i + 3] += alpha * b[ip[i + 3]];\n        a[i + 4] += alpha * b[ip[i + 4]];\n    }\n    // Handle remainder\n    for (size_t i = limit; i < n; ++i) {\n         a[i] += alpha * b[ip[i]];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s353", "entrypoint_scalar": "s353_scalar", "entrypoint_simd": "s353_simd"}
{"task_id": "tsvc_s421", "prompt": "", "solution_scalar": "void s421_scalar(float *xx, const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Equivalence - no overlap assumed by yy=xx usage\n    // Effectively: xx[i] = xx[i+1] + a[i]\n    // This is tricky due to read/write overlap on xx\n    if (n == 0) return;\n    float next_xx = xx[n-1]; // Need to read ahead or use temp\n    for (long long i = (long long)n - 2; i >= 0; --i) { // Iterate backwards\n        float current_xx = xx[i]; // Store old value needed for next iteration's read\n        xx[i] = next_xx + a[i];\n        next_xx = current_xx;\n    }\n    // Original loop (forward) modifies array during read, harder to vectorize:\n    // float* yy = xx; \n    // for (size_t i = 0; i < n - 1; i++) {\n    //    xx[i] = yy[i+1] + a[i]; // yy[i+1] is potentially already modified xx[i+1]\n    // }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s421", "entrypoint_scalar": "s421_scalar", "entrypoint_simd": "s421_simd"}
{"task_id": "tsvc_s1421", "prompt": "", "solution_scalar": "void s1421_scalar(float *b, const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Equivalence - no overlap (b[0..n/2-1] vs b[n/2..n-1])\n    float* xx = &b[n/2];\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        b[i] = xx[i] + a[i]; // Equivalent to b[i] = b[i + n/2] + a[i]\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1421", "entrypoint_scalar": "s1421_scalar", "entrypoint_simd": "s1421_simd"}
{"task_id": "tsvc_s422", "prompt": "", "solution_scalar": "void s422_scalar(float *flat_2d_array, const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Equivalence - anti-dependence\n    float* xx = flat_2d_array + 4; // xx points into flat_2d_array with offset\n    for (size_t i = 0; i < n; i++) {\n        // xx[i] = flat_2d_array[i + 8] + a[i];\n        // Equivalent to: flat_2d_array[i+4] = flat_2d_array[i + 8] + a[i];\n        if (i + 8 < n * n) { // Basic bounds check on flat_2d_array read\n           if (i + 4 < n * n) { // Basic bounds check on flat_2d_array write\n               flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\n           }\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s422", "entrypoint_scalar": "s422_scalar", "entrypoint_simd": "s422_simd"}
{"task_id": "tsvc_s423", "prompt": "", "solution_scalar": "void s423_scalar(float *flat_2d_array, const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Equivalence - anti-dependence\n    int vl = 64; // Offset\n    float* xx = flat_2d_array + vl;\n    for (size_t i = 0; i < n - 1; i++) {\n        // flat_2d_array[i+1] = xx[i] + a[i];\n        // Equivalent to: flat_2d_array[i+1] = flat_2d_array[i + vl] + a[i];\n        if (i + vl < n * n && i + 1 < n * n) { // Basic bounds check\n            flat_2d_array[i+1] = flat_2d_array[i + vl] + a[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s423", "entrypoint_scalar": "s423_scalar", "entrypoint_simd": "s423_simd"}
{"task_id": "tsvc_s424", "prompt": "", "solution_scalar": "void s424_scalar(float *flat_2d_array, const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Equivalence - true dependence, overlap\n    int vl = 63; // Offset\n    float* xx = flat_2d_array + vl;\n    for (size_t i = 0; i < n - 1; i++) {\n        // xx[i+1] = flat_2d_array[i] + a[i];\n        // Equivalent to: flat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i];\n         if (i < n * n && i + 1 + vl < n*n) { // Basic bounds check\n             flat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i];\n         }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s424", "entrypoint_scalar": "s424_scalar", "entrypoint_simd": "s424_simd"}
{"task_id": "tsvc_s431", "prompt": "", "solution_scalar": "void s431_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Parameter statement - equivalent to constant k=0\n    int k1 = 1;\n    int k2 = 2;\n    int k = 2 * k1 - k2; // k = 0\n    for (size_t i = 0; i < n; i++) {\n        // a[i] = a[i+k] + b[i]; -> a[i] = a[i] + b[i];\n        a[i] = a[i] + b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s431", "entrypoint_scalar": "s431_scalar", "entrypoint_simd": "s431_simd"}
{"task_id": "tsvc_s441", "prompt": "", "solution_scalar": "void s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Arithmetic if (3-way branch)\n    for (size_t i = 0; i < n; i++) {\n        if (d[i] < 0.0f) {\n            a[i] += b[i] * c[i];\n        } else if (d[i] == 0.0f) {\n            a[i] += b[i] * b[i];\n        } else { // d[i] > 0.0f\n            a[i] += c[i] * c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s441", "entrypoint_scalar": "s441_scalar", "entrypoint_simd": "s441_simd"}
{"task_id": "tsvc_s442", "prompt": "", "solution_scalar": "void s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int *indx, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Computed goto (switch statement)\n    for (size_t i = 0; i < n; i++) {\n        switch (indx[i]) {\n            case 1:\n                a[i] += b[i] * b[i];\n                break;\n            case 2:\n                a[i] += c[i] * c[i];\n                break;\n            case 3:\n                a[i] += d[i] * d[i];\n                break;\n            case 4:\n                a[i] += e[i] * e[i];\n                break;\n            default:\n                // Original code had no default, implies no action\n                break;\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s442", "entrypoint_scalar": "s442_scalar", "entrypoint_simd": "s442_simd"}
{"task_id": "tsvc_s443", "prompt": "", "solution_scalar": "void s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Arithmetic if translated to if/else\n    for (size_t i = 0; i < n; i++) {\n        if (d[i] <= 0.0f) {\n            // L20:\n            a[i] += b[i] * c[i];\n        } else {\n            // L30:\n            a[i] += b[i] * b[i];\n        }\n        // L50:\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s443", "entrypoint_scalar": "s443_scalar", "entrypoint_simd": "s443_simd"}
{"task_id": "tsvc_s451", "prompt": "", "solution_scalar": "#include <cmath> // For sinf, cosf\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Intrinsic functions\n    for (size_t i = 0; i < n; i++) {\n        a[i] = sinf(b[i]) + cosf(c[i]);\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s451", "entrypoint_scalar": "s451_scalar", "entrypoint_simd": "s451_simd"}
{"task_id": "tsvc_s452", "prompt": "", "solution_scalar": "void s452_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Seq function (using loop index in calculation)\n    for (size_t i = 0; i < n; i++) {\n        a[i] = b[i] + c[i] * (float)(i + 1);\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s452", "entrypoint_scalar": "s452_scalar", "entrypoint_simd": "s452_simd"}
{"task_id": "tsvc_s453", "prompt": "", "solution_scalar": "void s453_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Induction variable recognition\n    float s = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        s += 2.0f;\n        a[i] = s * b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s453", "entrypoint_scalar": "s453_scalar", "entrypoint_simd": "s453_simd"}
{"task_id": "tsvc_s471", "prompt": "", "solution_scalar": "// s471s() is empty, so calls are removed.\nvoid s471_scalar(float *x_out, const float *b, float *c_in_out, const float *d, const float *e, size_t n) {\n    // Assuming n corresponds to LEN_1D. Renamed x to x_out, c to c_in_out for clarity.\n    // Call statements (empty call removed)\n    for (size_t i = 0; i < n; i++) {\n        x_out[i] = b[i] + d[i] * d[i];\n        // s471s(); // Removed empty call\n        c_in_out[i] = c_in_out[i] + d[i] * e[i]; // Original used 'b', assuming typo based on context?\n                                            // Sticking to original: b[i] = c[i] + d[i] * e[i];\n        // Assuming 'b' is meant to be modified:\n        // b[i] = c_in_out[i] + d[i] * e[i]; \n        // Reverting to exact original logic affecting 'b':\n    }\n    // If the intent was to modify 'b' based on 'c', the signature needs change\n    // Let's assume the original TSVC structure where 'b' IS modified:\n}\n\nvoid s471_scalar_modifies_b(float *x_arr, float *b, const float *c, const float *d, const float *e, size_t n) {\n     for (size_t i = 0; i < n; i++) {\n        x_arr[i] = b[i] + d[i] * d[i];\n        b[i] = c[i] + d[i] * e[i]; // Modifies b\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s471", "entrypoint_scalar": "s471_scalar_modifies_b", "entrypoint_simd": "s471_simd"}
{"task_id": "tsvc_s481", "prompt": "", "solution_scalar": "#include <cstdlib> // For exit()\n// Return value indicates if exit was called (1) or loop completed (0)\nint s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Stop statement (exit)\n    for (size_t i = 0; i < n; i++) {\n        if (d[i] < 0.0f) {\n             // In a real scenario, might return an error code instead of exiting.\n             // For testing loop vectorization, the loop body is the focus.\n             // Let's comment out exit() for scalar reference loop.\n             // exit(0); \n             return 1; // Indicate early exit\n        }\n        a[i] += b[i] * c[i];\n    }\n    return 0; // Indicate normal completion\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s481", "entrypoint_scalar": "s481_scalar", "entrypoint_simd": "s481_simd"}
{"task_id": "tsvc_s482", "prompt": "", "solution_scalar": "void s482_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Loop exit (break)\n    for (size_t i = 0; i < n; i++) {\n        a[i] += b[i] * c[i];\n        if (c[i] > b[i]) {\n            break; // Exit loop early\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s482", "entrypoint_scalar": "s482_scalar", "entrypoint_simd": "s482_simd"}
{"task_id": "tsvc_s491", "prompt": "", "solution_scalar": "void s491_scalar(float *a, const float *b, const float *c, const float *d, const int *ip, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Indirect addressing on LHS (scatter)\n    for (size_t i = 0; i < n; i++) {\n        // Need bounds check for ip[i] if it can index out of 'a'\n        int index = ip[i];\n        if (index >= 0 && (size_t)index < n) { \n           a[index] = b[i] + c[i] * d[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s491", "entrypoint_scalar": "s491_scalar", "entrypoint_simd": "s491_simd"}
{"task_id": "tsvc_s4112", "prompt": "", "solution_scalar": "void s4112_scalar(float *a, const float *b, const int *ip, float s, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Indirect addressing on RHS (gather) - sparse saxpy\n    for (size_t i = 0; i < n; i++) {\n        // Need bounds check for ip[i] if it can index out of 'b'\n        int index = ip[i];\n        if (index >= 0 && (size_t)index < n) { \n            a[i] += b[index] * s;\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4112", "entrypoint_scalar": "s4112_scalar", "entrypoint_simd": "s4112_simd"}
{"task_id": "tsvc_s4113", "prompt": "", "solution_scalar": "void s4113_scalar(float *a, const float *b, const float *c, const int *ip, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Indirect addressing on LHS and RHS (gather/scatter)\n    for (size_t i = 0; i < n; i++) {\n        // Need bounds check for ip[i]\n        int index = ip[i];\n        if (index >= 0 && (size_t)index < n) {\n            a[index] = b[index] + c[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4113", "entrypoint_scalar": "s4113_scalar", "entrypoint_simd": "s4113_simd"}
{"task_id": "tsvc_s4114", "prompt": "", "solution_scalar": "void s4114_scalar(float *a, const float *b, const float *c, const float *d, const int *ip, size_t n, int n1) {\n    // Assuming n corresponds to LEN_1D\n    // Mix indirect addressing with variable bounds\n    int k;\n    for (int i = n1 - 1; i < (int)n; i++) {\n        if (i < 0) continue; // Skip if n1-1 is negative\n        // Bounds check needed for ip[i], k, and c[n-k+1-2]\n        int index_ip = ip[i];\n        if (index_ip < 0) continue; // Assuming indices are non-negative\n        k = index_ip;\n        size_t c_index = n - (size_t)k + 1 - 2; // Calculate index for c\n        if (c_index < n) { // Check bounds for c read\n            a[i] = b[i] + c[c_index] * d[i];\n        }\n        // k += 5; // Original code modifies k, but it's recalculated next iteration\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4114", "entrypoint_scalar": "s4114_scalar", "entrypoint_simd": "s4114_simd"}
{"task_id": "tsvc_s4115", "prompt": "", "solution_scalar": "float s4115_scalar(const float *a, const float *b, const int *ip, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Sparse dot product (gather required)\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        // Bounds check needed for ip[i]\n        int index = ip[i];\n        if (index >= 0 && (size_t)index < n) {\n            sum += a[i] * b[index];\n        }\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4115", "entrypoint_scalar": "s4115_scalar", "entrypoint_simd": "s4115_simd"}
{"task_id": "tsvc_s4116", "prompt": "", "solution_scalar": "// Assuming aa is a pointer to a flattened 2D array (row-major)\nfloat s4116_scalar(const float *a, const float* aa_flat, const int *ip, size_t n_1d, size_t n_2d, int j_idx, int inc) {\n    // Assuming n_1d=LEN_1D, n_2d=LEN_2D\n    // Complicated sparse dot product\n    float sum = 0.0f;\n    int off;\n    // Original loop limit was n_2d-1, seems like it should relate to ip size?\n    // Assuming loop runs up to n_1d based on 'a' access pattern and typical usage of ip\n    size_t loop_limit = (n_2d < n_1d) ? n_2d -1 : n_1d; // Heuristic limit\n    if (j_idx <= 0) return 0.0f; // Need j_idx-1 >= 0 for aa access\n    \n    for (size_t i = 0; i < loop_limit; i++) {\n        off = inc + (int)i;\n        // Bounds check for 'a', 'ip', and 'aa'\n        int index_ip = ip[i];\n        if (off >= 0 && (size_t)off < n_1d && index_ip >= 0 && (size_t)index_ip < n_2d) {\n             // Access aa[j_idx-1][ip[i]]\n             size_t aa_index = (size_t)(j_idx - 1) * n_2d + (size_t)index_ip;\n             sum += a[off] * aa_flat[aa_index];\n        }\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4116", "entrypoint_scalar": "s4116_scalar", "entrypoint_simd": "s4116_simd"}
{"task_id": "tsvc_s4117", "prompt": "", "solution_scalar": "void s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Seq function (integer division in index)\n    for (size_t i = 0; i < n; i++) {\n        // Bounds check for c[i/2]\n        size_t c_index = i / 2;\n        if (c_index < n) { // Assuming c has at least n elements\n            a[i] = b[i] + c[c_index] * d[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4117", "entrypoint_scalar": "s4117_scalar", "entrypoint_simd": "s4117_simd"}
{"task_id": "tsvc_s4121", "prompt": "", "solution_scalar": "// Helper function (could be inlined)\nfloat f_helper(float val_a, float val_b){\n    return val_a * val_b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Statement function (elementwise multiplication)\n    for (size_t i = 0; i < n; i++) {\n        a[i] += f_helper(b[i], c[i]);\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4121", "entrypoint_scalar": "s4121_scalar", "entrypoint_simd": "s4121_simd"}
{"task_id": "tsvc_va", "prompt": "", "solution_scalar": "void va_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector assignment (copy)\n    for (size_t i = 0; i < n; i++) {\n        a[i] = b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "va", "entrypoint_scalar": "va_scalar", "entrypoint_simd": "va_simd"}
{"task_id": "tsvc_vag", "prompt": "", "solution_scalar": "void vag_scalar(float *a, const float *b, const int *ip, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector assignment, gather\n    for (size_t i = 0; i < n; i++) {\n        // Bounds check needed for ip[i]\n        int index = ip[i];\n        if (index >= 0 && (size_t)index < n) {\n            a[i] = b[index];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vag", "entrypoint_scalar": "vag_scalar", "entrypoint_simd": "vag_simd"}
{"task_id": "tsvc_vas", "prompt": "", "solution_scalar": "void vas_scalar(float *a, const float *b, const int *ip, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector assignment, scatter\n    for (size_t i = 0; i < n; i++) {\n        // Bounds check needed for ip[i]\n        int index = ip[i];\n        if (index >= 0 && (size_t)index < n) {\n            a[index] = b[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vas", "entrypoint_scalar": "vas_scalar", "entrypoint_simd": "vas_simd"}
{"task_id": "tsvc_vif", "prompt": "", "solution_scalar": "void vif_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector if (conditional copy)\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] > 0.0f) {\n            a[i] = b[i];\n        }\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vif", "entrypoint_scalar": "vif_scalar", "entrypoint_simd": "vif_simd"}
{"task_id": "tsvc_vpv", "prompt": "", "solution_scalar": "void vpv_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector plus vector\n    for (size_t i = 0; i < n; i++) {\n        a[i] += b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpv", "entrypoint_scalar": "vpv_scalar", "entrypoint_simd": "vpv_simd"}
{"task_id": "tsvc_vtv", "prompt": "", "solution_scalar": "void vtv_scalar(float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector times vector\n    for (size_t i = 0; i < n; i++) {\n        a[i] *= b[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vtv", "entrypoint_scalar": "vtv_scalar", "entrypoint_simd": "vtv_simd"}
{"task_id": "tsvc_vpvtv", "prompt": "", "solution_scalar": "void vpvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector plus vector times vector (FMA)\n    for (size_t i = 0; i < n; i++) {\n        a[i] += b[i] * c[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvtv", "entrypoint_scalar": "vpvtv_scalar", "entrypoint_simd": "vpvtv_simd"}
{"task_id": "tsvc_vpvts", "prompt": "", "solution_scalar": "void vpvts_scalar(float *a, const float *b, float s, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector plus vector times scalar\n    for (size_t i = 0; i < n; i++) {\n        a[i] += b[i] * s;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvts", "entrypoint_scalar": "vpvts_scalar", "entrypoint_simd": "vpvts_simd"}
{"task_id": "tsvc_vpvpv", "prompt": "", "solution_scalar": "void vpvpv_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector plus vector plus vector\n    for (size_t i = 0; i < n; i++) {\n        a[i] += b[i] + c[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvpv", "entrypoint_scalar": "vpvpv_scalar", "entrypoint_simd": "vpvpv_simd"}
{"task_id": "tsvc_vtvtv", "prompt": "", "solution_scalar": "void vtvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector times vector times vector\n    for (size_t i = 0; i < n; i++) {\n        a[i] = a[i] * b[i] * c[i];\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vtvtv", "entrypoint_scalar": "vtvtv_scalar", "entrypoint_simd": "vtvtv_simd"}
{"task_id": "tsvc_vsumr", "prompt": "", "solution_scalar": "float vsumr_scalar(const float *a, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector sum reduction (identical to s311)\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    return sum;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vsumr", "entrypoint_scalar": "vsumr_scalar", "entrypoint_simd": "vsumr_simd"}
{"task_id": "tsvc_vdotr", "prompt": "", "solution_scalar": "float vdotr_scalar(const float *a, const float *b, size_t n) {\n    // Assuming n corresponds to LEN_1D\n    // Vector dot product reduction (identical to s313)\n    float dot = 0.0f;\n    for (size_t i = 0; i < n; i++) {\n        dot += a[i] * b[i];\n    }\n    return dot;\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vdotr", "entrypoint_scalar": "vdotr_scalar", "entrypoint_simd": "vdotr_simd"}
{"task_id": "tsvc_vbor", "prompt": "", "solution_scalar": "// Assuming x, a, b, c, d, e, aa are pointers to arrays/flattened arrays\n// n_2d likely corresponds to LEN_2D\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n    float a1, b1, c1, d1, e1, f1;\n    for (size_t i = 0; i < n_2d; i++) {\n        a1 = a[i];\n        b1 = b[i];\n        c1 = c[i];\n        d1 = d[i];\n        e1 = e[i];\n        // Assuming aa is accessed like aa[0][i]\n        f1 = aa_flat[0 * n_2d + i]; // Indexing into flattened aa\n        a1 = a1 * b1 * c1 + a1 * b1 * d1 + a1 * b1 * e1 + a1 * b1 * f1 +\n             a1 * c1 * d1 + a1 * c1 * e1 + a1 * c1 * f1 + a1 * d1 * e1\n             + a1 * d1 * f1 + a1 * e1 * f1;\n        b1 = b1 * c1 * d1 + b1 * c1 * e1 + b1 * c1 * f1 + b1 * d1 * e1 +\n             b1 * d1 * f1 + b1 * e1 * f1;\n        c1 = c1 * d1 * e1 + c1 * d1 * f1 + c1 * e1 * f1;\n        d1 = d1 * e1 * f1;\n        x[i] = a1 * b1 * c1 * d1;\n    }\n}", "test_correctness": "", "test_performance": "", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vbor", "entrypoint_scalar": "vbor_scalar", "entrypoint_simd": "vbor_simd"}
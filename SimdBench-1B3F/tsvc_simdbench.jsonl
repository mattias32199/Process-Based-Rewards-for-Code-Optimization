{"task_id": "tsvc_s000_AVX", "prompt": "/*This function takes a destination float array 'a', a source float array 'b', and their length 'n'.It performs the element-wise operation: a[i] = b[i] + 1.0f;Implement this using AVX intrinsics.*/#include <immintrin.h>void s000_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s000_scalar(float *a, const float *b, size_t n) {    for (size_t i = 0; i < n; i++) {        a[i] = b[i] + 1.0f;    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>// Assume Random.h and allclose.h are available in the include path#include \"Random.h\"#include \"allclose.h\"// Define constants from common.h#define LEN_1D 32000#define ITERATIONS 1 // For correctness, one iteration is enough#define ERROR_PRINT 1#define Small_Arg_1D LEN_1D// Forward declare functionsvoid s000_scalar(float *a, const float *b, size_t n);void s000_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    std::vector<float> b_input(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s000 from initialise_arrays()        for (size_t i = 0; i < length; ++i) {            b_input[i] = 2.0f + static_cast<float>(i);        }        // Initialize output arrays to a known-bad value        std::fill(a_scalar.begin(), a_scalar.end(), std::nanf(\"\"));        std::fill(a_simd.begin(), a_simd.end(), std::nanf(\"\"));        s000_scalar(a_scalar.data(), b_input.data(), length);        s000_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s000!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>// Assume Random.h is available#include \"Random.h\"// Define constants#define LEN_1D 32000#define DEFAULT_SEED 12345// Forward declare functionsvoid s000_scalar(float *a, const float *b, size_t n);void s000_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s000(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    // Ported Initialization Logic for s000    for (size_t i = 0; i < length; ++i) {         b_input[i] = 2.0f + static_cast<float>(i);    }    for (auto _ : state) {        Func(a_output.data(), b_input.data(), length);        benchmark::DoNotOptimize(a_output.data());    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s000, s000_scalar)->Name(\"Scalar_s000\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s000, s000_simd)->Name(\"SIMD_s000\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s000", "entrypoint_scalar": "s000_scalar", "entrypoint_simd": "s000_simd"}
{"task_id": "tsvc_s111_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs an element-wise operation with a stride of 2: a[i] = a[i - 1] + b[i];This loop has a read-after-write dependency that is broken by the stride.Implement this using AVX intrinsics.*/#include <immintrin.h>void s111_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s111_scalar(float *a, const float *b, size_t n) {    for (size_t i = 1; i < n; i += 2) {        a[i] = a[i - 1] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1D// Forward declare functionsvoid s111_scalar(float *a, const float *b, size_t n);void s111_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s111        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));        }        // Copy initial state for both runs        a_scalar = a_initial;        a_simd = a_initial;        s111_scalar(a_scalar.data(), b_input.data(), length);        s111_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s111!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345// Forward declare functionsvoid s111_scalar(float *a, const float *b, size_t n);void s111_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s111(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s111    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));    }    for (auto _ : state) {        // Reset 'a' to initial state for each run        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory(); // Ensure writes are committed    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // Approx 1 read (b), 1 read/write (a)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s111, s111_scalar)->Name(\"Scalar_s111\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s111, s111_simd)->Name(\"SIMD_s111\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s111", "entrypoint_scalar": "s111_scalar", "entrypoint_simd": "s111_simd"}
{"task_id": "tsvc_s1111_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.It performs a strided write: a[2*i] = c[i]*b[i] + d[i]*b[i] + c[i]*c[i] + d[i]*b[i] + d[i]*c[i];It loops 'n/2' times.Implement this using AVX intrinsics.*/#include <immintrin.h>void s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n) {}", "solution_scalar": "void s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {    size_t len_half = n / 2;    for (size_t i = 0; i < len_half; i++) {        a[2*i] = c[i] * b[i] + d[i] * b[i] + c[i] * c[i] + d[i] * b[i] + d[i] * c[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1D// Forward declare functionsvoid s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n);void s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s1111 (uses default init())        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f;            c_input[i] = 1.0f;            d_input[i] = 1.0f;        }        a_scalar = a_initial;        a_simd = a_initial;        s1111_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);        s1111_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1111!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345// Forward declare functionsvoid s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n);void s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n);template<void (*Func)(float *, const float *, const float *, const float *, size_t)>static void BM_s1111(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s1111 (uses default init())    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f;        c_input[i] = 1.0f;        d_input[i] = 1.0f;    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);                benchmark::ClobberMemory();    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length/2) * sizeof(float) * 4); // 3 reads, 1 write (approx)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s1111, s1111_scalar)->Name(\"Scalar_s1111\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s1111, s1111_simd)->Name(\"SIMD_s1111\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1111", "entrypoint_scalar": "s1111_scalar", "entrypoint_simd": "s1111_simd"}
{"task_id": "tsvc_s112_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs an operation in a reverse loop: a[i+1] = a[i] + b[i];This tests dependency analysis in a backwards loop.Implement this using AVX intrinsics.*/#include <immintrin.h>void s112_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s112_scalar(float *a, const float *b, size_t n) {    for (long long i = (long long)n - 2; i >= 0; --i) {        a[i+1] = a[i] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1D// Forward declare functionsvoid s112_scalar(float *a, const float *b, size_t n);void s112_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s112        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));        }        a_scalar = a_initial;        a_simd = a_initial;        s112_scalar(a_scalar.data(), b_input.data(), length);        s112_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s112!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345// Forward declare functionsvoid s112_scalar(float *a, const float *b, size_t n);void s112_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s112(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s112    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 3); // 1 read (b), 1 read/write (a)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s112, s112_scalar)->Name(\"Scalar_s112\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s112, s112_simd)->Name(\"SIMD_s112\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s112", "entrypoint_scalar": "s112_scalar", "entrypoint_simd": "s112_simd"}
{"task_id": "tsvc_s1112_AVX", "prompt": "/*This function takes a destination float array 'a', a source float array 'b', and their length 'n'.It performs an element-wise operation in a reverse loop: a[i] = b[i] + 1.0f;Implement this using AVX intrinsics.*/#include <immintrin.h>void s1112_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s1112_scalar(float *a, const float *b, size_t n) {    for (long long i = (long long)n - 1; i >= 0; --i) {        a[i] = b[i] + 1.0f;    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1D// Forward declare functionsvoid s1112_scalar(float *a, const float *b, size_t n);void s1112_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    std::vector<float> b_input(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s1112 (uses default init())        for (size_t i = 0; i < length; ++i) {            b_input[i] = 1.0f;        }        std::fill(a_scalar.begin(), a_scalar.end(), std::nanf(\"\"));        std::fill(a_simd.begin(), a_simd.end(), std::nanf(\"\"));        s1112_scalar(a_scalar.data(), b_input.data(), length);        s1112_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1112!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345// Forward declare functionsvoid s1112_scalar(float *a, const float *b, size_t n);void s1112_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s1112(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    // Ported Initialization Logic for s1112 (uses default init())    for (size_t i = 0; i < length; ++i) {         b_input[i] = 1.0f;    }    for (auto _ : state) {        Func(a_output.data(), b_input.data(), length);        benchmark::DoNotOptimize(a_output.data());    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s1112, s1112_scalar)->Name(\"Scalar_s1112\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s1112, s1112_simd)->Name(\"SIMD_s1112\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1112", "entrypoint_scalar": "s1112_scalar", "entrypoint_simd": "s1112_simd"}
{"task_id": "tsvc_s113_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs the operation: a[i] = a[0] + b[i];This tests dependency on a single broadcasted value (a[0]).Implement this using AVX intrinsics.*/#include <immintrin.h>void s113_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s113_scalar(float *a, const float *b, size_t n) {    float a0 = a[0];    for (size_t i = 1; i < n; i++) {        a[i] = a0 + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s113_scalar(float *a, const float *b, size_t n);void s113_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s113        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s113_scalar(a_scalar.data(), b_input.data(), length);        s113_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s113!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s113_scalar(float *a, const float *b, size_t n);void s113_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s113(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s113    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length - 1) * sizeof(float) * 2); // 1 read (b), 1 read/write (a)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s113, s113_scalar)->Name(\"Scalar_s113\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s113, s113_simd)->Name(\"SIMD_s113\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s113", "entrypoint_scalar": "s113_scalar", "entrypoint_simd": "s113_simd"}
{"task_id": "tsvc_s1113_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs the operation: a[i] = a[n/2] + b[i];This tests dependency on a single broadcasted value (a[n/2]).Implement this using AVX intrinsics.*/#include <immintrin.h>void s1113_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s1113_scalar(float *a, const float *b, size_t n) {    float a_mid = a[n/2];    for (size_t i = 0; i < n; i++) {        a[i] = a_mid + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s1113_scalar(float *a, const float *b, size_t n);void s1113_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s1113 (uses default init())        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f;        }        a_scalar = a_initial;        a_simd = a_initial;        s1113_scalar(a_scalar.data(), b_input.data(), length);        s1113_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1113!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s1113_scalar(float *a, const float *b, size_t n);void s1113_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s1113(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s1113 (uses default init())    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f;    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s1113, s1113_scalar)->Name(\"Scalar_s1113\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s1113, s1113_simd)->Name(\"SIMD_s1113\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1113", "entrypoint_scalar": "s1113_scalar", "entrypoint_simd": "s1113_simd"}
{"task_id": "tsvc_s114_AVX", "prompt": "/*This function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.It performs a triangular loop operation: aa[i][j] = aa[j][i] + bb[i][j]; for j < i.This tests complex dependencies (transpose vectorization).Implement this using AVX intrinsics.*/#include <immintrin.h>void s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {}", "solution_scalar": "void s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {    for (size_t i = 0; i < n_2d; i++) {        for (size_t j = 0; j < i; j++) {            aa_flat[i * n_2d + j] = aa_flat[j * n_2d + i] + bb_flat[i * n_2d + j];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);void s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> aa_initial(length);    std::vector<float> bb_input(length);    std::vector<float> aa_scalar(length);    std::vector<float> aa_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s114        for (size_t i = 0; i < length; ++i) {            aa_initial[i] = 1.0f / (float)(i+1); // frac            bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2t        }        aa_scalar = aa_initial;        aa_simd = aa_initial;        s114_scalar(aa_scalar.data(), bb_input.data(), n_2d);        s114_simd(aa_simd.data(), bb_input.data(), n_2d);        if (!allclose(aa_scalar, aa_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s114!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);void s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d);template<void (*Func)(float*, const float*, size_t)>static void BM_s114(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> aa_output(length);    std::vector<float> bb_input(length);    std::vector<float> aa_initial(length);    // Ported Initialization Logic for s114    for (size_t i = 0; i < length; ++i) {        aa_initial[i] = 1.0f / (float)(i+1); // frac        bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        aa_output = aa_initial;        benchmark::DoNotOptimize(aa_output.data());        benchmark::DoNotOptimize(bb_input.data());        Func(aa_output.data(), bb_input.data(), n_2d);                benchmark::ClobberMemory();    }    // Ops = (n_2d * (n_2d - 1) / 2) * (2 reads + 1 write)    size_t num_ops = (n_2d * (n_2d - 1)) / 2;    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s114, s114_scalar)->Name(\"Scalar_s114\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s114, s114_simd)->Name(\"SIMD_s114\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s114", "entrypoint_scalar": "s114_scalar", "entrypoint_simd": "s114_simd"}
{"task_id": "tsvc_s115_AVX", "prompt": "/*This function takes a 1D float array 'a' (size n_1d) and a flattened 2D float array 'aa' (size n_2d * n_2d).It performs a triangular saxpy loop: a[i] -= aa[j][i] * a[j];This tests complex dependencies.Implement this using AVX intrinsics.*/#include <immintrin.h>void s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d) {}", "solution_scalar": "void s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d) {    // n_2d = LEN_2D, n_1d = LEN_1D    for (size_t j = 0; j < n_2d; j++) {        float a_j = a[j];        for (size_t i = j + 1; i < n_2d; i++) {            a[i] -= aa_flat[j * n_2d + i] * a_j;        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2D#define Small_Arg_1D LEN_1Dvoid s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);void s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length_2d = n_2d * n_2d;    size_t length_1d = Small_Arg_1D;    std::vector<float> a_initial(length_1d);    std::vector<float> aa_input(length_2d);    std::vector<float> a_scalar(length_1d);    std::vector<float> a_simd(length_1d);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s115        float small_val = 0.000001f;        for (size_t i = 0; i < length_1d; ++i) {            a_initial[i] = 1.0f;        }        for (size_t i = 0; i < length_2d; ++i) {            aa_input[i] = small_val;        }        a_scalar = a_initial;        a_simd = a_initial;        s115_scalar(a_scalar.data(), aa_input.data(), n_2d, length_1d);        s115_simd(a_simd.data(), aa_input.data(), n_2d, length_1d);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s115!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define LEN_2D 256#define DEFAULT_SEED 12345void s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);void s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);template<void (*Func)(float*, const float*, size_t, size_t)>static void BM_s115(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length_2d = n_2d * n_2d;    size_t length_1d = LEN_1D;    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length_1d);    std::vector<float> aa_input(length_2d);    std::vector<float> a_initial(length_1d);    // Ported Initialization Logic for s115    float small_val = 0.000001f;    for (size_t i = 0; i < length_1d; ++i) {        a_initial[i] = 1.0f;    }    for (size_t i = 0; i < length_2d; ++i) {        aa_input[i] = small_val;    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(aa_input.data());        Func(a_output.data(), aa_input.data(), n_2d, length_1d);                benchmark::ClobberMemory();    }    // Ops = (n_2d * (n_2d - 1) / 2) * (1 read + 1 read/write)    size_t num_ops = (n_2d * (n_2d - 1)) / 2;    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s115, s115_scalar)->Name(\"Scalar_s115\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s115, s115_simd)->Name(\"SIMD_s115\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s115", "entrypoint_scalar": "s115_scalar", "entrypoint_simd": "s115_simd"}
{"task_id": "tsvc_s1115_AVX", "prompt": "/*This function takes three flattened 2D float arrays 'aa', 'bb', and 'cc' (row-major) of size n_2d * n_2d.It performs the operation: aa[i][j] = aa[i][j]*cc[j][i] + bb[i][j];This tests matrix multiplication with mixed indexing.Implement this using AVX intrinsics.*/#include <immintrin.h>void s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {}", "solution_scalar": "void s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {    for (size_t i = 0; i < n_2d; i++) {        for (size_t j = 0; j < n_2d; j++) {            size_t idx_ij = i * n_2d + j;            size_t idx_ji = j * n_2d + i;            aa_flat[idx_ij] = aa_flat[idx_ij] * cc_flat[idx_ji] + bb_flat[idx_ij];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);void s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> aa_initial(length);    std::vector<float> bb_input(length);  C   std::vector<float> cc_input(length);    std::vector<float> aa_scalar(length);    std::vector<float> aa_simd(length);    for (int iter = 0; iter < iterations; ++iter) {  g       // Ported Initialization Logic for s1115        float small_val = 0.000001f;        for (size_t i = 0; i < length; ++i) {ci            aa_initial[i] = small_val;            bb_input[i] = small_val;            cc_input[i] = small_val;        }        aa_scalar = aa_initial;        aa_simd = aa_initial;        s1115_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);        s1115_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);        if (!allclose(aa_scalar, aa_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1115!\" << std::endl;A            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);void s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);template<void (*Func)(float*, const float*, const float*, size_t)>static void BM_s1115(benchmark::State& state) {D   size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> aa_output(length);    std::vector<float> bb_input(length);    std::vector<float> cc_input(length);    std::vector<float> aa_initial(length);    // Ported Initialization Logic for s1115    float small_val = 0.000001f;    for (size_t i = 0; i < length; ++i) {        aa_initial[i] = small_val;        bb_input[i] = small_val;        cc_input[i] = small_val;    }    for (auto _ : state) {        aa_output = aa_initial;        benchmark::DoNotOptimize(aa_output.data());This is an executable test containing a number of loops to measure        benchmark::DoNotOptimize(bb_input.data());        benchmark::DoNotOptimize(cc_input.data());        Func(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);                benchmark::ClobberMemory();    }    // Ops = (n_2d * n_2d) * (1 read/write + 2 reads)A   state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 3);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s1115, s1115_scalar)->Name(\"Scalar_s1115\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s1115, s1115_simd)->Name(\"SIMD_s1115\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1115", "entrypoint_scalar": "s1115_scalar", "entrypoint_simd": "s1115_simd"}
{"task_id": "tsvc_s116_AVX", "prompt": "/*This function takes a float array 'a' and its length 'n'.It performs an unrolled loop with dependencies: a[i] = a[i+1] * a[i]; ... 5 times.This tests dependency analysis in unrolled loops.Implement this using AVX intrinsics.*/#include <immintrin.h>void s116_simd(float *a, size_t n) {}", "solution_scalar": "void s116_scalar(float *a, size_t n) {    for (size_t i = 0; i < n - 5; i += 5) {        a[i] = a[i + 1] * a[i];        a[i + 1] = a[i + 2] * a[i + 1];        a[i + 2] = a[i + 3] * a[i + 2];        a[i + 3] = a[i + 4] * a[i + 3];        a[i + 4] = a[i + 5] * a[i + 4];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s116_scalar(float *a, size_t n);void s116_simd(float *a, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s116        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;        }        a_scalar = a_initial;        a_simd = a_initial;        s116_scalar(a_scalar.data(), length);        s116_simd(a_simd.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s116!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s116_scalar(float *a, size_t n);void s116_simd(float *a, size_t n);template<void (*Func)(float *, size_t)>static void BM_s116(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s116    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        Func(a_output.data(), length);                benchmark::ClobberMemory();    }    // 5 ops per block (2 reads, 1 write) = 15 accesses. (length / 5) blocks.    size_t num_ops = (length - 5) / 5;    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * 15 * sizeof(float));}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s116, s116_scalar)->Name(\"Scalar_s116\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s116, s116_simd)->Name(\"SIMD_s116\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s116", "entrypoint_scalar": "s116_scalar", "entrypoint_simd": "s116_simd"}
{"task_id": "tsvc_s118_AVX", "prompt": "/*This function takes a 1D float array 'a' (size n_1d) and a flattened 2D float array 'bb' (size n_2d * n_2d).It performs a complex recursive operation: a[i] += bb[j][i] * a[i-j-1];This tests potential dot product recursion.Implement this using AVX intrinsics.*/#include <immintrin.h>void s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d) {}", "solution_scalar": "void s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d) {    // n_1d is LEN_1D, n_2d is LEN_2D    for (size_t i = 1; i < n_2d; i++) {        for (size_t j = 0; j <= i - 1; j++) {            a[i] += bb_flat[j * n_2d + i] * a[i-j-1];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2D#define Small_Arg_1D LEN_1Dvoid s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);void s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length_2d = n_2d * n_2d;    size_t length_1d = Small_Arg_1D;    std::vector<float> a_initial(length_1d);    std::vector<float> bb_input(length_2d);    std::vector<float> a_scalar(length_1d);    std::vector<float> a_simd(length_1d);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s118        float small_val = 0.000001f;        for (size_t i = 0; i < length_1d; ++i) {            a_initial[i] = 1.0f;        }        for (size_t i = 0; i < length_2d; ++i) {            bb_input[i] = small_val;        }        a_scalar = a_initial;        a_simd = a_initial;        s118_scalar(a_scalar.data(), bb_input.data(), n_2d, length_1d);        s118_simd(a_simd.data(), bb_input.data(), n_2d, length_1d);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s118!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define LEN_2D 256#define DEFAULT_SEED 12345void s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);void s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);template<void (*Func)(float*, const float*, size_t, size_t)>static void BM_s118(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length_2d = n_2d * n_2d;    size_t length_1d = LEN_1D;    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length_1d);    std::vector<float> bb_input(length_2d);    std::vector<float> a_initial(length_1d);    // Ported Initialization Logic for s118    float small_val = 0.000001f;    for (size_t i = 0; i < length_1d; ++i) {        a_initial[i] = 1.0f;    }    for (size_t i = 0; i < length_2d; ++i) {        bb_input[i] = small_val;    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(bb_input.data());        Func(a_output.data(), bb_input.data(), n_2d, length_1d);                benchmark::ClobberMemory();    }    // Ops = (n_2d * (n_2d - 1) / 2). Each op: 1 R/W(a), 1 R(bb), 1 R(a)    size_t num_ops = (n_2d * (n_2d - 1)) / 2;    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s118, s118_scalar)->Name(\"Scalar_s118\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s118, s118_simd)->Name(\"SIMD_s118\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s118", "entrypoint_scalar": "s118_scalar", "entrypoint_simd": "s118_simd"}
{"task_id": "tsvc_s119_AVX", "prompt": "/*This function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.It performs the operation: aa[i][j] = aa[i-1][j-1] + bb[i][j];This tests a dependency on a diagonal element.Implement this using AVX intrinsics.*/#include <immintrin.h>void s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {}", "solution_scalar": "void s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {    for (size_t i = 1; i < n_2d; i++) {        for (size_t j = 1; j < n_2d; j++) {            aa_flat[i * n_2d + j] = aa_flat[(i-1) * n_2d + (j-1)] + bb_flat[i * n_2d + j];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);void s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> aa_initial(length);    std::vector<float> bb_input(length);    std::vector<float> aa_scalar(length);    std::vector<float> aa_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s119        for (size_t i = 0; i < length; ++i) {            aa_initial[i] = 1.0f;            bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        aa_scalar = aa_initial;        aa_simd = aa_initial;        s119_scalar(aa_scalar.data(), bb_input.data(), n_2d);        s119_simd(aa_simd.data(), bb_input.data(), n_2d);        if (!allclose(aa_scalar, aa_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s119!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);void s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);template<void (*Func)(float*, const float*, size_t)>static void BM_s119(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> aa_output(length);    std::vector<float> bb_input(length);    std::vector<float> aa_initial(length);    // Ported Initialization Logic for s119    for (size_t i = 0; i < length; ++i) {        aa_initial[i] = 1.0f;        bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        aa_output = aa_initial;        benchmark::DoNotOptimize(aa_output.data());        benchmark::DoNotOptimize(bb_input.data());        Func(aa_output.data(), bb_input.data(), n_2d);                benchmark::ClobberMemory();    }    // Ops = (n_2d - 1) * (n_2d - 1). Each op: 1 W(aa), 2 R(aa, bb)    size_t num_ops = (n_2d - 1) * (n_2d - 1);    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s119, s119_scalar)->Name(\"Scalar_s119\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s119, s119_simd)->Name(\"SIMD_s119\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s119", "entrypoint_scalar": "s119_scalar", "entrypoint_simd": "s119_simd"}
{"task_id": "tsvc_s1119_AVX", "prompt": "/*This function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.It performs the operation: aa[i][j] = aa[i-1][j] + bb[i][j];This tests a dependency on the element directly above.Implement this using AVX intrinsics.*/#include <immintrin.h>void s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {}", "solution_scalar": "void s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {    for (size_t i = 1; i < n_2d; i++) {        for (size_t j = 0; j < n_2d; j++) {            aa_flat[i * n_2d + j] = aa_flat[(i-1) * n_2d + j] + bb_flat[i * n_2d + j];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);void s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> aa_initial(length);    std::vector<float> bb_input(length);    std::vector<float> aa_scalar(length);    std::vector<float> aa_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s1119        for (size_t i = 0; i < length; ++i) {            aa_initial[i] = 1.0f;            bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        aa_scalar = aa_initial;        aa_simd = aa_initial;        s1119_scalar(aa_scalar.data(), bb_input.data(), n_2d);        s1119_simd(aa_simd.data(), bb_input.data(), n_2d);        if (!allclose(aa_scalar, aa_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1119!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);void s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);template<void (*Func)(float*, const float*, size_t)>static void BM_s1119(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> aa_output(length);    std::vector<float> bb_input(length);    std::vector<float> aa_initial(length);    // Ported Initialization Logic for s1119    for (size_t i = 0; i < length; ++i) {        aa_initial[i] = 1.0f;        bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        aa_output = aa_initial;        benchmark::DoNotOptimize(aa_output.data());        benchmark::DoNotOptimize(bb_input.data());        Func(aa_output.data(), bb_input.data(), n_2d);                benchmark::ClobberMemory();    }    // Ops = (n_2d - 1) * n_2d. Each op: 1 W(aa), 2 R(aa, bb)    size_t num_ops = (n_2d - 1) * n_2d;    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s1119, s1119_scalar)->Name(\"Scalar_s1119\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s1119, s1119_simd)->Name(\"SIMD_s1119\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1119", "entrypoint_scalar": "s1119_scalar", "entrypoint_simd": "s1119_simd"}
{"task_id": "tsvc_s121_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs the operation: a[i] = a[i+1] + b[i];This tests a simple loop-carried dependency (a[i] depends on a[i+1]).Implement this using AVX intrinsics.*/#include <immintrin.h>void s121_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s121_scalar(float *a, const float *b, size_t n) {    int j;    for (size_t i = 0; i < n - 1; i++) {        j = i + 1;        a[i] = a[j] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s121_scalar(float *a, const float *b, size_t n);void s121_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s121        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s121_scalar(a_scalar.data(), b_input.data(), length);        s121_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s121!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s121_scalar(float *a, const float *b, size_t n);void s121_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s121(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s121    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }    // Ops = (length - 1). Each op: 1 W(a), 2 R(a, b)    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length - 1) * sizeof(float) * 3);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s121, s121_scalar)->Name(\"Scalar_s121\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s121, s121_simd)->Name(\"SIMD_s121\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s121", "entrypoint_scalar": "s121_scalar", "entrypoint_simd": "s121_simd"}
{"task_id": "tsvc_s122_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', length 'n', and two integers 'n1' and 'n3'.It performs a complex strided and indexed operation: a[i] += b[n - k];This tests induction variables and irregular access.Implement this using AVX intrinsics.*/#include <immintrin.h>void s122_simd(float *a, const float *b, size_t n, int n1, int n3) {}", "solution_scalar": "void s122_scalar(float *a, const float *b, size_t n, int n1, int n3) {    int j, k;    j = 1;    k = 0;    for (size_t i = (size_t)n1 - 1; i < n; i += n3) {        k += j;        a[i] += b[n - k];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s122_scalar(float *a, const float *b, size_t n, int n1, int n3);void s122_simd(float *a, const float *b, size_t n, int n1, int n3);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    int n1 = 1; // From tsvc.c main()    int n3 = 1; // From tsvc.c main()    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s122        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s122_scalar(a_scalar.data(), b_input.data(), length, n1, n3);        s122_simd(a_simd.data(), b_input.data(), length, n1, n3);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s122!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s122_scalar(float *a, const float *b, size_t n, int n1, int n3);void s122_simd(float *a, const float *b, size_t n, int n1, int n3);template<void (*Func)(float *, const float *, size_t, int, int)>static void BM_s122(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    int n1 = 1; // From tsvc.c main()    int n3 = 1; // From tsvc.c main()    // Ported Initialization Logic for s122    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length, n1, n3);                benchmark::ClobberMemory();    }    // Loop runs approx (length - n1) / n3 times. Each op: 1 R/W(a), 1 R(b)    size_t num_ops = (length - n1) / n3;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s122, s122_scalar)->Name(\"Scalar_s122\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s122, s122_simd)->Name(\"SIMD_s122\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s122", "entrypoint_scalar": "s122_scalar", "entrypoint_simd": "s122_simd"}
{"task_id": "tsvc_s123_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs a conditional write: a[j] = ... where 'j' is incremented conditionally.This tests conditional induction variables (a pack/compress pattern).Implement this using AVX intrinsics.*/#include <immintrin.h>void s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {    int j = -1;    for (size_t i = 0; i < (n / 2); i++) {        j++;        a[j] = b[i] + d[i] * e[i];        if (c[i] > 0.0f) {            j++;            a[j] = c[i] + d[i] * e[i];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);void s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s123        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 0.0f;            b_input[i] = 1.0f;            c_input[i] = 1.0f; // Original test data is all 1.0f, so 'if' is always true            d_input[i] = 1.0f / (float)(i+1); // frac            e_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        s123_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);        s123_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s123!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);void s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>static void BM_s123(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s123    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 0.0f;        b_input[i] = 1.0f;        c_input[i] = 1.0f; // Original test data is all 1.0f        d_input[i] = 1.0f / (float)(i+1);        e_input[i] = 1.0f / (float)(i+1);    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }    // Loop (n/2). Since c[i] is always true: 6 R (b,d,e,c,d,e), 2 W(a,a)    size_t num_ops = length / 2;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s123, s123_scalar)->Name(\"Scalar_s123\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s123, s123_simd)->Name(\"SIMD_s123\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s123", "entrypoint_scalar": "s123_scalar", "entrypoint_simd": "s123_simd"}
{"task_id": "tsvc_s124_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs a conditional write based on b[i]: a[j] = ... where 'j' is incremented in both paths.This tests induction variables in if-then-else.Implement this using AVX intrinsics.*/#include <immintrin.h>void s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {    int j = -1;    for (size_t i = 0; i < n; i++) {        if (b[i] > 0.0f) {            j++;            a[j] = b[i] + d[i] * e[i];        } else {            j++;            a[j] = c[i] + d[i] * e[i];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);void s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s124        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 0.0f;            b_input[i] = 1.0f; // Original test data is all 1.0f, so 'if' is always true            c_input[i] = 1.0f;            d_input[i] = 1.0f / (float)(i+1); // frac            e_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        s124_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);        s124_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s124!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);void s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>static void BM_s124(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s124    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 0.0f;        b_input[i] = 1.0f; // Original test data is all 1.0f        c_input[i] = 1.0f;        d_input[i] = 1.0f / (float)(i+1);        e_input[i] = 1.0f / (float)(i+1);    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }    // Loop (n). Each op: 4 R (b,c,d,e), 1 W(a). (Blend pattern)   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 5);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s124, s124_scalar)->Name(\"Scalar_s124\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s124, s124_simd)->Name(\"SIMD_s124\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s124", "entrypoint_scalar": "s124_scalar", "entrypoint_simd": "s124_simd"}
{"task_id": "tsvc_s125_AVX", "prompt": "/*This function flattens a 2D array operation into a 1D array 'flat_2d_array'.It takes 4 flattened 2D arrays and size n_2d.Operation: flat_2d_array[k] = aa[i][j] + bb[i][j] * cc[i][j];Implement this using AVX intrinsics.*/#include <immintrin.h>void s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {}", "solution_scalar": "void s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {    int k = -1;    for (size_t i = 0; i < n_2d; i++) {        for (size_t j = 0; j < n_2d; j++) {            k++;            size_t idx_ij = i * n_2d + j;            flat_2d_array[k] = aa_flat[idx_ij] + bb_flat[idx_ij] * cc_flat[idx_ij];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);void s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> flat_initial(length);    std::vector<float> aa_input(length);    std::vector<float> bb_input(length);    std::vector<float> cc_input(length);    std::vector<float> flat_scalar(length);    std::vector<float> flat_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s125        for (size_t i = 0; i < length; ++i) {            flat_initial[i] = 0.0f;            aa_input[i] = 1.0f;            bb_input[i] = 0.5f;            cc_input[i] = 2.0f;        }        flat_scalar = flat_initial;        flat_simd = flat_initial;        s125_scalar(flat_scalar.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);        s125_simd(flat_simd.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);        if (!allclose(flat_scalar, flat_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s125!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);void s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);template<void (*Func)(float*, const float*, const float*, const float*, size_t)>static void BM_s125(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> flat_output(length);    std::vector<float> aa_input(length);    std::vector<float> bb_input(length);    std::vector<float> cc_input(length);    std::vector<float> flat_initial(length);    // Ported Initialization Logic for s125    for (size_t i = 0; i < length; ++i) {        flat_initial[i] = 0.0f;        aa_input[i] = 1.0f;        bb_input[i] = 0.5f;        cc_input[i] = 2.0f;    }    for (auto _ : state) {        flat_output = flat_initial;        benchmark::DoNotOptimize(flat_output.data());        benchmark::DoNotOptimize(aa_input.data());        benchmark::DoNotOptimize(bb_input.data());        benchmark::DoNotOptimize(cc_input.data());        Func(flat_output.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);                benchmark::ClobberMemory();    }    // Loop (n_2d * n_2d). Each op: 3 R (aa,bb,cc), 1 W(flat)   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 4);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s125, s125_scalar)->Name(\"Scalar_s125\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s125, s125_simd)->Name(\"SIMD_s125\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s125", "entrypoint_scalar": "s125_scalar", "entrypoint_simd": "s125_simd"}
{"task_id": "tsvc_s126_AVX", "prompt": "/*This function takes three flattened 2D float arrays 'bb', 'flat_2d_array', 'cc' and size n_2d.It performs a complex recursive op: bb[j][i] = bb[j-1][i] + flat_2d_array[k-1] * cc[j][i];This tests induction variables and recurrence.Implement this using AVX intrinsics.*/#include <immintrin.h>void s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {}", "solution_scalar": "void s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {    int k = 1;    for (size_t i = 0; i < n_2d; i++) {        for (size_t j = 1; j < n_2d; j++) {            bb_flat[j * n_2d + i] = bb_flat[(j-1) * n_2d + i] + flat_2d_array[k-1] * cc_flat[j * n_2d + i];            ++k;        }        ++k;   	}}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);void s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> bb_initial(length);    std::vector<float> flat_input(length);    std::vector<float> cc_input(length);    std::vector<float> bb_scalar(length);    std::vector<float> bb_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s126        for (size_t i = 0; i < length; ++i) {            bb_initial[i] = 1.0f;            flat_input[i] = 1.0f / (float)(i+1); // frac            cc_input[i] = 1.0f / (float)(i+1); // frac        }        bb_scalar = bb_initial;        bb_simd = bb_initial;        s126_scalar(bb_scalar.data(), flat_input.data(), cc_input.data(), n_2d);        s126_simd(bb_simd.data(), flat_input.data(), cc_input.data(), n_2d);        if (!allclose(bb_scalar, bb_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s126!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);void s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);template<void (*Func)(float*, const float*, const float*, size_t)>static void BM_s126(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> bb_output(length);    std::vector<float> flat_input(length);    std::vector<float> cc_input(length);    std::vector<float> bb_initial(length);    // Ported Initialization Logic for s126    for (size_t i = 0; i < length; ++i) {        bb_initial[i] = 1.0f;   	    flat_input[i] = 1.0f / (float)(i+1); // frac        cc_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        bb_output = bb_initial;        benchmark::DoNotOptimize(bb_output.data());        benchmark::DoNotOptimize(flat_input.data());        benchmark::DoNotOptimize(cc_input.data());        Func(bb_output.data(), flat_input.data(), cc_input.data(), n_2d);                benchmark::ClobberMemory();    }    // Loop n_2d * (n_2d - 1). Each op: 3 R (bb, flat, cc), 1 W(bb)    size_t num_ops = n_2d * (n_2d - 1);   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s126, s126_scalar)->Name(\"Scalar_s126\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s126, s126_simd)->Name(\"SIMD_s126\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s126", "entrypoint_scalar": "s126_scalar", "entrypoint_simd": "s126_simd"}
{"task_id": "tsvc_s127_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs an operation with multiple increments to the index 'j': a[j++] = ...; a[j++] = ...;This tests induction variables with multiple increments.Implement this using AVX intrinsics.*/#include <immintrin.h>void s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {    int j = -1;    for (size_t i = 0; i < n / 2; i++) {        j++;        a[j] = b[i] + c[i] * d[i];        j++;        a[j] = b[i] + d[i] * e[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);void s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s127        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 0.0f;            b_input[i] = 1.0f;            c_input[i] = 1.0f / (float)(i+1); // frac            d_input[i] = 1.0f / (float)(i+1); // frac            e_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        s127_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);        s127_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s127!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);void s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>static void BM_s127(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s127    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 0.0f;        b_input[i] = 1.0f;        c_input[i] = 1.0f / (float)(i+1);        d_input[i] = 1.0f / (float)(i+1);        e_input[i] = 1.0f / (float)(i+1);    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }    // Loop (n/2). Each op: 5 R (b,c,d,b,e), 2 W(a,a) ->  size_t num_ops = length / 2;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s127, s127_scalar)->Name(\"Scalar_s127\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s127, s127_simd)->Name(\"SIMD_s127\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s127", "entrypoint_scalar": "s127_scalar", "entrypoint_simd": "s127_simd"}
{"task_id": "tsvc_s128_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.It performs a coupled induction variable update: a[i] = b[k] - d[i]; b[k] = a[i] + c[k];This tests dependency analysis in coupled loops.Implement this using AVX intrinsics.*/#include <immintrin.h>void s128_simd(float *a, float *b, const float *c, const float *d, size_t n) {}", "solution_scalar": "void s128_scalar(float *a, float *b, const float *c, const float *d, size_t n) {    int j = -1;    int k;    for (size_t i = 0; i < n / 2; i++) {        k = j + 1;        a[i] = b[k] - d[i];        j = k + 1;        b[k] = a[i] + c[k];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s128_scalar(float *a, float *b, const float *c, const float *d, size_t n);void s128_simd(float *a, float *b, const float *c, const float *d, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    std::vector<float> b_scalar(length);    std::vector<float> b_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s128        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 0.0f;            b_initial[i] = 2.0f;            c_input[i] = 1.0f;            d_input[i] = 1.0f;        }        a_scalar = a_initial;        a_simd = a_initial;        b_scalar = b_initial;        b_simd = b_initial;        s128_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);        s128_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);        // Must check both 'a' and 'b' arrays as they are both modified        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) { Team          if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s128!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s128_scalar(float *a, float *b, const float *c, const float *d, size_t n);void s128_simd(float *a, float *b, const float *c, const float *d, size_t n);template<void (*Func)(float *, float *, const float *, const float *, size_t)>static void BM_s128(benchmark::State& state) {   	size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_output(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    // Ported Initialization Logic for s128    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 0.0f;        b_initial[i] = 2.0f;        c_input[i] = 1.0f;        d_input[i] = 1.0f;   ci}    for (auto _ : state) {        a_output = a_initial;        b_output = b_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_output.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);               	benchmark::ClobberMemory();    }    // Loop (n/2). Each op: 4 R (b,d,a,c), 2 W (a,b)   	size_t num_ops = length / 2;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s128, s128_scalar)->Name(\"Scalar_s128\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s128, s128_simd)->Name(\"SIMD_s128\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s128", "entrypoint_scalar": "s128_scalar", "entrypoint_simd": "s128_simd"}
{"task_id": "tsvc_s131_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs the operation: a[i] = a[i + 1] + b[i]; (with m=1 hardcoded).This tests forward substitution dependency.Implement this using AVX intrinsics.*/#include <immintrin.h>void s131_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s131_scalar(float *a, const float *b, size_t n) {    int m  = 1;    for (size_t i = 0; i < n - 1; i++) {        a[i] = a[i + m] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s131_scalar(float *a, const float *b, size_t n);void s131_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s131        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s131_scalar(a_scalar.data(), b_input.data(), length);        s131_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s131!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s131_scalar(float *a, const float *b, size_t n);void s131_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s131(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s131    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s131, s131_scalar)->Name(\"Scalar_s131\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s131, s131_simd)->Name(\"SIMD_s131\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s131", "entrypoint_scalar": "s131_scalar", "entrypoint_simd": "s131_simd"}
{"task_id": "tsvc_s132_AVX", "prompt": "/*This function takes a flattened 2D float array 'aa' (row-major), 1D arrays 'b' and 'c', and the 2D dimension 'n_2d'.It performs the operation: aa[0][i] = aa[1][i-1] + b[i] * c[1]; (with j=0, k=1 hardcoded).Implement this using AVX intrinsics.*/#include <immintrin.h>void s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d) {}", "solution_scalar": "void s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d) {    // n_2d = LEN_2D, n_1d = LEN_1D    int m = 0;    int j = m;   // j = 0    int k = m+1; // k = 1    float c1 = c[1]; // Hoist c[1]    for (size_t i = 1; i < n_2d; i++) {        // aa[j][i] = aa[k][i-1] + b[i] * c[1];        aa_flat[j * n_2d + i] = aa_flat[k * n_2d + (i-1)] + b[i] * c1;    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2D#define Small_Arg_1D LEN_1Dvoid s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);void s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t n_1d = Small_Arg_1D;    size_t length_2d = n_2d * n_2d;    std::vector<float> aa_initial(length_2d);    std::vector<float> b_input(n_1d);    std::vector<float> c_input(n_1d);    std::vector<float> aa_scalar(length_2d);    std::vector<float> aa_simd(length_2d);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s132        for (size_t i = 0; i < length_2d; ++i) {            aa_initial[i] = 1.0f;        }        for (size_t i = 0; i < n_1d; ++i) {            b_input[i] = 1.0f / (float)(i+1); // frac            c_input[i] = 1.0f / (float)(i+1); // frac        }        aa_scalar = aa_initial;        aa_simd = aa_initial;        s132_scalar(aa_scalar.data(), b_input.data(), c_input.data(), n_2d, n_1d);        s132_simd(aa_simd.data(), b_input.data(), c_input.data(), n_2d, n_1d);        if (!allclose(aa_scalar, aa_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s132!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define LEN_2D 256#define DEFAULT_SEED 12345void s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);void s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);template<void (*Func)(float*, const float*, const float*, size_t, size_t)>static void BM_s132(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t n_1d = LEN_1D;    size_t length_2d = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> aa_output(length_2d);    std::vector<float> b_input(n_1d);    std::vector<float> c_input(n_1d);    std::vector<float> aa_initial(length_2d);    // Ported Initialization Logic for s132    for (size_t i = 0; i < length_2d; ++i) {        aa_initial[i] = 1.0f;    }    for (size_t i = 0; i < n_1d; ++i) {        b_input[i] = 1.0f / (float)(i+1); // frac        c_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        aa_output = aa_initial;        benchmark::DoNotOptimize(aa_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        Func(aa_output.data(), b_input.data(), c_input.data(), n_2d, n_1d);                benchmark::ClobberMemory();    }}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s132, s132_scalar)->Name(\"Scalar_s132\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s132, s132_simd)->Name(\"SIMD_s132\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s132", "entrypoint_scalar": "s132_scalar", "entrypoint_simd": "s132_simd"}
{"task_id": "tsvc_s141_AVX", "prompt": "/*This function takes a 1D float array 'flat_2d_array' and a flattened 2D float array 'bb' (row-major) of size n_2d * n_2d.It performs a complex non-linear operation, walking a row in a symmetric packed array.Implement this using AVX intrinsics.*/#include <immintrin.h>void s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d) {}", "solution_scalar": "void s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d) {    int k;    for (size_t i = 0; i < n_2d; i++) {        k = (i+1) * (i) / 2 + i;        for (size_t j = i; j < n_2d; j++) {            // flat_2d_array[k] += bb[j][i];            flat_2d_array[k] += bb_flat[j * n_2d + i];            k += j+1;        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_2D 256#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_2D LEN_2Dvoid s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d);void s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d);bool correctness_check(int iterations) {    Random rng;    size_t n_2d = Small_Arg_2D;    size_t length = n_2d * n_2d;    std::vector<float> flat_initial(length);    std::vector<float> bb_input(length);    std::vector<float> flat_scalar(length);    std::vector<float> flat_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s141        for (size_t i = 0; i < length; ++i) {            flat_initial[i] = 1.0f;            bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        flat_scalar = flat_initial;        flat_simd = flat_initial;        s141_scalar(flat_scalar.data(), bb_input.data(), n_2d);        s141_simd(flat_simd.data(), bb_input.data(), n_2d);        if (!allclose(flat_scalar, flat_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s141!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_2D 256#define DEFAULT_SEED 12345void s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d);void s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d);template<void (*Func)(float*, const float*, size_t)>static void BM_s141(benchmark::State& state) {    size_t n_2d = state.range(0);    size_t length = n_2d * n_2d;    Random rng(DEFAULT_SEED);    std::vector<float> flat_output(length);    std::vector<float> bb_input(length);    std::vector<float> flat_initial(length);    // Ported Initialization Logic for s141    for (size_t i = 0; i < length; ++i) {        flat_initial[i] = 1.0f;        bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        flat_output = flat_initial;        benchmark::DoNotOptimize(flat_output.data());        benchmark::DoNotOptimize(bb_input.data());        Func(flat_output.data(), bb_input.data(), n_2d);                benchmark::ClobberMemory();    }}#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)BENCHMARK_TEMPLATE(BM_s141, s141_scalar)->Name(\"Scalar_s141\")->Large_Args_2D;BENCHMARK_TEMPLATE(BM_s141, s141_simd)->Name(\"SIMD_s141\")->Large_Args_2D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s141", "entrypoint_scalar": "s141_scalar", "entrypoint_simd": "s141_simd"}
{"task_id": "tsvc_s151_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and their length 'n'.It performs the operation: a[i] = a[i + 1] + b[i]; (with m=1 hardcoded).This is an interprocedural test, but the core logic is what matters.Implement this using AVX intrinsics.*/#include <immintrin.h>void s151_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "// This scalar solution is the inlined logic of s151s(a, b, 1)void s151_scalar(float *a, const float *b, size_t n) {    int m = 1;    // Assuming n corresponds to LEN_1D    for (size_t i = 0; i < n - 1; i++) {        a[i] = a[i + m] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s151_scalar(float *a, const float *b, size_t n);void s151_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s151        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s151_scalar(a_scalar.data(), b_input.data(), length);        s151_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s151!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s151_scalar(float *a, const float *b, size_t n);void s151_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s151(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s151    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s151, s151_scalar)->Name(\"Scalar_s151\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s151, s151_simd)->Name(\"SIMD_s151\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s151", "entrypoint_scalar": "s151_scalar", "entrypoint_simd": "s151_simd"}
{"task_id": "tsvc_s152_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs two inlined operations: 1. b[i] = d[i] * e[i];2. a[i] += b[i] * c[i];Implement this using AVX intrinsics.*/#include <immintrin.h>void s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {    // Inlined logic from s152 and s152s    for (size_t i = 0; i < n; i++) {        b[i] = d[i] * e[i];        a[i] += b[i] * c[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);void s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length), a_simd(length);    std::vector<float> b_scalar(length), b_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s152        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_initial[i] = 0.0f;            c_input[i] = 1.0f / (float)(i+1); // frac            d_input[i] = 1.0f / (float)(i+1); // frac            e_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        b_scalar = b_initial;        b_simd = b_initial;        s152_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);        s152_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s152!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);void s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>static void BM_s152(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_output(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    // Ported Initialization Logic for s152    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_initial[i] = 0.0f;        c_input[i] = 1.0f / (float)(i+1); // frac        d_input[i] = 1.0f / (float)(i+1); // frac        e_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        a_output = a_initial;        b_output = b_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_output.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s152, s152_scalar)->Name(\"Scalar_s152\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s152, s152_simd)->Name(\"SIMD_s152\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s152", "entrypoint_scalar": "s152_scalar", "entrypoint_simd": "s152_simd"}
{"task_id": "tsvc_s161_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs a conditional operation based on b[i]:If b[i] < 0, it calculates: c[i+1] = a[i] + d[i] * d[i];Otherwise, it calculates: a[i] = c[i] + d[i] * e[i];Implement this using AVX intrinsics.*/#include <immintrin.h>void s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {    for (size_t i = 0; i < n - 1; ++i) {        if (b[i] < 0.0f) {            c[i+1] = a[i] + d[i] * d[i];        } else {            a[i] = c[i] + d[i] * e[i];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n);void s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_initial(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length), a_simd(length);    std::vector<float> c_scalar(length), c_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s161        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Alternating 1.0 and -1.0            c_initial[i] = 1.0f;            d_input[i] = 1.0f / (float)(i+1); // frac            e_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        c_scalar = c_initial;        c_simd = c_initial;        s161_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), e_input.data(), length);        s161_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s161!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n);void s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, const float *, float *, const float *, const float *, size_t)>static void BM_s161(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_output(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    std::vector<float> c_initial(length);    // Ported Initialization Logic for s161    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = (i % 2 == 0) ? 1.0f : -1.0f;        c_initial[i] = 1.0f;        d_input[i] = 1.0f / (float)(i+1); // frac        e_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        a_output = a_initial;        c_output = c_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_output.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_input.data(), c_output.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s161, s161_scalar)->Name(\"Scalar_s161\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s161, s161_simd)->Name(\"SIMD_s161\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s161", "entrypoint_scalar": "s161_scalar", "entrypoint_simd": "s161_simd"}
{"task_id": "tsvc_s1161_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs a conditional operation based on c[i]:If c[i] < 0, it calculates: b[i] = a[i] + d[i] * d[i];Otherwise, it calculates: a[i] = c[i] + d[i] * e[i];Implement this using AVX intrinsics.*/#include <immintrin.h>void s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {    for (size_t i = 0; i < n - 1; ++i) {        if (c[i] < 0.0f) {            b[i] = a[i] + d[i] * d[i];        } else {            a[i] = c[i] + d[i] * e[i];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);void s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length), a_simd(length);    std::vector<float> b_scalar(length), b_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s1161 (uses default init())        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_initial[i] = 1.0f;            c_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Mix for condition            d_input[i] = 1.0f;            e_input[i] = 1.0f;        }        a_scalar = a_initial;        a_simd = a_initial;        b_scalar = b_initial;        b_simd = b_initial;        s1161_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);        s1161_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1161!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);void s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>static void BM_s1161(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_output(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    // Ported Initialization Logic for s1161 (uses default init())    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_initial[i] = 1.0f;        c_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Mix for condition        d_input[i] = 1.0f;        e_input[i] = 1.0f;    }    for (auto _ : state) {        a_output = a_initial;        b_output = b_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_output.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s1161, s1161_scalar)->Name(\"Scalar_s1161\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s1161, s1161_simd)->Name(\"SIMD_s1161\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1161", "entrypoint_scalar": "s1161_scalar", "entrypoint_simd": "s1161_simd"}
{"task_id": "tsvc_s162_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', length 'n', and an integer 'k'.If k > 0, it performs the operation: a[i] = a[i + k] + b[i] * c[i];This tests conditional execution based on a scalar argument.Implement this using AVX intrinsics.*/#include <immintrin.h>void s162_simd(float *a, const float *b, const float *c, size_t n, int k) {}", "solution_scalar": "void s162_scalar(float *a, const float *b, const float *c, size_t n, int k) {    if (k > 0) {        for (size_t i = 0; i < n - 1; i++) {            a[i] = a[i + k] + b[i] * c[i];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s162_scalar(float *a, const float *b, const float *c, size_t n, int k);void s162_simd(float *a, const float *b, const float *c, size_t n, int k);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    int k = 1; // From tsvc.c main(), n1 is 1    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s162        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / (float)(i+1); // frac            c_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        s162_scalar(a_scalar.data(), b_input.data(), c_input.data(), length, k);        s162_simd(a_simd.data(), b_input.data(), c_input.data(), length, k);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s162!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s162_scalar(float *a, const float *b, const float *c, size_t n, int k);void s162_simd(float *a, const float *b, const float *c, size_t n, int k);template<void (*Func)(float *, const float *, const float *, size_t, int)>static void BM_s162(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> a_initial(length);    int k = 1; // From tsvc.c main(), n1 is 1    // Ported Initialization Logic for s162    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / (float)(i+1); // frac        c_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        Func(a_output.data(), b_input.data(), c_input.data(), length, k);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s162, s162_scalar)->Name(\"Scalar_s162\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s162, s162_simd)->Name(\"SIMD_s162\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s162", "entrypoint_scalar": "s162_scalar", "entrypoint_simd": "s162_simd"}
{"task_id": "tsvc_s171_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', length 'n', and an integer 'inc'.It performs a strided write operation: a[i * inc] += b[i];This tests symbolic dependence and strided access.Implement this using AVX intrinsics.*/#include <immintrin.h>void s171_simd(float *a, const float *b, size_t n, int inc) {}", "solution_scalar": "void s171_scalar(float *a, const float *b, size_t n, int inc) {    for (size_t i = 0; i < n; i++) {        a[i * inc] += b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s171_scalar(float *a, const float *b, size_t n, int inc);void s171_simd(float *a, const float *b, size_t n, int inc);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    int inc = 1; // From tsvc.c main(), n1 is 1    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s171        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s171_scalar(a_scalar.data(), b_input.data(), length, inc);        s171_simd(a_simd.data(), b_input.data(), length, inc);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s171!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s171_scalar(float *a, const float *b, size_t n, int inc);void s171_simd(float *a, const float *b, size_t n, int inc);template<void (*Func)(float *, const float *, size_t, int)>static void BM_s171(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    int inc = 1; // From tsvc.c main(), n1 is 1    // Ported Initialization Logic for s171    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length, inc);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s171, s171_scalar)->Name(\"Scalar_s171\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s171, s171_simd)->Name(\"SIMD_s171\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s171", "entrypoint_scalar": "s171_scalar", "entrypoint_simd": "s171_simd"}
{"task_id": "tsvc_s172_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', length 'n', and two integers 'n1' and 'n3'.It performs a strided operation: a[i] += b[i];The loop starts at n1-1 and increments by n3.Implement this using AVX intrinsics.*/#include <immintrin.h>void s172_simd(float *a, const float *b, size_t n, int n1, int n3) {}", "solution_scalar": "void s172_scalar(float *a, const float *b, size_t n, int n1, int n3) {    // n = LEN_1D    for (size_t i = n1 - 1; i < n; i += n3) {        a[i] += b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s172_scalar(float *a, const float *b, size_t n, int n1, int n3);void s172_simd(float *a, const float *b, size_t n, int n1, int n3);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    int n1 = 1; // From tsvc.c main()    int n3 = 1; // From tsvc.c main()    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s172        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s172_scalar(a_scalar.data(), b_input.data(), length, n1, n3);        s172_simd(a_simd.data(), b_input.data(), length, n1, n3);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s172!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s172_scalar(float *a, const float *b, size_t n, int n1, int n3);void s172_simd(float *a, const float *b, size_t n, int n1, int n3);template<void (*Func)(float *, const float *, size_t, int, int)>static void BM_s172(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    int n1 = 1; // From tsvc.c main()    int n3 = 1; // From tsvc.c main()    // Ported Initialization Logic for s172    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length, n1, n3);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s172, s172_scalar)->Name(\"Scalar_s172\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s172, s172_simd)->Name(\"SIMD_s172\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s172", "entrypoint_scalar": "s172_scalar", "entrypoint_simd": "s172_simd"}
{"task_id": "tsvc_s173_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', and length 'n'.It performs the operation: a[i+k] = a[i] + b[i]; where k = n/2.This tests expressions in loop bounds and subscripts.Implement this using AVX intrinsics.*/#include <immintrin.h>void s173_simd(float *a, const float *b, size_t n) {}", "solution_scalar": "void s173_scalar(float *a, const float *b, size_t n) {    // n = LEN_1D    int k = n / 2;    for (size_t i = 0; i < n / 2; i++) {        a[i+k] = a[i] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s173_scalar(float *a, const float *b, size_t n);void s173_simd(float *a, const float *b, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s173        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s173_scalar(a_scalar.data(), b_input.data(), length);        s173_simd(a_simd.data(), b_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s173!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s173_scalar(float *a, const float *b, size_t n);void s173_simd(float *a, const float *b, size_t n);template<void (*Func)(float *, const float *, size_t)>static void BM_s173(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s173    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s173, s173_scalar)->Name(\"Scalar_s173\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s173, s173_simd)->Name(\"SIMD_s173\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s173", "entrypoint_scalar": "s173_scalar", "entrypoint_simd": "s173_simd"}
{"task_id": "tsvc_s174_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', length 'n', and an integer 'M'.It performs the operation: a[i+M] = a[i] + b[i]; for i < M.This tests symbolic subscripts.Implement this using AVX intrinsics.*/#include <immintrin.h>void s174_simd(float *a, const float *b, size_t n, int M) {}", "solution_scalar": "void s174_scalar(float *a, const float *b, size_t n, int M) {    // n = LEN_1D. M = n/2 from main().    for (size_t i = 0; i < M; i++) {        a[i+M] = a[i] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s174_scalar(float *a, const float *b, size_t n, int M);void s174_simd(float *a, const float *b, size_t n, int M);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    int M = length / 2; // From tsvc.c main()    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s174        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s174_scalar(a_scalar.data(), b_input.data(), length, M);        s174_simd(a_simd.data(), b_input.data(), length, M);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s174!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s174_scalar(float *a, const float *b, size_t n, int M);void s174_simd(float *a, const float *b, size_t n, int M);template<void (*Func)(float *, const float *, size_t, int)>static void BM_s174(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    int M = length / 2; // From tsvc.c main()    // Ported Initialization Logic for s174    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length, M);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s174, s174_scalar)->Name(\"Scalar_s174\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s174, s174_simd)->Name(\"SIMD_s174\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s174", "entrypoint_scalar": "s174_scalar", "entrypoint_simd": "s174_simd"}
{"task_id": "tsvc_s175_AVX", "prompt": "/*This function takes a float array 'a', a const float array 'b', length 'n', and an integer 'inc'.It performs a strided operation: a[i] = a[i + inc] + b[i];This tests symbolic dependence.Implement this using AVX intrinsics.*/#include <immintrin.h>void s175_simd(float *a, const float *b, size_t n, int inc) {}", "solution_scalar": "void s175_scalar(float *a, const float *b, size_t n, int inc) {    // n = LEN_1D    for (size_t i = 0; i < n - inc; i += inc) {        a[i] = a[i + inc] + b[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s175_scalar(float *a, const float *b, size_t n, int inc);void s175_simd(float *a, const float *b, size_t n, int inc);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    int inc = 1; // From tsvc.c main(), n1 is 1    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s175        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2        }        a_scalar = a_initial;        a_simd = a_initial;        s175_scalar(a_scalar.data(), b_input.data(), length, inc);        s175_simd(a_simd.data(), b_input.data(), length, inc);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s175!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s175_scalar(float *a, const float *b, size_t n, int inc);void s175_simd(float *a, const float *b, size_t n, int inc);template<void (*Func)(float *, const float *, size_t, int)>static void BM_s175(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> a_initial(length);    int inc = 1; // From tsvc.c main(), n1 is 1    // Ported Initialization Logic for s175    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        Func(a_output.data(), b_input.data(), length, inc);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s175, s175_scalar)->Name(\"Scalar_s175\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s175, s175_simd)->Name(\"SIMD_s175\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s175", "entrypoint_scalar": "s175_scalar", "entrypoint_simd": "s175_simd"}
{"task_id": "tsvc_s176_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c' and length 'n'.It performs a 2D convolution operation: a[i] += b[i+m-j-1] * c[j]; where m = n/2.This tests a complex dependency pattern (convolution).Implement this using AVX intrinsics.*/#include <immintrin.h>void s176_simd(float *a, const float *b, const float *c, size_t n) {}", "solution_scalar": "void s176_scalar(float *a, const float *b, const float *c, size_t n) {    // n = LEN_1D    int m = n / 2;    for (size_t j = 0; j < (n / 2); j++) {        for (size_t i = 0; i < m; i++) {            a[i] += b[i+m-j-1] * c[j];        }    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s176_scalar(float *a, const float *b, const float *c, size_t n);void s176_simd(float *a, const float *b, const float *c, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> a_scalar(length);    std::vector<float> a_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s176        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_input[i] = 1.0f / (float)(i+1); // frac            c_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        s176_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);        s176_simd(a_simd.data(), b_input.data(), c_input.data(), length);        if (!allclose(a_scalar, a_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s176!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s176_scalar(float *a, const float *b, const float *c, size_t n);void s176_simd(float *a, const float *b, const float *c, size_t n);template<void (*Func)(float *, const float *, const float *, size_t)>static void BM_s176(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_input(length);    std::vector<float> c_input(length);    std::vector<float> a_initial(length);    // Ported Initialization Logic for s176    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_input[i] = 1.0f / (float)(i+1); // frac        c_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        a_output = a_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_input.data());        benchmark::DoNotOptimize(c_input.data());        Func(a_output.data(), b_input.data(), c_input.data(), length);                benchmark::ClobberMemory();    }}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s176, s176_scalar)->Name(\"Scalar_s176\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s176, s176_simd)->Name(\"SIMD_s176\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s176", "entrypoint_scalar": "s176_scalar", "entrypoint_simd": "s176_simd"}
{"task_id": "tsvc_s211_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.It performs a statement reordering task with dependencies:1. a[i] = b[i - 1] + c[i] * d[i];2. b[i] = b[i + 1] - e[i] * d[i];Implement this using AVX intrinsics.*/#include <immintrin.h>void s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {}", "solution_scalar": "void s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {    for (size_t i = 1; i < n - 1; i++) {        a[i] = b[i - 1] + c[i] * d[i];        b[i] = b[i + 1] - e[i] * d[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);void s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_scalar(length), a_simd(length);    std::vector<float> b_scalar(length), b_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s211        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 0.0f;            b_initial[i] = 1.0f;            c_input[i] = 1.0f / (float)(i+1); // frac            d_input[i] = 1.0f / (float)(i+1); // frac            e_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        b_scalar = b_initial;        b_simd = b_initial;        s211_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);        s211_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s211!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);void s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);template<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>static void BM_s211(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_output(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> e_input(length);    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    // Ported Initialization Logic for s211    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 0.0f;        b_initial[i] = 1.0f;        c_input[i] = 1.0f / (float)(i+1); // frac        d_input[i] = 1.0f / (float)(i+1); // frac        e_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        a_output = a_initial;        b_output = b_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_output.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        benchmark::DoNotOptimize(e_input.data());        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);                benchmark::ClobberMemory();    }    // Loop (n-2). Each op: 6R (b,c,d,b,e,d), 2W (a,b)    size_t num_ops = length - 2;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s211, s211_scalar)->Name(\"Scalar_s211\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s211, s211_simd)->Name(\"SIMD_s211\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s211", "entrypoint_scalar": "s211_scalar", "entrypoint_simd": "s211_simd"}
{"task_id": "tsvc_s212_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.It performs a task with dependency needing a temporary variable:1. a[i] *= c[i];2. b[i] += a[i + 1] * d[i];Implement this using AVX intrinsics.*/#include <immintrin.h>void s212_simd(float *a, float *b, const float *c, const float *d, size_t n) {}", "solution_scalar": "void s212_scalar(float *a, float *b, const float *c, const float *d, size_t n) {    for (size_t i = 0; i < n - 1; i++) {        a[i] *= c[i];        b[i] += a[i + 1] * d[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s212_scalar(float *a, float *b, const float *c, const float *d, size_t n);void s212_simd(float *a, float *b, const float *c, const float *d, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_scalar(length), a_simd(length);    std::vector<float> b_scalar(length), b_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s212        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f / (float)(i+1); // frac            b_initial[i] = 1.0f;            c_input[i] = 1.0f;            d_input[i] = 1.0f / (float)(i+1); // frac        }        a_scalar = a_initial;        a_simd = a_initial;        b_scalar = b_initial;        b_simd = b_initial;        s212_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);        s212_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s212!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s212_scalar(float *a, float *b, const float *c, const float *d, size_t n);void s212_simd(float *a, float *b, const float *c, const float *d, size_t n);template<void (*Func)(float *, float *, const float *, const float *, size_t)>static void BM_s212(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_output(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    // Ported Initialization Logic for s212    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f / (float)(i+1); // frac        b_initial[i] = 1.0f;        c_input[i] = 1.0f;        d_input[i] = 1.0f / (float)(i+1); // frac    }    for (auto _ : state) {        a_output = a_initial;        b_output = b_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_output.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);                benchmark::ClobberMemory();    }    // Loop (n-1). Each op: 5R (a,c,b,a,d), 2W (a,b)    size_t num_ops = length - 1;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s212, s212_scalar)->Name(\"Scalar_s212\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s212, s212_simd)->Name(\"SIMD_s212\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s212", "entrypoint_scalar": "s212_scalar", "entrypoint_simd": "s212_simd"}
{"task_id": "tsvc_s1213_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.It performs a dependency needing a temporary variable:1. a[i] = b[i-1] + c[i];2. b[i] = a[i+1] * d[i];Implement this using AVX intrinsics.*/#include <immintrin.h>void s1213_simd(float *a, float *b, const float *c, const float *d, size_t n) {}", "solution_scalar": "void s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n) {    for (size_t i = 1; i < n - 1; i++) {        a[i] = b[i-1] + c[i];        b[i] = a[i+1] * d[i];    }}", "test_correctness": "#include <vector>#include <numeric>#include <iostream>#include <cmath>#include \"Random.h\"#include \"allclose.h\"#define LEN_1D 32000#define ITERATIONS 1#define ERROR_PRINT 1#define Small_Arg_1D LEN_1Dvoid s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n);void s1213_simd(float *a, float *b, const float *c, const float *d, size_t n);bool correctness_check(int iterations) {    Random rng;    size_t length = Small_Arg_1D;    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_scalar(length), a_simd(length);    std::vector<float> b_scalar(length), b_simd(length);    for (int iter = 0; iter < iterations; ++iter) {        // Ported Initialization Logic for s1213 (uses default init())        for (size_t i = 0; i < length; ++i) {            a_initial[i] = 1.0f;            b_initial[i] = 1.0f;            c_input[i] = 1.0f;            d_input[i] = 1.0f;        }        a_scalar = a_initial;        a_simd = a_initial;        b_scalar = b_initial;        b_simd = b_initial;        s1213_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);        s1213_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1213!\" << std::endl;            return false;        }    }    return true;}int main() {    bool pass = correctness_check(ITERATIONS);    printf(\"{ \\\"correctness\\\": %s }\\", pass ? \"1\" : \"0\");    return !pass;}", "test_performance": "#include <vector>#include <numeric>#include <benchmark/benchmark.h>#include \"Random.h\"#define LEN_1D 32000#define DEFAULT_SEED 12345void s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n);void s1213_simd(float *a, float *b, const float *c, const float *d, size_t n);template<void (*Func)(float *, float *, const float *, const float *, size_t)>static void BM_s1213(benchmark::State& state) {    size_t length = state.range(0);    Random rng(DEFAULT_SEED);    std::vector<float> a_output(length);    std::vector<float> b_output(length);    std::vector<float> c_input(length);    std::vector<float> d_input(length);    std::vector<float> a_initial(length);    std::vector<float> b_initial(length);    // Ported Initialization Logic for s1213 (uses default init())    for (size_t i = 0; i < length; ++i) {        a_initial[i] = 1.0f;        b_initial[i] = 1.0f;        c_input[i] = 1.0f;        d_input[i] = 1.0f;    }    for (auto _ : state) {        a_output = a_initial;        b_output = b_initial;        benchmark::DoNotOptimize(a_output.data());        benchmark::DoNotOptimize(b_output.data());        benchmark::DoNotOptimize(c_input.data());        benchmark::DoNotOptimize(d_input.data());        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);                benchmark::ClobberMemory();    }    // Loop (n-2). Each op: 4R (b,c,a,d), 2W (a,b)    size_t num_ops = length - 2;   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);}#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)BENCHMARK_TEMPLATE(BM_s1213, s1213_scalar)->Name(\"Scalar_s1213\")->Large_Args_1D;BENCHMARK_TEMPLATE(BM_s1213, s1213_simd)->Name(\"SIMD_s1213\")->Large_Args_1D;BENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1213", "entrypoint_scalar": "s1213_scalar", "entrypoint_simd": "s1213_simd"}
{"task_id": "tsvc_s221_AVX", "prompt": "/*This function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.It performs a partially recursive operation (loop distribution):1. a[i] += c[i] * d[i];2. b[i] = b[i - 1] + a[i] + d[i];Implement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s221_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        a[i] += c[i] * d[i];\n        b[i] = b[i - 1] + a[i] + d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s221_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s221\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s221_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s221_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s221!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s221_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s221(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s221\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-1). Each op: 6R (a,c,d,b,a,d), 2W (a,b)\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s221, s221_scalar)->Name(\"Scalar_s221\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s221, s221_simd)->Name(\"SIMD_s221\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s221", "entrypoint_scalar": "s221_scalar", "entrypoint_simd": "s221_simd"}
//{"task_id": "tsvc_s1221_AVX", "prompt": "/*\nThis function takes float arrays 'a' and 'b' and length 'n'.\nIt performs a recurrence: b[i] = b[i - 4] + a[i];\nThis tests loop-carried dependencies with a fixed stride.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1221_simd(const float *a, float *b, size_t n) {\n}", "solution_scalar": "void s1221_scalar(const float *a, float *b, size_t n) {\n    for (size_t i = 4; i < n; i++) {\n        b[i] = b[i - 4] + a[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1221_scalar(const float *a, float *b, size_t n);\nvoid s1221_simd(const float *a, float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_input(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> b_scalar(length);\n    std::vector<float> b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1221 (uses default init())\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n       	}\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s1221_scalar(a_input.data(), b_scalar.data(), length);\n       	s1221_simd(a_input.data(), b_simd.data(), length);\n\n       	if (!allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1221!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1221_scalar(const float *a, float *b, size_t n);\nvoid s1221_simd(const float *a, float *b, size_t n);\n\ntemplate<void (*Func)(const float *, float *, size_t)>\nstatic void BM_s1221(benchmark::State& state) {\n -> 	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s1221 (uses default init())\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_output.data());\n\n       	Func(a_input.data(), b_output.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n -> 	// Loop (n-4). Each op: 2R (b,a), 1W (b)\n   	size_t num_ops = length - 4;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1221, s1221_scalar)->Name(\"Scalar_s1221\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1221, s1221_simd)->Name(\"SIMD_s1221\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1221", "entrypoint_scalar": "s1221_scalar", "entrypoint_simd": "s1221_simd"}
{"task_id": "tsvc_s222_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'e' and length 'n'.\nIt performs a partially recursive operation:\n1. a[i] += b[i] * c[i];\n2. e[i] = e[i - 1] * e[i - 1]; // Recurrence\n3. a[i] -= b[i] * c[i];\nImplement this using AVX intrinsics. The 'e' loop has a dependency.\n*/\n#include <immintrin.h>\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n) {\n}", "solution_scalar": "void s222_scalar(float *a, const float *b, const float *c, float *e, size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        a[i] += b[i] * c[i];\n        e[i] = e[i - 1] * e[i - 1];\n        a[i] -= b[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s222_scalar(float *a, const float *b, const float *c, float *e, size_t n);\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> e_initial(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> e_scalar(length), e_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s222\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            e_initial[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n       	a_simd = a_initial;\n       	e_scalar = e_initial;\n       	e_simd = e_initial;\n\n       	s222_scalar(a_scalar.data(), b_input.data(), c_input.data(), e_scalar.data(), length);\n       	s222_simd(a_simd.data(), b_input.data(), c_input.data(), e_simd.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(e_scalar, e_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s222!\" << std::endl;\n            return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s222_scalar(float *a, const float *b, const float *c, float *e, size_t n);\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, float *, size_t)>\nstatic void BM_s222(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> e_output(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> e_initial(length);\n\n   	// Ported Initialization Logic for s222\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f;\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	e_initial[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	e_output = e_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(e_output.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), e_output.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 2 R/W(a), 4 R(b,c,b,c), 1 R/W(e), 1 R(e). Total: 10 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s222, s222_scalar)->Name(\"Scalar_s222\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s222, s222_simd)->Name(\"SIMD_s222\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s222", "entrypoint_scalar": "s222_scalar", "entrypoint_simd": "s222_simd"}
{"task_id": "tsvc_s231_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a column-wise recurrence: aa[j][i] = aa[j - 1][i] + bb[j][i];\nThis tests dependencies in the inner loop with non-unit stride.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n   	for (size_t i = 0; i < n_2d; ++i) {\n       	for (size_t j = 1; j < n_2d; j++) {\n           	// aa[j][i] = aa[j-1][i] + bb[j][i]\n           	size_t idx_ji = j * n_2d + i;\n           	size_t idx_j_1_i = (j - 1) * n_2d + i;\n           	aa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> aa_scalar(length);\n   	std::vector<float> aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s231\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f;\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s231_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n       	s231_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s231!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s231(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s231\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f;\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n\n       	Func(aa_output.data(), bb_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop n_2d * (n_2d - 1). Each op: 2R (aa, bb), 1W (aa)\n   	size_t num_ops = n_2d * (n_2d - 1);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s231, s231_scalar)->Name(\"Scalar_s231\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s231, s231_simd)->Name(\"SIMD_s231\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s231", "entrypoint_scalar": "s231_scalar", "entrypoint_simd": "s231_simd"}
{"task_id": "tsvc_s232_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop with recurrence: aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i];\nThis tests recurrence in the inner loop.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n   	for (size_t j = 1; j < n_2d; j++) {\n       	for (size_t i = 1; i <= j; i++) {\n           	// aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i]\n           	size_t idx_ji = j * n_2d + i;\n           	size_t idx_j_i_1 = j * n_2d + (i - 1);\n           	float temp = aa_flat[idx_j_i_1];\n           	aa_flat[idx_ji] = temp * temp + bb_flat[idx_ji];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> aa_scalar(length);\n   	std::vector<float> aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s232\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s232_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n       	s232_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s232!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s232(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s232\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n\n       	Func(aa_output.data(), bb_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d * (n_2d - 1)) / 2. Each op: 3R (aa, aa, bb), 1W (aa)\n   	size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s232, s232_scalar)->Name(\"Scalar_s232\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s232, s232_simd)->Name(\"SIMD_s232\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s232", "entrypoint_scalar": "s232_scalar", "entrypoint_simd": "s232_simd"}
{"task_id": "tsvc_s1232_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop, column-wise: aa[i][j] = bb[i][j] + cc[i][j];\nThis tests non-unit stride (strided) memory access.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   	for (size_t j = 0; j < n_2d; j++) {\n       	for (size_t i = j; i < n_2d; i++) {\n           	// aa[i][j] = bb[i][j] + cc[i][j]\n           	size_t idx_ij = i * n_2d + j;\n           	aa_flat[idx_ij] = bb_flat[idx_ij] + cc_flat[idx_ij];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_scalar(length);\n   	std::vector<float> aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1232\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 0.0f;\n           	bb_input[i] = 1.0f / (float)(i+1); // frac\n           	cc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s1232_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       	s1232_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1232!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s1232(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s1232\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 0.0f;\n       	bb_input[i] = 1.0f / (float)(i+1); // frac\n       	cc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n       	benchmark::DoNotOptimize(cc_input.data());\n\n       	Func(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d * (n_2d + 1)) / 2. Each op: 2R (bb, cc), 1W (aa)\n   	size_t num_ops = (n_2d * (n_2d + 1)) / 2;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1232, s1232_scalar)->Name(\"Scalar_s1232\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1232, s1232_simd)->Name(\"SIMD_s1232\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1232", "entrypoint_scalar": "s1232_scalar", "entrypoint_simd": "s1232_simd"}
{"task_id": "tsvc_s233_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt contains two inner loops with different dependencies:\n1. aa[j][i] = aa[j-1][i] + cc[j][i]; (Column-wise recurrence)\n2. bb[j][i] = bb[j][i-1] + cc[j][i]; (Column-wise recurrence)\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n   	for (size_t i = 1; i < n_2d; i++) {\n       	for (size_t j = 1; j < n_2d; j++) {\n           	// aa[j][i] = aa[j-1][i] + cc[j][i]\n           	size_t idx_ji = j * n_2d + i;\n           	size_t idx_j_1_i = (j - 1) * n_2d + i;\n           	aa_flat[idx_ji] = aa_flat[idx_j_1_i] + cc_flat[idx_ji];\n       	}\n       	for (size_t j = 1; j < n_2d; j++) {\n           	// bb[j][i] = bb[j][i-1] + cc[j][i]  -- NOTE: TSVC source has bb[j][i-1], this is column-wise\n           	size_t idx_ji = j * n_2d + i;\n           	size_t idx_j_i_1 = j * n_2d + (i - 1);\n           	bb_flat[idx_ji] = bb_flat[idx_j_i_1] + cc_flat[idx_ji];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_initial(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_scalar(length), aa_simd(length);\n   	std::vector<float> bb_scalar(length), bb_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s233\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_initial[i] = 1.0f / (float)(i+1); // frac\n           	cc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n       	bb_scalar = bb_initial;\n       	bb_simd = bb_initial;\n\n       	s233_scalar(aa_scalar.data(), bb_scalar.data(), cc_input.data(), n_2d);\n       	s233_simd(aa_simd.data(), bb_simd.data(), cc_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd) || !allclose(bb_scalar, bb_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s233!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t)>\nstatic void BM_s233(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_output(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_initial(length);\n\n   	// Ported Initialization Logic for s233\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_initial[i] = 1.0f / (float)(i+1); // frac\n       	cc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	bb_output = bb_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_output.data());\n       	benchmark::DoNotOptimize(cc_input.data());\n\n       	Func(aa_output.data(), bb_output.data(), cc_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// (n_2d - 1) * (n_2d - 1) ops for each loop. Each op = 2R, 1W. Total = 6 accesses.\n   	size_t num_ops = (n_2d - 1) * (n_2d - 1);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s233, s233_scalar)->Name(\"Scalar_s233\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s233, s233_simd)->Name(\"SIMD_s233\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s233", "entrypoint_scalar": "s233_scalar", "entrypoint_simd": "s233_simd"}
{"task_id": "tsvc_s2233_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt contains two inner loops with different dependencies:\n1. aa[j][i] = aa[j-1][i] + cc[j][i]; (Column-wise recurrence)\n2. bb[i][j] = bb[i-1][j] + cc[i][j]; (Row-wise recurrence)\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n   	for (size_t i = 1; i < n_2d; i++) {\n       	for (size_t j = 1; j < n_2d; j++) {\n           	// aa[j][i] = aa[j-1][i] + cc[j][i]\n           	size_t idx_ji = j * n_2d + i;\n           	size_t idx_j_1_i = (j - 1) * n_2d + i;\n           	aa_flat[idx_ji] = aa_flat[idx_j_1_i] + cc_flat[idx_ji];\n       	}\n       	for (size_t j = 1; j < n_2d; j++) {\n           	// bb[i][j] = bb[i-1][j] + cc[i][j]\n           	size_t idx_ij = i * n_2d + j;\n           	size_t idx_i_1_j = (i - 1) * n_2d + j;\n           	bb_flat[idx_ij] = bb_flat[idx_i_1_j] + cc_flat[idx_ij];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_initial(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_scalar(length), aa_simd(length);\n   	std::vector<float> bb_scalar(length), bb_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2233 (same as s233)\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_initial[i] = 1.0f / (float)(i+1); // frac\n           	cc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n       	bb_scalar = bb_initial;\n       	bb_simd = bb_initial;\n\n       	s2233_scalar(aa_scalar.data(), bb_scalar.data(), cc_input.data(), n_2d);\n       	s2233_simd(aa_simd.data(), bb_simd.data(), cc_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd) || !allclose(bb_scalar, bb_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2233!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t)>\nstatic void BM_s2233(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_output(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_initial(length);\n\n   	// Ported Initialization Logic for s2233 (same as s233)\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_initial[i] = 1.0f / (float)(i+1); // frac\n       	cc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	bb_output = bb_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_output.data());\n       	benchmark::DoNotOptimize(cc_input.data());\n\n       	Func(aa_output.data(), bb_output.data(), cc_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// (n_2d - 1) * (n_2d - 1) ops for each loop. Each op = 2R, 1W. Total = 6 accesses.\n   	size_t num_ops = (n_2d - 1) * (n_2d - 1);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2233, s2233_scalar)->Name(\"Scalar_s2233\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2233, s2233_simd)->Name(\"SIMD_s2233\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2233", "entrypoint_scalar": "s2233_scalar", "entrypoint_simd": "s2233_simd"}
{"task_id": "tsvc_s235_AVX", "prompt": "/*\nThis function is imperfectly nested. It takes 1D arrays 'a', 'b', 'c' and 2D arrays 'aa', 'bb'.\n1. a[i] += b[i] * c[i];\n2. Inner loop: aa[j][i] = aa[j-1][i] + bb[j][i] * a[i];\nThis tests loop interchange on imperfectly nested loops.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   	// n_1d = LEN_1D, n_2d = LEN_2D\n   	for (size_t i = 0; i < n_2d; i++) {\n       	a[i] += b[i] * c[i];\n       	float a_i = a[i]; // Hoist for inner loop\n       	for (size_t j = 1; j < n_2d; j++) {\n           	// aa[j][i] = aa[j-1][i] + bb[j][i] * a_i\n           	size_t idx_ji = j * n_2d + i;\n           	size_t idx_j_1_i = (j - 1) * n_2d + i;\n           	aa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji] * a_i;\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_1d = Small_Arg_1D;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> b_input(length_1d);\n   	std::vector<float> c_input(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n   	std::vector<float> bb_input(length_2d);\n\n   	std::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   	std::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s235\n       	for(size_t i = 0; i < n_1d; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n       	}\n       	for(size_t i = 0; i < length_2d; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s235_scalar(a_scalar.data(), b_input.data(), c_input.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n       	s235_simd(a_simd.data(), b_input.data(), c_input.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s235!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, float*, const float*, size_t, size_t)>\nstatic void BM_s235(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t n_1d = LEN_1D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length_1d);\n   	std::vector<float> b_input(length_1d);\n   	std::vector<float> c_input(length_1d);\n   	std::vector<float> aa_output(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n\n   	// Ported Initialization Logic for s235\n   	for(size_t i = 0; i < n_1d; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n   	}\n   	for(size_t i = 0; i < length_2d; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n Z     	\n       	benchmark::ClobberMemory();\n   	}\n   	// Ops: n_2d * (3 accesses) + n_2d * (n_2d - 1) * (4 accesses)\n   	size_t outer_ops = n_2d;\n   	size_t inner_ops = n_2d * (n_2d - 1);\n   	int64_t bytes = (int64_t(outer_ops) * 3 + int64_t(inner_ops) * 4) * sizeof(float);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s235, s235_scalar)->Name(\"Scalar_s235\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s235, s235_simd)->Name(\"SIMD_s235\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s235", "entrypoint_scalar": "s235_scalar", "entrypoint_simd": "s235_simd"}
{"task_id": "tsvc_s241_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a node-splitting task with dependencies:\n1. a[i] = b[i] * c[i] * d[i];\n2. b[i] = a[i] * a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s241_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = b[i] * c[i] * d[i];\n        b[i] = a[i] * a[i + 1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s241_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s241\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s241_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n       	s241_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s241!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s241_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s241(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s241\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 5R (b,c,d,a[i+1],d), 1 R/W (a), 1W (b). Total: 8 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s241, s241_scalar)->Name(\"Scalar_s241\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s241, s241_simd)->Name(\"SIMD_s241\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s241", "entrypoint_scalar": "s241_scalar", "entrypoint_simd": "s241_simd"}
{"task_id": "tsvc_s242_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', length 'n', and two scalars 's1', 's2'.\nIt performs a recurrence: a[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n}", "solution_scalar": "void s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n   	for (size_t i = 1; i < n; ++i) {\n       	a[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	float s1 = 1.2f;\n   	float s2 = 2.1f;\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s242 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s242_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n       	s242_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s242!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t, float, float)>\nstatic void BM_s242(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n   	float s1 = 1.2f;\n   	float s2 = 2.1f;\n\n   	// Ported Initialization Logic for s242 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 4R (a[i-1], b, c, d), 1W (a[i]). Total: 5 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s242, s242_scalar)->Name(\"Scalar_s242\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s242, s242_simd)->Name(\"SIMD_s242\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s242", "entrypoint_scalar": "s242_scalar", "entrypoint_simd": "s242_simd"}
{"task_id": "tsvc_s243_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a node-splitting task with false dependencies:\n1. a[i] = b[i] + c[i] * d[i];\n2. b[i] = a[i] + d[i] * e[i];\n3. a[i] = b[i] + a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n - 1; i++) {\n       	a[i] = b[i] + c[i] * d[i];\n       	b[i] = a[i] + d[i] * e[i];\n       	a[i] = b[i] + a[i + 1] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s243 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s243_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s243_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s243!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s243(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s243 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 5R (b,c,d,e,a[i+1]), 2 R/W (a,b). Total: 9 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s243, s243_scalar)->Name(\"Scalar_s243\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s243, s243_simd)->Name(\"SIMD_s243\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s243", "entrypoint_scalar": "s243_scalar", "entrypoint_simd": "s243_simd"}
{"task_id": "tsvc_s244_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a node-splitting task with false dependencies:\n1. a[i] = b[i] + c[i] * d[i];\n2. b[i] = c[i] + b[i];\n3. a[i+1] = b[i] + a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s244_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n - 1; ++i) {\n       	a[i] = b[i] + c[i] * d[i];\n       	b[i] = c[i] + b[i];\n       	a[i + 1] = b[i] + a[i + 1] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s244_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s244 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s244_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n       	s244_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s244!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s244_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s244(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s244 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 2R (c,d), 2 R/W (a,b). Total: 8 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s244, s244_scalar)->Name(\"Scalar_s244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s244, s244_simd)->Name(\"SIMD_s244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s244", "entrypoint_scalar": "s244_scalar", "entrypoint_simd": "s244_simd"}
{"task_id": "tsvc_s1244_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a task with true and anti-dependencies:\n1. a[i] = b[i] + c[i] * c[i] + b[i]*b[i] + c[i];\n2. d[i] = a[i] + a[i+1];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n) {\n}", "solution_scalar": "void s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n) {\n   	for (size_t i = 0; i < n - 1; i++) {\n       	a[i] = b[i] + c[i] * c[i] + b[i] * b[i] + c[i];\n       	d[i] = a[i] + a[i + 1];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n);\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_initial(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> d_scalar(length), d_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1244 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	d_initial[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	d_scalar = d_initial;\n       	d_simd = d_initial;\n\n       	s1244_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_scalar.data(), length);\n       	s1244_simd(a_simd.data(), b_input.data(), c_input.data(), d_simd.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(d_scalar, d_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1244!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n);\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, float *, size_t)>\nstatic void BM_s1244(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_output(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> d_initial(length);\n\n   	// Ported Initialization Logic for s1244 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	d_initial[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	d_output = d_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_output.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_output.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 7R (b,c,c,b,c, a[i], a[i+1]), 2W (a,d). Total: 9 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1244, s1244_scalar)->Name(\"Scalar_s1244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1244, s1244_simd)->Name(\"SIMD_s1244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1244", "entrypoint_scalar": "s1244_scalar", "entrypoint_simd": "s1244_simd"}
{"task_id": "tsvc_s2244_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'e' and length 'n'.\nIt performs a node-splitting task:\n1. a[i+1] = b[i] + e[i];\n2. a[i] = b[i] + c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n) {\n}", "solution_scalar": "void s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n) {\n   	for (size_t i = 0; i < n - 1; i++) {\n       	a[i + 1] = b[i] + e[i];\n       	a[i] = b[i] + c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n);\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2244 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s2244_scalar(a_scalar.data(), b_input.data(), c_input.data(), e_input.data(), length);\n       	s2244_simd(a_simd.data(), b_input.data(), c_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2244!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n);\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s2244(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s2244 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 4R (b,e,b,c), 2W (a,a). Total: 6 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2244, s2244_scalar)->Name(\"Scalar_s2244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2244, s2244_simd)->Name(\"SIMD_s2244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2244", "entrypoint_scalar": "s2244_scalar", "entrypoint_simd": "s2244_simd"}
{"task_id": "tsvc_s251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a scalar expansion task:\n1. s = b[i] + c[i] * d[i];\n2. a[i] = s * s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	float s = b[i] + c[i] * d[i];\n       	a[i] = s * s;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s251\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s251_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	s251_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s251!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s251(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s251\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b,c,d), 1W (a). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s251, s251_scalar)->Name(\"Scalar_s251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s251, s251_simd)->Name(\"SIMD_s251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s251", "entrypoint_scalar": "s251_scalar", "entrypoint_simd": "s251_simd"}
{"task_id": "tsvc_s1251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task:\n1. s = b[i]+c[i];\n2. b[i] = a[i]+d[i];\n3. a[i] = s*e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	float s = b[i] + c[i];\n       	b[i] = a[i] + d[i];\n       	a[i] = s * e[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1251\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n           	c_input[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s1251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s1251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1251!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n s  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1251(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s1251\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 5R (b,c,a,d,e), 2W (b,a). Total: 7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1251, s1251_scalar)->Name(\"Scalar_s1251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1251, s1251_simd)->Name(\"SIMD_s1251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1251", "entrypoint_scalar": "s1251_scalar", "entrypoint_simd": "s1251_simd"}
{"task_id": "tsvc_s2251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task with a loop-carried dependency:\n1. a[i] = s*e[i];\n2. s = b[i]+c[i];\n3. b[i] = a[i]+d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	float s = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = s * e[i];\n       	s = b[i] + c[i];\n       	b[i] = a[i] + d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2251\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n           	c_input[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s2251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s2251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2251!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s2251(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s2251\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 5R (e,b,c,a,d), 2W (a,b). Total: 7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2251, s2251_scalar)->Name(\"Scalar_s2251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2251, s2251_simd)->Name(\"SIMD_s2251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2251", "entrypoint_scalar": "s2251_scalar", "entrypoint_simd": "s2251_simd"}
{"task_id": "tsvc_s3251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task with dependencies:\n1. a[i+1] = b[i]+c[i];\n2. b[i] = c[i]*e[i];\n3. d[i] = a[i]*e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n - 1; i++) {\n       	a[i + 1] = b[i] + c[i];\n       	b[i] = c[i] * e[i];\n       	d[i] = a[i] * e[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n);\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_initial(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n   	std::vector<float> d_scalar(length), d_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s3251 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	d_initial[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n       	d_scalar = d_initial;\n       	d_simd = d_initial;\n\n       	s3251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_scalar.data(), e_input.data(), length);\n       	s3251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_simd.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(d_scalar, d_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3251!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n);\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, float *, const float *, size_t)>\nstatic void BM_s3251(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_output(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> d_initial(length);\n\n   	// Ported Initialization Logic for s3251 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	d_initial[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	d_output = d_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_output.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_output.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 6R (b,c,c,e,a,e), 3W (a,b,d). Total: 9 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3251, s3251_scalar)->Name(\"Scalar_s3251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3251, s3251_simd)->Name(\"SIMD_s3251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3251", "entrypoint_scalar": "s3251_scalar", "entrypoint_simd": "s3251_simd"}
{"task_id": "tsvc_s252_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a scalar expansion with a loop-carried dependency:\n1. s = b[i] * c[i];\n2. a[i] = s + t; (where t = s from previous iteration)\n3. t = s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s252_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s252_scalar(float *a, const float *b, const float *c, size_t n) {\n   	float t = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	float s = b[i] * c[i];\n       	a[i] = s + t;\n       	t = s;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s252_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s252_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s252 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s252_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s252_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s252!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s252_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s252_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s252(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s252 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s252, s252_scalar)->Name(\"Scalar_s252\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s252, s252_simd)->Name(\"SIMD_s252\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s252", "entrypoint_scalar": "s252_scalar", "entrypoint_simd": "s252_simd"}
{"task_id": "tsvc_s253_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a conditional scalar expansion and update:\nif (a[i] > b[i]) { s = a[i] - b[i] * d[i]; c[i] += s; a[i] = s; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s253_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > b[i]) {\n           	float s = a[i] - b[i] * d[i];\n           	c[i] += s;\n           	a[i] = s;\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s253_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s253\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s253_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), length);\n       	s253_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s253!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s253_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, size_t)>\nstatic void BM_s253(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s253\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_output.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 4R (a,b,c,d), 2W (c,a). Total: 6 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s253, s253_scalar)->Name(\"Scalar_s253\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s253, s253_simd)->Name(\"SIMD_s253\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s253", "entrypoint_scalar": "s253_scalar", "entrypoint_simd": "s253_simd"}
{"task_id": "tsvc_s254_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a scalar expansion with a carry-around variable:\na[i] = (b[i] + x) * 0.5f; (where x = b[i-1])\nx = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s254_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s254_scalar(float *a, const float *b, size_t n) {\n   	float x = b[n - 1];\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = (b[i] + x) * 0.5f;\n       	x = b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s254_scalar(float *a, const float *b, size_t n);\nvoid s254_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s254\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s254_scalar(a_scalar.data(), b_input.data(), length);\n       	s254_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s254!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s254_scalar(float *a, const float *b, size_t n);\nvoid s254_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s254(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s254\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (b[i], x=b[i-1]), 1W (a). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s254, s254_scalar)->Name(\"Scalar_s254\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s254, s254_simd)->Name(\"SIMD_s254\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s254", "entrypoint_scalar": "s254_scalar", "entrypoint_simd": "s254_simd"}
{"task_id": "tsvc_s255_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a scalar expansion with 2-level carry-around variables:\na[i] = (b[i] + x + y) * 0.333f; (where x=b[i-1], y=b[i-2])\ny = x; x = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s255_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s255_scalar(float *a, const float *b, size_t n) {\n   	float x = b[n - 1];\n   	float y = b[n - 2];\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = (b[i] + x + y) * 0.333f;\n       	y = x;\n       	x = b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s255_scalar(float *a, const float *b, size_t n);\nvoid s255_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s255\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s255_scalar(a_scalar.data(), b_input.data(), length);\n       	s255_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s255!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s255_scalar(float *a, const float *b, size_t n);\nvoid s255_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s255(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s255\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b[i], x=b[i-1], y=b[i-2]), 1W (a). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s255, s255_scalar)->Name(\"Scalar_s255\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s255, s255_simd)->Name(\"SIMD_s255\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s255", "entrypoint_scalar": "s255_scalar", "entrypoint_simd": "s255_simd"}
{"task_id": "tsvc_s256_AVX", "prompt": "/*\nThis function tests array expansion. It takes 1D arrays 'a', 'd' and 2D arrays 'aa', 'bb'.\nInner loop: \n1. a[j] = 1.0f - a[j - 1];\n2. aa[j][i] = a[j] + bb[j][i] * d[j];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   	// n_1d = LEN_1D, n_2d = LEN_2D\n   	for (size_t i = 0; i < n_2d; i++) {\n       	for (size_t j = 1; j < n_2d; j++) {\n           	a[j] = 1.0f - a[j - 1];\n           	// aa[j][i] = a[j] + bb[j][i]*d[j]\n           	aa_flat[j * n_2d + i] = a[j] + bb_flat[j * n_2d + i] * d[j];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_1d = Small_Arg_1D;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> d_input(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   	std::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s256\n       	for (size_t i = 0; i < length_1d; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	for (size_t i = 0; i < length_2d; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s256_scalar(a_scalar.data(), d_input.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n       	s256_simd(a_simd.data(), d_input.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s256!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float *, const float *, float*, const float*, size_t, size_t)>\nstatic void BM_s256(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t n_1d = LEN_1D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length_1d);\n   	std::vector<float> d_input(length_1d);\n   	std::vector<float> aa_output(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n\n   	// Ported Initialization Logic for s256\n   	for (size_t i = 0; i < length_1d; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	for (size_t i = 0; i < length_2d; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n\n       	Func(a_output.data(), d_input.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop n_2d * (n_2d - 1). Ops: 1R/W(a), 1R(a[j-1]), 2R(bb,d), 1W(aa). Total: 5 accesses.\n   	size_t num_ops = n_2d * (n_2d - 1);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s256, s256_scalar)->Name(\"Scalar_s256\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s256, s256_simd)->Name(\"SIMD_s256\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s256", "entrypoint_scalar": "s256_scalar", "entrypoint_simd": "s256_simd"}
{"task_id": "tsvc_s257_AVX", "prompt": "/*\nThis function tests array expansion. It takes 1D array 'a' and 2D arrays 'aa', 'bb'.\nInner loop: \n1. a[i] = aa[j][i] - a[i-1];\n2. aa[j][i] = a[i] + bb[j][i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   	// n_1d = LEN_1D, n_2d = LEN_2D\n   	for (size_t i = 1; i < n_2d; i++) {\n       	for (size_t j = 0; j < n_2d; j++) {\n           	// a[i] = aa[j][i] - a[i-1]\n           	a[i] = aa_flat[j * n_2d + i] - a[i - 1];\n           	// aa[j][i] = a[i] + bb[j][i]\n           	aa_flat[j * n_2d + i] = a[i] + bb_flat[j * n_2d + i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_1d = Small_Arg_1D;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   	std::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s257\n       	for (size_t i = 0; i < length_1d; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	for (size_t i = 0; i < length_2d; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s257_scalar(a_scalar.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n g     	s257_simd(a_simd.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s257!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t, size_t)>\nstatic void BM_s257(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t n_1d = LEN_1D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length_1d);\n   	std::vector<float> aa_output(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n\n   	// Ported Initialization Logic for s257\n   	for (size_t i = 0; i < length_1d; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	for (size_t i = 0; i < length_2d; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n\n       	Func(a_output.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d - 1) * n_2d. Ops: 1R/W(aa), 1R(a[i-1]), 1R(bb), 1R/W(a). Total: 5 accesses.\n   	size_t num_ops = (n_2d - 1) * n_2d;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s257, s257_scalar)->Name(\"Scalar_s257\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s257, s257_simd)->Name(\"SIMD_s257\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s257", "entrypoint_scalar": "s257_scalar", "entrypoint_simd": "s257_simd"}
{"task_id": "tsvc_s258_AVX", "prompt": "/*\nThis function tests a wrap-around scalar dependency under an if.\nScalar 's' is updated conditionally and used in subsequent iterations.\n1. if (a[i] > 0.) { s = d[i] * d[i]; }\n2. b[i] = s * c[i] + d[i];\n3. e[i] = (s + 1.0f) * aa[0][i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d) {\n   	// n_1d = LEN_1D, n_2d = LEN_2D. Loop is to n_2d\n   	float s = 0.0f;\n   	for (size_t i = 0; i < n_2d; ++i) {\n       	if (a[i] > 0.0f) {\n           	s = d[i] * d[i];\n       	}\n       	b[i] = s * c[i] + d[i];\n       	e[i] = (s + 1.0f) * aa_flat[0 * n_2d + i]; // aa[0][i]\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_1d = Small_Arg_1D;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n\n   	std::vector<float> a_input(length_1d);\n   	std::vector<float> b_initial(length_1d);\n   	std::vector<float> c_input(length_1d);\n   	std::vector<float> d_input(length_1d);\n   	std::vector<float> e_initial(length_1d);\n   	std::vector<float> aa_input(length_2d);\n   	std::vector<float> b_scalar(length_1d), b_simd(length_1d);\n   	std::vector<float> e_scalar(length_1d), e_simd(length_1d);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s258\n       	for (size_t i = 0; i < length_1d; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_initial[i] = 1.0f;\n       	}\n       	for (size_t i = 0; i < length_2d; ++i) {\n           	aa_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n       	e_scalar = e_initial;\n       	e_simd = e_initial;\n\n       	s258_scalar(a_input.data(), b_scalar.data(), c_input.data(), d_input.data(), e_scalar.data(), aa_input.data(), n_2d, n_1d);\n       	s258_simd(a_input.data(), b_simd.data(), c_input.data(), d_input.data(), e_simd.data(), aa_input.data(), n_2d, n_1d);\n\n       	if (!allclose(b_scalar, b_simd) || !allclose(e_scalar, e_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s258!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n T  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(const float *, float *, const float *, const float *, float *, const float*, size_t, size_t)>\nstatic void BM_s258(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t n_1d = LEN_1D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length_1d);\n   	std::vector<float> b_output(length_1d);\n   	std::vector<float> c_input(length_1d);\n   	std::vector<float> d_input(length_1d);\n   	std::vector<float> e_output(length_1d);\n   	std::vector<float> aa_input(length_2d);\n   	std::vector<float> b_initial(length_1d);\n   	std::vector<float> e_initial(length_1d);\n\n   	// Ported Initialization Logic for s258\n   	for (size_t i = 0; i < length_1d; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_initial[i] = 1.0f;\n   	}\n   	for (size_t i = 0; i < length_2d; ++i) {\n       	aa_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	b_output = b_initial;\n       	e_output = e_initial;\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_output.data());\n       	benchmark::DoNotOptimize(aa_input.data());\n\n       	Func(a_input.data(), b_output.data(), c_input.data(), d_input.data(), e_output.data(), aa_input.data(), n_2d, n_1d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d). Ops: 5R (a, d, c, d, aa), 2W (b, e). Total: 7 accesses.\n   	size_t num_ops = n_2d;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s258, s258_scalar)->Name(\"Scalar_s258\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s258, s258_simd)->Name(\"SIMD_s258\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s258", "entrypoint_scalar": "s258_scalar", "entrypoint_simd": "s258_simd"}
{"task_id": "tsvc_s261_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt tests scalar variable reuse:\n1. t = a[i] + b[i];\n2. a[i] = t + c[i-1];\n3. t = c[i] * d[i];\n4. c[i] = t;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s261_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n   	for (size_t i = 1; i < n; ++i) {\n       	float t = a[i] + b[i];\n       	a[i] = t + c[i - 1];\n       	t = c[i] * d[i];\n       	c[i] = t;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s261_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s261\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s261_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), length);\n       	s261_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s261!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s261_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, size_t)>\nstatic void BM_s261(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s261\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_output.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 3R (b,c[i-1],d), 2 R/W (a,c). Total: 7 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s261, s261_scalar)->Name(\"Scalar_s261\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s261, s261_simd)->Name(\"SIMD_s261\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s261", "entrypoint_scalar": "s261_scalar", "entrypoint_simd": "s261_simd"}
{"task_id": "tsvc_s271_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple conditional operation (masked write):\nif (b[i] > 0.0f) { a[i] += b[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s271_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s271_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (b[i] > 0.0f) {\n           	a[i] += b[i] * c[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s271_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s271_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s271\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s271_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s271_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s271!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s271_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s271_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s271(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s271\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b,a,c), 1W (a). Total: 4 accesses. (b[i] > 0 always true)\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s271, s271_scalar)->Name(\"Scalar_s271\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s271, s271_simd)->Name(\"SIMD_s271\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s271", "entrypoint_scalar": "s271_scalar", "entrypoint_simd": "s271_simd"}
{"task_id": "tsvc_s272_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', length 'n' and an int 't'.\nIt performs two conditional operations under a single check:\nif (e[i] >= t) { a[i] += c[i] * d[i]; b[i] += c[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int) {\n}", "solution_scalar": "void s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int) {\n   	float t = (float)t_int;\n   	for (size_t i = 0; i < n; i++) {\n       	if (e[i] >= t) {\n           	a[i] += c[i] * d[i];\n           	b[i] += c[i] * c[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int t = 1; // From tsvc.c\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n -> 	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s272\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	e_input[i] = 1.0f; // e[i] >= t (1.0) is always true\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s272_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n       	s272_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s272!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t, int)>\nstatic void BM_s272(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n   	int t = 1; // From tsvc.c\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s272\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	e_input[i] = 1.0f; // e[i] >= t (1.0) is always true\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 6R (e,a,c,d,b,c), 2W (a,b). Total: 8 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s272, s272_scalar)->Name(\"Scalar_s272\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s272, s272_simd)->Name(\"SIMD_s272\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s272", "entrypoint_scalar": "s272_scalar", "entrypoint_simd": "s272_simd"}
{"task_id": "tsvc_s273_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a dependent conditional operation:\n1. a[i] += d[i] * e[i];\n2. if (a[i] < 0.0f) { b[i] += d[i] * e[i]; }\n3. c[i] += a[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += d[i] * e[i];\n       	if (a[i] < 0.0f)\n           	b[i] += d[i] * e[i];\n       	c[i] += a[i] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s273\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = (i % 2 == 0) ? (1.0f / (float)(i+1)) : (-1.0f / (float)(i+1)); // frac, alternating sign\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s273_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       	s273_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s273!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s273(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s273\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = (i % 2 == 0) ? (1.0f / (float)(i+1)) : (-1.0f / (float)(i+1)); // frac, alternating sign\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 4R(d,e,d,a), 1R/W(a), 1R/W(b), 1R/W(c) + 2R(d,e) in 'if'. ~10 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s273, s273_scalar)->Name(\"Scalar_s273\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s273, s273_simd)->Name(\"SIMD_s273\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s273", "entrypoint_scalar": "s273_scalar", "entrypoint_simd": "s273_simd"}
{"task_id": "tsvc_s274_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a complex conditional (if-then-else) operation:\n1. a[i] = c[i] + e[i] * d[i];\n2. if (a[i] > 0.0f) { b[i] = a[i] + b[i]; } else { a[i] = d[i] * e[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = c[i] + e[i] * d[i];\n       	if (a[i] > 0.0f) {\n           	b[i] = a[i] + b[i];\n       	} else {\n           	a[i] = d[i] * e[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s274\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s274_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s274_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s274!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n Type  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s274(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s274\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R(c,e,d). Blend: 2R(a,b),1W(b) OR 2R(d,e),1W(a). R/W(a), R/W(b). Total ~7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s274, s274_scalar)->Name(\"Scalar_s274\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s274, s274_simd)->Name(\"SIMD_s274\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s274", "entrypoint_scalar": "s274_scalar", "entrypoint_simd": "s274_simd"}
{"task_id": "tsvc_s275_AVX", "prompt": "/*\nThis function takes 2D float arrays 'aa', 'bb', 'cc' (flattened, row-major) of size n_2d * n_2d.\nIt performs a conditional inner loop (if around inner loop):\nif (aa[0][i] > 0.0f) { for (j=1..n_2d-1) aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   	for (size_t i = 0; i < n_2d; i++) {\n       	if (aa_flat[0 * n_2d + i] > 0.0f) { // aa[0][i]\n           	for (size_t j = 1; j < n_2d; j++) {\n             	// aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i]\n             	size_t idx_ji = j * n_2d + i;\n             	size_t idx_j_1_i = (j - 1) * n_2d + i;\n             	aa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji] * cc_flat[idx_ji];\n           	}\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_scalar(length), aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s275\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	cc_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s275_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       	s275_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s275!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s275(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s275\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	cc_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n       	benchmark::DoNotOptimize(cc_input.data());\n\n       	Func(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop n_2d * (n_2d - 1). Each op: 3R (aa,bb,cc), 1W (aa). (if is always true)\n   	size_t num_ops = n_2d * (n_2d - 1);\n   	int64_t bytes = (int64_t(num_ops) * 4 + int64_t(n_2d)) * sizeof(float); // 4 accesses in inner, 1 in outer 'if'\n   	state.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s275, s275_scalar)->Name(\"Scalar_s275\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s275, s275_simd)->Name(\"SIMD_s275\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s275", "entrypoint_scalar": "s275_scalar", "entrypoint_simd": "s275_simd"}
{"task_id": "tsvc_s2275_AVX", "prompt": "/*\nThis function is imperfectly nested. It takes 1D arrays 'a', 'b', 'c', 'd' and 2D 'aa', 'bb', 'cc'.\n1. Inner: aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i];\n2. Outer: a[i] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d) {\n   	// n_1d = LEN_1D, n_2d = LEN_2D\n   	for (size_t i = 0; i < n_2d; i++) {\n       	for (size_t j = 0; j < n_2d; j++) {\n           	// aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i]\n           	size_t idx_ji = j * n_2d + i;\n           	aa_flat[idx_ji] = aa_flat[idx_ji] + bb_flat[idx_ji] * cc_flat[idx_ji];\n       	}\n       	a[i] = b[i] + c[i] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_1d = Small_Arg_1D;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> b_input(length_1d);\n   	std::vector<float> c_input(length_1d);\n   	std::vector<float> d_input(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> cc_input(length_2d);\n   	std::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   	std::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2275\n       	for (size_t i = 0; i < length_1d; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n       	}\n       	for (size_t i = 0; i < length_2d; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	cc_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s2275_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n       	s2275_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), aa_simd.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2275!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, const float*, float*, const float*, const float*, size_t, size_t)>\nstatic void BM_s2275(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t n_1d = LEN_1D;\n   	size_t length_1d = n_1d;\n   	size_t length_2d = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length_1d);\n   	std::vector<float> b_input(length_1d);\n   	std::vector<float> c_input(length_1d);\n   	std::vector<float> d_input(length_1d);\n   	std::vector<float> aa_output(length_2d);\n   	std::vector<float> bb_input(length_2d);\n   	std::vector<float> cc_input(length_2d);\n   	std::vector<float> a_initial(length_1d);\n   	std::vector<float> aa_initial(length_2d);\n\n   	// Ported Initialization Logic for s2275\n   	for (size_t i = 0; i < length_1d; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n   	}\n   	for (size_t i = 0; i < length_2d; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	cc_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n       	benchmark::DoNotOptimize(cc_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), aa_output.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Inner: n_2d*n_2d ops * 3 accesses. Outer: n_2d ops * 4 accesses.\n   	size_t inner_ops = n_2d * n_2d;\n   	size_t outer_ops = n_2d;\n   	int64_t bytes = (int64_t(inner_ops) * 3 + int64_t(outer_ops) * 4) * sizeof(float);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2275, s2275_scalar)->Name(\"Scalar_s2275\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2275, s2275_simd)->Name(\"SIMD_s2275\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2275", "entrypoint_scalar": "s2275_scalar", "entrypoint_simd": "s2275_simd"}
{"task_id": "tsvc_s276_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a conditional operation based on the loop index 'i':\nif (i+1 < mid) { a[i] += b[i] * c[i]; } else { a[i] += b[i] * d[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   	size_t mid = n / 2;\n   	for (size_t i = 0; i < n; i++) {\n       	if (i + 1 < mid) {\n           	a[i] += b[i] * c[i];\n       	} else {\n           	a[i] += b[i] * d[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s276\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s276_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	s276_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s276!\" << std::endl;\n t       	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s276(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s276\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b,c,d), 1 R/W(a). Total: 5 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s276, s276_scalar)->Name(\"Scalar_s276\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s276, s276_simd)->Name(\"SIMD_s276\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s276", "entrypoint_scalar": "s276_scalar", "entrypoint_simd": "s276_simd"}
{"task_id": "tsvc_s277_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs conditional operations with goto statements:\nif (a[i] >= 0.0f) goto L20;\nif (b[i] >= 0.0f) goto L30;\na[i] += c[i] * d[i];\nL30: b[i+1] = c[i] + d[i] * e[i];\nL20: ;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n - 1; i++) {\n       	if (a[i] >= 0.0f) {\n           	goto L20;\n       	}\n       	if (b[i] >= 0.0f) {\n           	goto L30;\n       	}\n       	a[i] += c[i] * d[i];\nL30:\n       	b[i + 1] = c[i] + d[i] * e[i];\nL20:\n       	;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s277\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = -1.0f; // Force first 'if' to fail\n           	b_initial[i] = -1.0f; // Force second 'if' to fail\n           	c_input[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s277_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s277_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s277!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s277(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s277\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = -1.0f; // Force first 'if' to fail\n       	b_initial[i] = -1.0f; // Force second 'if' to fail\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Worst case (both 'if's fail): 7R (a,b,a,c,d,c,d,e), 1W (b), 1R/W(a). Total 10 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s277, s277_scalar)->Name(\"Scalar_s277\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s277, s277_simd)->Name(\"SIMD_s277\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s277", "entrypoint_scalar": "s277_scalar", "entrypoint_simd": "s277_simd"}
{"task_id": "tsvc_s278_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs an if-then-else pattern using goto:\nif (a[i] > 0.0f) goto L20;\nb[i] = -b[i] + d[i] * e[i];\ngoto L30;\nL20: c[i] = -c[i] + d[i] * e[i];\nL30: a[i] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > 0.0f) {\n           	goto L20;\n       	}\n       	b[i] = -b[i] + d[i] * e[i];\n       	goto L30;\nL20:\n       	c[i] = -c[i] + d[i] * e[i];\nL30:\n       	a[i] = b[i] + c[i] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s278\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s278_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       	s278_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s278!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s278(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s278\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 6R(a,b,d,e,b,c,d) 1W(b or c) 1R/W(a). Total ~9 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s278, s278_scalar)->Name(\"Scalar_s278\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s278, s278_simd)->Name(\"SIMD_s278\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s278", "entrypoint_scalar": "s278_scalar", "entrypoint_simd": "s278_simd"}
{"task_id": "tsvc_s279_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs complex conditional logic with gotos:\nif (a[i] > 0.0f) goto L20;\nb[i] = -b[i] + d[i] * d[i];\nif (b[i] <= a[i]) goto L30;\nc[i] += d[i] * e[i];\ngoto L30;\nL20: c[i] = -c[i] + e[i] * e[i];\nL30: a[i] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > 0.0f) {\n           	goto L20;\n       	}\n       	b[i] = -b[i] + d[i] * d[i];\n       	if (b[i] <= a[i]) {\n           	goto L30;\n       	}\n       	c[i] += d[i] * e[i];\n       	goto L30;\nL20:\n       	c[i] = -c[i] + e[i] * e[i];\nL30:\n       	a[i] = b[i] + c[i] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s279\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s279_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       	s279_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s279!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s279(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s279\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n ->   	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Very complex, worst case ~10-12 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 12);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s279, s279_scalar)->Name(\"Scalar_s279\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s279, s279_simd)->Name(\"SIMD_s279\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s279", "entrypoint_scalar": "s279_scalar", "entrypoint_simd": "s279_simd"}
{"task_id": "tsvc_s1279_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a nested conditional operation:\nif (a[i] < 0.0f) { if (b[i] > a[i]) { c[i] += d[i] * e[i]; } }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] < 0.0f) {\n           	if (b[i] > a[i]) {\n             	c[i] += d[i] * e[i];\n           	}\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1279\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = -1.0f / (float)(i+1); // frac neg\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 pos\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s1279_scalar(a_input.data(), b_input.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       	s1279_simd(a_input.data(), b_input.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1279!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(const float *, const float *, float *, const float *, const float *, size_t)>\nstatic void BM_s1279(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s1279\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = -1.0f / (float)(i+1); // frac neg\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 pos\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_input.data(), b_input.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 5R (a,b,a,d,e), 1 R/W(c). Total: 7 accesses. (all ifs true)\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1279, s1279_scalar)->Name(\"Scalar_s1279\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1279, s1279_simd)->Name(\"SIMD_s1279\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1279", "entrypoint_scalar": "s1279_scalar", "entrypoint_simd": "s1279_simd"}
{"task_id": "tsvc_s2710_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', length 'n' and a scalar int 'x'.\nIt performs complex nested conditional logic:\nif (a[i] > b[i]) {\n  a[i] += b[i] * d[i];\n  if (n > 10) c[i] += d[i] * d[i]; else c[i] = d[i] * e[i] + 1.0f;\n} else {\n  b[i] = a[i] + e[i] * e[i];\n  if (x > 0) c[i] = a[i] + d[i] * d[i]; else c[i] += e[i] * e[i];\n}\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x) {\n}", "solution_scalar": "void s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > b[i]) {\n           	a[i] += b[i] * d[i];\n           	if (n > 10) { // This will be true for benchmark runs\n             	c[i] += d[i] * d[i];\n           	} else {\n             	c[i] = d[i] * e[i] + 1.0f;\n           	}\n       	} else {\n           	b[i] = a[i] + e[i] * e[i];\n           	if (x > 0) { // This is true for the test case\n             	c[i] = a[i] + d[i] * d[i];\n           	} else {\n             	c[i] += e[i] * e[i];\n           	}\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int x = 1; // From tsvc.c\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n   	std::vector<float> c_scalar(length), c_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2710\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = (i % 2 == 0) ? 1.0f : 0.5f; // Test both paths\n           	b_initial[i] = 0.8f;\n           	c_initial[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n       	c_scalar = c_initial;\n       	c_simd = c_initial;\n\n       	s2710_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length, x);\n       	s2710_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length, x);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2710!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t, int)>\nstatic void BM_s2710(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n   	int x = 1; // From tsvc.c\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_output(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_initial(length);\n\n   	// Ported Initialization Logic for s2710\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = (i % 2 == 0) ? 1.0f : 0.5f; // Test both paths\n       	b_initial[i] = 0.8f;\n       	c_initial[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	c_output = c_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_output.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length, x);\n g     	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Complex blend. ~10 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2710, s2710_scalar)->Name(\"Scalar_s2710\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2710, s2710_simd)->Name(\"SIMD_s2710\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2710", "entrypoint_scalar": "s2710_scalar", "entrypoint_simd": "s2710_simd"}
{"task_id": "tsvc_s2711_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a conditional operation (masked write):\nif (b[i] != 0.0f) { a[i] += b[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s2711_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (b[i] != 0.0f) {\n           	a[i] += b[i] * c[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2711_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2711\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = (float)(i % 2); // Mix of 0.0 and 1.0\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s2711_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s2711_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2711!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2711_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s2711(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s2711\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = (float)(i % 2); // Mix of 0.0 and 1.0\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b,a,c), 1W (a). Total: 4 accesses (worst case).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2711, s2711_scalar)->Name(\"Scalar_s2711\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2711, s2711_simd)->Name(\"SIMD_s2711\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2711", "entrypoint_scalar": "s2711_scalar", "entrypoint_simd": "s2711_simd"}
{"task_id": "tsvc_s2712_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple conditional operation (masked write):\nif (a[i] > b[i]) { a[i] += b[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s2712_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > b[i]) {\n           	a[i] += b[i] * c[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2712_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2712 (same as s271 init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 (a > b is true for i > 0)\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s2712_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s2712_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2712!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2712_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s2712(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s2712\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (a,b,c), 1W (a). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2712, s2712_scalar)->Name(\"Scalar_s2712\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2712, s2712_simd)->Name(\"SIMD_s2712\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2712", "entrypoint_scalar": "s2712_scalar", "entrypoint_simd": "s2712_simd"}
{"task_id": "tsvc_s281_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs an operation with a reverse-index read:\n1. x = a[n-i-1] + b[i] * c[i];\n2. a[i] = x - 1.0f;\n3. b[i] = x;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s281_simd(float *a, float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s281_scalar(float *a, float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	float x = a[n - i - 1] + b[i] * c[i];\n       	a[i] = x - 1.0f;\n       	b[i] = x;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s281_scalar(float *a, float *b, const float *c, size_t n);\nvoid s281_simd(float *a, float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s281\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s281_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), length);\n       	s281_simd(a_simd.data(), b_simd.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s281!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s281_scalar(float *a, float *b, const float *c, size_t n);\nvoid s281_simd(float *a, float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, size_t)>\nstatic void BM_s281(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s281\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (a_rev, b, c), 2W (a, b). Total: 5 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s281, s281_scalar)->Name(\"Scalar_s281\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s281, s281_simd)->Name(\"SIMD_s281\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s281", "entrypoint_scalar": "s281_scalar", "entrypoint_simd": "s281_simd"}
{"task_id": "tsvc_s1281_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion:\n1. x = b[i]*c[i] + a[i]*d[i] + e[i];\n2. a[i] = x - 1.0f;\n3. b[i] = x;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	float x = b[i] * c[i] + a[i] * d[i] + e[i];\n       	a[i] = x - 1.0f;\n       	b[i] = x;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1281 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_initial[i] = 1.0f;\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s1281_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s1281_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1281!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1281(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s1281 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_initial[i] = 1.0f;\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 5R (b,c,a,d,e), 2W (a,b). Total: 7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1281, s1281_scalar)->Name(\"Scalar_s1281\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1281, s1281_simd)->Name(\"SIMD_s1281\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1281", "entrypoint_scalar": "s1281_scalar", "entrypoint_simd": "s1281_simd"}
{"task_id": "tsvc_s291_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a loop peeling / wrap-around variable task:\na[i] = (b[i] + b[im1]) * 0.5f; (where im1 = i-1, and b[-1] = b[n-1])\nim1 = i;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s291_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s291_scalar(float *a, const float *b, size_t n) {\n   	size_t im1 = n - 1;\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = (b[i] + b[im1]) * 0.5f;\n       	im1 = i;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s291_scalar(float *a, const float *b, size_t n);\nvoid s291_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s291 (same as s254)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s291_scalar(a_scalar.data(), b_input.data(), length);\n       	s291_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s291!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s291_scalar(float *a, const float *b, size_t n);\nvoid s291_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s291(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s291\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (b[i], b[im1]), 1W (a). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s291, s291_scalar)->Name(\"Scalar_s291\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s291, s291_simd)->Name(\"SIMD_s291\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s291", "entrypoint_scalar": "s291_scalar", "entrypoint_simd": "s291_simd"}
{"task_id": "tsvc_s292_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a 2-level wrap-around variable task:\na[i] = (b[i] + b[im1] + b[im2]) * 0.333f; (im1 = i-1, im2 = i-2)\nim2 = im1; im1 = i;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s292_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s292_scalar(float *a, const float *b, size_t n) {\n   	size_t im1 = n - 1;\n   	size_t im2 = n - 2;\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = (b[i] + b[im1] + b[im2]) * 0.333f;\n       	im2 = im1;\n       	im1 = i;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s292_scalar(float *a, const float *b, size_t n);\nvoid s292_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s292 (same as s255)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s292_scalar(a_scalar.data(), b_input.data(), length);\n       	s292_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s292!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s292_scalar(float *a, const float *b, size_t n);\nvoid s292_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s292(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s292\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b[i], b[im1], b[im2]), 1W (a). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s292, s292_scalar)->Name(\"Scalar_s292\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s292, s292_simd)->Name(\"SIMD_s292\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s292", "entrypoint_scalar": "s292_scalar", "entrypoint_simd": "s292_simd"}
{"task_id": "tsvc_s293_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a broadcast operation: a[i] = a[0];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s293_simd(float *a, size_t n) {\n}", "solution_scalar": "void s293_scalar(float *a, size_t n) {\n   	float a0 = a[0];\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = a0;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s293_scalar(float *a, size_t n);\nvoid s293_simd(float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s293 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s293_scalar(a_scalar.data(), length);\n       	s293_simd(a_simd.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s293!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s293_scalar(float *a, size_t n);\nvoid s293_simd(float *a, size_t n);\n\ntemplate<void (*Func)(float *, size_t)>\nstatic void BM_s293(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s293 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n\n       	Func(a_output.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R (a[0] - hoisted), 1W (a[i]). Total: 2 accesses (or 1 in loop).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s293, s293_scalar)->Name(\"Scalar_s293\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s293, s293_simd)->Name(\"SIMD_s293\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s293", "entrypoint_scalar": "s293_scalar", "entrypoint_simd": "s293_simd"}
{"task_id": "tsvc_s2101_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt performs a main diagonal operation: aa[i][i] += bb[i][i] * cc[i][i];\nThis tests strided memory access.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   	for (size_t i = 0; i < n_2d; i++) {\n       	size_t idx_ii = i * n_2d + i;\n       	aa_flat[idx_ii] += bb_flat[idx_ii] * cc_flat[idx_ii];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_scalar(length), aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2101\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	cc_input[i] = 1.0f;\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s2101_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       	s2101_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2101!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s2101(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> cc_input(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s2101\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	cc_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n       	benchmark::DoNotOptimize(cc_input.data());\n\n       	Func(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d). Ops: 1 R/W(aa), 2R(bb,cc). Total: 4 accesses.\n   	size_t num_ops = n_2d;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2101, s2101_scalar)->Name(\"Scalar_s2101\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2101, s2101_simd)->Name(\"SIMD_s2101\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2101", "entrypoint_scalar": "s2101_scalar", "entrypoint_simd": "s2101_simd"}
{"task_id": "tsvc_s2102_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt creates an identity matrix by first zeroing columns, then setting the diagonal.\n1. Inner loop: aa[j][i] = 0.0f;\n2. Outer loop: aa[i][i] = 1.0f;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2102_simd(float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "void s2102_scalar(float* aa_flat, size_t n_2d) {\n   	for (size_t i = 0; i < n_2d; i++) {\n       	for (size_t j = 0; j < n_2d; j++) {\n           	aa_flat[j * n_2d + i] = 0.0f;\n       	}\n       	aa_flat[i * n_2d + i] = 1.0f;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2102_scalar(float* aa_flat, size_t n_2d);\nvoid s2102_simd(float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> aa_scalar(length), aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2102\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 123.0f; // Fill with non-zero/one\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s2102_scalar(aa_scalar.data(), n_2d);\n       	s2102_simd(aa_simd.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2102!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2102_scalar(float* aa_flat, size_t n_2d);\nvoid s2102_simd(float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, size_t)>\nstatic void BM_s2102(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s2102\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 123.0f;\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n\n       	Func(aa_output.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d * n_2d) writes + n_2d writes. Total (n_2d^2 + n_2d) writes.\n   	size_t num_ops = (n_2d * n_2d) + n_2d;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2102, s2102_scalar)->Name(\"Scalar_s2102\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2102, s2102_simd)->Name(\"SIMD_s2102\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2102", "entrypoint_scalar": "s2102_scalar", "entrypoint_simd": "s2102_simd"}
{"task_id": "tsvc_s2111_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt performs a wavefront computation (2D recurrence):\naa[j][i] = (aa[j][i-1] + aa[j-1][i]) / 1.9f;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2111_simd(float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "void s2111_scalar(float* aa_flat, size_t n_2d) {\n   	for (size_t j = 1; j < n_2d; j++) {\n       	for (size_t i = 1; i < n_2d; i++) {\n           	aa_flat[j * n_2d + i] = (aa_flat[j * n_2d + (i - 1)] + aa_flat[(j - 1) * n_2d + i]) / 1.9f;\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2111_scalar(float* aa_flat, size_t n_2d);\nvoid s2111_simd(float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_initial(length);\n   	std::vector<float> aa_scalar(length), aa_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s2111 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_initial[i] = 1.0f;\n       	}\n       	aa_scalar = aa_initial;\n       	aa_simd = aa_initial;\n\n       	s2111_scalar(aa_scalar.data(), n_2d);\n       	s2111_simd(aa_simd.data(), n_2d);\n\n       	if (!allclose(aa_scalar, aa_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2111!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2111_scalar(float* aa_flat, size_t n_2d);\nvoid s2111_simd(float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, size_t)>\nstatic void BM_s2111(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_output(length);\n   	std::vector<float> aa_initial(length);\n\n   	// Ported Initialization Logic for s2111 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_initial[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	aa_output = aa_initial;\n       	benchmark::DoNotOptimize(aa_output.data());\n\n       	Func(aa_output.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d-1) * (n_2d-1). Ops: 2R(aa), 1W(aa). Total: 3 accesses.\n   	size_t num_ops = (n_2d - 1) * (n_2d - 1);\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2111, s2111_scalar)->Name(\"Scalar_s2111\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2111, s2111_simd)->Name(\"SIMD_s2111\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2111", "entrypoint_scalar": "s2111_scalar", "entrypoint_simd": "s2111_simd"}
{"task_id": "tsvc_s311_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a sum reduction: sum += a[i];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s311_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s311_scalar(const float *a, size_t n) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	sum += a[i];\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s311_scalar(const float *a, size_t n);\nfloat s311_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s311\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n\n       	float sum_scalar = s311_scalar(a_input.data(), length);\n       	float sum_simd = s311_simd(a_input.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s311!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s311_scalar(const float *a, size_t n);\nfloat s311_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s311(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s311\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float sum = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s311, s311_scalar)->Name(\"Scalar_s311\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s311, s311_simd)->Name(\"SIMD_s311\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s311", "entrypoint_scalar": "s311_scalar", "entrypoint_simd": "s311_simd"}
{"task_id": "tsvc_s31111_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a sum reduction over the first 32 elements of 'a' using a helper.\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s31111_simd(const float *a, size_t n) {\n}", "solution_scalar": "static float test_scalar(const float* A) {\n   	float s = 0.0f;\n   	for (int i = 0; i < 4; i++)\n     	s += A[i];\n   	return s;\n}\n\nfloat s31111_scalar(const float *a, size_t n) {\n   	float sum = 0.0f;\n   	sum += test_scalar(a);\n   	sum += test_scalar(&a[4]);\n   	sum += test_scalar(&a[8]);\n   	sum += test_scalar(&a[12]);\n   	sum += test_scalar(&a[16]);\n   	sum += test_scalar(&a[20]);\n   	sum += test_scalar(&a[24]);\n   	sum += test_scalar(&a[28]);\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstatic float test_scalar(const float* A) {\n   	float s = 0.0f;\n   	for (int i = 0; i < 4; i++)\n     	s += A[i];\n   	return s;\n}\nfloat s31111_scalar(const float *a, size_t n);\nfloat s31111_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s31111\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n\n       	float sum_scalar = s31111_scalar(a_input.data(), length);\n       	float sum_simd = s31111_simd(a_input.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s31111!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s31111_scalar(const float *a, size_t n);\nfloat s31111_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s31111(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s31111\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float sum = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Ops: 32 Reads (8 calls * 4 reads/call)\n   	size_t num_ops = 32;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s31111, s31111_scalar)->Name(\"Scalar_s31111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s31111, s31111_simd)->Name(\"SIMD_s31111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s31111", "entrypoint_scalar": "s31111_scalar", "entrypoint_simd": "s31111_simd"}
{"task_id": "tsvc_s312_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a product reduction: prod *= a[i];\nImplement this using AVX intrinsics. The function should return the product.\n*/\n#include <immintrin.h>\nfloat s312_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s312_scalar(const float *a, size_t n) {\n   	float prod = 1.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	prod *= a[i];\n   	}\n   	return prod;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s312_scalar(const float *a, size_t n);\nfloat s312_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s312\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f + 1.0f / (float)(i+1); // 1 + frac to avoid zero/denormal\n       	}\n\n       	float prod_scalar = s312_scalar(a_input.data(), length);\n       	float prod_simd = s312_simd(a_input.data(), length);\n\n       	if (!allclose(prod_scalar, prod_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s312!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s312_scalar(const float *a, size_t n);\nfloat s312_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s312(benchmark::State& state) {\n g  	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s312\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f + 1.0f / (float)(i+1); // 1 + frac\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float prod = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(prod);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s312, s312_scalar)->Name(\"Scalar_s312\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s312, s312_simd)->Name(\"SIMD_s312\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s312", "entrypoint_scalar": "s312_scalar", "entrypoint_simd": "s312_simd"}
{"task_id": "tsvc_s313_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a dot product reduction: dot += a[i] * b[i];\nImplement this using AVX intrinsics. The function should return the dot product.\n*/\n#include <immintrin.h>\nfloat s313_simd(const float *a, const float *b, size_t n) {\n}", "solution_scalar": "float s313_scalar(const float *a, const float *b, size_t n) {\n   	float dot = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	dot += a[i] * b[i];\n   	}\n   	return dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s313_scalar(const float *a, const float *b, size_t n);\nfloat s313_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s313\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n\n       	float dot_scalar = s313_scalar(a_input.data(), b_input.data(), length);\n       	float dot_simd = s313_simd(a_input.data(), b_input.data(), length);\n\n       	if (!allclose(dot_scalar, dot_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s313!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s313_scalar(const float *a, const float *b, size_t n);\nfloat s313_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_s313(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n\n   	// Ported Initialization Logic for s313\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	float dot = Func(a_input.data(), b_input.data(), length);\n       	benchmark::DoNotOptimize(dot);\n   	}\n   	// Loop (n). Ops: 2R (a, b).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s313, s313_scalar)->Name(\"Scalar_s313\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s313, s313_simd)->Name(\"SIMD_s313\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s313", "entrypoint_scalar": "s313_scalar", "entrypoint_simd": "s313_simd"}
{"task_id": "tsvc_s314_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a max reduction: x = max(x, a[i]);\nImplement this using AVX intrinsics. The function should return the max value.\n*/\n#include <immintrin.h>\n#include <limits>\nfloat s314_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s314_scalar(const float *a, size_t n) {\n   	float x = a[0];\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > x) {\n           	x = a[i];\n       	}\n   	}\n   	return x;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s314_scalar(const float *a, size_t n);\nfloat s314_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s314\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n\n       	float max_scalar = s314_scalar(a_input.data(), length);\n       	float max_simd = s314_simd(a_input.data(), length);\n\n       	if (!allclose(max_scalar, max_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s314!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s314_scalar(const float *a, size_t n);\nfloat s314_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s314(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s314\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float max_val = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(max_val);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s314, s314_scalar)->Name(\"Scalar_s314\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s314, s314_simd)->Name(\"SIMD_s314\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s314", "entrypoint_scalar": "s314_scalar", "entrypoint_simd": "s314_simd"}
{"task_id": "tsvc_s315_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt finds the max value and the index of that max value.\nImplement this using AVX intrinsics. The function should return a pair of {max_value, index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <utility>\nstd::pair<float, int> s315_simd(const float *a, size_t n) {\n}", "solution_scalar": "#include <utility>\nstd::pair<float, int> s315_scalar(const float *a, size_t n) {\n   	float x = a[0];\n   	int index = 0;\n   	for (size_t i = 0; i < n; ++i) {\n       	if (a[i] > x) {\n           	x = a[i];\n           	index = (int)i;\n       	}\n   	}\n   	return {x, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s315_scalar(const float *a, size_t n);\nstd::pair<float, int> s315_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s315\n       	for (size_t i = 0; i < length; ++i)\n           	a_input[i] = (float)((i * 7) % length);\n\n       	std::pair<float, int> res_scalar = s315_scalar(a_input.data(), length);\n       	std::pair<float, int> res_simd = s315_simd(a_input.data(), length);\n\n       	if (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s315!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s315_scalar(const float *a, size_t n);\nstd::pair<float, int> s315_simd(const float *a, size_t n);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t)>\nstatic void BM_s315(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s315\n   	for (size_t i = 0; i < length; ++i)\n       	a_input[i] = (float)((i * 7) % length);\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	std::pair<float, int> res = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(res);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s315, s315_scalar)->Name(\"Scalar_s315\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s315, s315_simd)->Name(\"SIMD_s315\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s315", "entrypoint_scalar": "s315_scalar", "entrypoint_simd": "s315_simd"}
{"task_id": "tsvc_s316_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a min reduction: x = min(x, a[i]);\nImplement this using AVX intrinsics. The function should return the min value.\n*/\n#include <immintrin.h>\n#include <limits>\nfloat s316_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s316_scalar(const float *a, size_t n) {\n   	float x = a[0];\n   	for (size_t i = 1; i < n; ++i) {\n       	if (a[i] < x) {\n           	x = a[i];\n       	}\n   	}\n   	return x;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s316_scalar(const float *a, size_t n);\nfloat s316_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s316 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n\n       	float min_scalar = s316_scalar(a_input.data(), length);\n       	float min_simd = s316_simd(a_input.data(), length);\n\n       	if (!allclose(min_scalar, min_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s316!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s316_scalar(const float *a, size_t n);\nfloat s316_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s316(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s316 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float min_val = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(min_val);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s316, s316_scalar)->Name(\"Scalar_s316\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s316, s316_simd)->Name(\"SIMD_s316\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s316", "entrypoint_scalar": "s316_scalar", "entrypoint_simd": "s316_simd"}
{"task_id": "tsvc_s317_AVX", "prompt": "/*\nThis function takes length 'n' (n/2 iterations).\nIt performs a product reduction of a constant: q *= 0.99f;\nImplement this using AVX intrinsics. The function should return the product.\n*/\n#include <immintrin.h>\n#include <cmath>\nfloat s317_simd(size_t n) {\n}", "solution_scalar": "float s317_scalar(size_t n) {\n   	float q = 1.0f;\n   	for (size_t i = 0; i < n / 2; i++) {\n       	q *= 0.99f;\n   	}\n   	return q;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s317_scalar(size_t n);\nfloat s317_simd(size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	float prod_scalar = s317_scalar(length);\n       	float prod_simd = s317_simd(length);\n\n       	if (!allclose(prod_scalar, prod_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s317!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s317_scalar(size_t n);\nfloat s317_simd(size_t n);\n\ntemplate<float (*Func)(size_t)>\nstatic void BM_s317(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	for (auto _ : state) {\n       	float prod = Func(length);\n       	benchmark::DoNotOptimize(prod);\n   	}\n   	// Loop (n/2). No memory ops.\n   	state.SetBytesProcessed(0);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s317, s317_scalar)->Name(\"Scalar_s317\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s317, s317_simd)->Name(\"SIMD_s317\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s317", "entrypoint_scalar": "s317_scalar", "entrypoint_simd": "s317_simd"}
{"task_id": "tsvc_s318_AVX", "prompt": "/*\nThis function takes a float array 'a', length 'n', and an increment 'inc'.\nIt performs an ISAMAX (index of max absolute value) reduction with a stride 'inc'.\nImplement this using AVX intrinsics. The function should return a pair of {max_abs_value, index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <cmath>\n#include <utility>\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc) {\n}", "solution_scalar": "#include <cmath>\n#include <utility>\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc) {\n   	int k = 0;\n   	int index = 0;\n   	float max = std::abs(a[0]);\n   	k += inc;\n   	for (size_t i = 1; i < n; i++) {\n       	if (std::abs(a[k]) > max) {\n           	index = (int)i;\n           	max = std::abs(a[k]);\n       	}\n       	k += inc;\n   	}\n   	return {max, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc);\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int inc = 1; // From tsvc.c\n\n   	std::vector<float> a_input(length * inc); // Ensure enough space for max index\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s318\n       	for (size_t i = 0; i < a_input.size(); ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	// Ensure a negative value is present\n       	if (length > 10) a_input[10] = -2.0f;\n\n       	std::pair<float, int> res_scalar = s318_scalar(a_input.data(), length, inc);\n       	std::pair<float, int> res_simd = s318_simd(a_input.data(), length, inc);\n\n       	if (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s318!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc);\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t, int)>\nstatic void BM_s318(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	int inc = 1; // From tsvc.c\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length * inc + 1);\n\n   	// Ported Initialization Logic for s318\n   	for (size_t i = 0; i < a_input.size(); ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	if (length > 10) a_input[10] = -2.0f;\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	std::pair<float, int> res = Func(a_input.data(), length, inc);\n       	benchmark::DoNotOptimize(res);\n   	}\n   	// Loop (n-1). Ops: 1R (a[k]).\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s318, s318_scalar)->Name(\"Scalar_s318\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s318, s318_simd)->Name(\"SIMD_s318\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s318", "entrypoint_scalar": "s318_scalar", "entrypoint_simd": "s318_simd"}
{"task_id": "tsvc_s319_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a coupled reduction:\n1. a[i] = c[i] + d[i];\n2. sum += a[i];\n3. b[i] = c[i] + e[i];\n4. sum += b[i];\nImplement this using AVX intrinsics. The function should return the final sum.\n*/\n#include <immintrin.h>\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "float s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = c[i] + d[i];\n       	sum += a[i];\n       	b[i] = c[i] + e[i];\n       	sum += b[i];\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s319\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_initial[i] = 0.0f;\n           	c_input[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	float sum_scalar = s319_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	float sum_simd = s319_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd) || !allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s319!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<float (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s319(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s319\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_initial[i] = 0.0f;\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	float sum = Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n). Ops: 6R (c,d,a,c,e,b), 2W (a,b). Total: 8 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s319, s319_scalar)->Name(\"Scalar_s319\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s319, s319_simd)->Name(\"SIMD_s319\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s319", "entrypoint_scalar": "s319_scalar", "entrypoint_simd": "s319_simd"}
{"task_id": "tsvc_s3110_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt finds the max value and its 2D indices (xindex, yindex).\nImplement this using AVX intrinsics. The function should return a tuple of {max_value, x_index, y_index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <tuple>\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "#include <tuple>\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d) {\n   	float max = aa_flat[0]; // aa[0][0]\n   	int xindex = 0;\n   	int yindex = 0;\n   	for (size_t i = 0; i < n_2d; i++) {\n       	for (size_t j = 0; j < n_2d; j++) {\n           	float val = aa_flat[i * n_2d + j];\n           	if (val > max) {\n             	max = val;\n             	xindex = (int)i;\n             	yindex = (int)j;\n           	}\n       	}\n   	}\n   	return std::make_tuple(max, xindex, yindex);\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s3110 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	// Ensure a specific max value\n       	if (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n \n       	std::tuple<float, int, int> res_scalar = s3110_scalar(aa_input.data(), n_2d);\n       	std::tuple<float, int, int> res_simd = s3110_simd(aa_input.data(), n_2d);\n\n       	if (!allclose(std::get<0>(res_scalar), std::get<0>(res_simd)) || \n           	std::get<1>(res_scalar) != std::get<1>(res_simd) || \n           	std::get<2>(res_scalar) != std::get<2>(res_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3110!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <tuple>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d);\n\ntemplate<std::tuple<float, int, int> (*Func)(const float*, size_t)>\nstatic void BM_s3110(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_input(length);\n\n   	// Ported Initialization Logic for s3110 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	if (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(aa_input.data());\n       	std::tuple<float, int, int> res = Func(aa_input.data(), n_2d);\n       	benchmark::DoNotOptimize(res);\n   	}\n   	// Loop (n_2d * n_2d). Ops: 1R (aa).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s3110, s3110_scalar)->Name(\"Scalar_s3110\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s3110, s3110_simd)->Name(\"SIMD_s3110\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3110", "entrypoint_scalar": "s3110_scalar", "entrypoint_simd": "s3110_simd"}
{"task_id": "tsvc_s13110_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt finds the max value and its 2D indices (xindex, yindex). (Identical to s3110)\nImplement this using AVX intrinsics. The function should return a tuple of {max_value, x_index, y_index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <tuple>\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "#include <tuple>\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d) {\n   	float max = aa_flat[0]; // aa[0][0]\n   	int xindex = 0;\n   	int yindex = 0;\n   	for (size_t i = 0; i < n_2d; i++) {\n       	for (size_t j = 0; j < n_2d; j++) {\n           	float val = aa_flat[i * n_2d + j];\n           	if (val > max) {\n             	max = val;\n             	xindex = (int)i;\n             	yindex = (int)j;\n           	}\n       	}\n   	}\n   	return std::make_tuple(max, xindex, yindex);\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> aa_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s13110 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	aa_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	// Ensure a specific max value\n       	if (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n \n       	std::tuple<float, int, int> res_scalar = s13110_scalar(aa_input.data(), n_2d);\n       	std::tuple<float, int, int> res_simd = s13110_simd(aa_input.data(), n_2d);\n\n       	if (!allclose(std::get<0>(res_scalar), std::get<0>(res_simd)) || \n           	std::get<1>(res_scalar) != std::get<1>(res_simd) || \n           	std::get<2>(res_scalar) != std::get<2>(res_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s13110!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <tuple>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d);\n\ntemplate<std::tuple<float, int, int> (*Func)(const float*, size_t)>\nstatic void BM_s13110(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> aa_input(length);\n\n   	// Ported Initialization Logic for s13110 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	aa_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	if (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(aa_input.data());\n       	std::tuple<float, int, int> res = Func(aa_input.data(), n_2d);\n       	benchmark::DoNotOptimize(res);\n   	}\n   	// Loop (n_2d * n_2d). Ops: 1R (aa).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s13110, s13110_scalar)->Name(\"Scalar_s13110\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s13110, s13110_simd)->Name(\"SIMD_s13110\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s13110", "entrypoint_scalar": "s13110_scalar", "entrypoint_simd": "s13110_simd"}
{"task_id": "tsvc_s3111_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a conditional sum reduction: if (a[i] > 0.0f) { sum += a[i]; }\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s3111_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s3111_scalar(const float *a, size_t n) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > 0.0f) {\n           	sum += a[i];\n       	}\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3111_scalar(const float *a, size_t n);\nfloat s3111_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s3111\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	}\n\n       	float sum_scalar = s3111_scalar(a_input.data(), length);\n       	float sum_simd = s3111_simd(a_input.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3111!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3111_scalar(const float *a, size_t n);\nfloat s3111_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s3111(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s3111\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float sum = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3111, s3111_scalar)->Name(\"Scalar_s3111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3111, s3111_simd)->Name(\"SIMD_s3111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3111", "entrypoint_scalar": "s3111_scalar", "entrypoint_simd": "s3111_simd"}
{"task_id": "tsvc_s3112_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a sum reduction while saving the running sum to 'b':\n1. sum += a[i];\n2. b[i] = sum;\nImplement this using AVX intrinsics. The function should return the final sum.\n*/\n#include <immintrin.h>\nfloat s3112_simd(const float *a, float *b, size_t n) {\n}", "solution_scalar": "float s3112_scalar(const float *a, float *b, size_t n) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	sum += a[i];\n       	b[i] = sum;\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3112_scalar(const float *a, float *b, size_t n);\nfloat s3112_simd(const float *a, float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s3112\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_initial[i] = 0.0f;\n       	}\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	float sum_scalar = s3112_scalar(a_input.data(), b_scalar.data(), length);\n       	float sum_simd = s3112_simd(a_input.data(), b_simd.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3112!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3112_scalar(const float *a, float *b, size_t n);\nfloat s3112_simd(const float *a, float *b, size_t n);\n\ntemplate<float (*Func)(const float *, float *, size_t)>\nstatic void BM_s3112(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s3112\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_initial[i] = 0.0f;\n   	}\n\n   	for (auto _ : state) {\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_output.data());\n\n       	float sum = Func(a_input.data(), b_output.data(), length);\n       	\n       	benchmark::ClobberMemory();\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n). Ops: 1R (a), 1W (b).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3112, s3112_scalar)->Name(\"Scalar_s3112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3112, s3112_simd)->Name(\"SIMD_s3112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3112", "entrypoint_scalar": "s3112_scalar", "entrypoint_simd": "s3112_simd"}
{"task_id": "tsvc_s3113_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a max absolute value reduction: max = max(max, abs(a[i]));\nImplement this using AVX intrinsics. The function should return the max absolute value.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <cmath>\nfloat s3113_simd(const float *a, size_t n) {\n}", "solution_scalar": "#include <cmath>\nfloat s3113_scalar(const float *a, size_t n) {\n   	float max = std::abs(a[0]);\n   	for (size_t i = 0; i < n; i++) {\n       	if (std::abs(a[i]) > max) {\n           	max = std::abs(a[i]);\n       	}\n   	}\n   	return max;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3113_scalar(const float *a, size_t n);\nfloat s3113_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s3113 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	if (length > 10) a_input[10] = -2.0f; // Add a negative value\n\n       	float max_scalar = s3113_scalar(a_input.data(), length);\n       	float max_simd = s3113_simd(a_input.data(), length);\n\n       	if (!allclose(max_scalar, max_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3113!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3113_scalar(const float *a, size_t n);\nfloat s3113_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s3113(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s3113 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	if (length > 10) a_input[10] = -2.0f; // Add a negative value\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float max_val = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(max_val);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3113, s3113_scalar)->Name(\"Scalar_s3113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3113, s3113_simd)->Name(\"SIMD_s3113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3113", "entrypoint_scalar": "s3113_scalar", "entrypoint_simd": "s3113_simd"}
{"task_id": "tsvc_s321_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a first-order linear recurrence: a[i] += a[i-1] * b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s321_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s321_scalar(float *a, const float *b, size_t n) {\n   	for (size_t i = 1; i < n; i++) {\n       	a[i] += a[i - 1] * b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s321_scalar(float *a, const float *b, size_t n);\nvoid s321_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s321\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s321_scalar(a_scalar.data(), b_input.data(), length);\n       	s321_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s321!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s321_scalar(float *a, const float *b, size_t n);\nvoid s321_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s321(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s321\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 1 R/W(a), 1R(a[i-1]), 1R(b). Total: 3 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s321, s321_scalar)->Name(\"Scalar_s321\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s321, s321_simd)->Name(\"SIMD_s321\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s321", "entrypoint_scalar": "s321_scalar", "entrypoint_simd": "s321_simd"}
{"task_id": "tsvc_s322_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a second-order linear recurrence:\na[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s322_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s322_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 2; i < n; i++) {\n       	a[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s322_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s322_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s322\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s322_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s322_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s322!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s322_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s322_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s322(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s322\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-2). Ops: 1 R/W(a), 2R(a), 2R(b,c). Total: 5 accesses.\n   	size_t num_ops = length - 2;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s322, s322_scalar)->Name(\"Scalar_s322\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s322, s322_simd)->Name(\"SIMD_s322\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s322", "entrypoint_scalar": "s322_scalar", "entrypoint_simd": "s322_simd"}
{"task_id": "tsvc_s323_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a coupled recurrence:\n1. a[i] = b[i-1] + c[i] * d[i];\n2. b[i] = a[i] + c[i] * e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 1; i < n; i++) {\n       	a[i] = b[i - 1] + c[i] * d[i];\n       	b[i] = a[i] + c[i] * e[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s323\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_initial[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s323_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s323_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s323!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s323(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s323\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_initial[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 6R (b,c,d,a,c,e), 2W (a,b). Total: 8 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s323, s323_scalar)->Name(\"Scalar_s323\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s323, s323_simd)->Name(\"SIMD_s323\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s323", "entrypoint_scalar": "s323_scalar", "entrypoint_simd": "s323_simd"}
{"task_id": "tsvc_s331_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a search loop to find the *last* index i where a[i] < 0.\nImplement this using AVX intrinsics. The function should return the last index found, or -1.\n*/\n#include <immintrin.h>\n#include <limits>\nint s331_simd(const float *a, size_t n) {\n}", "solution_scalar": "int s331_scalar(const float *a, size_t n) {\n   	int j = -1;\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] < 0.0f) {\n           	j = (int)i;\n       	}\n   	}\n   	return j;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nint s331_scalar(const float *a, size_t n);\nint s331_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s331\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 0.5f - (float)i; // Will be negative for i > 0\n       	}\n       	if (length > 0) a_input[0] = 1.0f; // Ensure first is not negative\n\n       	int j_scalar = s331_scalar(a_input.data(), length);\n       	int j_simd = s331_simd(a_input.data(), length);\n\n       	if (j_scalar != j_simd) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s331!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nint s331_scalar(const float *a, size_t n);\nint s331_simd(const float *a, size_t n);\n\ntemplate<int (*Func)(const float *, size_t)>\nstatic void BM_s331(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s331\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 0.5f - (float)i; // Will be negative for i > 0\n   	}\n   	if (length > 0) a_input[0] = 1.0f;\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	int j = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(j);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s331, s331_scalar)->Name(\"Scalar_s331\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s331, s331_simd)->Name(\"SIMD_s331\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s331", "entrypoint_scalar": "s331_scalar", "entrypoint_simd": "s331_simd"}
{"task_id": "tsvc_s332_AVX", "prompt": "/*\nThis function takes a float array 'a', length 'n', and a threshold 't'.\nIt finds the *first* value and index where a[i] > t.\nImplement this using AVX intrinsics. The function should return a pair of {value, index}.\nReturns {-1.0f, -2} if not found.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <utility>\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int) {\n}", "solution_scalar": "#include <utility>\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int) {\n   	float t = (float)t_int;\n   	int index = -2;\n   	float value = -1.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > t) {\n           	index = (int)i;\n           	value = a[i];\n           	break;\n       	}\n   	}\n   	return {value, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int);\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int t = (int)(length / 2); // Set threshold t\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s332\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = (float)i;\n       	}\n\n       	std::pair<float, int> res_scalar = s332_scalar(a_input.data(), length, t);\n       	std::pair<float, int> res_simd = s332_simd(a_input.data(), length, t);\n\n       	if (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s332!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int);\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t, int)>\nstatic void BM_s332(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	int t = (int)(length / 2);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for s332\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = (float)i;\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	std::pair<float, int> res = Func(a_input.data(), length, t);\n       	benchmark::DoNotOptimize(res);\n   	}\n   	// Loop (n). Ops: 1R (a). (Breaks early, but n is worst-case).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s332, s332_scalar)->Name(\"Scalar_s332\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s332, s332_simd)->Name(\"SIMD_s332\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s332", "entrypoint_scalar": "s332_scalar", "entrypoint_simd": "s332_simd"}
{"task_id": "tsvc_s341_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a pack operation (compresses 'b' into 'a'):\nif (b[i] > 0.0f) { a[j++] = b[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s341_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s341_scalar(float *a, const float *b, size_t n) {\n   	int j = -1;\n   	for (size_t i = 0; i < n; i++) {\n       	if (b[i] > 0.0f) {\n           	j++;\n           	a[j] = b[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s341_scalar(float *a, const float *b, size_t n);\nvoid s341_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s341\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s341_scalar(a_scalar.data(), b_input.data(), length);\n       	s341_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s341!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s341_scalar(float *a, const float *b, size_t n);\nvoid s341_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s341(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s341\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R (b), 1W (a) (since if is always true). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s341, s341_scalar)->Name(\"Scalar_s341\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s341, s341_simd)->Name(\"SIMD_s341\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s341", "entrypoint_scalar": "s341_scalar", "entrypoint_simd": "s341_simd"}
{"task_id": "tsvc_s342_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an unpack operation (scatters 'b' into 'a'):\nif (a[i] > 0.0f) { a[i] = b[j++]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s342_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s342_scalar(float *a, const float *b, size_t n) {\n   	int j = -1;\n   	for (size_t i = 0; i < n; i++) {\n       	if (a[i] > 0.0f) {\n           	j++;\n           	a[i] = b[j];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s342_scalar(float *a, const float *b, size_t n);\nvoid s342_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s342\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s342_scalar(a_scalar.data(), b_input.data(), length);\n       	s342_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s342!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s342_scalar(float *a, const float *b, size_t n);\nvoid s342_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s342(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s342\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(a), 1R(b), 1W(a) (since if is always true). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s342, s342_scalar)->Name(\"Scalar_s342\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s342, s342_simd)->Name(\"SIMD_s342\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s342", "entrypoint_scalar": "s342_scalar", "entrypoint_simd": "s342_simd"}
{"task_id": "tsvc_s343_AVX", "prompt": "/*\nThis function packs a 2D array 'aa' into a 1D array 'flat_2d_array'.\nIt packs elements from 'aa' where 'bb' is positive.\nif (bb[j][i] > 0.0f) { flat_2d_array[k++] = aa[j][i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n   	int k = -1;\n   	for (size_t i = 0; i < n_2d; i++) {\n       	for (size_t j = 0; j < n_2d; j++) {\n           	if (bb_flat[j * n_2d + i] > 0.0f) {\n             	k++;\n             	flat_2d_array[k] = aa_flat[j * n_2d + i];\n           	}\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length = n_2d * n_2d;\n\n   	std::vector<float> flat_initial(length);\n   	std::vector<float> aa_input(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> flat_scalar(length), flat_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s343\n       	for (size_t i = 0; i < length; ++i) {\n           	flat_initial[i] = 0.0f;\n           	aa_input[i] = 1.0f / (float)(i+1); // frac\n           	bb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       	}\n       	flat_scalar = flat_initial;\n       	flat_simd = flat_initial;\n\n       	s343_scalar(flat_scalar.data(), aa_input.data(), bb_input.data(), n_2d);\n       	s343_simd(flat_simd.data(), aa_input.data(), bb_input.data(), n_2d);\n\n       	if (!allclose(flat_scalar, flat_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s343!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s343(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length = n_2d * n_2d;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> flat_output(length);\n   	std::vector<float> aa_input(length);\n   	std::vector<float> bb_input(length);\n   	std::vector<float> flat_initial(length);\n\n   	// Ported Initialization Logic for s343\n   	for (size_t i = 0; i < length; ++i) {\n       	flat_initial[i] = 0.0f;\n       	aa_input[i] = 1.0f / (float)(i+1); // frac\n       	bb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   	}\n\n   	for (auto _ : state) {\n       	flat_output = flat_initial;\n       	benchmark::DoNotOptimize(flat_output.data());\n       	benchmark::DoNotOptimize(aa_input.data());\n       	benchmark::DoNotOptimize(bb_input.data());\n\n       	Func(flat_output.data(), aa_input.data(), bb_input.data(), n_2d);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d*n_2d). Ops: 2R(bb,aa), 1W(flat) (since if is always true). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s343, s343_scalar)->Name(\"Scalar_s343\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s343, s343_simd)->Name(\"SIMD_s343\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s343", "entrypoint_scalar": "s343_scalar", "entrypoint_simd": "s343_simd"}
{"task_id": "tsvc_s351_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs an unrolled SAXPY operation (loop rerolling).\na[i+k] += alpha * b[i+k]; for k=0..4\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s351_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s351_scalar(float *a, const float *b, const float *c, size_t n) {\n   	float alpha = c[0];\n   	for (size_t i = 0; i < n; i += 5) {\n       	a[i] += alpha * b[i];\n       	a[i + 1] += alpha * b[i + 1];\n       	a[i + 2] += alpha * b[i + 2];\n       	a[i + 3] += alpha * b[i + 3];\n       	a[i + 4] += alpha * b[i + 4];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s351_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s351\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s351_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s351_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s351!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s351_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s351(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s351\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n/5) blocks. 5 ops * (1R/W(a), 1R(b)) = 15 accesses. Total n*3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s351, s351_scalar)->Name(\"Scalar_s351\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s351, s351_simd)->Name(\"SIMD_s351\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s351", "entrypoint_scalar": "s351_scalar", "entrypoint_simd": "s351_simd"}
{"task_id": "tsvc_s1351_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple vector add: a[i] = b[i] + c[i];\nThis tests induction pointer recognition (A++, B++, C++).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s1351_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = b[i] + c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1351\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s1351_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s1351_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1351!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s1351(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s1351\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1351, s1351_scalar)->Name(\"Scalar_s1351\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1351, s1351_simd)->Name(\"SIMD_s1351\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1351", "entrypoint_scalar": "s1351_scalar", "entrypoint_simd": "s1351_simd"}
{"task_id": "tsvc_s352_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an unrolled dot product reduction (loop rerolling).\ndot += a[i]*b[i] + ... + a[i+4]*b[i+4];\nImplement this using AVX intrinsics. The function should return the dot product.\n*/\n#include <immintrin.h>\nfloat s352_simd(const float *a, const float *b, size_t n) {\n}", "solution_scalar": "float s352_scalar(const float *a, const float *b, size_t n) {\n   	float dot = 0.0f;\n   	for (size_t i = 0; i < n; i += 5) {\n       	dot = dot + a[i] * b[i] + a[i + 1] * b[i + 1] + a[i + 2]\n             * b[i + 2] + a[i + 3] * b[i + 3] + a[i + 4] * b[i + 4];\n   	}\n   	return dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s352_scalar(const float *a, const float *b, size_t n);\nfloat s352_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s352 (same as s313)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n\n       	float dot_scalar = s352_scalar(a_input.data(), b_input.data(), length);\n       	float dot_simd = s352_simd(a_input.data(), b_input.data(), length);\n\n       	if (!allclose(dot_scalar, dot_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s352!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s352_scalar(const float *a, const float *b, size_t n);\nfloat s352_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_s352(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n\n   	// Ported Initialization Logic for s352 (same as s313)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	float dot = Func(a_input.data(), b_input.data(), length);\n       	benchmark::DoNotOptimize(dot);\n   	}\n   	// Loop (n/5) blocks. 5 ops * 2R = 10R per block. Total n*2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s352, s352_scalar)->Name(\"Scalar_s352\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s352, s352_simd)->Name(\"SIMD_s352\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s352", "entrypoint_scalar": "s352_scalar", "entrypoint_simd": "s352_simd"}
{"task_id": "tsvc_s353_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and an int array 'ip' (indices).\nIt performs an unrolled sparse SAXPY (a gather operation).\na[i+k] += alpha * b[ip[i+k]]; for k=0..4\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n) {\n}", "solution_scalar": "void s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n) {\n   	float alpha = c[0];\n   	for (size_t i = 0; i < n; i += 5) {\n       	a[i] += alpha * b[ip[i]];\n       	a[i + 1] += alpha * b[ip[i + 1]];\n       	a[i + 2] += alpha * b[ip[i + 2]];\n       	a[i + 3] += alpha * b[ip[i + 3]];\n       	a[i + 4] += alpha * b[ip[i + 4]];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n);\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s353\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s353_scalar(a_scalar.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       	s353_simd(a_simd.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s353!\" << std::endl;\n Next         	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n);\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const int *, size_t)>\nstatic void BM_s353(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s353\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n _simd     	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n/5) blocks. 5 ops * (1R/W(a) + 1R(b) + 1R(ip)) = 15 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * (sizeof(float)*2 + sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s353, s353_scalar)->Name(\"Scalar_s353\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s353, s353_simd)->Name(\"SIMD_s353\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s353", "entrypoint_scalar": "s353_scalar", "entrypoint_simd": "s353_simd"}
{"task_id": "tsvc_s421_AVX", "prompt": "/*\nThis function takes a 1D float array 'a' and a 1D float array 'flat_2d_array'.\nIt performs a recurrence: flat_2d_array[i] = flat_2d_array[i+1] + a[i];\n(Based on xx = flat_2d_array, yy = xx, xx[i] = yy[i+1] + a[i])\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s421_scalar(float* flat_2d_array, const float* a, size_t n) {\n   	// Original: xx = flat_2d_array, yy = xx. Loop: xx[i] = yy[i+1] + a[i]\n   	// This simplifies to: flat_2d_array[i] = flat_2d_array[i+1] + a[i]\n   	for (size_t i = 0; i < n - 1; i++) {\n       	flat_2d_array[i] = flat_2d_array[i + 1] + a[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s421_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> flat_initial(length);\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_scalar(length), flat_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s421\n       	for (size_t i = 0; i < length; ++i) {\n           	flat_initial[i] = 1.0f;\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	flat_scalar = flat_initial;\n       	flat_simd = flat_initial;\n\n       	s421_scalar(flat_scalar.data(), a_input.data(), length);\n       	s421_simd(flat_simd.data(), a_input.data(), length);\n\n       	if (!allclose(flat_scalar, flat_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s421!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s421_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s421(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> flat_output(length);\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_initial(length);\n\n   	// Ported Initialization Logic for s421\n   	for (size_t i = 0; i < length; ++i) {\n       	flat_initial[i] = 1.0f;\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	flat_output = flat_initial;\n       	benchmark::DoNotOptimize(flat_output.data());\n       	benchmark::DoNotOptimize(a_input.data());\n\n       	Func(flat_output.data(), a_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 2R (flat[i+1], a[i]), 1W (flat[i]). Total: 3 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s421, s421_scalar)->Name(\"Scalar_s421\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s421, s421_simd)->Name(\"SIMD_s421\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s421", "entrypoint_scalar": "s421_scalar", "entrypoint_simd": "s421_simd"}
{"task_id": "tsvc_s1421_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an operation with aliased pointers:\nb[i] = xx[i] + a[i]; (where xx = &b[n/2])\nThis simplifies to: b[i] = b[n/2 + i] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1421_simd(float *b, const float *a, size_t n) {\n}", "solution_scalar": "void s1421_scalar(float *b, const float *a, size_t n) {\n   	// Original: xx = &b[n/2]. Loop: b[i] = xx[i] + a[i]\n   	size_t half_n = n / 2;\n   	for (size_t i = 0; i < half_n; i++) {\n       	b[i] = b[half_n + i] + a[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1421_scalar(float *b, const float *a, size_t n);\nvoid s1421_simd(float *b, const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s1421\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s1421_scalar(b_scalar.data(), a_input.data(), length);\n       	s1421_simd(b_simd.data(), a_input.data(), length);\n\n       	if (!allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1421!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1421_scalar(float *b, const float *a, size_t n);\nvoid s1421_simd(float *b, const float *a, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1421(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s1421\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_output.data());\n\n       	Func(b_output.data(), a_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n/2). Ops: 2R (b[half+i], a[i]), 1W (b[i]). Total: 3 accesses.\n   	size_t num_ops = length / 2;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1421, s1421_scalar)->Name(\"Scalar_s1421\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1421, s1421_simd)->Name(\"SIMD_s1421\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1421", "entrypoint_scalar": "s1421_scalar", "entrypoint_simd": "s1421_simd"}
{"task_id": "tsvc_s422_AVX", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', and length 'n'.\nIt performs an operation with aliased pointers and offsets:\nxx = flat_2d_array + 4; xx[i] = flat_2d_array[i + 8] + a[i];\nThis simplifies to: flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s422_scalar(float* flat_2d_array, const float* a, size_t n) {\n   	// Original: xx = flat_2d_array + 4. Loop: xx[i] = flat_2d_array[i + 8] + a[i]\n   	// This simplifies to: flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i]\n   	for (size_t i = 0; i < n; i++) {\n       	flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s422_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> flat_initial(length + 8); // Ensure space for offsets\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_scalar(length + 8), flat_simd(length + 8);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s422\n       	for (size_t i = 0; i < flat_initial.size(); ++i) {\n           	flat_initial[i] = 1.0f;\n       	}\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	flat_scalar = flat_initial;\n       	flat_simd = flat_initial;\n\n       	s422_scalar(flat_scalar.data(), a_input.data(), length);\n       	s422_simd(flat_simd.data(), a_input.data(), length);\n\n       	if (!allclose(flat_scalar, flat_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s422!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s422_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s422(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> flat_output(length + 8);\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_initial(length + 8);\n\n   	// Ported Initialization Logic for s422\n   	for (size_t i = 0; i < flat_initial.size(); ++i) {\n       	flat_initial[i] = 1.0f;\n   	}\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	flat_output = flat_initial;\n       	benchmark::DoNotOptimize(flat_output.data());\n       	benchmark::DoNotOptimize(a_input.data());\n\n       	Func(flat_output.data(), a_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (flat[i+8], a[i]), 1W (flat[i+4]). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s422, s422_scalar)->Name(\"Scalar_s422\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s422, s422_simd)->Name(\"SIMD_s422\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s422", "entrypoint_scalar": "s422_scalar", "entrypoint_simd": "s422_simd"}
{"task_id": "tsvc_s423_AVX", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', length 'n', and 'vl' (offset).\nIt performs an operation with aliased pointers and offsets:\nxx = flat_2d_array + vl; flat_2d_array[i+1] = xx[i] + a[i]; (vl=64)\nThis simplifies to: flat_2d_array[i+1] = flat_2d_array[i + 64] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s423_scalar(float* flat_2d_array, const float* a, size_t n) {\n   	int vl = 64;\n   	// Original: xx = flat_2d_array + vl. Loop: flat_2d_array[i+1] = xx[i] + a[i]\n   	// This simplifies to: flat_2d_array[i + 1] = flat_2d_array[i + vl] + a[i]\n   	for (size_t i = 0; i < n - 1; i++) {\n       	flat_2d_array[i + 1] = flat_2d_array[i + vl] + a[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s423_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int vl = 64;\n\n   	std::vector<float> flat_initial(length + vl); // Ensure space for offsets\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_scalar(length + vl), flat_simd(length + vl);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s423\n       	for (size_t i = 0; i < flat_initial.size(); ++i) {\n           	flat_initial[i] = 1.0f;\n       	}\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	flat_scalar = flat_initial;\n       	flat_simd = flat_initial;\n\n       	s423_scalar(flat_scalar.data(), a_input.data(), length);\n       	s423_simd(flat_simd.data(), a_input.data(), length);\n\n       	if (!allclose(flat_scalar, flat_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s423!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s423_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s423(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	int vl = 64;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> flat_output(length + vl);\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_initial(length + vl);\n\n   	// Ported Initialization Logic for s423\n   	for (size_t i = 0; i < flat_initial.size(); ++i) {\n       	flat_initial[i] = 1.0f;\n   	}\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	flat_output = flat_initial;\n       	benchmark::DoNotOptimize(flat_output.data());\n       	benchmark::DoNotOptimize(a_input.data());\n\n       	Func(flat_output.data(), a_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 2R (flat[i+vl], a[i]), 1W (flat[i+1]). Total: 3 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s423, s423_scalar)->Name(\"Scalar_s423\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s423, s423_simd)->Name(\"SIMD_s423\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s423", "entrypoint_scalar": "s423_scalar", "entrypoint_simd": "s423_simd"}
{"task_id": "tsvc_s424_AVX", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', length 'n', and 'vl' (offset).\nIt performs a recurrence with aliased pointers:\nxx = flat_2d_array + vl; xx[i+1] = flat_2d_array[i] + a[i]; (vl=63)\nThis simplifies to: flat_2d_array[i + 64] = flat_2d_array[i] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s424_scalar(float* flat_2d_array, const float* a, size_t n) {\n   	int vl = 63;\n   	// Original: xx = flat_2d_array + vl. Loop: xx[i+1] = flat_2d_array[i] + a[i]\n   	// This simplifies to: flat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i]\n   	for (size_t i = 0; i < n - 1; i++) {\n       	flat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s424_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int vl = 63;\n\n   	std::vector<float> flat_initial(length + vl + 1); // Ensure space for offsets\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_scalar(length + vl + 1), flat_simd(length + vl + 1);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s424\n       	for (size_t i = 0; i < flat_initial.size(); ++i) {\n           	flat_initial[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	flat_scalar = flat_initial;\n       	flat_simd = flat_initial;\n\n       	s424_scalar(flat_scalar.data(), a_input.data(), length);\n       	s424_simd(flat_simd.data(), a_input.data(), length);\n\n       	if (!allclose(flat_scalar, flat_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s424!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s424_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s424(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	int vl = 63;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> flat_output(length + vl + 1);\n   	std::vector<float> a_input(length);\n   	std::vector<float> flat_initial(length + vl + 1);\n\n   	// Ported Initialization Logic for s424\n   	for (size_t i = 0; i < flat_initial.size(); ++i) {\n       	flat_initial[i] = 1.0f / (float)(i+1); // frac\n   	}\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	flat_output = flat_initial;\n       	benchmark::DoNotOptimize(flat_output.data());\n       	benchmark::DoNotOptimize(a_input.data());\n\n       	Func(flat_output.data(), a_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-1). Ops: 2R (flat[i], a[i]), 1W (flat[i+1+vl]). Total: 3 accesses.\n   	size_t num_ops = length - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s424, s424_scalar)->Name(\"Scalar_s424\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s424, s424_simd)->Name(\"SIMD_s424\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s424", "entrypoint_scalar": "s424_scalar", "entrypoint_simd": "s424_simd"}
{"task_id": "tsvc_s431_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs: a[i] = a[i+k] + b[i]; (where k=0)\nThis simplifies to: a[i] += b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s431_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s431_scalar(float *a, const float *b, size_t n) {\n   	int k = 0;\n   	for (size_t i = 0; i < n; i++) {\n       	// a[i] = a[i+k] + b[i] simplifies to a[i] = a[i] + b[i]\n       	a[i] += b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s431_scalar(float *a, const float *b, size_t n);\nvoid s431_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s431\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s431_scalar(a_scalar.data(), b_input.data(), length);\n       	s431_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s431!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s431_scalar(float *a, const float *b, size_t n);\nvoid s431_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s431(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s431\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1 R/W (a), 1R (b). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s431, s431_scalar)->Name(\"Scalar_s431\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s431, s431_simd)->Name(\"SIMD_s431\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s431", "entrypoint_scalar": "s431_scalar", "entrypoint_simd": "s431_simd"}
{"task_id": "tsvc_s441_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a 3-way conditional operation (arithmetic if):\nif (d[i] < 0) a[i] += b[i] * c[i];\nelse if (d[i] == 0) a[i] += b[i] * b[i];\nelse a[i] += c[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (d[i] < 0.0f) {\n           	a[i] += b[i] * c[i];\n       	} else if (d[i] == 0.0f) {\n           	a[i] += b[i] * b[i];\n       	} else {\n           	a[i] += c[i] * c[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s441\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = (float)(i % 3) - 1.0f; // -1, 0, 1\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s441_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	s441_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s441!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s441(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s441\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = (float)(i % 3) - 1.0f; // -1, 0, 1\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R (d), 1 R/W (a), 2R (b/c). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s441, s441_scalar)->Name(\"Scalar_s441\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s441, s441_simd)->Name(\"SIMD_s441\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s441", "entrypoint_scalar": "s441_scalar", "entrypoint_simd": "s441_simd"}
{"task_id": "tsvc_s442_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', 'indx' and length 'n'.\nIt performs a computed goto (switch-case) operation:\nswitch (indx[i]) {\n  case 1: a[i] += b[i] * b[i]; break;\n  case 2: a[i] += c[i] * c[i]; break;\n  case 3: a[i] += d[i] * d[i]; break;\n  case 4: a[i] += e[i] * e[i]; break;\n}\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n) {\n}", "solution_scalar": "void s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	switch (indx[i]) {\n           	case 1:\n             	a[i] += b[i] * b[i];\n             	break;\n           	case 2:\n             	a[i] += c[i] * c[i];\n             	break;\n           	case 3:\n             	a[i] += d[i] * d[i];\n             	break;\n           	case 4:\n             	a[i] += e[i] * e[i];\n             	break;\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<int> indx_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s442\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f;\n           	indx_input[i] = (int)(i % 4) + 1; // 1, 2, 3, 4\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s442_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n       	s442_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s442!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s442(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<int> indx_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s442\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f;\n       	indx_input[i] = (int)(i % 4) + 1; // 1, 2, 3, 4\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n       	benchmark::DoNotOptimize(indx_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(indx), 1 R/W(a), 2R(b/c/d/e). Total: 4 accesses (3 float, 1 int).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 3 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s442, s442_scalar)->Name(\"Scalar_s442\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s442, s442_simd)->Name(\"SIMD_s442\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s442", "entrypoint_scalar": "s442_scalar", "entrypoint_simd": "s442_simd"}
{"task_id": "tsvc_s443_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a 2-way conditional (arithmetic if):\nif (d[i] <= 0) { a[i] += b[i] * c[i]; }\nelse { a[i] += b[i] * b[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (d[i] <= 0.0f) {\n           	a[i] += b[i] * c[i];\n       	} else {\n           	a[i] += b[i] * b[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s443\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = (float)(i % 2) - 0.5f; // -0.5, 0.5\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s443_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	s443_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s443!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s443(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s443\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = (float)(i % 2) - 0.5f; // -0.5, 0.5\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(d), 1R/W(a), 2R(b,c). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s443, s443_scalar)->Name(\"Scalar_s443\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s443, s443_simd)->Name(\"SIMD_s443\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s443", "entrypoint_scalar": "s443_scalar", "entrypoint_simd": "s443_simd"}
{"task_id": "tsvc_s451_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs intrinsic math functions: a[i] = sinf(b[i]) + cosf(c[i]);\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\n#include <cmath>\nvoid s451_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "#include <cmath>\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = std::sin(b[i]) + std::cos(c[i]);\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s451_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s451\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s451_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s451_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s451!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s451_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s451(benchmark::State& state) {\n g  	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s451\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s451, s451_scalar)->Name(\"Scalar_s451\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s451, s451_simd)->Name(\"SIMD_s451\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s451", "entrypoint_scalar": "s451_scalar", "entrypoint_simd": "s451_simd"}
{"task_id": "tsvc_s452_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] = b[i] + c[i] * (float)(i + 1);\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s452_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s452_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = b[i] + c[i] * (float)(i + 1);\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s452_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s452_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s452\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s452_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s452_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s452!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s452_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s452_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s452(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n i  // Ported Initialization Logic for s452\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n A   	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s452, s452_scalar)->Name(\"Scalar_s452\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s452, s452_simd)->Name(\"SIMD_s452\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s452", "entrypoint_scalar": "s452_scalar", "entrypoint_simd": "s452_simd"}
{"task_id": "tsvc_s453_AVX", "prompt": "/* This function takes float arrays 'a', 'b' and length 'n'.\nIt performs an operation using an induction variable 's':s = 0.0f;\nfor (i=0..n) { s += 2.0f; a[i] = s * b[i]; }\nImplement this using AVX intrinsics.\n*/#include <immintrin.h>\nvoid s453_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s453_scalar(float *a, const float *b, size_t n) {\n   	float s = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	s += 2.0f;\n       	a[i] = s * b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s453_scalar(float *a, const float *b, size_t n);\nvoid s453_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s453 (default init)\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s453_scalar(a_scalar.data(), b_input.data(), length);\n       	s453_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s453!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s453_scalar(float *a, const float *b, size_t n);\nvoid s453_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s453(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s453 (default init)\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R (b), 1W (a). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s453, s453_scalar)->Name(\"Scalar_s453\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s453, s453_simd)->Name(\"SIMD_s453\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s453", "entrypoint_scalar": "s453_scalar", "entrypoint_simd": "s453_simd"}
{"task_id": "tsvc_s471_AVX", "prompt": "/*\nThis function takes float arrays 'x', 'b', 'c', 'd', 'e' and length 'n'.\nIt tests loop distribution dependencies:\n1. x[i] = b[i] + d[i] * d[i];\n2. b[i] = c[i] + d[i] * e[i];\n(Original code had a dummy s471s() call between lines).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	x[i] = b[i] + d[i] * d[i];\n       	// s471s() dummy call removed\n       	b[i] = c[i] + d[i] * e[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> x_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> x_scalar(length), x_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s471\n       	for (size_t i = 0; i < length; ++i) {\n           	x_initial[i] = 0.0f;\n           	b_initial[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	x_scalar = x_initial;\n       	x_simd = x_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s471_scalar(x_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s471_simd(x_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(x_scalar, x_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s471!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n D  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s471(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> x_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> x_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s471\n   	for (size_t i = 0; i < length; ++i) {\n       	x_initial[i] = 0.0f;\n       	b_initial[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	x_output = x_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(x_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(x_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(b), 2R(d), 1W(x), 1R(c), 1R(e), 1W(b). Total: 5R, 2W = 7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s471, s471_scalar)->Name(\"Scalar_s471\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s471, s471_simd)->Name(\"SIMD_s471\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s471", "entrypoint_scalar": "s471_scalar", "entrypoint_simd": "s471_simd"}
{"task_id": "tsvc_s471_AVX", "prompt": "/*\nThis function takes float arrays 'x', 'b', 'c', 'd', 'e' and length 'n'.\nIt tests loop distribution dependencies:\n1. x[i] = b[i] + d[i] * d[i];\n2. b[i] = c[i] + d[i] * e[i];\n(Original code had a dummy s471s() call between lines).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	x[i] = b[i] + d[i] * d[i];\n       	// s471s() dummy call removed\n       	b[i] = c[i] + d[i] * e[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> x_initial(length);\n   	std::vector<float> b_initial(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> x_scalar(length), x_simd(length);\n   	std::vector<float> b_scalar(length), b_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s471\n       	for (size_t i = 0; i < length; ++i) {\n           	x_initial[i] = 0.0f;\n           	b_initial[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n           	e_input[i] = 1.0f;\n       	}\n       	x_scalar = x_initial;\n       	x_simd = x_initial;\n       	b_scalar = b_initial;\n       	b_simd = b_initial;\n\n       	s471_scalar(x_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	s471_simd(x_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       	if (!allclose(x_scalar, x_simd) || !allclose(b_scalar, b_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s471!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n D  	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s471(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> x_output(length);\n   	std::vector<float> b_output(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> x_initial(length);\n   	std::vector<float> b_initial(length);\n\n   	// Ported Initialization Logic for s471\n   	for (size_t i = 0; i < length; ++i) {\n       	x_initial[i] = 0.0f;\n       	b_initial[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n       	e_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	x_output = x_initial;\n       	b_output = b_initial;\n       	benchmark::DoNotOptimize(x_output.data());\n       	benchmark::DoNotOptimize(b_output.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n\n       	Func(x_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(b), 2R(d), 1W(x), 1R(c), 1R(e), 1W(b). Total: 5R, 2W = 7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s471, s471_scalar)->Name(\"Scalar_s471\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s471, s471_simd)->Name(\"SIMD_s471\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s471", "entrypoint_scalar": "s471_scalar", "entrypoint_simd": "s471_simd"}
{"task_id": "tsvc_s481_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs: if (d[i] < 0) break; a[i] += b[i] * c[i];\n(Original code had exit(0), translated to break).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (d[i] < 0.0f) {\n           	break;\n       	}\n       	a[i] += b[i] * c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s481\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n           	d_input[i] = 1.0f / (float)(i+1); // frac (all positive, no break)\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s481_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	s481_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s481!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s481(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s481\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n       	d_input[i] = 1.0f / (float)(i+1); // frac (all positive, no break)\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(d), 1R/W(a), 2R(b,c). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s481, s481_scalar)->Name(\"Scalar_s481\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s481, s481_simd)->Name(\"SIMD_s481\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s481", "entrypoint_scalar": "s481_scalar", "entrypoint_simd": "s481_simd"}
{"task_id": "tsvc_s482_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] += b[i] * c[i]; if (c[i] > b[i]) break;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s482_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s482_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += b[i] * c[i];\n       	if (c[i] > b[i]) break;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s482_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s482_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s482\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	c_input[i] = 1.0f;\n       	}\n       	// c[i] > b[i] will be true for i > 0, so loop breaks at i=1\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s482_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s482_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s482!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s482_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s482_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s482(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s482\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	c_input[i] = 1.0f;\n   	}\n   	// c[i] > b[i] will be true for i > 0, so loop breaks at i=1\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop breaks early, but worst case is (n). Ops: 1R/W(a), 3R(b,c,c,b). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s482, s482_scalar)->Name(\"Scalar_s482\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s482, s482_simd)->Name(\"SIMD_s482\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s482", "entrypoint_scalar": "s482_scalar", "entrypoint_simd": "s482_simd"}
{"task_id": "tsvc_s491_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'ip' and length 'n'.\nIt performs a scatter operation: a[ip[i]] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n) {\n}", "solution_scalar": "void s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[ip[i]] = b[i] + c[i] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s491\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s491_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n       	s491_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s491!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s491(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s491\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R(b,c,d), 1R(ip), 1W(a). Total: 4 float, 1 int access.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 4 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s491, s491_scalar)->Name(\"Scalar_s491\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s491, s491_simd)->Name(\"SIMD_s491\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s491", "entrypoint_scalar": "s491_scalar", "entrypoint_simd": "s491_simd"}
{"task_id": "tsvc_s4112_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', an int array 'ip', float 's' and length 'n'.\nIt performs a sparse SAXPY (gather operation): a[i] += b[ip[i]] * s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n) {\n}", "solution_scalar": "void s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += b[ip[i]] * s;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n);\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	float s = 2.0f;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4112\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s4112_scalar(a_scalar.data(), b_input.data(), ip_input.data(), s, length);\n       	s4112_simd(a_simd.data(), b_input.data(), ip_input.data(), s, length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4112!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n);\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, float, size_t)>\nstatic void BM_s4112(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	float s = 2.0f;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s4112\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), ip_input.data(), s, length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 1R(b via ip), 1R(ip). Total: 2 float, 1 int access.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4112, s4112_scalar)->Name(\"Scalar_s4112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4112, s4112_simd)->Name(\"SIMD_s4112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4112", "entrypoint_scalar": "s4112_scalar", "entrypoint_simd": "s4112_simd"}
{"task_id": "tsvc_s4113_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'ip' and length 'n'.\nIt performs a gather-scatter operation: a[ip[i]] = b[ip[i]] + c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n) {\n}", "solution_scalar": "void s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[ip[i]] = b[ip[i]] + c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n);\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4113\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       S   	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s4113_scalar(a_scalar.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       	s4113_simd(a_simd.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4113!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n);\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s4113(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s4113\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(b via ip), 1R(c), 1R(ip), 1W(a via ip). Total: 3 float, 2 int access.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 3 + int64_t(num_ops) * sizeof(int) * 2));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4113, s4113_scalar)->Name(\"Scalar_s4113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4113, s4113_simd)->Name(\"SIMD_s4113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4113", "entrypoint_scalar": "s4113_scalar", "entrypoint_simd": "s4113_simd"}
{"task_id": "tsvc_s4114_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'ip' and length 'n', 'n1'.\nIt performs a gather operation with complex indexing:\na[i] = b[i] + c[n - k - 1] * d[i]; (k = ip[i])\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1) {\n}", "solution_scalar": "void s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1) {\n   	for (size_t i = (size_t)n1 - 1; i < n; i++) {\n       	int k = ip[i];\n       	// Original: c[LEN_1D-k+1-2] -> c[n-k-1]\n       	a[i] = b[i] + c[n - k - 1] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	int n1 = 1;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4114\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n           	ip_input[i] = (int)((i * 7) % (length / 2)); // Scrambled indices, ensure n-k-1 is valid\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s4114_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n       	s4114_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4114!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const int*, size_t, int)>\nstatic void BM_s4114(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	int n1 = 1;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s4114\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n       	ip_input[i] = (int)((i * 7) % (length / 2)); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n-n1+1). Ops: 3R(b,c via ip,d), 1R(ip), 1W(a). Total: 4 float, 1 int access.\n   	size_t num_ops = length - n1 + 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 4 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4114, s4114_scalar)->Name(\"Scalar_s4114\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4114, s4114_simd)->Name(\"SIMD_s4114\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4114", "entrypoint_scalar": "s4114_scalar", "entrypoint_simd": "s4114_simd"}
{"task_id": "tsvc_s4115_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'ip' and length 'n'.\nIt performs a sparse dot product (gather): sum += a[i] * b[ip[i]];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n) {\n}", "solution_scalar": "float s4115_scalar(const float *a, const float *b, const int* ip, size_t n) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	sum += a[i] * b[ip[i]];\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s4115_scalar(const float *a, const float *b, const int* ip, size_t n);\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4115\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n\n       	float sum_scalar = s4115_scalar(a_input.data(), b_input.data(), ip_input.data(), length);\n       	float sum_simd = s4115_simd(a_input.data(), b_input.data(), ip_input.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4115!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s4115_scalar(const float *a, const float *b, const int* ip, size_t n);\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, const int*, size_t)>\nstatic void BM_s4115(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n\n   	// Ported Initialization Logic for s4115\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	float sum = Func(a_input.data(), b_input.data(), ip_input.data(), length);\n       	\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n). Ops: 1R(a), 1R(b via ip), 1R(ip). Total: 2 float, 1 int access.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4115, s4115_scalar)->Name(\"Scalar_s4115\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4115, s4115_simd)->Name(\"SIMD_s4115\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4115", "entrypoint_scalar": "s4115_scalar", "entrypoint_simd": "s4115_simd"}
{"task_id": "tsvc_s4116_AVX", "prompt": "/*\nThis function takes float array 'a', flattened 2D array 'aa', 'ip', 'n_2d', 'j', 'inc'.\nIt performs a sparse dot product (gather): sum += a[i+inc] * aa[j-1][ip[i]];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc) {\n}", "solution_scalar": "float s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n_2d - 1; i++) {\n       	int off = inc + (int)i;\n       	sum += a[off] * aa_flat[(j - 1) * n_2d + ip[i]];\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nfloat s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length_1d = Small_Arg_1D;\n   	size_t n_2d = Small_Arg_2D;\n   	size_t length_2d = n_2d * n_2d;\n   	int j = 1; \n   	int inc = 1;\n\n   	std::vector<float> a_input(length_1d);\n   	std::vector<float> aa_input(length_2d);\n   	std::vector<int> ip_input(length_1d);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4116\n       	for (size_t i = 0; i < length_1d; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	ip_input[i] = (int)((i * 7) % n_2d); // Scrambled indices within one row\n       	}\n       	for (size_t i = 0; i < length_2d; ++i) {\n           	aa_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n\n       	float sum_scalar = s4116_scalar(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n       	float sum_simd = s4116_simd(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n\n       	if (!allclose(sum_scalar, sum_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4116!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nfloat s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\n\ntemplate<float (*Func)(const float *, const float*, const int*, size_t, int, int)>\nstatic void BM_s4116(benchmark::State& state) {\n   	size_t n_2d = state.range(0);\n   	size_t length_1d = LEN_1D;\n   	size_t length_2d = n_2d * n_2d;\n   	int j = 1; \n   	int inc = 1;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length_1d);\n   	std::vector<float> aa_input(length_2d);\n   	std::vector<int> ip_input(length_1d);\n\n   	// Ported Initialization Logic for s4116\n   	for (size_t i = 0; i < length_1d; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	ip_input[i] = (int)((i * 7) % n_2d); // Scrambled indices\n   	}\n   	for (size_t i = 0; i < length_2d; ++i) {\n       	aa_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(aa_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	float sum = Func(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n       	\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n_2d-1). Ops: 1R(a), 1R(aa via ip), 1R(ip). Total: 2 float, 1 int access.\n   	size_t num_ops = n_2d - 1;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s4116, s4116_scalar)->Name(\"Scalar_s4116\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s4116, s4116_simd)->Name(\"SIMD_s4116\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4116", "entrypoint_scalar": "s4116_scalar", "entrypoint_simd": "s4116_simd"}
{"task_id": "tsvc_s4117_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs: a[i] = b[i] + c[i / 2] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = b[i] + c[i / 2] * d[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4117\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           	d_input[i] = 1.0f;\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s4117_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n S   	s4117_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4117!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n S 	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s4117(benchmark::State& state) {\n I 	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s4117\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	d_input[i] = 1.0f;\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n       	benchmark::DoNotOptimize(d_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n C   	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 3R (b,c,d), 1W (a). Total: 4 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4117, s4117_scalar)->Name(\"Scalar_s4117\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4117, s4117_simd)->Name(\"SIMD_s4117\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4117", "entrypoint_scalar": "s4117_scalar", "entrypoint_simd": "s4117_simd"}
{"task_id": "tsvc_s4121_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] += f(b[i], c[i]); where f(a,b) is a*b.\nThis tests statement functions (inlined).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\n\n// Helper function\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += f(b[i], c[i]);\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for s4121\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	s4121_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	s4121_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4121!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s4121(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for s4121\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4121, s4121_scalar)->Name(\"Scalar_s4121\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4121, s4121_simd)->Name(\"SIMD_s4121\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4121", "entrypoint_scalar": "s4121_scalar", "entrypoint_simd": "s4121_simd"}
{"task_id": "tsvc_va_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector assignment: a[i] = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid va_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void va_scalar(float *a, const float *b, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid va_scalar(float *a, const float *b, size_t n);\nvoid va_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for va\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	va_scalar(a_scalar.data(), b_input.data(), length);\n       	va_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_va!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid va_scalar(float *a, const float *b, size_t n);\nvoid va_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_va(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for va\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(b), 1W(a). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_va, va_scalar)->Name(\"Scalar_va\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_va, va_simd)->Name(\"SIMD_va\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "va", "entrypoint_scalar": "va_scalar", "entrypoint_simd": "va_simd"}
{"task_id": "tsvc_vag_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', int array 'ip' and length 'n'.\nIt performs a vector assignment (gather): a[i] = b[ip[i]];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n) {\n}", "solution_scalar": "void vag_scalar(float *a, const float *b, const int* ip, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = b[ip[i]];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vag_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vag\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vag_scalar(a_scalar.data(), b_input.data(), ip_input.data(), length);\n       	vag_simd(a_simd.data(), b_input.data(), ip_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vag!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vag_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, size_t)>\nstatic void BM_vag(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vag\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), ip_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(b via ip), 1W(a), 1R(ip). Total: 2 float, 1 int access.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vag, vag_scalar)->Name(\"Scalar_vag\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vag, vag_simd)->Name(\"SIMD_vag\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vag", "entrypoint_scalar": "vag_scalar", "entrypoint_simd": "vag_simd"}
{"task_id": "tsvc_vas_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', int array 'ip' and length 'n'.\nIt performs a vector assignment (scatter): a[ip[i]] = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n) {\n}", "solution_scalar": "void vas_scalar(float *a, const float *b, const int* ip, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[ip[i]] = b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vas_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vas\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 0.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vas_scalar(a_scalar.data(), b_input.data(), ip_input.data(), length);\n       	vas_simd(a_simd.data(), b_input.data(), ip_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vas!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vas_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, size_t)>\nstatic void BM_vas(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<int> ip_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vas\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 0.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	ip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(ip_input.data());\n\n       	Func(a_output.data(), b_input.data(), ip_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R(b), 1W(a via ip), 1R(ip). Total: 2 float, 1 int access.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vas, vas_scalar)->Name(\"Scalar_vas\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vas, vas_simd)->Name(\"SIMD_vas\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vas", "entrypoint_scalar": "vas_scalar", "entrypoint_simd": "vas_simd"}
{"task_id": "tsvc_vif_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a conditional vector assignment: if (b[i] > 0.0f) a[i] = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vif_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void vif_scalar(float *a, const float *b, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	if (b[i] > 0.0f) {\n           	a[i] = b[i];\n       	}\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vif_scalar(float *a, const float *b, size_t n);\nvoid vif_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vif\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = (float)(i % 10) - 5.0f; // Mix of positive and negative\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vif_scalar(a_scalar.data(), b_input.data(), length);\n       	vif_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vif!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vif_scalar(float *a, const float *b, size_t n);\nvoid vif_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vif(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vif\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = (float)(i % 10) - 5.0f; // Mix of positive and negative\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 2R(b,b), 1W(a). Total: 3 accesses (worst case).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vif, vif_scalar)->Name(\"Scalar_vif\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vif, vif_simd)->Name(\"SIMD_vif\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vif", "entrypoint_scalar": "vif_scalar", "entrypoint_simd": "vif_simd"}
{"task_id": "tsvc_vpv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector plus vector: a[i] += b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpv_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void vpv_scalar(float *a, const float *b, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpv_scalar(float *a, const float *b, size_t n);\nvoid vpv_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vpv\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vpv_scalar(a_scalar.data(), b_input.data(), length);\n       	vpv_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpv!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpv_scalar(float *a, const float *b, size_t n);\nvoid vpv_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vpv(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vpv\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpv, vpv_scalar)->Name(\"Scalar_vpv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpv, vpv_simd)->Name(\"SIMD_vpv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpv", "entrypoint_scalar": "vpv_scalar", "entrypoint_simd": "vpv_simd"}
{"task_id": "tsvc_vtv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector times vector: a[i] *= b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vtv_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void vtv_scalar(float *a, const float *b, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] *= b[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vtv_scalar(float *a, const float *b, size_t n);\nvoid vtv_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vtv\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vtv_scalar(a_scalar.data(), b_input.data(), length);\n       	vtv_simd(a_simd.data(), b_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vtv!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vtv_scalar(float *a, const float *b, size_t n);\nvoid vtv_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vtv(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vtv\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n s 	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vtv, vtv_scalar)->Name(\"Scalar_vtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vtv, vtv_simd)->Name(\"SIMD_vtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vtv", "entrypoint_scalar": "vtv_scalar", "entrypoint_simd": "vtv_simd"}
{"task_id": "tsvc_vpvtv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector plus vector times vector: a[i] += b[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void vpvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += b[i] * c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vpvtv\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vpvtv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	vpvtv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvtv!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vpvtv(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vpvtv\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvtv, vpvtv_scalar)->Name(\"Scalar_vpvtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvtv, vpvtv_simd)->Name(\"SIMD_vpvtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvtv", "entrypoint_scalar": "vpvtv_scalar", "entrypoint_simd": "vpvtv_simd"}
{"task_id": "tsvc_vpvts_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', a scalar 's' and length 'n'.\nIt performs a vector plus vector times scalar: a[i] += b[i] * s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpvts_simd(float *a, const float *b, float s, size_t n) {\n}", "solution_scalar": "void vpvts_scalar(float *a, const float *b, float s, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += b[i] * s;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvts_scalar(float *a, const float *b, float s, size_t n);\nvoid vpvts_simd(float *a, const float *b, float s, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n   	float s = 2.0f;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vpvts\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vpvts_scalar(a_scalar.data(), b_input.data(), s, length);\n       	vpvts_simd(a_simd.data(), b_input.data(), s, length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvts!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvts_scalar(float *a, const float *b, float s, size_t n);\nvoid vpvts_simd(float *a, const float *b, float s, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float, size_t)>\nstatic void BM_vpvts(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	float s = 2.0f;\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vpvts\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n\n       	Func(a_output.data(), b_input.data(), s, length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvts, vpvts_scalar)->Name(\"Scalar_vpvts\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvts, vpvts_simd)->Name(\"SIMD_vpvts\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvts", "entrypoint_scalar": "vpvts_scalar", "entrypoint_simd": "vpvts_simd"}
{"task_id": "tsvc_vpvpv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector plus vector plus vector: a[i] += b[i] + c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void vpvpv_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] += b[i] + c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvpv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vpvpv\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vpvpv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	vpvpv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvpv!\" << std::endl;\n S     	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvpv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vpvpv(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vpvpv\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvpv, vpvpv_scalar)->Name(\"Scalar_vpvpv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvpv, vpvpv_simd)->Name(\"SIMD_vpvpv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvpv", "entrypoint_scalar": "vpvpv_scalar", "entrypoint_simd": "vpvpv_simd"}
{"task_id": "tsvc_vtvtv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector times vector times vector: a[i] = a[i] * b[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void vtvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n   	for (size_t i = 0; i < n; i++) {\n       	a[i] = a[i] * b[i] * c[i];\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vtvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_initial(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_scalar(length), a_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vtvtv\n       	for (size_t i = 0; i < length; ++i) {\n           	a_initial[i] = 1.0f;\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n       	a_scalar = a_initial;\n       	a_simd = a_initial;\n\n       	vtvtv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       	vtvtv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       	if (!allclose(a_scalar, a_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vtvtv!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vtvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vtvtv(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_output(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> a_initial(length);\n\n   	// Ported Initialization Logic for vtvtv\n   	for (size_t i = 0; i < length; ++i) {\n       	a_initial[i] = 1.0f;\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	a_output = a_initial;\n       	benchmark::DoNotOptimize(a_output.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n\n       	Func(a_output.data(), b_input.data(), c_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vtvtv, vtvtv_scalar)->Name(\"Scalar_vtvtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vtvtv, vtvtv_simd)->Name(\"SIMD_vtvtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vtvtv", "entrypoint_scalar": "vtvtv_scalar", "entrypoint_simd": "vtvtv_simd"}
{"task_id": "tsvc_vsumr_AVX", "prompt": "/*\nThis function takes float array 'a' and length 'n'.\nIt performs a vector sum reduction: sum += a[i];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat vsumr_simd(const float *a, size_t n) {\n}", "solution_scalar": "float vsumr_scalar(const float *a, size_t n) {\n   	float sum = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	sum += a[i];\n   	}\n   	return sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat vsumr_scalar(const float *a, size_t n);\nfloat vsumr_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vsumr\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n\n       	float sum_scalar = vsumr_scalar(a_input.data(), length);\n       	float sum_simd = vsumr_simd(a_input.data(), length);\n\n       	if (!allclose(sum_scalar, sum_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vsumr!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat vsumr_scalar(const float *a, size_t n);\nfloat vsumr_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_vsumr(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n\n   	// Ported Initialization Logic for vsumr\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	float sum = Func(a_input.data(), length);\n       	benchmark::DoNotOptimize(sum);\n   	}\n   	// Loop (n). Ops: 1R (a).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vsumr, vsumr_scalar)->Name(\"Scalar_vsumr\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vsumr, vsumr_simd)->Name(\"SIMD_vsumr\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vsumr", "entrypoint_scalar": "vsumr_scalar", "entrypoint_simd": "vsumr_simd"}
{"task_id": "tsvc_vdotr_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector dot product reduction: dot += a[i] * b[i];\nImplement this using AVX intrinsics. The function should return the dot product.\n*/\n#include <immintrin.h>\nfloat vdotr_simd(const float *a, const float *b, size_t n) {\n}", "solution_scalar": "float vdotr_scalar(const float *a, const float *b, size_t n) {\n   	float dot = 0.0f;\n   	for (size_t i = 0; i < n; i++) {\n       	dot += a[i] * b[i];\n   	}\n   	return dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat vdotr_scalar(const float *a, const float *b, size_t n);\nfloat vdotr_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_1D;\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vdotr\n       	for (size_t i = 0; i < length; ++i) {\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       	}\n\n       	float dot_scalar = vdotr_scalar(a_input.data(), b_input.data(), length);\n       	float dot_simd = vdotr_simd(a_input.data(), b_input.data(), length);\n\n       	if (!allclose(dot_scalar, dot_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vdotr!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n t 	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat vdotr_scalar(const float *a, const float *b, size_t n);\nfloat vdotr_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_vdotr(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n\n   	// Ported Initialization Logic for vdotr\n   	for (size_t i = 0; i < length; ++i) {\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   	}\n\n   	for (auto _ : state) {\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	float dot = Func(a_input.data(), b_input.data(), length);\n       	benchmark::DoNotOptimize(dot);\n   	}\n   	// Loop (n). Ops: 2R (a, b).\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vdotr, vdotr_scalar)->Name(\"Scalar_vdotr\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vdotr, vdotr_simd)->Name(\"SIMD_vdotr\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vdotr", "entrypoint_scalar": "vdotr_scalar", "entrypoint_simd": "vdotr_simd"}
{"task_id": "tsvc_vbor_AVX", "prompt": "/*\nThis function takes float arrays 'x', 'a', 'b', 'c', 'd', 'e', 'aa_flat' and length 'n_2d'.\nIt performs a complex series of arithmetic operations (basic operations rates).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "void vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n   	for (size_t i = 0; i < n_2d; i++) {\n       	float a1 = a[i];\n       	float b1 = b[i];\n       	float c1 = c[i];\n       	float d1 = d[i];\n       	float e1 = e[i];\n       	float f1 = aa_flat[i]; // Original was aa[0][i]\n       	a1 = a1 * b1 * c1 + a1 * b1 * d1 + a1 * b1 * e1 + a1 * b1 * f1 +\n             	a1 * c1 * d1 + a1 * c1 * e1 + a1 * c1 * f1 + a1 * d1 * e1\n             	+ a1 * d1 * f1 + a1 * e1 * f1;\n       	b1 = b1 * c1 * d1 + b1 * c1 * e1 + b1 * c1 * f1 + b1 * d1 * e1 +\n             	b1 * d1 * f1 + b1 * e1 * f1;\n       	c1 = c1 * d1 * e1 + c1 * d1 * f1 + c1 * e1 * f1;\n g   	d1 = d1 * e1 * f1;\n       	x[i] = a1 * b1 * c1 * d1;\n   	}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   	Random rng;\n   	size_t length = Small_Arg_2D;\n\n   	std::vector<float> x_initial(length);\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> aa_flat_input(length);\n   	std::vector<float> x_scalar(length), x_simd(length);\n\n   	for (int iter = 0; iter < iterations; ++iter) {\n       	// Ported Initialization Logic for vbor\n       	for (size_t i = 0; i < length; ++i) {\n           	x_initial[i] = 0.0f;\n           	a_input[i] = 1.0f / (float)(i+1); // frac\n           	b_input[i] = 1.0f / (float)(i+1); // frac\n           	c_input[i] = 1.0f / (float)(i+1); // frac\n           	d_input[i] = 1.0f / (float)(i+1); // frac\n           	e_input[i] = 1.0f / (float)(i+1); // frac\n           	aa_flat_input[i] = 1.0f / (float)(i+1); // frac\n       	}\n       	x_scalar = x_initial;\n       	x_simd = x_initial;\n\n       	vbor_scalar(x_scalar.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n       	vbor_simd(x_simd.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n\n       	if (!allclose(x_scalar, x_simd)) {\n           	if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vbor!\" << std::endl;\n           	return false;\n       	}\n   	}\n   	return true;\n}\n\nint main() {\n   	bool pass = correctness_check(ITERATIONS);\n   	printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   	return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, const float *, const float*, size_t)>\nstatic void BM_vbor(benchmark::State& state) {\n   	size_t length = state.range(0);\n   	Random rng(DEFAULT_SEED);\n\n   	std::vector<float> x_output(length);\n   	std::vector<float> a_input(length);\n   	std::vector<float> b_input(length);\n   	std::vector<float> c_input(length);\n   	std::vector<float> d_input(length);\n   	std::vector<float> e_input(length);\n   	std::vector<float> aa_flat_input(length);\n   	std::vector<float> x_initial(length);\n\n   	// Ported Initialization Logic for vbor\n   	for (size_t i = 0; i < length; ++i) {\n       	x_initial[i] = 0.0f;\n       	a_input[i] = 1.0f / (float)(i+1); // frac\n       	b_input[i] = 1.0f / (float)(i+1); // frac\n       	c_input[i] = 1.0f / (float)(i+1); // frac\n       	d_input[i] = 1.0f / (float)(i+1); // frac\n       	e_input[i] = 1.0f / (float)(i+1); // frac\n       	aa_flat_input[i] = 1.0f / (float)(i+1); // frac\n   	}\n\n   	for (auto _ : state) {\n       	x_output = x_initial;\n       	benchmark::DoNotOptimize(x_output.data());\n       	benchmark::DoNotOptimize(a_input.data());\n       	benchmark::DoNotOptimize(b_input.data());\n       	benchmark::DoNotOptimize(c_input.data());\n D   	benchmark::DoNotOptimize(d_input.data());\n       	benchmark::DoNotOptimize(e_input.data());\n       	benchmark::DoNotOptimize(aa_flat_input.data());\n\n       	Func(x_output.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n       	\n       	benchmark::ClobberMemory();\n   	}\n   	// Loop (n_2d). Ops: 6R(a,b,c,d,e,aa_flat), 1W(x). Total: 7 accesses.\n   	size_t num_ops = length;\n   	state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_vbor, vbor_scalar)->Name(\"Scalar_vbor\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_vbor, vbor_simd)->Name(\"SIMD_vbor\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vbor", "entrypoint_scalar": "vbor_scalar", "entrypoint_simd": "vbor_simd"}
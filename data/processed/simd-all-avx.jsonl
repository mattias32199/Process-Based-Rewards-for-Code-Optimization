{"task_id": "SimdBench_0_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n}", "solution_scalar": "void conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) dst[i] = src[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int64_t> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int64_t> dst_simd(dst); \n        std::vector<uint8_t> mask(length); rng.initialize_vector_with_random_values(mask, true);\n\n        conditional_move(src.data(), dst.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        conditional_move_simd(src.data(), dst_simd.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t *, int64_t *, const bool *, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int64_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int64_t> dst(length); rng.initialize_vector_with_random_values(dst);\n    std::vector<uint8_t> mask(length); rng.initialize_vector_with_random_values(mask, true);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_move)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_move_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "conditional_move", "entrypoint_simd": "conditional_move_simd"}
{"task_id": "SimdBench_1_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n}", "solution_scalar": "void load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        size_t length = Small_Arg_1D;\n        std::vector<int> src(length); for ( auto & element : src) { element = rng.randint(- (1 << 12), 1 << 12); }\n        std::vector<int> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int> dst_simd(dst);\n        int scale = rng.randint(-100, 100);\n\n        load_modify_store(src.data(), dst.data(), scale, length);\n        load_modify_store_simd(src.data(), dst_simd.data(), scale, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const int *, int *, int, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> src(length); for ( auto & element : src) { element = rng.randint(0, 1 << 12); }\n    std::vector<int> dst(length); rng.initialize_vector_with_random_values(dst);\n    std::vector<int> dst_simd(dst);\n    int scale = rng.randint(1, 100);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), scale, length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, load_modify_store)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, load_modify_store_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "load_modify_store", "entrypoint_simd": "load_modify_store_simd"}
{"task_id": "SimdBench_2_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n}", "solution_scalar": "void strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<double> dst(rows); rng.initialize_vector_with_random_values(dst);\n        std::vector<double> dst_simd(dst);\n        size_t stride = rng.randint(size_t(0), cols - 1);\n\n        strided_load_store(src.data(), dst.data(), rows, cols, stride);\n        strided_load_store_simd(src.data(), dst_simd.data(), rows, cols, stride);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const double *, double *, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<double> dst(rows); rng.initialize_vector_with_random_values(dst);\n    std::vector<double> dst_simd(dst);\n    size_t stride = rng.randint(size_t(0), cols - 1);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, stride);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, strided_load_store)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, strided_load_store_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "strided_load_store", "entrypoint_simd": "strided_load_store_simd"}
{"task_id": "SimdBench_3_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n}", "solution_scalar": "void indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_1D;\n        std::vector<float> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int> indices(length); for(auto& index : indices){ index = rng.randint(size_t(0), length - 1); }\n        std::vector<float> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<float> dst_simd(dst);\n\n        indexed_access(src.data(), indices.data(), dst.data(), length);\n        indexed_access_simd(src.data(), indices.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const float *, const int *, float *, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int> indices(length); for(auto& index : indices){ index = rng.randint(size_t(0), length - 1); }\n    std::vector<float> dst(length); rng.initialize_vector_with_random_values(dst);\n    \n    for (auto _ : state) {\n        Func(src.data(), indices.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, indexed_access)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, indexed_access_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "indexed_access", "entrypoint_simd": "indexed_access_simd"}
{"task_id": "SimdBench_4_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 16-bit non-empty integer array (arr);\n- The 64-bit starting index (start);\n- The 64-bit ending index (end).\n\nYour goal is to reverse the elements in the array between the start and end indices (inclusive), the remaining elements should be unchanged.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n}", "solution_scalar": "void range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        int length = Small_Arg_1D;\n        std::vector<int16_t> arr(length); rng.initialize_vector_with_random_values(arr);\n        std::vector<int16_t> arr_simd(arr);\n        uint64_t start = rng.randint<uint64_t>(0, length - 1);\n        uint64_t end = rng.randint<uint64_t>(start, length - 1);\n        range_reverse(arr.data(), start, end);\n        range_reverse_simd(arr_simd.data(), start, end);\n        \n        if(!allclose(arr, arr_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(int16_t *, uint64_t, uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    int length = state.range(0);\n    std::vector<int16_t> arr(length); rng.initialize_vector_with_random_values(arr);\n    int start = rng.randint(0, length - 1);\n    int end = rng.randint(start, length - 1);\n    \n    for (auto _ : state) {\n        Func(arr.data(), start, end);\n        benchmark::DoNotOptimize(arr.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, range_reverse)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, range_reverse_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "range_reverse", "entrypoint_simd": "range_reverse_simd"}
{"task_id": "SimdBench_5_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n}", "solution_scalar": "void extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n// Extract 2D slice from 3D tensor at given index\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        size_t slice_idx = rng.randint(size_t(0), dim3 - 1);\n        \n        std::vector<uint8_t> tensor(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor);\n        std::vector<uint8_t> slice(dim1 * dim2); rng.initialize_vector_with_random_values(slice);\n        std::vector<uint8_t> slice_simd(slice);\n\n        extract_tensor_slice(tensor.data(), slice.data(), dim1, dim2, dim3, slice_idx);\n        extract_tensor_slice_simd(tensor.data(), slice_simd.data(), dim1, dim2, dim3, slice_idx);\n        \n        if(!allclose(slice, slice_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const uint8_t *, uint8_t *, size_t, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    size_t slice_idx = rng.randint(size_t(0), dim3 - 1);\n    \n    std::vector<uint8_t> tensor(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor);\n    std::vector<uint8_t> slice(dim1 * dim2); rng.initialize_vector_with_random_values(slice);\n    std::vector<uint8_t> slice_simd(slice);\n    \n    for (auto _ : state) {\n        Func(tensor.data(), slice.data(), dim1, dim2, dim3, slice_idx);\n        benchmark::DoNotOptimize(slice.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, extract_tensor_slice)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, extract_tensor_slice_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "extract_tensor_slice", "entrypoint_simd": "extract_tensor_slice_simd"}
{"task_id": "SimdBench_6_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- The block size (block_size).\n\nThe matrix src and dst are represented as 1D arrays in memory.\nYour goal is to transpose the matrix in a blocked manner.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n}", "solution_scalar": "void blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size) < rows ? (i + block_size) : rows;\n            size_t j_end = (j + block_size) < cols ? (j + block_size) : cols;\n            \n            for (size_t ii = i; ii < i_end; ii++) {\n                for (size_t jj = j; jj < j_end; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        size_t block_size = rng.randint(size_t(1), std::min(rows, cols));\n        std::vector<int16_t> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<int16_t> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n        std::vector<int16_t> dst_simd(dst);\n\n        blocked_matrix_transpose(src.data(), dst.data(), rows, cols, block_size);\n        blocked_matrix_transpose_simd(src.data(), dst_simd.data(), rows, cols, block_size);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int16_t *, int16_t*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    size_t block_size = rng.randint(size_t(1), std::min(rows, cols));\n    std::vector<int16_t> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<int16_t> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, block_size);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, blocked_matrix_transpose)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, blocked_matrix_transpose_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "blocked_matrix_transpose", "entrypoint_simd": "blocked_matrix_transpose_simd"}
{"task_id": "SimdBench_7_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n}", "solution_scalar": "float diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i]; // Accessing the diagonal element\n    }\n    return sum;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_3D;\n        std::vector<float> array(length*length*length); rng.initialize_vector_with_random_values(array);\n        std::vector<float> array_simd(array);\n        float sum = diagonal_sum_3d(array.data(), length);\n        float sum_simd = diagonal_sum_3d_simd(array_simd.data(), length);\n        if(!allclose(sum, sum_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> array(length*length*length); rng.initialize_vector_with_random_values(array);\n    std::vector<float> array_simd(array);\n    for (auto _ : state) {\n        Func(array.data(), length);\n        benchmark::DoNotOptimize(array.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, diagonal_sum_3d)->Name(\"Scalar\")->RangeMultiplier(2)->Range(1 << 3, 1 << 7);\nBENCHMARK_TEMPLATE(BM, diagonal_sum_3d_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(1 << 3, 1 << 7);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "diagonal_sum_3d", "entrypoint_simd": "diagonal_sum_3d_simd"}
{"task_id": "SimdBench_8_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A threshold value (threshold);\n- A scale factor (scale).\n\nYour goal is to apply a conditional scaling operation on the source array.\nIf the value is greater than the threshold, scale it by the scale factor; otherwise, keep it unchanged.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n}", "solution_scalar": "void conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            dst[i * cols + j] = (val > threshold) ? val * scale : val;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n        std::vector<double> dst_simd(dst);\n        double threshold = rng.uniform(0.0f, 100.0f);\n        double scale = rng.uniform(-10.0f, 10.0f);\n\n        conditional_scale(src.data(), dst.data(), rows, cols, threshold, scale);\n        conditional_scale_simd(src.data(), dst_simd.data(), rows, cols, threshold, scale);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const double*, double*, size_t, size_t, double, double)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n    std::vector<double> dst_simd(dst);\n    double threshold = rng.uniform(0.0f, 100.0f);\n    double scale = rng.uniform(-10.0f, 10.0f);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, threshold, scale);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_scale)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, conditional_scale_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "conditional_scale", "entrypoint_simd": "conditional_scale_simd"}
{"task_id": "SimdBench_9_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n}", "solution_scalar": "void reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        Random rng;\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<size_t> indices(rows);\n        for (auto & index : indices) {\n            index = rng.randint(size_t(0), rows - 1);\n        }\n        std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n        std::vector<double> dst_simd(dst);\n\n        reorder_matrix_rows(src.data(), dst.data(), rows, cols, indices.data());\n        reorder_matrix_rows_simd(src.data(), dst_simd.data(), rows, cols, indices.data());\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const double*, double*, size_t, size_t, const size_t*)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<size_t> indices(rows);\n    for (auto & index : indices) {\n        index = rng.randint(size_t(0), rows - 1);\n    }\n    std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, indices.data());\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, reorder_matrix_rows)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, reorder_matrix_rows_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "reorder_matrix_rows", "entrypoint_simd": "reorder_matrix_rows_simd"}
{"task_id": "SimdBench_10_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n}", "solution_scalar": "void vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> src1(length); for ( auto & element : src1) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n        std::vector<int64_t> src2(length); for ( auto & element : src2) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n        std::vector<int64_t> dst(length); \n        std::vector<int64_t> dst_simd(length);\n        int64_t scalar = rng.randint<int64_t>(- (1 << 28), 1 << 28);\n\n        vector_vector_add(src1.data(), src2.data(), dst.data(), scalar, length);\n        vector_vector_add_simd(src1.data(), src2.data(), dst_simd.data(), scalar, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int64_t> src1(length); for ( auto & element : src1) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n    std::vector<int64_t> src2(length); for ( auto & element : src2) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n    std::vector<int64_t> dst(length); \n    int64_t scalar = rng.randint<int64_t>(- (1 << 28), 1 << 28);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), scalar, length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_vector_add)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_vector_add_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "vector_vector_add", "entrypoint_simd": "vector_vector_add_simd"}
{"task_id": "SimdBench_11_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find and return the minimum value among the even-numbered elements in the array..\nIf the array is empty, return -1.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nint vector_even_min_simd(const int *src, size_t length){\n}", "solution_scalar": "int vector_even_min(const int *src, size_t length) {\n    if(src == NULL || length <= 0) return -1;\n    int min_val = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] < min_val && i % 2 == 0) min_val = src[i];\n    }\n    return min_val;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(1024));\n        std::vector<int> src(length); \n        rng.initialize_vector_with_random_values(src);\n\n        int scalar_result = vector_even_min(src.data(), length);\n        int simd_result = vector_even_min_simd(src.data(), length);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const int*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int> src(length); \n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        int result = Func(src.data(), length);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_even_min)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_even_min_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "vector_even_min", "entrypoint_simd": "vector_even_min_simd"}
{"task_id": "SimdBench_12_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n}", "solution_scalar": "void mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[i] >> shift; // Arithmetic shift\n        dst[i] += (int)((unsigned int)src[i] >> shift); // Logical shift\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        uint8_t shift = rng.randint<uint8_t>(0, 31);\n        std::vector<int> src(length); \n        rng.initialize_vector_with_random_values(src);\n        std::vector<int> dst(length);\n        std::vector<int> dst_simd(length);\n\n        mixed_right_shift(src.data(), dst.data(), shift, length);\n        mixed_right_shift_simd(src.data(), dst_simd.data(), shift, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed! Shift: \" << shift << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int*, int*, uint8_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    uint8_t shift = rng.randint<uint8_t>(1, 31);\n    std::vector<int> src(length); \n    rng.initialize_vector_with_random_values(src);\n    std::vector<int> dst(length);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), shift, length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, mixed_right_shift)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, mixed_right_shift_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "mixed_right_shift", "entrypoint_simd": "mixed_right_shift_simd"}
{"task_id": "SimdBench_13_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n}", "solution_scalar": "int64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<int> matrix(rows * cols);\n        rng.initialize_vector_with_random_values(matrix);\n\n        int64_t scalar_result = matrix_sum(matrix.data(), rows, cols);\n        int64_t simd_result = matrix_sum_simd(matrix.data(), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const int*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<int> matrix(rows * cols);\n    rng.initialize_vector_with_random_values(matrix);\n\n    for (auto _ : state) {\n        int result = Func(matrix.data(), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_sum)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_sum_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "matrix_sum", "entrypoint_simd": "matrix_sum_simd"}
{"task_id": "SimdBench_14_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n}", "solution_scalar": "size_t argmax(const int8_t *src ,size_t length) {\n    if(src == NULL) return size_t(0);\n    size_t index = 0;\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > src[index]) index = i;\n    }\n    return index;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int8_t> src(length);\n        rng.initialize_vector_with_random_values(src);\n\n        size_t scalar_result = argmax(src.data(), length);\n        size_t simd_result = argmax_simd(src.data(), length);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result index: \" << scalar_result \n                          << \" (value: \" << src[scalar_result] << \")\" << std::endl;\n                std::cerr << \"SIMD result index: \" << simd_result\n                          << \" (value: \" << src[simd_result] << \")\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<size_t (*Func)(const int8_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int8_t> src(length);\n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        size_t result = Func(src.data(), length);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, argmax)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, argmax_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "argmax", "entrypoint_simd": "argmax_simd"}
{"task_id": "SimdBench_15_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n}", "solution_scalar": "void vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        uint32_t mask = rng.randint<uint32_t>();\n        std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<uint16_t> dst(length);\n        std::vector<uint16_t> dst_simd(length);\n\n        vector_blend(src1.data(), src2.data(), mask, dst.data(), length);\n        vector_blend_simd(src1.data(), src2.data(), mask, dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed! Mask: \" << mask << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    uint32_t mask = rng.randint<uint32_t>();\n    std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<uint16_t> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), mask, dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_blend)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_blend_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "vector_blend", "entrypoint_simd": "vector_blend_simd"}
{"task_id": "SimdBench_16_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint32_t source array (src);\n- A pointer to a non-empty uint32_t destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the population count (the number of 1 bits in the binary representation of an integer) \nfor each element in the array.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n}", "solution_scalar": "void population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        dst[i] = (((x + (x >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> src(length); \n        rng.initialize_vector_with_random_values(src);\n        std::vector<uint32_t> dst(length);\n        std::vector<uint32_t> dst_simd(length);\n\n        population_count(src.data(), dst.data(), length);\n        population_count_simd(src.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<uint32_t> src(length);\n    rng.initialize_vector_with_random_values(src);\n    std::vector<uint32_t> dst(length);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, population_count)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, population_count_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "population_count", "entrypoint_simd": "population_count_simd"}
{"task_id": "SimdBench_17_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit unsigned integer source array (src1);\n- A pointer to a non-empty 16-bit unsigned integer source array (src2);\n- A pointer to a non-empty 16-bit unsigned integer destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the element-wise addition of two arrays (src1 and src2)\nand store the result in the destination array (dst).\nThe addition should be saturating, meaning that if the result exceeds the maximum value for uint16_t,\nit should be clamped to UINT16_MAX.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n}", "solution_scalar": "void saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint16_t sum = src1[i] + src2[i];\n        dst[i] = (sum < src1[i]) ? UINT16_MAX : sum;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<uint16_t> dst(length);\n        std::vector<uint16_t> dst_simd(length);\n\n        if (i == 0) {\n            src1[0] = UINT16_MAX;\n            src2[0] = 1;\n        }\n\n        saturating_add(src1.data(), src2.data(), dst.data(), length);\n        saturating_add_simd(src1.data(), src2.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"First mismatch at index: \";\n                for (size_t j = 0; j < length; j++) {\n                    if (dst[j] != dst_simd[j]) {\n                        std::cerr << j << \" (scalar: \" << dst[j] \n                                  << \", SIMD: \" << dst_simd[j] \n                                  << \", src1: \" << src1[j]\n                                  << \", src2: \" << src2[j] << \")\" << std::endl;\n                        break;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint16_t*, const uint16_t*, uint16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<uint16_t> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, saturating_add)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, saturating_add_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "saturating_add", "entrypoint_simd": "saturating_add_simd"}
{"task_id": "SimdBench_18_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n}", "solution_scalar": "void range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i*p + j] = sum;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        size_t p = Small_Arg_2D;\n        \n        std::vector<double> A(m * n);\n        for(auto & item: A) { item = rng.normal_distribution<double>(); }\n        std::vector<double> B(n * p);\n        for(auto & item: B) { item = rng.normal_distribution<double>(); }\n        std::vector<double> C(m * p);\n        std::vector<double> C_simd(C);\n\n        range_matrix_mul(A.data(), B.data(), C.data(), m, n, p);\n        range_matrix_mul_simd(A.data(), B.data(), C_simd.data(), m, n, p);\n        \n        if(!allclose(C, C_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    size_t p = state.range(2);\n    \n    std::vector<double> A(m * n);\n    for(auto & item: A) { item = rng.normal_distribution<double>(); }\n    std::vector<double> B(n * p);\n    for(auto & item: B) { item = rng.normal_distribution<double>(); }\n    std::vector<double> C(m * p);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), m, n, p);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, range_matrix_mul)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, range_matrix_mul_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "range_matrix_mul", "entrypoint_simd": "range_matrix_mul_simd"}
{"task_id": "SimdBench_19_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t idx = i*dim2*dim3 + j*dim3 + k;\n                C[idx] = A[idx] + B[idx];\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        \n        std::vector<int64_t> A(dim1 * dim2 * dim3); for ( auto & element : A) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n        std::vector<int64_t> B(dim1 * dim2 * dim3); for ( auto & element : B) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n        std::vector<int64_t> C(dim1 * dim2 * dim3);\n        std::vector<int64_t> C_simd(dim1 * dim2 * dim3);\n\n        tensor_add_3d(A.data(), B.data(), C.data(), dim1, dim2, dim3);\n        tensor_add_3d_simd(A.data(), B.data(), C_simd.data(), dim1, dim2, dim3);\n        \n        if(!allclose(C, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t*, const int64_t*, int64_t*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    \n    std::vector<int64_t> A(dim1 * dim2 * dim3); for ( auto & element : A) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n    std::vector<int64_t> B(dim1 * dim2 * dim3); for ( auto & element : B) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n    std::vector<int64_t> C(dim1 * dim2 * dim3);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), dim1, dim2, dim3);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_add_3d)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor_add_3d_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "tensor_add_3d", "entrypoint_simd": "tensor_add_3d_simd"}
{"task_id": "SimdBench_20_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n}", "solution_scalar": "void vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<float> dst(length);\n        std::vector<float> dst_simd(length);\n\n        vector_add_round_nearest(src1.data(), src2.data(), dst.data(), length);\n        vector_add_round_nearest_simd(src1.data(), src2.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<float> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_add_round_nearest)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_add_round_nearest_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "vector_add_round_nearest", "entrypoint_simd": "vector_add_round_nearest_simd"}
{"task_id": "SimdBench_21_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise multiplication of src1 and src2\nfor elements that meet the following conditions:\n    1: the absolute value of the difference is within 50;\n    2: index is is a multiple of 2.\nand then round the result up toward positive infinity.\nFor elements that do not meet the above conditions, the results should be -1.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n}", "solution_scalar": "void vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<float> dst(length);\n        std::vector<float> dst_simd(length);\n\n        vector_mul_round_up(src1.data(), src2.data(), dst.data(), length);\n        vector_mul_round_up_simd(src1.data(), src2.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<float> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_mul_round_up)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_mul_round_up_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "vector_mul_round_up", "entrypoint_simd": "vector_mul_round_up_simd"}
{"task_id": "SimdBench_22_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point source matrix (mat);\n- A scalar value in 64-bit floating-point (scalar);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nmat and dst are 2D matrices flattened into 1D arrays.\nYour goal is to calculate the result of the element-wise multiplication of mat and scalar,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        double scalar = rng.uniform<double>();\n        std::vector<double> mat(m * n); rng.initialize_vector_with_random_values(mat);\n        std::vector<double> dst(m * n);\n        std::vector<double> dst_simd(dst);\n\n        matrix_scalar_mul(mat.data(), scalar, dst.data(), m, n);\n        matrix_scalar_mul_simd(mat.data(), scalar, dst_simd.data(), m, n);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, double, double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    double scalar = rng.uniform<double>();\n    std::vector<double> mat(m * n);\n    rng.initialize_vector_with_random_values(mat);\n    std::vector<double> dst(m * n);\n\n    for (auto _ : state) {\n        Func(mat.data(), scalar, dst.data(), m, n);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_scalar_mul)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_scalar_mul_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_scalar_mul", "entrypoint_simd": "matrix_scalar_mul_simd"}
{"task_id": "SimdBench_23_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat) that is flattened into a 1D array;\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to normalize each row of the matrix mat by dividing each element in the row by the L^2 norm of that row.\nThe L^2 norm is calculated as the square root of the sum of squares of the elements in the row.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n        if (norm > 1e-8f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<float> mat(m * n); rng.initialize_vector_with_random_values(mat);\n        std::vector<float> mat_simd(mat);\n\n        matrix_normalize_rows(mat.data(), m, n);\n        matrix_normalize_rows_simd(mat_simd.data(), m, n);\n        \n        if(!allclose(mat, mat_simd, 1e-6f, 1e-6f)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(float*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<float> mat(m * n);\n    rng.initialize_vector_with_random_values(mat);\n\n    for (auto _ : state) {\n        Func(mat.data(), m, n);\n        benchmark::DoNotOptimize(mat.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_normalize_rows)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_normalize_rows_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_normalize_rows", "entrypoint_simd": "matrix_normalize_rows_simd"}
{"task_id": "SimdBench_24_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n}", "solution_scalar": "void matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        size_t p = Small_Arg_2D;\n        \n        std::vector<double> mat1(m * n); rng.initialize_vector_with_random_values(mat1);\n        std::vector<double> mat2(n * p); rng.initialize_vector_with_random_values(mat2);\n        std::vector<double> dst(m * p);\n        std::vector<double> dst_simd(m * p);\n\n        matrix_mul_round_int(mat1.data(), mat2.data(), dst.data(), m, n, p);\n        matrix_mul_round_int_simd(mat1.data(), mat2.data(), dst_simd.data(), m, n, p);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    size_t p = state.range(2);\n    \n    std::vector<double> mat1(m * n); rng.initialize_vector_with_random_values(mat1);\n    std::vector<double> mat2(n * p); rng.initialize_vector_with_random_values(mat2);\n    std::vector<double> dst(m * p);\n\n    for (auto _ : state) {\n        Func(mat1.data(), mat2.data(), dst.data(), m, n, p);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_mul_round_int)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, matrix_mul_round_int_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_mul_round_int", "entrypoint_simd": "matrix_mul_round_int_simd"}
{"task_id": "SimdBench_25_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n}", "solution_scalar": "void matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<float> src(rows * cols); \n        rng.initialize_vector_with_random_values(src);\n        std::vector<float> dst(rows * cols);\n        std::vector<float> dst_simd(rows * cols);\n\n        matrix_transpose_round_quarter(src.data(), dst.data(), rows, cols);\n        matrix_transpose_round_quarter_simd(src.data(), dst_simd.data(), rows, cols);\n        \n        if(!allclose(dst, dst_simd, 1e-6f, 1e-6f)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, float*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<float> src(rows * cols);\n    rng.initialize_vector_with_random_values(src);\n    std::vector<float> dst(rows * cols);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_transpose_round_quarter)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_transpose_round_quarter_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_transpose_round_quarter", "entrypoint_simd": "matrix_transpose_round_quarter_simd"}
{"task_id": "SimdBench_26_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t idx = i * dim2 * dim3 + j * dim3 + k;\n                dst[idx] = truncf(tensor1[idx] - tensor2[idx]);\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        \n        std::vector<float> tensor1(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor1);\n        std::vector<float> tensor2(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor2);\n        std::vector<float> dst(dim1 * dim2 * dim3);\n        std::vector<float> dst_simd(dim1 * dim2 * dim3);\n\n        tensor3d_sub_round_zero(tensor1.data(), tensor2.data(), dst.data(), dim1, dim2, dim3);\n        tensor3d_sub_round_zero_simd(tensor1.data(), tensor2.data(), dst_simd.data(), dim1, dim2, dim3);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    \n    std::vector<float> tensor1(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor1);\n    std::vector<float> tensor2(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor2);\n    std::vector<float> dst(dim1 * dim2 * dim3);\n\n    for (auto _ : state) {\n        Func(tensor1.data(), tensor2.data(), dst.data(), dim1, dim2, dim3);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor3d_sub_round_zero)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor3d_sub_round_zero_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "tensor3d_sub_round_zero", "entrypoint_simd": "tensor3d_sub_round_zero_simd"}
{"task_id": "SimdBench_27_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrices (m);\n- The number of columns in the matrices (n).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform the Hadamard product (element-wise multiplication) of mat1 and mat2,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<double> mat1(m * n); rng.initialize_vector_with_random_values(mat1);\n        std::vector<double> mat2(m * n); rng.initialize_vector_with_random_values(mat2);\n        std::vector<double> dst(m * n);\n        std::vector<double> dst_simd(m * n);\n\n        matrix_hadamard_product(mat1.data(), mat2.data(), dst.data(), m, n);\n        matrix_hadamard_product_simd(mat1.data(), mat2.data(), dst_simd.data(), m, n);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<double> mat1(m * n);\n    rng.initialize_vector_with_random_values(mat1);\n    std::vector<double> mat2(m * n);\n    rng.initialize_vector_with_random_values(mat2);\n    std::vector<double> dst(m * n);\n\n    for (auto _ : state) {\n        Func(mat1.data(), mat2.data(), dst.data(), m, n);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_hadamard_product)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_hadamard_product_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_hadamard_product", "entrypoint_simd": "matrix_hadamard_product_simd"}
{"task_id": "SimdBench_28_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat);\n- A pointer to a non-empty 32-bit floating-point vector (vec);\n- A pointer to a non-empty 32-bit floating-point destination vector (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nThe matrix is flattened into a 1D array.\nmat has the shape (m, n), and vec has the shape (n).\nYour goal is to perform matrix-vector multiplication of mat and vec,\nand then store the result in the dst vector in the shape (m).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n\n*/\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<float> mat(m * n); rng.initialize_vector_with_random_values(mat);\n        std::vector<float> vec(n); rng.initialize_vector_with_random_values(vec);\n        std::vector<float> dst(m);\n        std::vector<float> dst_simd(m);\n\n        matrix_vector_mul(mat.data(), vec.data(), dst.data(), m, n);\n        matrix_vector_mul_simd(mat.data(), vec.data(), dst_simd.data(), m, n);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<float> mat(m * n); rng.initialize_vector_with_random_values(mat);\n    std::vector<float> vec(n); rng.initialize_vector_with_random_values(vec);\n    std::vector<float> dst(m);\n\n    for (auto _ : state) {\n        Func(mat.data(), vec.data(), dst.data(), m, n);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_vector_mul)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_vector_mul_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_vector_mul", "entrypoint_simd": "matrix_vector_mul_simd"}
{"task_id": "SimdBench_29_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n}", "solution_scalar": "double matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t j = 0; j < n; j++) {\n        for (size_t i = 0; i < m; i++) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / double(m * n);\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<double> mat(m * n);  rng.initialize_vector_with_random_values(mat);\n\n        double avg = matrix_average(mat.data(), m, n);\n        double avg_simd = matrix_average_simd(mat.data(), m, n);\n        \n        if(!allclose(avg, avg_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<double (*Func)(const double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<double> mat(m * n);  rng.initialize_vector_with_random_values(mat);\n\n    for (auto _ : state) {\n        double res = Func(mat.data(), m, n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_average)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_average_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_average", "entrypoint_simd": "matrix_average_simd"}
{"task_id": "SimdBench_30_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (matrix);\n- A pointer to a boolean array (directions) indicating the sort direction for each row;\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if each row in the matrix is sorted according to the specified direction.\nThe value of the boolean array (directions) indicates whether the row should be sorted in ascending (true) or descending (false) order.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 1; j < cols; j++) {\n            int curr = matrix[i*cols + j];\n            int prev = matrix[i*cols + (j-1)];\n            if ((ascending && curr < prev) || (!ascending && curr > prev)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<int> matrix(rows * cols); for ( auto & element : matrix) { element = rng.randint(- (1 << 8), 1 << 8); }\n        std::vector<uint8_t> directions(rows);\n        rng.initialize_vector_with_random_values(directions, true);\n\n        // Sort each row according to its direction\n        bool sth_wrong = rng.randint(0, 2)%3==0;\n        for (size_t i = 0; i < rows; i++) {\n            if(sth_wrong){\n                bool out_of_order = rng.randint(0, 10)%10==0;\n                if(out_of_order) continue;\n                else{\n                    if(rng.randint(0, 1)==0) std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols);\n                    else std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols, std::greater<int>());\n                }\n            } else if (directions[i]) {\n                std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols);\n            } else {\n                std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols, std::greater<int>());\n            }\n        }\n\n        bool scalar_result = matrix_rows_sorted_verify(matrix.data(), reinterpret_cast<const bool*>(directions.data()), rows, cols);\n        bool simd_result = matrix_rows_sorted_verify_simd(matrix.data(), reinterpret_cast<const bool*>(directions.data()), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const int*, const bool*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<int> matrix(rows * cols);\n    rng.initialize_vector_with_random_values(matrix);\n    std::vector<uint8_t> directions(rows);\n    rng.initialize_vector_with_random_values(directions, true);\n\n    // Sort the matrix rows according to directions\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols);\n        } else {\n            std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols, std::greater<int>());\n        }\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), reinterpret_cast<const bool*>(directions.data()), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_rows_sorted_verify)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_rows_sorted_verify_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_rows_sorted_verify", "entrypoint_simd": "matrix_rows_sorted_verify_simd"}
{"task_id": "SimdBench_31_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n}", "solution_scalar": "void nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t mode = ((value % base) + base) % base;\n        dst[i] = value - mode;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        \n        std::vector<int16_t> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int16_t> dst(length);\n        std::vector<int16_t> dst_simd(length);\n\n        uint8_t base = rng.randint<uint8_t>(1, 255);\n\n        nearest_multiple(src.data(), dst.data(), base, length);\n        nearest_multiple_simd(src.data(), dst_simd.data(), base, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int16_t*, int16_t*, uint8_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n\n    std::vector<int16_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int16_t> dst(length);\n    uint8_t base = rng.randint<uint8_t>(1, 255);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), base, length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, nearest_multiple)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, nearest_multiple_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "nearest_multiple", "entrypoint_simd": "nearest_multiple_simd"}
{"task_id": "SimdBench_32_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (vector);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if any row in the matrix matches the given vector.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<double> matrix(rows * cols); rng.initialize_vector_with_random_values(matrix);\n        std::vector<double> vector(cols); rng.initialize_vector_with_random_values(vector);\n\n        bool correct_case = rng.random_bool();\n        if(correct_case){\n            size_t idx = rng.randint( size_t(0), rows-1);\n            std::copy(vector.begin(), vector.end(), matrix.begin()+idx*cols);\n        }\n\n        bool scalar_result = matrix_has_row(matrix.data(), vector.data(), rows, cols);\n        bool simd_result = matrix_has_row_simd(matrix.data(), vector.data(), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result: \" << scalar_result \n                          << \", SIMD result: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const double*, const double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<double> matrix(rows * cols); rng.initialize_vector_with_random_values(matrix);\n    std::vector<double> vector(cols); rng.initialize_vector_with_random_values(vector);\n\n    bool correct_case = rng.random_bool();\n    if(correct_case){\n        size_t idx = rng.randint( size_t(0), rows-1);\n        std::copy(vector.begin(), vector.end(), matrix.begin()+idx*cols);\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), vector.data(), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_has_row)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_has_row_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_has_row", "entrypoint_simd": "matrix_has_row_simd"}
{"task_id": "SimdBench_33_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (B);\n- An array of 4 size_t integers representing the dimensions of the tensors (dims).\n\nA and B are flattened into 1D arrays.\nYour goal is to count the number of equal elements between the two tensors.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n}", "solution_scalar": "size_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total; i++) {\n        count += (A[i] == B[i]);\n    }\n    return count;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dims[4] = {Small_Arg_4D, Small_Arg_4D, Small_Arg_4D, Small_Arg_4D};\n        size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n        \n        std::vector<uint8_t> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<uint8_t> B(total); rng.initialize_vector_with_random_values(B);\n\n        size_t n = rng.randint(size_t(0), total);\n        while(n-- && total > 0){\n            size_t idx = rng.randint(size_t(0), total-1);\n            B[idx] = A[idx];\n        }\n\n        size_t scalar_result = tensor_4d_equal_count(A.data(), B.data(), dims);\n        size_t simd_result = tensor_4d_equal_count_simd(A.data(), B.data(), dims);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar count: \" << scalar_result \n                          << \", SIMD count: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<size_t (*Func)(const uint8_t*, const uint8_t*, const size_t[4])>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dims[4] = {static_cast<size_t>(state.range(0)),\n                      static_cast<size_t>(state.range(1)),\n                      static_cast<size_t>(state.range(2)),\n                      static_cast<size_t>(state.range(3))};\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    std::vector<uint8_t> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<uint8_t> B(total); rng.initialize_vector_with_random_values(B);\n\n    size_t n = rng.randint(size_t(0), total);\n    while(n-- && total > 0){\n        size_t idx = rng.randint(size_t(0), total-1);\n        B[idx] = A[idx];\n    }\n\n    for (auto _ : state) {\n        size_t count = Func(A.data(), B.data(), dims);\n        benchmark::DoNotOptimize(&count);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_4d_equal_count)->Name(\"Scalar\")->Large_Args_4D;\nBENCHMARK_TEMPLATE(BM, tensor_4d_equal_count_simd)->Name(\"SIMD\")->Large_Args_4D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "tensor_4d_equal_count", "entrypoint_simd": "tensor_4d_equal_count_simd"}
{"task_id": "SimdBench_34_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n}", "solution_scalar": "void axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        \n        int64_t a = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n        std::vector<int64_t> x(length); \n        for (auto & item: x) { item = rng.randint<int64_t>( - (1 << 20), (1 << 20)); }\n        std::vector<int64_t> y_scalar(length);\n        std::vector<int64_t> y_simd(length);\n        for(int i=0; i<length; ++i){\n            int64_t item = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n            y_scalar[i] = item;\n            y_simd[i] = item;\n        }\n\n        axm_abs(length, a, x.data(), y_scalar.data());\n        axm_abs_simd(length, a, x.data(), y_simd.data());\n        \n        if(!allclose(y_scalar, y_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(size_t, const int64_t, const int64_t*, int64_t *)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n\n    int64_t a = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n    std::vector<int64_t> x(length); \n    for (auto & item: x) { item = rng.randint<int64_t>( - (1 << 20), (1 << 20)); }\n    std::vector<int64_t> y(length);\n    for(int i=0; i<length; ++i){\n        int64_t item = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n        y[i] = item;\n    }\n\n    for (auto _ : state) {\n        Func(length, a, x.data(), y.data());\n        benchmark::DoNotOptimize(y);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, axm_abs)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, axm_abs_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "axm_abs", "entrypoint_simd": "axm_abs_simd"}
{"task_id": "SimdBench_35_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer vector (vec);\n- The length of the given vector.\n\nYour goal is to return the the maximum and minimum values in the given vector.\nThe function should return a value of the defined `MinMaxPair` type:\n```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n```\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n}", "solution_scalar": "typedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    if (length == 0 || vec == NULL) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n\n    for (size_t i = 1; i < length; i++) {\n        min_val = std::min(vec[i], min_val);\n        max_val = std::max(vec[i], max_val);\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;       \n        std::vector<int16_t> src(length); rng.initialize_vector_with_random_values(src);\n\n        MinMaxPair res_scalar = min_max_pair(src.data(), length);\n        MinMaxPair res_simd = min_max_pair_simd(src.data(), length);\n        \n        if(!(res_scalar.max_num == res_simd.max_num && \n        res_scalar.min_num == res_simd.min_num)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<MinMaxPair (*Func)(const int16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int16_t> src(length); \n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        MinMaxPair res = Func(src.data(), length);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, min_max_pair)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, min_max_pair_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "min_max_pair", "entrypoint_simd": "min_max_pair_simd"}
{"task_id": "SimdBench_36_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if(matrix == NULL || rows <= 0 || cols <= 0) return false;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<int> matrix(rows * cols);\n        \n        for (size_t r = 0; r < rows; r++) {\n            for (size_t c = 0; c < cols; c++) {\n                matrix[r * cols + c] = static_cast<int>(r * cols + c);\n            }\n        }\n\n        bool wrong_case = rng.random_bool();\n        if (wrong_case && rows > 0 && cols > 0) {\n            size_t r = rng.randint(size_t(0), rows-1);\n            size_t c = rng.randint(size_t(0), cols-1);\n            matrix[r*cols + c] = rng.randint<int>();\n        }\n\n        bool scalar_result = matrix_rows_strictly_increasing(matrix.data(), rows, cols);\n        bool simd_result = matrix_rows_strictly_increasing_simd(matrix.data(), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result: \" << scalar_result \n                          << \", SIMD result: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const int*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<int> matrix(rows * cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c++) {\n            matrix[r * cols + c] = static_cast<int>(r * cols + c);\n        }\n    }\n\n    bool wrong_case = rng.random_bool();\n    if (wrong_case && rows > 0 && cols > 0) {\n        size_t r = rng.randint(size_t(0), rows-1);\n        size_t c = rng.randint(size_t(0), cols-1);\n        matrix[r*cols + c] = rng.randint<int>();\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_rows_strictly_increasing)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_rows_strictly_increasing_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_rows_strictly_increasing", "entrypoint_simd": "matrix_rows_strictly_increasing_simd"}
{"task_id": "SimdBench_37_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (matrix == NULL) return false;\n    if (block_size <= 0) return false;\n    if (rows % block_size != 0 || cols % block_size != 0) return false;\n    \n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Compare all blocks to first block\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            for (size_t r = 0; r < block_size; r++) {\n                for (size_t c = 0; c < block_size; c++) {\n                    size_t idx1 = r*cols + c; // First block\n                    size_t idx2 = (br*block_size + r)*cols + (bc*block_size + c);\n                    if (matrix[idx1] != matrix[idx2]) return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        bool wrong_case = rng.random_bool();\n        size_t block_size = rng.randint(size_t(0), size_t(8));\n        size_t rows, cols;\n        if(wrong_case || block_size==0){\n            rows = Small_Arg_2D;\n            cols = Small_Arg_2D;\n        }else{\n            size_t times = rng.randint(size_t(1), size_t(8));\n            rows = block_size * times;\n            cols = block_size * times;\n        }\n        \n        std::vector<int> matrix(rows * cols);\n        for (size_t r = 0; r < rows; r++) {\n            for (size_t c = 0; c < cols; c++) {\n                if(block_size > 0) matrix[r * cols + c] = static_cast<int>((r % block_size) + (c % block_size));\n                else matrix[r * cols + c] = rng.randint<int>();\n            }\n        }\n\n        if (wrong_case) {\n            size_t r = rng.randint(size_t(0), rows - 1);\n            size_t c = rng.randint(size_t(0), cols - 1);\n            matrix[r * cols + c] = rng.randint<int>();\n        }\n\n        bool scalar_result = matrix_blocks_equal(matrix.data(), block_size, rows, cols);\n        bool simd_result = matrix_blocks_equal_simd(matrix.data(), block_size, rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool null_pass = matrix_blocks_equal_simd(NULL, 1, 0, 0) == matrix_blocks_equal(NULL, 1, 0, 0);\n    bool pass = correctness_check(ITERATIONS) && null_pass;\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const int*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t block_size = rng.randint(size_t(1), size_t(8));\n    size_t rows = block_size * static_cast<size_t>(state.range(0));\n    size_t cols = block_size * static_cast<size_t>(state.range(1));\n    \n    std::vector<int> matrix(rows * cols);\n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c++) {\n            matrix[r * cols + c] = static_cast<int>((r % block_size) + (c % block_size));\n        }\n    }\n\n    if (rng.random_bool()) {\n        size_t r = rng.randint(size_t(0), rows - 1);\n        size_t c = rng.randint(size_t(0), cols - 1);\n        matrix[r * cols + c] = rng.randint<int>();\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), block_size, rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_blocks_equal)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_blocks_equal_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_blocks_equal", "entrypoint_simd": "matrix_blocks_equal_simd"}
{"task_id": "SimdBench_38_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 64-bit floating-point vector (vec);\n- A 64-bit floating-point tolerance;\n- The length of the given vector (length);\n- The size of each block (block_size).\n\nYour goal is to check whether all blocks (excluding tail elements that cannot form a complete block)\nof the vector are element-wise equal to the first block, within the specified tolerance.\nReturn false is the input is illegal or no complete blocks in block_size.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n}", "solution_scalar": "bool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            double diff = fabsf(vec[i * block_size + j] - vec[j]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;    \n    for (int i = 0; i < iterations; i++) {\n        const double tolerance = rng.random<double>();\n        size_t length = Small_Arg_1D;\n        size_t block_size = Small_Arg_2D;\n        std::vector<double> vec(length); for(auto & element: vec) { element = rng.uniform<double>(); }\n        \n        bool correct_case = rng.random_bool();\n        if(correct_case && block_size < length && block_size > 0) { \n            size_t num_blocks = length / block_size;\n            for(int block_n=1; block_n < num_blocks; block_n++){\n                for(int k=0; k<block_size; ++k){\n                    vec[block_n*block_size+k] = vec[ k ];\n                }\n            } \n        }\n\n        bool scalar_result = vector_block_equal(vec.data(), tolerance, length, block_size);\n        bool simd_result = vector_block_equal_simd(vec.data(), tolerance, length, block_size);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result: \" << scalar_result \n                          << \", SIMD result: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool corner_pass = true;\n    corner_pass = corner_pass && \\\n    ( vector_block_equal(NULL, 1.0f, 0, 100) == vector_block_equal_simd(NULL, 1.0f, 0, 100) );\n    std::vector<double> tmp(100);\n    corner_pass = corner_pass && \\\n    ( vector_block_equal(tmp.data(), 1.0f, 100, 0) == vector_block_equal_simd(tmp.data(), 1.0f, 100, 0) );      \n    bool pass = corner_pass && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const double*, double, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    const double tolerance = rng.random<double>();\n    size_t length = state.range(0);\n    size_t block_size = 32;\n    std::vector<double> vec(length); for(auto & element: vec) { element = rng.uniform<double>(); }\n    \n    // true\n    if(block_size < length && block_size > 0) { \n        size_t num_blocks = length / block_size;\n        for(int block_n=1; block_n < num_blocks; block_n++){\n            for(int k=0; k<block_size; ++k){\n                vec[block_n*block_size+k] = vec[ k ];\n            }\n        } \n    }\n\n    for (auto _ : state) {\n        bool result = Func(vec.data(), tolerance, length, block_size);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_block_equal)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_block_equal_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "vector_block_equal", "entrypoint_simd": "vector_block_equal_simd"}
{"task_id": "SimdBench_39_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (thresholds);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n- A pointer to a boolean result array (result).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to check if the Euclidean norm of each row in the matrix exceeds the corresponding threshold in the vector.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n}", "solution_scalar": "void matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_sq = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i*cols + j];\n            sum_sq += val * val;\n        }\n        result[i] = (sqrt(sum_sq) > thresholds[i]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<double> matrix(rows * cols); for(auto & element: matrix) { element = rng.random<double>(); }\n        //rng.initialize_vector_with_random_values(matrix);\n        std::vector<double> thresholds(rows); for(auto & element: thresholds) { element = rng.normal_distribution(1.0, 0.75); }\n        //rng.initialize_vector_with_random_values(thresholds);\n\n        std::vector<uint8_t> result_scalar(rows);\n        std::vector<uint8_t> result_simd(rows);\n\n        matrix_row_norm_compare(matrix.data(), thresholds.data(), rows, cols, reinterpret_cast<bool*>(result_scalar.data()));\n        matrix_row_norm_compare_simd(matrix.data(), thresholds.data(), rows, cols, reinterpret_cast<bool*>(result_simd.data()));\n        \n        if(!allclose(result_scalar, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, size_t, size_t, bool*)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<double> matrix(rows * cols); for(auto & element: matrix) { element = rng.random<double>(); }\n    //rng.initialize_vector_with_random_values(matrix);\n    std::vector<double> thresholds(rows); for(auto & element: thresholds) { element = rng.normal_distribution(1.0, 0.75); }\n    //rng.initialize_vector_with_random_values(thresholds);\n\n    std::vector<uint8_t> result(rows);\n\n    for (auto _ : state) {\n        Func(matrix.data(), thresholds.data(), rows, cols, reinterpret_cast<bool*>(result.data()));\n        benchmark::DoNotOptimize(result.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_row_norm_compare)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_row_norm_compare_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_row_norm_compare", "entrypoint_simd": "matrix_row_norm_compare_simd"}
{"task_id": "SimdBench_40_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n}", "solution_scalar": "void tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        C[idx] = A[idx] | B[idx];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<uint32_t> A(total);\n        rng.initialize_vector_with_random_values(A);\n        std::vector<uint32_t> B(total);\n        rng.initialize_vector_with_random_values(B);\n        \n        std::vector<uint32_t> C_scalar(total);\n        std::vector<uint32_t> C_simd(total);\n\n        tensor_bitwise_or(A.data(), B.data(), C_scalar.data(), total);\n        tensor_bitwise_or_simd(A.data(), B.data(), C_simd.data(), total);\n        \n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, const uint32_t*, uint32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<uint32_t> A(total);\n    rng.initialize_vector_with_random_values(A);\n    std::vector<uint32_t> B(total);\n    rng.initialize_vector_with_random_values(B);\n    std::vector<uint32_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bitwise_or)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_bitwise_or_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bitwise_or", "entrypoint_simd": "tensor_bitwise_or_simd"}
{"task_id": "SimdBench_41_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n}", "solution_scalar": "int64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum1 = 0, sum2 = 0;\n    for (int i = 0; i < length; i++) {\n        sum1 += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum2 += (int64_t)A[i] * B[i];\n    }\n    return sum1 - sum2;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int8_t> A(length); rng.initialize_vector_with_random_values(A);\n        std::vector<int8_t> B(length); rng.initialize_vector_with_random_values(B);\n\n        int64_t diff_scalar = squarediff(A.data(), B.data(), length);\n        int64_t diff_simd =  squarediff_simd(A.data(), B.data(), length);\n        \n        if(diff_scalar != diff_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const int8_t *, const int8_t *, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int8_t> A(length); rng.initialize_vector_with_random_values(A);\n    std::vector<int8_t> B(length); rng.initialize_vector_with_random_values(B);\n    \n    for (auto _ : state) {\n        int64_t diff = Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(diff);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, squarediff)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, squarediff_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "squarediff", "entrypoint_simd": "squarediff_simd"}
{"task_id": "SimdBench_42_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n}", "solution_scalar": "void tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        C[idx] = A[idx] & (~B[idx]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<uint64_t> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<uint64_t> B(total); rng.initialize_vector_with_random_values(B);\n        \n        std::vector<uint64_t> C_scalar(total);\n        std::vector<uint64_t> C_simd(total);\n\n        tensor_bit_clear(A.data(), B.data(), C_scalar.data(), total);\n        tensor_bit_clear_simd(A.data(), B.data(), C_simd.data(), total);\n        \n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint64_t*, const uint64_t*, uint64_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<uint64_t> A(total);\n    rng.initialize_vector_with_random_values(A);\n    std::vector<uint64_t> B(total);\n    rng.initialize_vector_with_random_values(B);\n    std::vector<uint64_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bit_clear)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_bit_clear_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bit_clear", "entrypoint_simd": "tensor_bit_clear_simd"}
{"task_id": "SimdBench_43_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n}", "solution_scalar": "void tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        int a = A[idx], b = B[idx];\n        if (a == 0 || b == 0) {\n            C[idx] = 0;\n        } else if (a > 0 && b > 0) {\n            C[idx] = 1;\n        } else if (a < 0 && b < 0) {\n            C[idx] = -1;\n        } else {\n            C[idx] = 0;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<int8_t> A(total); rng.initialize_vector_with_random_values(A);      \n        std::vector<int8_t> B(total); rng.initialize_vector_with_random_values(B); \n        \n        std::vector<int8_t> C_scalar(total);\n        std::vector<int8_t> C_simd(total);\n\n        tensor_three_valued_logic(A.data(), B.data(), C_scalar.data(), total);\n        tensor_three_valued_logic_simd(A.data(), B.data(), C_simd.data(), total);\n        \n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int8_t*, const int8_t*, int8_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<int8_t> A(total); rng.initialize_vector_with_random_values(A);      \n    std::vector<int8_t> B(total); rng.initialize_vector_with_random_values(B); \n    std::vector<int8_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_three_valued_logic)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_three_valued_logic_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_three_valued_logic", "entrypoint_simd": "tensor_three_valued_logic_simd"}
{"task_id": "SimdBench_44_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit unsigned integer tensor (A);\n- A pointer to a non-empty 16-bit unsigned integer tensor (B);\n- A pointer to a non-empty 16-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform the following operation to A and B,\nand then store the result in tensor C:\nfor the element **exactly** at the midpoint: keep the value in A;\nfor elements before the midpoint: values are element-wise bitwise XOR operation between A and B;\nfor elements before the midpoint: values are element-wise bitwise AND operation between A and B.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n}", "solution_scalar": "void tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    double half_idx = double(length) / 2.0;\n    for (size_t idx = 0; idx < length; idx++){\n        if(idx < half_idx) C[idx] = A[idx] ^ B[idx];\n        else if(idx == half_idx) C[idx] = A[idx];\n        else if(idx > half_idx) C[idx] = A[idx] & B[idx];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<uint16_t> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<uint16_t> B(total); rng.initialize_vector_with_random_values(B);\n        \n        std::vector<uint16_t> C_scalar(total);\n        std::vector<uint16_t> C_simd(total);\n\n        tensor_bit_op(A.data(), B.data(), C_scalar.data(), total);\n        tensor_bit_op_simd(A.data(), B.data(), C_simd.data(), total);\n\n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint16_t*, const uint16_t*, uint16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<uint16_t> A(total);\n    rng.initialize_vector_with_random_values(A);\n    std::vector<uint16_t> B(total);\n    rng.initialize_vector_with_random_values(B);\n    std::vector<uint16_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bit_op)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_bit_op_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bit_op", "entrypoint_simd": "tensor_bit_op_simd"}
{"task_id": "SimdBench_45_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t idx = i * dim2 * dim3 + j * dim3 + k;\n                bool c1 = cond1[idx], c2 = cond2[idx];\n                if (c1 && c2) out[idx] = A[idx];\n                else if (c1 && !c2) out[idx] = B[idx];\n                else if (!c1 && c2) out[idx] = C[idx];\n                else out[idx] = D[idx];\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        size_t total = dim1 * dim2 * dim3;\n\n        std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n        std::vector<float> C(total); rng.initialize_vector_with_random_values(C);\n        std::vector<float> D(total); rng.initialize_vector_with_random_values(D);\n\n        std::vector<uint8_t> cond1_data(total);\n        rng.initialize_vector_with_random_values(cond1_data, true);\n        const bool* cond1 = reinterpret_cast<const bool*>(cond1_data.data());\n        \n        std::vector<uint8_t> cond2_data(total);\n        rng.initialize_vector_with_random_values(cond2_data, true);\n        const bool* cond2 = reinterpret_cast<const bool*>(cond2_data.data());\n        \n        std::vector<float> out_scalar(total);\n        std::vector<float> out_simd(total);\n\n        tensor_multi_select(A.data(), B.data(), C.data(), D.data(),\n                           cond1, cond2, out_scalar.data(),\n                           dim1, dim2, dim3);\n        tensor_multi_select_simd(A.data(), B.data(), C.data(), D.data(),\n                                cond1, cond2, out_simd.data(),\n                                dim1, dim2, dim3);\n        \n        if(!allclose(out_scalar, out_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, const float*, const float*,\n    const bool*, const bool*, float*,\n    size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    size_t total = dim1 * dim2 * dim3;\n\n    std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n    std::vector<float> C(total); rng.initialize_vector_with_random_values(C);\n    std::vector<float> D(total); rng.initialize_vector_with_random_values(D);\n\n    std::vector<uint8_t> cond1_data(total);\n    rng.initialize_vector_with_random_values(cond1_data, true);\n    const bool* cond1 = reinterpret_cast<const bool*>(cond1_data.data());\n    \n    std::vector<uint8_t> cond2_data(total);\n    rng.initialize_vector_with_random_values(cond2_data, true);\n    const bool* cond2 = reinterpret_cast<const bool*>(cond2_data.data());\n    std::vector<float> out(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), D.data(),\n            cond1, cond2, out.data(),\n            dim1, dim2, dim3);\n        benchmark::DoNotOptimize(out.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_multi_select)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor_multi_select_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_multi_select", "entrypoint_simd": "tensor_multi_select_simd"}
{"task_id": "SimdBench_46_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t length = dim1 * dim2 * dim3;\n    for(size_t idx = 0; idx < length; ++idx){\n        uint32_t val = A[idx];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[idx] = count;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        size_t total = dim1 * dim2 * dim3;\n        \n        std::vector<uint32_t> A(total);\n        int idx = 0;\n        for (auto& val : A) {\n            val = rng.randint<uint32_t>();\n            // corner cases\n            if (idx % 16 == 0) val = 0;\n            else if (idx % 16 == 1) val = ~0u;\n            else if (idx % 16 == 2) val = 0x55555555;\n            else if (idx % 16 == 3) val = 0xAAAAAAAA;\n            idx++;\n        }\n        \n        std::vector<uint8_t> out_scalar(total);\n        std::vector<uint8_t> out_simd(total);\n\n        tensor_bit_count(A.data(), out_scalar.data(), dim1, dim2, dim3);\n        tensor_bit_count_simd(A.data(), out_simd.data(), dim1, dim2, dim3);\n        \n        if(!allclose(out_scalar, out_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint8_t*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    size_t total = dim1 * dim2 * dim3;\n    \n    std::vector<uint32_t> A(total);\n    for (auto& val : A) {\n        val = rng.randint<uint32_t>();\n    }\n    \n    std::vector<uint8_t> out(total);\n\n    for (auto _ : state) {\n        Func(A.data(), out.data(), dim1, dim2, dim3);\n        benchmark::DoNotOptimize(out.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bit_count)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor_bit_count_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bit_count", "entrypoint_simd": "tensor_bit_count_simd"}
{"task_id": "SimdBench_47_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n}", "solution_scalar": "void matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t length = rows*cols;\n    for (size_t idx = 0; idx < length; idx++) {\n        int val = A[idx];\n        B[idx] = (val % 3 == 0) ? (val < 0 ? -val : val) : val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        size_t total = rows * cols;\n        \n        std::vector<int> A(total); rng.initialize_vector_with_random_values(A);\n        \n        std::vector<int> B_scalar(total);\n        std::vector<int> B_simd(total);\n        matrix_conditional_abs(A.data(), B_scalar.data(), rows, cols);\n        matrix_conditional_abs_simd(A.data(), B_simd.data(), rows, cols);\n        \n        if(!allclose(B_scalar, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int*, int*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    size_t total = rows * cols;\n    \n    std::vector<int> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<int> B(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), rows, cols);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_conditional_abs)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_conditional_abs_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_conditional_abs", "entrypoint_simd": "matrix_conditional_abs_simd"}
{"task_id": "SimdBench_48_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n}", "solution_scalar": "void matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    rotate_bits %= 32;\n    for (size_t idx = 0; idx < length; idx++) {\n        uint32_t val = src[idx];\n        if (val & 0xf == 0xf) {\n            dst[idx] = (val >> rotate_bits) | (val << (32 - rotate_bits));\n        } else {\n            dst[idx] = val;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        size_t total = rows * cols;\n        std::vector<uint32_t> src(total); rng.initialize_vector_with_random_values(src);\n        uint8_t rotate_bits = rng.randint<uint8_t>();\n        \n        std::vector<uint32_t> dst_scalar(total);\n        std::vector<uint32_t> dst_simd(total);\n\n        matrix_conditional_bit_rotate(src.data(), dst_scalar.data(), rotate_bits, total);\n        matrix_conditional_bit_rotate_simd(src.data(), dst_simd.data(), rotate_bits, total);\n        \n        if(!allclose(dst_scalar, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint32_t*, uint8_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    size_t total = rows * cols;\n\n    std::vector<uint32_t> src(total); rng.initialize_vector_with_random_values(src);\n    uint8_t rotate_bits = rng.randint<uint8_t>();\n    \n    std::vector<uint32_t> dst(total);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rotate_bits, total);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_conditional_bit_rotate)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_conditional_bit_rotate_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "matrix_conditional_bit_rotate", "entrypoint_simd": "matrix_conditional_bit_rotate_simd"}
{"task_id": "SimdBench_49_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (out);\n- A floating-point epsilon value (epsilon);\n- The common length of the tensors.\n\nYour goal is to perform element-wise comparison between tensors A and B.\nIf A[i] - B[i] > abs(epsilon), out[i] should be 1;\nif A[i] - B[i] < -abs(epsilon), out[i] should be -1;\nif abs(A[i] - B[i]) <= abs(epsilon), out[i] should be 0.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n}", "solution_scalar": "void tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        float diff = A[idx] - B[idx];\n        float eps = abs(epsilon);\n        if (diff > eps) out[idx] = 1;\n        else if (diff < -eps) out[idx] = -1;\n        else out[idx] = 0;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        float epsilon = rng.normal_distribution<float>(0.0f, 10.0f);\n\n        std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n        \n        // corner case\n        if(i==0){ \n            for(int idx=0; idx<total; ++idx){\n                B[idx] = A[idx] + pow(-1, idx) * epsilon;\n            }\n        } \n        \n        std::vector<int8_t> out_scalar(total); rng.initialize_vector_with_random_values(out_scalar);\n        std::vector<int8_t> out_simd(out_scalar);\n\n        tensor_ternary_compare(A.data(), B.data(), out_scalar.data(), epsilon, total);\n        tensor_ternary_compare_simd(A.data(), B.data(), out_simd.data(), epsilon, total);\n        \n        if(!allclose(out_scalar, out_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, int8_t*, float, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    float epsilon = rng.normal_distribution<float>(0.0f, 10.0f);\n\n    std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n    std::vector<int8_t> out(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), out.data(), epsilon, total);\n        benchmark::DoNotOptimize(out.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_ternary_compare)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_ternary_compare_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "tensor_ternary_compare", "entrypoint_simd": "tensor_ternary_compare_simd"}
{"task_id": "SimdBench_50_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n}", "solution_scalar": "void float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) B[i] = INT32_MAX;\n        else if (val < INT32_MIN) B[i] = INT32_MIN;\n        else B[i] = (int32_t)val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> src(length);\n        for (auto & element: src) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n        std::vector<int32_t> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int32_t> dst_simd(dst);\n        \n        float_to_int_saturate(src.data(), dst.data(), length);\n        float_to_int_saturate_simd(src.data(), dst_simd.data(), length);\n        \n        if (!allclose(dst, dst_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, int32_t*, size_t)>\nstatic void BM_FloatToIntSaturate(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> src(length); \n    for (auto & element: src) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n    std::vector<int32_t> dst(length); \n    rng.initialize_vector_with_random_values(dst);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\n\nBENCHMARK_TEMPLATE(BM_FloatToIntSaturate, float_to_int_saturate)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_FloatToIntSaturate, float_to_int_saturate_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "float_to_int_saturate", "entrypoint_simd": "float_to_int_saturate_simd"}
{"task_id": "SimdBench_51_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n}", "solution_scalar": "void int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;    \n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int32_t> src(length);\n        std::vector<float> dst(length);\n        std::vector<float> dst_simd(length);\n        const int8_t test_scale = rng.randint<int8_t>();\n        rng.initialize_vector_with_random_values(src);\n        \n        int_to_float_scaled(src.data(), test_scale, dst.data(), length);\n        int_to_float_scaled_simd(src.data(), test_scale, dst_simd.data(), length);      \n        \n        if (!allclose(dst, dst_simd)) {\n            if (ERROR_PRINT) {\n                std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n                std::cerr << \"Expected: \" << dst[0] << \" Got: \" << dst_simd[0] << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0; \n}", "test_performance": "template<void (*Func)(const int32_t*, int8_t, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int32_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<float> dst(length);\n    const int8_t scale = rng.randint<int8_t>();\n    \n    for (auto _ : state) {\n        Func(src.data(), scale, dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, int_to_float_scaled)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int_to_float_scaled_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int_to_float_scaled", "entrypoint_simd": "int_to_float_scaled_simd"}
{"task_id": "SimdBench_52_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n}", "solution_scalar": "void float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = roundf(A[i] / B[i]);\n        if (val > INT32_MAX) C[i] = INT32_MAX;\n        else if (val < INT32_MIN) C[i] = INT32_MIN;\n        else C[i] = (int32_t)val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> A(length);\n        std::vector<float> B(length);\n        std::vector<int32_t> C(length);\n        std::vector<int32_t> C_simd(length);\n        \n        for (auto & element: A) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n        rng.initialize_vector_with_random_values(B);\n\n        float_div_round(A.data(), B.data(), C.data(), length);\n        float_div_round_simd(A.data(), B.data(), C_simd.data(), length);\n        \n        if(!allclose(C, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, int32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> A(length);\n    std::vector<float> B(length);\n    std::vector<int32_t> C(length);\n    \n    for (auto & element: A) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n    rng.initialize_vector_with_random_values(B);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), length);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, float_div_round)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, float_div_round_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "float_div_round", "entrypoint_simd": "float_div_round_simd"}
{"task_id": "SimdBench_53_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n}", "solution_scalar": "void double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) B[i] = FLT_MAX;\n        else if (val < -FLT_MAX) B[i] = -FLT_MAX;\n        else B[i] = (float)val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<double> A(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        for(auto & item: A) { item = (double)(FLT_MAX) * rng.normal_distribution<double>(0.0, 2.0); }\n\n        double_to_float_saturate(A.data(), B.data(), length);\n        double_to_float_saturate_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<double> A(length);\n    std::vector<float> B(length);\n    \n    for(auto & item: A) { item = (double)(FLT_MAX) * rng.normal_distribution<double>(0.0, 2.0); }\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, double_to_float_saturate)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, double_to_float_saturate_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "double_to_float_saturate", "entrypoint_simd": "double_to_float_saturate_simd"}
{"task_id": "SimdBench_54_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 16-bit integer (int16_t) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the int16_t values in A to int32_t values in B.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n}", "solution_scalar": "void int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int16_t> A(length);\n        std::vector<int32_t> B(length);\n        std::vector<int32_t> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n\n        int16_to_int32(A.data(), B.data(), length);\n        int16_to_int32_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int16_t*, int32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int16_t> A(length);\n    std::vector<int32_t> B(length);\n    \n    rng.initialize_vector_with_random_values(A);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, int16_to_int32)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int16_to_int32_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int16_to_int32", "entrypoint_simd": "int16_to_int32_simd"}
{"task_id": "SimdBench_55_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n}", "solution_scalar": "void conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = A[i];\n            val = (val - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> A(length);\n        std::vector<int32_t> control(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n        rng.initialize_vector_with_random_values(control);\n\n        float a = rng.uniform<float>(), b = rng.uniform<float>();\n        float min_val = std::min(a, b);\n        float max_val = std::max(a, b) + 0.1; // assert(min_val != max_val)\n\n        conditional_normalize(A.data(), control.data(), B.data(), length, min_val, max_val);\n        conditional_normalize_simd(A.data(), control.data(), B_simd.data(), length, min_val, max_val);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const int32_t*, float*, size_t, float, float)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> A(length);\n    std::vector<int32_t> control(length);\n    std::vector<float> B(length);\n    std::vector<float> B_simd(length);\n    \n    rng.initialize_vector_with_random_values(A);\n    rng.initialize_vector_with_random_values(control);\n\n    float a = rng.uniform<float>(), b = rng.uniform<float>();\n    float min_val = std::min(a, b);\n    float max_val = std::max(a, b) + 0.1; // assert(min_val != max_val)\n\n    for (auto _ : state) {\n        Func(A.data(), control.data(), B.data(), length, min_val, max_val);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_normalize)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_normalize_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "conditional_normalize", "entrypoint_simd": "conditional_normalize_simd"}
{"task_id": "SimdBench_56_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n}", "solution_scalar": "void int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint16_t high16 = static_cast<uint16_t>(A[i] >> 16);\n        float fval = static_cast<float>(high16);\n        B[i] = sqrtf(fval);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> A(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n\n        int_to_float_sqrt(A.data(), B.data(), length);\n        int_to_float_sqrt_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<uint32_t> A(length);\n    std::vector<float> B(length);\n    \n    rng.initialize_vector_with_random_values(A);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, int_to_float_sqrt)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int_to_float_sqrt_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int_to_float_sqrt", "entrypoint_simd": "int_to_float_sqrt_simd"}
{"task_id": "SimdBench_57_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Interpret the bit pattern of each uint32_t value in A as an IEEE 754 floating-point representation\n2. Store the resulting float value in B without any numerical conversion\n3. This is effectively a type-punning operation that reinterprets the bits directly\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n}", "solution_scalar": "void int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union { uint32_t i; float f; } u;\n        u.i = A[i];\n        B[i] = u.f;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> A(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n\n        int_bits_to_float(A.data(), B.data(), length);\n        int_bits_to_float_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<uint32_t> A(length);\n    std::vector<float> B(length);\n    \n    rng.initialize_vector_with_random_values(A);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\nBENCHMARK_TEMPLATE(BM, int_bits_to_float)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int_bits_to_float_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int_bits_to_float", "entrypoint_simd": "int_bits_to_float_simd"}
{"task_id": "SimdBench_58_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n}", "solution_scalar": "void conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int32_t> A(length);\n        std::vector<uint8_t> cond(length);\n        std::vector<float> diff(length);\n        std::vector<float> diff_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n        rng.initialize_vector_with_random_values(cond, true);\n\n        conditional_diff(A.data(), reinterpret_cast<const bool*>(cond.data()), diff.data(), length);\n        conditional_diff_simd(A.data(), reinterpret_cast<const bool*>(cond.data()), diff_simd.data(), length);\n\n        if(!allclose(diff, diff_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int32_t*, const bool*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int32_t> A(length);\n    std::vector<u_int8_t> cond(length);\n    std::vector<float> diff(length);\n    \n    rng.initialize_vector_with_random_values(A);\n    rng.initialize_vector_with_random_values(cond, true);\n\n    for (auto _ : state) {\n        Func(A.data(), reinterpret_cast<const bool*>(cond.data()), diff.data(), length);\n        benchmark::DoNotOptimize(diff.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_diff)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_diff_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "conditional_diff", "entrypoint_simd": "conditional_diff_simd"}
{"task_id": "SimdBench_59_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (src);\n- A pointer to a non-empty 64-bit unsigned integer (uint64_t) destination array (dst);\n- The common length of the arrays (length).\n\nYour goal is to:\n1. Convert each element in src to a 64-bit unsigned integer;\n2. Set all the high 32 bits of each value to 1 and store the results in dst.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n}", "solution_scalar": "void widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint64_t val = static_cast<uint64_t>(src[i]);\n        val |= 0xFFFFFFFF00000000ULL;\n        dst[i] = val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> src(length);\n        std::vector<uint64_t> dst(length);\n        std::vector<uint64_t> dst_simd(length);\n        \n        rng.initialize_vector_with_random_values(src);\n\n        widening_uint(src.data(), dst.data(), length);\n        widening_uint_simd(src.data(), dst_simd.data(), length);\n\n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint64_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const size_t length = state.range(0);\n\n    std::vector<uint32_t> src(length);\n    std::vector<uint64_t> dst(length);\n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, widening_uint)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, widening_uint_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "widening_uint", "entrypoint_simd": "widening_uint_simd"}
{"task_id": "SimdBench_60_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point source array (vec);\n- A pointer to a non-empty 16-bit integer (int16_t) index array (index);\n- The common length of the arrays (length).\n\nYour goal is to:\nFor all legal indices `index[i]` (i.e., within the range [0, length)), sum the elements `vec[index[i]]`, \nand return the result.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n}", "solution_scalar": "double indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] < length && index[i] >= 0) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<double> vec(length); rng.initialize_vector_with_random_values(vec);\n        std::vector<int16_t> index(length);\n        for(auto& item: index){\n            item = rng.randint<int16_t>( -(2*length), 2*length );\n        }\n\n        double res_scalar = indexed_sum(vec.data(), index.data(), length);\n        double res_simd = indexed_sum_simd(vec.data(), index.data(), length);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<double (*Func)(const double*, const int16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const size_t length = state.range(0);\n    std::vector<double> vec(length); rng.initialize_vector_with_random_values(vec);\n    std::vector<int16_t> index(length);\n    for(auto& item: index){\n        item = rng.randint<int16_t>( -(2*length), 2*length );\n    }\n\n    for (auto _ : state) {\n        double res = Func(vec.data(), index.data(), length);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, indexed_sum)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, indexed_sum_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "indexed_sum", "entrypoint_simd": "indexed_sum_simd"}
{"task_id": "SimdBench_61_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n}", "solution_scalar": "void simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n                    \n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n\n            // ReLU activation\n            if (sum < 0) { sum = 0.0; }\n            output[i * output_size + j] = sum;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t input_size = Small_Arg_2D;\n        size_t kernel_size = rng.randint(size_t(1), input_size);\n        size_t output_size = input_size - kernel_size + 1;\n\n        std::vector<double> input(input_size * input_size); rng.initialize_vector_with_random_values(input);\n        std::vector<double> kernel(kernel_size * kernel_size); rng.initialize_vector_with_random_values(kernel);\n        std::vector<double> output_scalar(output_size * output_size); rng.initialize_vector_with_random_values(output_scalar);\n        std::vector<double> output_simd(output_scalar);\n        \n        simple_conv2d(input.data(), kernel.data(), output_scalar.data(), input_size, kernel_size);\n        simple_conv2d_simd(input.data(), kernel.data(), output_simd.data(), input_size, kernel_size);\n\n        if(!allclose(output_scalar, output_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t input_size = state.range(0);\n    size_t kernel_size = 8;\n    size_t output_size = input_size - kernel_size + 1;\n\n    std::vector<double> input(input_size * input_size); rng.initialize_vector_with_random_values(input);\n    std::vector<double> kernel(kernel_size * kernel_size); rng.initialize_vector_with_random_values(kernel);\n    std::vector<double> output(output_size * output_size);\n\n    for (auto _ : state) {\n        Func(input.data(), kernel.data(), output.data(), input_size, kernel_size);\n        benchmark::DoNotOptimize(output.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, simple_conv2d)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, simple_conv2d_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "simple_conv2d", "entrypoint_simd": "simple_conv2d_simd"}
{"task_id": "SimdBench_62_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n}", "solution_scalar": "bool has_close_elements(const std::vector<double> & numbers, double threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (std::abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}", "test_correctness": "bool humaneval_check(){\n    std::vector<double> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    bool res = true;\n    res = res && (has_close_elements_simd(a, 0.3)==true);\n    res = res && (has_close_elements_simd(a, 0.05) == false);\n\n    res = res && (has_close_elements_simd({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    res = res && (has_close_elements_simd({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    res = res && (has_close_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    res = res && (has_close_elements_simd({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    res = res && (has_close_elements_simd({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<double> numbers(length); rng.initialize_vector_with_random_values(numbers);\n        double threshold = rng.normal_distribution<double>();\n        \n        bool res_scalar = has_close_elements(numbers, threshold);\n        bool res_simd = has_close_elements_simd(numbers, threshold);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::vector<double> &, double)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    size_t length = state.range(0);\n    std::vector<double> numbers(length); rng.initialize_vector_with_random_values(numbers);\n    double threshold = rng.normal_distribution<double>();\n\n    for (auto _ : state) {\n        bool res = Func(numbers, threshold);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, has_close_elements)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, has_close_elements_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/0", "entrypoint_scalar": "has_close_elements", "entrypoint_simd": "has_close_elements_simd"}
{"task_id": "SimdBench_63_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero_simd({1, 2, 3})\nfalse\n>>> below_zero_simd({1, 2, -4, 5})\ntrue\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool below_zero_simd(std::vector<int> operations){\n}", "solution_scalar": "bool below_zero(std::vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (below_zero_simd({}) == false);\n    res = res && (below_zero_simd({1, 2, -3, 1, 2, -3}) == false);\n    res = res && (below_zero_simd({1, 2, -4, 5, 6}) == true);\n    res = res && (below_zero_simd({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    res = res && (below_zero_simd({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    res = res && (below_zero_simd({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<int> operations(length);\n        for(auto& item:operations){\n            item = rng.randint<int>(-10.0, 20.0);\n        }\n        \n        bool res_scalar = below_zero(operations);\n        bool res_simd = below_zero_simd(operations);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    size_t length = state.range(0);\n    std::vector<int> operations(length);\n    for(auto& item:operations){\n        item = rng.randint<int>(-10.0, 20.0);\n    }\n\n    for (auto _ : state) {\n        bool res = Func(operations);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, below_zero)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, below_zero_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/3", "entrypoint_scalar": "below_zero", "entrypoint_simd": "below_zero_simd"}
{"task_id": "SimdBench_64_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n}", "solution_scalar": "double mean_absolute_deviation(std::vector<double> numbers){\n    double sum=0;\n    double avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (abs(mean_absolute_deviation_simd({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    res = res && (abs(mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    res = res && (abs(mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<double> numbers(length); \n        rng.initialize_vector_with_random_values(numbers);\n        \n        double res_scalar = mean_absolute_deviation(numbers);\n        double res_simd = mean_absolute_deviation_simd(numbers);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<double (*Func)(std::vector<double>)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    size_t length = state.range(0);\n    std::vector<double> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n\n    for (auto _ : state) {\n        double res = Func(numbers);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, mean_absolute_deviation)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, mean_absolute_deviation_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/4", "entrypoint_scalar": "mean_absolute_deviation", "entrypoint_simd": "mean_absolute_deviation_simd"}
{"task_id": "SimdBench_65_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n}", "solution_scalar": "std::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n    size_t output_size = numbers.size() + (numbers.size() - 1);\n    std::vector<int> out(output_size);\n\n    size_t out_index = 0;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        out[out_index++] = numbers[i];\n        if (i != numbers.size() - 1) { \n            out[out_index++] = delimeter;\n        }\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (allclose(intersperse_simd({}, 7), {}));\n    res = res && (allclose(intersperse_simd({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    res = res && (allclose(intersperse_simd({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        int delimeter = rng.randint<int>();\n        \n        std::vector<int> res_scalar = intersperse(numbers, delimeter);\n        std::vector<int> res_simd = intersperse_simd(numbers, delimeter);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t length = state.range(0);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    int delimeter = rng.randint<int>();\n\n    for (auto _ : state) {\n        std::vector<int> res = Func(numbers, delimeter);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, intersperse)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, intersperse_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/5", "entrypoint_scalar": "intersperse", "entrypoint_simd": "intersperse_simd"}
{"task_id": "SimdBench_66_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n}", "solution_scalar": "std::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (allclose(sum_product_simd({}) ,{0, 1}));\n    res = res && (allclose(sum_product_simd({1, 1, 1}), {3, 1}));\n    res = res && (allclose(sum_product_simd({100, 0}),{100, 0}));\n    res = res && (allclose(sum_product_simd({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n    res = res && (allclose(sum_product_simd({10}) ,{10, 10}));\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(1), size_t(32));\n\n        std::vector<int16_t> numbers(length);\n        for(auto& item:numbers){\n            item = rng.randint<int16_t>(1, 4);\n        }\n        \n        std::vector<int64_t> res_scalar = sum_product(numbers);\n        std::vector<int64_t> res_simd = sum_product_simd(numbers);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int64_t> (*Func)(std::vector<int16_t>)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t length = state.range(0);\n    std::vector<int16_t> numbers(length);\n    for(auto& item:numbers){\n        item = 1;\n    }\n\n    for (auto _ : state) {\n        std::vector<int64_t> res = Func(numbers);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sum_product)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sum_product_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/8", "entrypoint_scalar": "sum_product", "entrypoint_simd": "sum_product_simd"}
{"task_id": "SimdBench_67_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n}", "solution_scalar": "std::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> out(numbers.size());\n    int max = numbers[0];\n    out[0] = max;\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max = std::max(max, numbers[i]);\n        out[i] = max;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (allclose(rolling_max_simd({}),{}));\n    res = res && (allclose(rolling_max_simd({1, 2, 3, 4}) , {1, 2, 3, 4}));\n    res = res && (allclose(rolling_max_simd({4, 3, 2, 1}),{4, 4, 4, 4}));\n    res = res && (allclose(rolling_max_simd({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<int> numbers(length); rng.initialize_vector_with_random_values(numbers);       \n        std::vector<int> res_scalar = rolling_max(numbers);\n        std::vector<int> res_simd = rolling_max_simd(numbers);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t length = state.range(0);\n    std::vector<int> numbers(length); rng.initialize_vector_with_random_values(numbers);\n\n    for (auto _ : state) {\n        std::vector<int> res = Func(numbers);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, rolling_max)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, rolling_max_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/9", "entrypoint_scalar": "rolling_max", "entrypoint_simd": "rolling_max_simd"}
{"task_id": "SimdBench_68_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n}", "solution_scalar": "std::string string_xor(std::string a, std::string b){\n    std::string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (string_xor_simd(\"111000\", \"101010\") == \"010010\");\n    res = res && (string_xor_simd(\"1\", \"1\") == \"0\");\n    res = res && (string_xor_simd(\"0101\", \"0000\") == \"0101\");\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = \"01\";\n        std::string a = rng.random_string(charset, length);\n        std::string b = rng.random_string(charset, length);\n              \n        std::string res_scalar = string_xor(a, b);\n        std::string res_simd = string_xor_simd(a, b);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(std::string, std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = \"01\";\n    std::string a = rng.random_string(charset, length);\n    std::string b = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        std::string res = Func(a, b);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, string_xor)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, string_xor_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/11", "entrypoint_scalar": "string_xor", "entrypoint_simd": "string_xor_simd"}
{"task_id": "SimdBench_69_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n}", "solution_scalar": "std::string longest(const std::vector<std::string>& strings){\n    std::string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (longest_simd({}) == \"\");\n    res = res && (longest_simd({\"x\", \"y\", \"z\"}) == \"x\");\n    res = res && (longest_simd({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_ALPHANUMERIC;\n        std::vector<std::string> strings(length);\n        for(auto& item: strings){\n            item = rng.random_string(charset, rng.randint(size_t(0), size_t(64)));\n        }\n              \n        std::string res_scalar = longest(strings);\n        std::string res_simd = longest_simd(strings);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::vector<std::string>&)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_ALPHANUMERIC;\n    std::vector<std::string> strings(length);\n    for(auto& item: strings){\n        item = rng.random_string(charset, rng.randint(size_t(0), size_t(64)));\n    }\n\n    for (auto _ : state) {\n        std::string res = Func(strings);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, longest)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, longest_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/12", "entrypoint_scalar": "longest", "entrypoint_simd": "longest_simd"}
{"task_id": "SimdBench_70_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n}", "solution_scalar": "uint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    uint64_t out, m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (greatest_common_divisor_simd(3, 7) == 1);\n    res = res && (greatest_common_divisor_simd(10, 15) == 5);\n    res = res && (greatest_common_divisor_simd(49, 14) == 7);\n    res = res && (greatest_common_divisor_simd(144, 60) == 12);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t a = rng.randint<uint64_t>(1);\n        uint64_t b = rng.randint<uint64_t>(1);\n        \n        uint64_t result = greatest_common_divisor(a, b);\n        uint64_t result_simd = greatest_common_divisor_simd(a, b);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t, uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    uint64_t a = rng.randint<uint64_t>(1);\n    uint64_t b = rng.randint<uint64_t>(1, 1024);\n\n    for (auto _ : state) {\n        uint64_t res = Func(a, b);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, greatest_common_divisor)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, greatest_common_divisor_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/13", "entrypoint_scalar": "greatest_common_divisor", "entrypoint_simd": "greatest_common_divisor_simd"}
{"task_id": "SimdBench_71_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n}", "solution_scalar": "std::vector<float> find_closest_elements(std::vector<float> numbers){\n    std::vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or std::abs(numbers[i]-numbers[j])<std::abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n    pass = pass && (allclose(find_closest_elements_simd({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n    return true;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(2), size_t(512));\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = find_closest_elements(numbers);\n        std::vector<float> result_simd = find_closest_elements_simd(numbers);\n        \n        if(result.size() != 2 || result_simd.size() != 2 || \n           result[0] != result_simd[0] || result[1] != result_simd[1]){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, find_closest_elements)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, find_closest_elements_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/20", "entrypoint_scalar": "find_closest_elements", "entrypoint_simd": "find_closest_elements_simd"}
{"task_id": "SimdBench_72_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n}", "solution_scalar": "std::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(rescale_to_unit_simd({2.0, 49.9}), {0.0, 1.0}));\n    pass = pass && (allclose(rescale_to_unit_simd({100.0, 49.9}), {1.0, 0.0}));\n    pass = pass && (allclose(rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0}), {0.0, 0.25, 0.5, 0.75, 1.0}));\n    pass = pass && (allclose(rescale_to_unit_simd({2.0, 1.0, 5.0, 3.0, 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75}));\n    pass = pass && (allclose(rescale_to_unit_simd({12.0, 11.0, 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(2), size_t(128));\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = rescale_to_unit(numbers);\n        std::vector<float> result_simd = rescale_to_unit_simd(numbers);\n        \n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, rescale_to_unit)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, rescale_to_unit_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/21", "entrypoint_scalar": "rescale_to_unit", "entrypoint_simd": "rescale_to_unit_simd"}
{"task_id": "SimdBench_73_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n}", "solution_scalar": "uint64_t largest_divisor(uint64_t n){\n    for (uint64_t i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (largest_divisor_simd(3) == 1);\n    pass = pass && (largest_divisor_simd(7) == 1);\n    pass = pass && (largest_divisor_simd(10) == 5);\n    pass = pass && (largest_divisor_simd(100) == 50);\n    pass = pass && (largest_divisor_simd(49) == 7);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t n = rng.randint<uint64_t>(1, 1000000);\n        uint64_t result = largest_divisor(n);\n        uint64_t result_simd = largest_divisor_simd(n);        \n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    uint64_t n = rng.randint<uint64_t>(1 << 12, 1 << 24);\n\n    for (auto _ : state) {\n        uint64_t res = Func(n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, largest_divisor)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, largest_divisor_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/24", "entrypoint_scalar": "largest_divisor", "entrypoint_simd": "largest_divisor_simd"}
{"task_id": "SimdBench_74_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector of prime factors of given integer in the order from smallest to largest.\nEach of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\nInput number should be equal to the product of all factors\n>>> factorize_simd(8)\n{2, 2, 2}\n>>> factorize_simd(25)\n{5, 5}\n>>> factorize_simd(70)\n{2, 5, 7}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> factorize_simd(int n){\n}", "solution_scalar": "std::vector<int> factorize(int n) {\n    // Estimate the maximum size of the factor list\n    int max_factors = std::log2(n) + 1;  // A rough upper bound for prime factors\n    std::vector<int> out(max_factors);  // Pre-allocate space\n    int index = 0;  // Current position in the vector\n\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {  // While `i` is a factor of `n`\n            n /= i;\n            out[index++] = i;  // Add factor to the vector\n        }\n    }\n    if (n > 1) {  // If there is a remaining prime factor > sqrt(n)\n        out[index++] = n;\n    }\n\n    // Resize the vector to match the number of factors found\n    out.resize(index);\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(factorize_simd(2) , {2}));\n    pass = pass && (allclose(factorize_simd(4) , {2, 2}));\n    pass = pass && (allclose(factorize_simd(8) , {2, 2, 2}));\n    pass = pass && (allclose(factorize_simd(3 * 19) , {3, 19}));\n    pass = pass && (allclose(factorize_simd(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    pass = pass && (allclose(factorize_simd(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    pass = pass && (allclose(factorize_simd(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    pass = pass && (allclose(factorize_simd(3 * 2 * 3) , {2, 3, 3}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint(2, 1000000);\n        std::vector<int> result = factorize(n);\n        std::vector<int> result_simd = factorize_simd(n);\n    \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    int n = rng.randint<int>(1 << 15, 1 << 30);\n\n    for (auto _ : state) {\n        std::vector<int> res = Func(n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, factorize)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, factorize_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/25", "entrypoint_scalar": "factorize", "entrypoint_simd": "factorize_simd"}
{"task_id": "SimdBench_75_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n}", "solution_scalar": "std::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> out(l.size());  // Pre-allocate space equal to the input size\n    int index = 0;  // Track the current position in the output vector\n\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] > 0) {\n            out[index++] = l[i];  // Add positive numbers to the output vector\n        }\n    }\n    // Resize the vector to contain only the positive numbers\n    out.resize(index);\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(get_positive_simd({-1, -2, 4, 5, 6}), { 4, 5, 6}));\n    pass = pass && (allclose(get_positive_simd({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), {5, 3, 2, 3, 3, 9, 123, 1}));\n    pass = pass && (allclose(get_positive_simd({-1, -2}), {}));\n    pass = pass && (allclose(get_positive_simd({}), {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = get_positive(numbers);\n        std::vector<float> result_simd = get_positive_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(const std::vector<float> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, get_positive)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, get_positive_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/30", "entrypoint_scalar": "get_positive", "entrypoint_simd": "get_positive_simd"}
{"task_id": "SimdBench_76_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime_simd(6)\nfalse\n>>> is_prime_simd(101)\ntrue\n>>> is_prime_simd(11)\ntrue\n>>> is_prime_simd(13441)\ntrue\n>>> is_prime_simd(61)\ntrue\n>>> is_prime_simd(4)\nfalse\n>>> is_prime_simd(1)\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n){\n}", "solution_scalar": "bool is_prime(int64_t n){\n    if (n<2) return false;\n    for (int64_t i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_prime_simd(6) == false);\n    pass = pass && (is_prime_simd(101) == true);\n    pass = pass && (is_prime_simd(11) == true);\n    pass = pass && (is_prime_simd(13441) == true);\n    pass = pass && (is_prime_simd(61) == true);\n    pass = pass && (is_prime_simd(4) == false);\n    pass = pass && (is_prime_simd(1) == false);\n    pass = pass && (is_prime_simd(5) == true);\n    pass = pass && (is_prime_simd(11) == true);\n    pass = pass && (is_prime_simd(17) == true);\n    pass = pass && (is_prime_simd(5 * 17) == false);\n    pass = pass && (is_prime_simd(11 * 7) == false);\n    pass = pass && (is_prime_simd(13441 * 19) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int64_t n = rng.randint(2, 1000000);\n        bool result = is_prime(n);\n        bool result_simd = is_prime_simd(n);\n    \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(int64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    std::vector<int64_t> large_primes = {100000007, 1000000007, 10000000019, 100000000003, 1000000000039,\n    100000841, 1000000931, 10000001051, 10000000949, 100000000747, 1000000001123};\n    \n    int64_t n = rng.choice(large_primes);\n    for (auto _ : state) {\n        bool res = Func(n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_prime)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, is_prime_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/31", "entrypoint_scalar": "is_prime", "entrypoint_simd": "is_prime_simd"}
{"task_id": "SimdBench_77_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n}", "solution_scalar": "std::string solve(const std::string & s){\n    int nletter=0;\n    std::string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        std::string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (solve_simd(\"AsDf\") == \"aSdF\");\n    res = res && (solve_simd(\"1234\") == \"4321\");\n    res = res && (solve_simd(\"ab\") == \"AB\");\n    res = res && (solve_simd(\"#a@C\") == \"#A@c\");\n    res = res && (solve_simd(\"#AsdfW^45\") == \"#aSDFw^45\");\n    res = res && (solve_simd(\"#6@2\") == \"2@6#\");\n    res = res && (solve_simd(\"#$a^D\") == \"#$A^d\");\n    res = res && (solve_simd(\"#ccc\") == \"#CCC\");\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::string charset;\n        if( i % 2 ) charset = CHARSET_PRINTABLE;\n        else charset = CHARSET_DIGITS;\n\n        std::string s = rng.random_string(charset, length);\n\n        std::string res_scalar = solve(s);\n        std::string res_simd = solve_simd(s);\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t length = state.range(0);\n    \n    std::string charset;\n    if(rng.random_bool()) charset = CHARSET_PRINTABLE;\n    else charset = CHARSET_DIGITS;\n    \n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        std::string res = Func(s);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, solve)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, solve_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/161", "entrypoint_scalar": "solve", "entrypoint_simd": "solve_simd"}
{"task_id": "SimdBench_78_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n}", "solution_scalar": "std::vector<int> sort_third(std::vector<int> l) {\n    int third_size = (l.size() + 2) / 3;\n    std::vector<int> third(third_size);\n    for (int i = 0; i < third_size; i++) {\n        third[i] = l[i * 3];\n    }\n    std::sort(third.begin(), third.end());\n    std::vector<int> out(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(sort_third_simd({1, 2, 3}), sort_third({1, 2, 3})));\n    pass = pass && (allclose(sort_third_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), \n                     sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    pass = pass && (allclose(sort_third_simd({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}),\n                     sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    pass = pass && (allclose(sort_third_simd({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5}));\n    pass = pass && (allclose(sort_third_simd({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5}));\n    pass = pass && (allclose(sort_third_simd({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5}));\n    pass = pass && (allclose(sort_third_simd({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<int> result = sort_third(numbers);\n        std::vector<int> result_simd = sort_third_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sort_third)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sort_third_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/33", "entrypoint_scalar": "sort_third", "entrypoint_simd": "sort_third_simd"}
{"task_id": "SimdBench_79_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n}", "solution_scalar": "float max_element(std::vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(max_element_simd({1, 2, 3}), 3.0f));\n    pass = pass && (allclose(max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), 124.0f));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        float result = max_element(numbers);\n        float result_simd = max_element_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<float (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, max_element)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, max_element_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/35", "entrypoint_scalar": "max_element", "entrypoint_simd": "max_element_simd"}
{"task_id": "SimdBench_80_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n}", "solution_scalar": "int fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (fizz_buzz_simd(50) == 0);\n    pass = pass && (fizz_buzz_simd(78) == 2);\n    pass = pass && (fizz_buzz_simd(79) == 3);\n    pass = pass && (fizz_buzz_simd(100) == 3);\n    pass = pass && (fizz_buzz_simd(200) == 6);\n    pass = pass && (fizz_buzz_simd(4000) == 192);\n    pass = pass && (fizz_buzz_simd(10000) == 639);\n    pass = pass && (fizz_buzz_simd(100000) == 8026);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(0, 10000);\n        \n        auto result = fizz_buzz(n);\n        auto result_simd = fizz_buzz_simd(n);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const size_t n = state.range(0);    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, fizz_buzz)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, fizz_buzz_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/36", "entrypoint_scalar": "fizz_buzz", "entrypoint_simd": "fizz_buzz_simd"}
{"task_id": "SimdBench_81_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n}", "solution_scalar": "std::vector<float> sort_even(std::vector<float> l) {\n    int even_size = (l.size() + 1) / 2;\n    std::vector<float> even(even_size);\n\n    for (int i = 0; i < even_size; i++) {\n        even[i] = l[i * 2];\n    }\n\n    std::sort(even.begin(), even.end());\n    std::vector<float> out(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(sort_even_simd({1, 2, 3}), {1, 2, 3}));\n    pass = pass && (allclose(sort_even_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), \n                     {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    pass = pass && (allclose(sort_even_simd({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}),\n                     {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = sort_even(numbers);\n        std::vector<float> result_simd = sort_even_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sort_even)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sort_even_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/37", "entrypoint_scalar": "sort_even", "entrypoint_simd": "sort_even_simd"}
{"task_id": "SimdBench_82_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\ntriples_sum_to_zero takes a vector of integers as an input.\nit returns true if there are three distinct elements in the vector that\nsum to zero, and false otherwise.\n\n>>> triples_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero_simd({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero_simd({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool triples_sum_to_zero_simd(std::vector<int> l){\n}", "solution_scalar": "bool triples_sum_to_zero(std::vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (triples_sum_to_zero_simd({1, 3, 5, 0}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 3, 5, -1}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 3, -2, 1}) == true);\n    pass = pass && (triples_sum_to_zero_simd({1, 2, 3, 7}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 2, 5, 7}) == false);\n    pass = pass && (triples_sum_to_zero_simd({2, 4, -5, 3, 9, 7}) == true);\n    pass = pass && (triples_sum_to_zero_simd({1}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 3, 5, -100}) == false);\n    pass = pass && (triples_sum_to_zero_simd({100, 3, 5, -100}) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_2D;\n        std::vector<int> numbers(length);\n        for(auto& number : numbers) {\n            number = rng.randint(-100, 100);\n        }\n        \n        bool result = triples_sum_to_zero(numbers);\n        bool result_simd = triples_sum_to_zero_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = sqrt(state.range(0) * state.range(1));\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, triples_sum_to_zero)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, triples_sum_to_zero_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/40", "entrypoint_scalar": "triples_sum_to_zero", "entrypoint_simd": "triples_sum_to_zero_simd"}
{"task_id": "SimdBench_83_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n}", "solution_scalar": "std::vector<int> incr_list(std::vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(incr_list_simd({}), {}));\n    pass = pass && (allclose(incr_list_simd({3, 2, 1}), {4, 3, 2}));\n    pass = pass && (allclose(incr_list_simd({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> numbers(length);\n        for (size_t j = 0; j < length; j++) {\n            numbers[j] = rng.randint( - (1 << 24), (1 << 24));\n        }\n        \n        std::vector<int> result = incr_list(numbers);\n        std::vector<int> result_simd = incr_list_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, incr_list)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, incr_list_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/42", "entrypoint_scalar": "incr_list", "entrypoint_simd": "incr_list_simd"}
{"task_id": "SimdBench_84_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\npairs_sum_to_zero takes a vector of integers as an input.\nit returns true if there are two distinct elements in the vector that\nsum to zero, and false otherwise.\n>>> pairs_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero_simd({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero_simd({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n}", "solution_scalar": "bool pairs_sum_to_zero(std::vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (pairs_sum_to_zero_simd({1, 3, 5, 0}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({1, 3, -2, 1}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({1, 2, 3, 7}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({2, 4, -5, 3, 5, 7}) == true);\n    pass = pass && (pairs_sum_to_zero_simd({1}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 3, 2, 30}) == true);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 3, 2, 31}) == true);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 4, 2, 30}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 4, 2, 31}) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for (size_t j = 0; j < length; j++) {\n            numbers[j] = rng.randint( -(1<<10), 1>>10);\n        }\n        \n        bool result = pairs_sum_to_zero(numbers);\n        bool result_simd = pairs_sum_to_zero_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    for (size_t j = 0; j < length; j++) {\n        numbers[j] = rng.randint( -(1<<10), 1>>10);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, pairs_sum_to_zero)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, pairs_sum_to_zero_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/43", "entrypoint_scalar": "pairs_sum_to_zero", "entrypoint_simd": "pairs_sum_to_zero_simd"}
{"task_id": "SimdBench_85_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nChange numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.\n>>> change_base_simd(8, 3)\n\"22\"\n>>> change_base_simd(8, 2)\n\"1000\"\n>>> change_base_simd(7, 2)\n\"111\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string change_base_simd(int64_t x, int8_t base){\n}", "solution_scalar": "std::string change_base(int64_t x, int8_t base){\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = std::abs(x);\n    }\n    std::string out=\"\";\n    if(x==0) out=std::to_string(0);\n    while (x>0)\n    {\n        out=std::to_string(x%base)+out;\n        x=x/base;\n    }\n    if (is_negative) {\n        out = \"-\" + out;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;    \n    pass = pass && (change_base_simd(8, 3) == \"22\");\n    pass = pass && (change_base_simd(9, 3) == \"100\");\n    pass = pass && (change_base_simd(234, 2) == \"11101010\");\n    pass = pass && (change_base_simd(16, 2) == \"10000\");\n    pass = pass && (change_base_simd(8, 2) == \"1000\");\n    pass = pass && (change_base_simd(7, 2) == \"111\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int x = rng.randint<int>(); if(i==0) x=0;\n        int base = rng.randint<int>(2, 9);\n        \n        auto result = change_base(x, base);\n        auto result_simd = change_base_simd(x, base);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(int64_t, int8_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t x = state.range(0); \n    int base = 3;   \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(x, base));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, change_base)->Name(\"Scalar\")->Arg(1<<30)->Arg(int64_t(1)<<35)->Arg(int64_t(1)<<40)->Arg(int64_t(1)<<45)\n->Arg(int64_t(1)<<50)->Arg(int64_t(1)<<55)->Arg(int64_t(1)<<60);\nBENCHMARK_TEMPLATE(BM, change_base_simd)->Name(\"SIMD\")->Arg(1<<30)->Arg(int64_t(1)<<35)->Arg(int64_t(1)<<40)->Arg(int64_t(1)<<45)\n->Arg(int64_t(1)<<50)->Arg(int64_t(1)<<55)->Arg(int64_t(1)<<60);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/44", "entrypoint_scalar": "change_base", "entrypoint_simd": "change_base_simd"}
{"task_id": "SimdBench_86_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n}", "solution_scalar": "bool is_palindrome(std::string text){\n    for(int i = 0; i < text.size() / 2; i++){\n        if(text[i] != text[text.size() - 1 - i]){\n            return false;\n        }\n    }\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_palindrome_simd(\"\") == true);\n    pass = pass && (is_palindrome_simd(\"aba\") == true);\n    pass = pass && (is_palindrome_simd(\"aaaaa\") == true);\n    pass = pass && (is_palindrome_simd(\"zbcd\") == false);\n    pass = pass && (is_palindrome_simd(\"xywyx\") == true);\n    pass = pass && (is_palindrome_simd(\"xywyz\") == false);\n    pass = pass && (is_palindrome_simd(\"xywzx\") == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    for (int i = 0; i < iterations; i++) {\n        int length = rng.randint<int>(0, 128);\n        std::string charset = rng.choice(charsets);\n        std::string text = rng.random_string(charset, length);\n        if(rng.random_bool()){\n            for(int ii = 0; ii < text.size() / 2; ii++) \n                text[ii] = text[text.size() - 1 - ii];\n        }\n        \n        auto result = is_palindrome(text);\n        auto result_simd = is_palindrome_simd(text);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    const size_t length = state.range(0);  \n    std::string charset = rng.choice(charsets);\n    std::string text = rng.random_string(charset, length);  \n    for(int ii = 0; ii < text.size() / 2; ii++) \n        text[ii] = text[text.size() - 1 - ii];\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(text));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_palindrome)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_palindrome_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/48", "entrypoint_scalar": "is_palindrome", "entrypoint_simd": "is_palindrome_simd"}
{"task_id": "SimdBench_87_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n}", "solution_scalar": "std::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+21-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "test_correctness": "std::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nbool humaneval_check() {\n    bool pass = true;\n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        std::string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        std::string encoded_str = encode_shift(str);\n        pass = pass && (decode_shift_simd(encoded_str) == str);\n    }\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    for (int i = 0; i < iterations; i++) {\n        int length = rng.randint<int>(0, 128);\n        std::string charset = rng.choice(charsets);\n        std::string text = rng.random_string(charset, length);\n        \n        auto result = decode_shift(text);\n        auto result_simd = decode_shift_simd(text);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    const size_t length = state.range(0);  \n    std::string charset = rng.choice(charsets);\n    std::string text = rng.random_string(charset, length);  \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(text));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, decode_shift)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, decode_shift_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/50", "entrypoint_scalar": "decode_shift", "entrypoint_simd": "decode_shift_simd"}
{"task_id": "SimdBench_88_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n}", "solution_scalar": "bool below_threshold(std::vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (below_threshold_simd({1, 2, 4, 10}, 100));\n    pass = pass && (!below_threshold_simd({1, 20, 4, 10}, 5));\n    pass = pass && (below_threshold_simd({1, 20, 4, 10}, 21));\n    pass = pass && (below_threshold_simd({1, 20, 4, 10}, 22));\n    pass = pass && (below_threshold_simd({1, 8, 4, 10}, 11));\n    pass = pass && (!below_threshold_simd({1, 8, 4, 10}, 10));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for (size_t j = 0; j < length; j++) {\n            numbers[j] = rng.randint<int>(-100, 100);\n        }\n        int threshold = rng.randint<int>(-1000, 1000);\n        \n        bool result = below_threshold(numbers, threshold);\n        bool result_simd = below_threshold_simd(numbers, threshold);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    int threshold = rng.randint<int>() % 100;\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers, threshold));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, below_threshold)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, below_threshold_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/52", "entrypoint_scalar": "below_threshold", "entrypoint_simd": "below_threshold_simd"}
{"task_id": "SimdBench_89_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nbrackets is a string of '<' and '>'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing_simd(\"<\")\nfalse\n>>> correct_bracketing_simd(\"<>\")\ntrue\n>>> correct_bracketing_simd(\"<<><>>\")\ntrue\n>>> correct_bracketing_simd(\"><<>\")\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool correct_bracketing_simd(std::string brackets){\n}", "solution_scalar": "bool correct_bracketing(std::string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (correct_bracketing_simd(\"<>\"));\n    pass = pass && (correct_bracketing_simd(\"<<><>>\"));\n    pass = pass && (correct_bracketing_simd(\"<><><<><>><>\"));\n    pass = pass && (correct_bracketing_simd(\"<><><<<><><>><>><<><><<>>>\"));\n    pass = pass && (! (correct_bracketing_simd(\"<<<><>>>>\")));\n    pass = pass && (! (correct_bracketing_simd(\"><<>\")));\n    pass = pass && (! (correct_bracketing_simd(\"<\")));\n    pass = pass && (! (correct_bracketing_simd(\"<<<<\")));\n    pass = pass && (! (correct_bracketing_simd(\">\")));\n    pass = pass && (! (correct_bracketing_simd(\"<<>\")));\n    pass = pass && (! (correct_bracketing_simd(\"<><><<><>><>><<>\")));\n    pass = pass && (! (correct_bracketing_simd(\"<><><<><>><>>><>\")));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 32);\n        const std::string charset = \"<>\";\n        std::string brackets = rng.random_string(charset, length);\n              \n        bool res_scalar = correct_bracketing(brackets);\n        bool res_simd = correct_bracketing_simd(brackets);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::string brackets;\n    if(rng.random_bool()){\n        for (int i = 0; i < length; ++i) {\n            brackets += \"<>\";\n        }\n    }else{\n        brackets = std::string(length, '<') + std::string(length, '>');\n    }\n\n    for (auto _ : state) {\n        bool res = Func(brackets);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, correct_bracketing)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, correct_bracketing_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/56", "entrypoint_scalar": "correct_bracketing", "entrypoint_simd": "correct_bracketing_simd"}
{"task_id": "SimdBench_90_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n/*\nbrackets is a string of '(' and ')'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing_simd(\"(\")\nfalse\n>>> correct_bracketing_simd(\"()\")\ntrue\n>>> correct_bracketing_simd(\"(()())\")\ntrue\n>>> correct_bracketing_simd(\")(()\")\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\n}", "solution_scalar": "bool correct_bracketing(std::string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (correct_bracketing_simd(\"()\"));\n    pass = pass && (correct_bracketing_simd(\"(()())\"));\n    pass = pass && (correct_bracketing_simd(\"()()(()())()\"));\n    pass = pass && (correct_bracketing_simd(\"()()((()()())())(()()(()))\"));\n    pass = pass && (! (correct_bracketing_simd(\"((()())))\")));\n    pass = pass && (! (correct_bracketing_simd(\")(()\")));\n    pass = pass && (! (correct_bracketing_simd(\"(\")));\n    pass = pass && (! (correct_bracketing_simd(\"((((\")));\n    pass = pass && (! (correct_bracketing_simd(\")\")));\n    pass = pass && (! (correct_bracketing_simd(\"(()\")));\n    pass = pass && (! (correct_bracketing_simd(\"()()(()())())(()\")));\n    pass = pass && (! (correct_bracketing_simd(\"()()(()())()))()\")));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 32);\n        const std::string charset = \"()\";\n        std::string brackets = rng.random_string(charset, length);\n              \n        bool res_scalar = correct_bracketing(brackets);\n        bool res_simd = correct_bracketing_simd(brackets);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::string brackets;\n    if(rng.random_bool()){\n        for (int i = 0; i < length; ++i) {\n            brackets += \"()\";\n        }\n    }else{\n        brackets = std::string(length, '(') + std::string(length, ')');\n    }\n\n    for (auto _ : state) {\n        bool res = Func(brackets);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, correct_bracketing)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, correct_bracketing_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/61", "entrypoint_scalar": "correct_bracketing", "entrypoint_simd": "correct_bracketing_simd"}
{"task_id": "SimdBench_91_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n}", "solution_scalar": "std::vector<float> derivative(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        std::vector<float> out(0);\n        return out;\n    }\n    std::vector<float> out(xs.size() - 1);\n    for (std::size_t i = 1; i < xs.size(); i++) {\n        out[i - 1] = i * xs[i];\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(derivative_simd({3, 1, 2, 4, 5}), {1, 4, 12, 20}));\n    pass = pass && (allclose(derivative_simd({1, 2, 3}), {2, 6}));\n    pass = pass && (allclose(derivative_simd({3, 2, 1}), {2, 2}));\n    pass = pass && (allclose(derivative_simd({3, 2, 1, 0, 4}), {2, 2, 0, 16}));\n    pass = pass && (allclose(derivative_simd({1}), {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = derivative(numbers);\n        std::vector<float> result_simd = derivative_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, derivative)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, derivative_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/62", "entrypoint_scalar": "derivative", "entrypoint_simd": "derivative_simd"}
{"task_id": "SimdBench_92_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n}", "solution_scalar": "int vowels_count(std::string s){\n    std::string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (vowels_count_simd(\"abcde\") == 2);\n    pass = pass && (vowels_count_simd(\"Alone\") == 3);\n    pass = pass && (vowels_count_simd(\"key\") == 2);\n    pass = pass && (vowels_count_simd(\"bye\") == 1);\n    pass = pass && (vowels_count_simd(\"keY\") == 2);\n    pass = pass && (vowels_count_simd(\"bYe\") == 1);\n    pass = pass && (vowels_count_simd(\"ACEDY\") == 3);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_ALPHANUMERIC;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = vowels_count(s);\n        auto res_simd = vowels_count_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_ALPHANUMERIC;\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        int res = Func(s);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vowels_count)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vowels_count_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/64", "entrypoint_scalar": "vowels_count", "entrypoint_simd": "vowels_count_simd"}
{"task_id": "SimdBench_93_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n}", "solution_scalar": "int digitSum(std::string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (digitSum_simd(\"\") == 0);\n    pass = pass && (digitSum_simd(\"abAB\") == 131);\n    pass = pass && (digitSum_simd(\"abcCd\") == 67);\n    pass = pass && (digitSum_simd(\"helloE\") == 69);\n    pass = pass && (digitSum_simd(\"woArBld\") == 131);\n    pass = pass && (digitSum_simd(\"aAaaaXa\") == 153);\n    pass = pass && (digitSum_simd(\" How are yOu?\") == 151);\n    pass = pass && (digitSum_simd(\"You arE Very Smart\") == 327);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_PRINTABLE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = digitSum(s);\n        auto res_simd = digitSum_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_PRINTABLE;\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, digitSum)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, digitSum_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/66", "entrypoint_scalar": "digitSum", "entrypoint_simd": "digitSum_simd"}
{"task_id": "SimdBench_94_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a vector, { smalest_value, its index },\nIf there are no even values or the given vector is empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> pluck_simd(std::vector<int> arr){\n}", "solution_scalar": "std::vector<int> pluck(std::vector<int> arr){\n    std::vector<int> out(0);\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(pluck_simd({4,2,3}), {2, 1}));\n    pass = pass && (allclose(pluck_simd({1,2,3}), {2, 1}));\n    pass = pass && (allclose(pluck_simd({}), {}));\n    pass = pass && (allclose(pluck_simd({5, 0, 3, 0, 4, 2}), {0, 1}));\n    pass = pass && (allclose(pluck_simd({1, 2, 3, 0, 5, 3}), {0, 3}));\n    pass = pass && (allclose(pluck_simd({5, 4, 8, 4 ,8}), {4, 1}));\n    pass = pass && (allclose(pluck_simd({7, 6, 7, 1}), {6, 1}));\n    pass = pass && (allclose(pluck_simd({7, 9, 7, 1}), {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<int> result = pluck(numbers);\n        std::vector<int> result_simd = pluck_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, pluck)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, pluck_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/68", "entrypoint_scalar": "pluck", "entrypoint_simd": "pluck_simd"}
{"task_id": "SimdBench_95_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a non-empty vector of positive integers. Return the greatest integer that is greater than \nzero, and has a frequency greater than or equal to the value of the integer itself. \nThe frequency of an integer is the number of times it appears in the vector.\nIf no such a value exist, return -1.\nExamples:\n    search_simd({4, 1, 2, 2, 3, 1}) == 2\n    search_simd({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search_simd({5, 5, 4, 4, 4}) == -1\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint search_simd(std::vector<int> lst){\n}", "solution_scalar": "int search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    int max = -1;\n    for (const auto& pair : freq) {\n        int value = pair.first;\n        int count = pair.second;\n        if (count >= value && value > max) {\n            max = value;\n        }\n    }\n    return max;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (search_simd({5, 5, 5, 5, 1}) == 1);\n    pass = pass && (search_simd({4, 1, 4, 1, 4, 4}) == 4);\n    pass = pass && (search_simd({3, 3}) == -1);\n    pass = pass && (search_simd({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    pass = pass && (search_simd({2, 3, 3, 2, 2}) == 2);\n    pass = pass && (search_simd({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    pass = pass && (search_simd({3, 2, 8, 2}) == 2);\n    pass = pass && (search_simd({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    pass = pass && (search_simd({8, 8, 3, 6, 5, 6, 4}) == -1);\n    pass = pass && (search_simd({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    pass = pass && (search_simd({1, 9, 10, 1, 3}) == 1);\n    pass = pass && (search_simd({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    pass = pass && (search_simd({1}) == 1);\n    pass = pass && (search_simd({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    pass = pass && (search_simd({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    pass = pass && (search_simd({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    pass = pass && (search_simd({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    pass = pass && (search_simd({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    pass = pass && (search_simd({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    pass = pass && (search_simd({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    pass = pass && (search_simd({10}) == -1);\n    pass = pass && (search_simd({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    pass = pass && (search_simd({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    pass = pass && (search_simd({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    pass = pass && (search_simd({3, 10, 10, 9, 2}) == -1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        int result = search(numbers);\n        int result_simd = search_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, search)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, search_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/69", "entrypoint_scalar": "search", "entrypoint_simd": "search_simd"}
{"task_id": "SimdBench_96_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that returns true if the non-empty object q will fly, and false otherwise.\nThe object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nwill_it_fly_simd({1, 2}, 5) \u279e false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly_simd({3, 2, 3}, 1) \u279e false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly_simd({3, 2, 3}, 9) \u279e true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly_simd({3}, 5) \u279e true\n// 3 is less than the maximum possible weight, and it's balanced.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool will_it_fly_simd(std::vector<int> q,int w){\n}", "solution_scalar": "bool will_it_fly(std::vector<int> q, int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (will_it_fly_simd({3, 2, 3}, 9) == true);\n    pass = pass && (will_it_fly_simd({1, 2}, 5) == false);\n    pass = pass && (will_it_fly_simd({3}, 5) == true);\n    pass = pass && (will_it_fly_simd({3, 2, 3}, 1) == false);\n    pass = pass && (will_it_fly_simd({1, 2, 3}, 6) == false);\n    pass = pass && (will_it_fly_simd({5}, 5) == true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for(auto & element : numbers) {\n            element = rng.randint<int>(-50, 100);\n        }\n        for(int j = 0; j < length / 2; j++) {\n            numbers[length - 1 - j] = numbers[j];\n        }\n        int weight = rng.randint<int>(0, 10000);\n        \n        bool result = will_it_fly(numbers, weight);\n        bool result_simd = will_it_fly_simd(numbers, weight);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    for(auto & element : numbers) {\n        element = rng.randint<int>(-50, 100);\n    }\n    for(int j = 0; j < length / 2; j++) {\n        numbers[length - 1 - j] = numbers[j];\n    }\n    int weight = rng.randint<int>(0, 10000);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers, weight));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, will_it_fly)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, will_it_fly_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/72", "entrypoint_scalar": "will_it_fly", "entrypoint_simd": "will_it_fly_simd"}
{"task_id": "SimdBench_97_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr){\n}", "solution_scalar": "int smallest_change(std::vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (smallest_change_simd({1,2,3,5,4,7,9,6}) == 4);\n    pass = pass && (smallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1);\n    pass = pass && (smallest_change_simd({1, 4, 2}) == 1);\n    pass = pass && (smallest_change_simd({1, 4, 4, 2}) == 1);\n    pass = pass && (smallest_change_simd({1, 2, 3, 2, 1}) == 0);\n    pass = pass && (smallest_change_simd({3, 1, 1, 3}) == 0);\n    pass = pass && (smallest_change_simd({1}) == 0);\n    pass = pass && (smallest_change_simd({0, 1}) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for(auto& number : numbers) {\n            number = rng.randint<int>(-10, 10);\n        }\n        \n        int result = smallest_change(numbers);\n        int result_simd = smallest_change_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, smallest_change)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, smallest_change_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/73", "entrypoint_scalar": "smallest_change", "entrypoint_simd": "smallest_change_simd"}
{"task_id": "SimdBench_98_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n}", "solution_scalar": "std::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (allclose(total_match_simd({}, {}) , {}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    pass = pass && (allclose(total_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    pass = pass && (allclose(total_match_simd({}, {\"this\"}) , {}));\n    pass = pass && (allclose(total_match_simd({\"this\"}, {}) , {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length1 = rng.randint(size_t(0), size_t(128));\n        size_t length2 = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_PRINTABLE;\n        std::vector<std::string> lst1(length1);\n        std::vector<std::string> lst2(length2);\n\n        for(auto & s: lst1) s = rng.random_string(charset, rng.randint(0,10));\n        for(auto & s: lst2) s = rng.random_string(charset, rng.randint(0,20));\n              \n        auto res_scalar = total_match(lst1, lst2);\n        auto res_simd = total_match_simd(lst1, lst2);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<std::string> (*Func)(const std::vector<std::string> &, const std::vector<std::string> &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0)/4;\n    const std::string charset = CHARSET_PRINTABLE;\n    std::vector<std::string> lst1(length);\n    std::vector<std::string> lst2(length);\n\n    for(auto & s: lst1) s = rng.random_string(charset, rng.randint(0,10));\n    for(auto & s: lst2) s = rng.random_string(charset, rng.randint(0,20));\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst1, lst2));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, total_match)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, total_match_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/74", "entrypoint_scalar": "total_match", "entrypoint_simd": "total_match_simd"}
{"task_id": "SimdBench_99_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n}", "solution_scalar": "bool is_simple_power(uint64_t x, uint64_t n){\n    uint64_t p=1, count=0;\n    while (p<=x && count<128)\n    {\n        if (p==x) return true;\n        p=p*n; count+=1;\n    }\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_simple_power_simd(1, 4)== true);\n    pass = pass && (is_simple_power_simd(2, 2)==true);\n    pass = pass && (is_simple_power_simd(8, 2)==true);\n    pass = pass && (is_simple_power_simd(3, 2)==false);\n    pass = pass && (is_simple_power_simd(3, 1)==false);\n    pass = pass && (is_simple_power_simd(5, 3)==false);\n    pass = pass && (is_simple_power_simd(16, 2)== true);\n    pass = pass && (is_simple_power_simd(143214, 16)== false);\n    pass = pass && (is_simple_power_simd(4, 2)==true);\n    pass = pass && (is_simple_power_simd(9, 3)==true);\n    pass = pass && (is_simple_power_simd(16, 4)==true);\n    pass = pass && (is_simple_power_simd(24, 2)==false);\n    pass = pass && (is_simple_power_simd(128, 4)==false);\n    pass = pass && (is_simple_power_simd(12, 6)==false);\n    pass = pass && (is_simple_power_simd(1, 1)==true);\n    pass = pass && (is_simple_power_simd(1, 12)==true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int x = rng.randint<int>(1, 10000);\n        int n = rng.randint<int>(1, 16);\n        \n        auto result = is_simple_power(x, n);\n        auto result_simd = is_simple_power_simd(x, n);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(uint64_t, uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    uint64_t n = rng.randint<int>(2, 3);\n    uint64_t x = pow(n, 30);  \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(x, n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_simple_power)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_simple_power_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/76", "entrypoint_scalar": "is_simple_power", "entrypoint_simd": "is_simple_power_simd"}
{"task_id": "SimdBench_100_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint hex_key_simd(const std::string & num){\n}", "solution_scalar": "int hex_key(const std::string & num){\n    std::string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (hex_key_simd(\"AB\") == 1);\n    res = res && (hex_key_simd(\"1077E\") == 2);\n    res = res && (hex_key_simd(\"ABED1A33\") == 4);\n    res = res && (hex_key_simd(\"2020\") == 2);\n    res = res && (hex_key_simd(\"123456789ABCDEF0\") == 6);\n    res = res && (hex_key_simd(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    res = res && (hex_key_simd(\"\") == 0);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_HEX;\n        std::string num = rng.random_string(charset, length);\n              \n        auto res_scalar = hex_key(num);\n        auto res_simd = hex_key_simd(num);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_HEX;\n    std::string num = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(num));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, hex_key)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, hex_key_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/78", "entrypoint_scalar": "hex_key", "entrypoint_simd": "hex_key_simd"}
{"task_id": "SimdBench_101_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n}", "solution_scalar": "bool is_happy(const std::string & s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (is_happy_simd(\"a\") == false );\n    pass = pass && (is_happy_simd(\"aa\") == false );\n    pass = pass && (is_happy_simd(\"abcd\") == true );\n    pass = pass && (is_happy_simd(\"aabb\") == false );\n    pass = pass && (is_happy_simd(\"adb\") == true );\n    pass = pass && (is_happy_simd(\"xyy\") == false );\n    pass = pass && (is_happy_simd(\"iopaxpoi\") == true );\n    pass = pass && (is_happy_simd(\"iopaxioi\") == false );\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(10));\n        const std::string charset = CHARSET_PRINTABLE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = is_happy(s);\n        auto res_simd = is_happy_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_PRINTABLE;\n    std::string s = \"\";\n    for(int i=0; i<length; ++i) s.push_back(charset[i%charset.length()]);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_happy)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_happy_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/80", "entrypoint_scalar": "is_happy", "entrypoint_simd": "is_happy_simd"}
{"task_id": "SimdBench_102_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n}", "solution_scalar": "bool prime_length(const std::string & str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (prime_length_simd(\"Hello\") == true);\n    pass = pass && (prime_length_simd(\"abcdcba\") == true);\n    pass = pass && (prime_length_simd(\"kittens\") == true);\n    pass = pass && (prime_length_simd(\"orange\") == false);\n    pass = pass && (prime_length_simd(\"wow\") == true);\n    pass = pass && (prime_length_simd(\"world\") == true);\n    pass = pass && (prime_length_simd(\"MadaM\") == true);\n    pass = pass && (prime_length_simd(\"Wow\") == true);\n    pass = pass && (prime_length_simd(\"\") == false);\n    pass = pass && (prime_length_simd(\"HI\") == true);\n    pass = pass && (prime_length_simd(\"go\") == true);\n    pass = pass && (prime_length_simd(\"gogo\") == false);\n    pass = pass && (prime_length_simd(\"aaaaaaaaaaaaaaa\") == false);\n    pass = pass && (prime_length_simd(\"Madam\") == true);\n    pass = pass && (prime_length_simd(\"M\") == false);\n    pass = pass && (prime_length_simd(\"0\") == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_PRINTABLE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = prime_length(s);\n        auto res_simd = prime_length_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    std::vector<size_t> large_primes = {8503057, 9834497, 29986577, 40960001, 45212177, 59969537, 65610001};\n    const std::string charset = CHARSET_ALPHA;\n    size_t length = rng.choice(large_primes);\n    std::string s = \"\";\n    for(int i=0; i<length; ++i) s.push_back(charset[i%charset.length()]);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, prime_length)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, prime_length_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/82", "entrypoint_scalar": "prime_length", "entrypoint_simd": "prime_length_simd"}
{"task_id": "SimdBench_103_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n}", "solution_scalar": "std::string solve(uint64_t N){\n    std::string str,bi=\"\";\n    str=std::to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=std::to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (solve_simd(1000) == \"1\");\n    pass = pass && (solve_simd(150) == \"110\");\n    pass = pass && (solve_simd(147) == \"1100\");\n    pass = pass && (solve_simd(333) == \"1001\");\n    pass = pass && (solve_simd(963) == \"10010\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        const uint64_t N = rng.randint<uint64_t>();\n              \n        auto res_scalar = solve(N);\n        auto res_simd = solve_simd(N);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    const uint64_t N = rng.randint<uint64_t>();\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(N));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, solve)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, solve_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/84", "entrypoint_scalar": "solve", "entrypoint_simd": "solve_simd"}
{"task_id": "SimdBench_104_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n}", "solution_scalar": "int add(std::vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (add_simd({4, 88}) == 88);\n    pass = pass && (add_simd({4, 5, 6, 7, 2, 122}) == 122);\n    pass = pass && (add_simd({4, 0, 6, 7}) == 0);\n    pass = pass && (add_simd({4, 4, 6, 8}) == 12);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        int result = add(numbers);\n        int result_simd = add_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, add)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, add_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/85", "entrypoint_scalar": "add", "entrypoint_simd": "add_simd"}
{"task_id": "SimdBench_105_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n}", "solution_scalar": "std::string encrypt(const std::string & s){\n    std::string out = \"\";\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (encrypt_simd(\"hi\") == \"lm\");\n    pass = pass && (encrypt_simd(\"asdfghjkl\") == \"ewhjklnop\");\n    pass = pass && (encrypt_simd(\"gf\") == \"kj\");\n    pass = pass && (encrypt_simd(\"et\") == \"ix\");\n    pass = pass && (encrypt_simd(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    pass = pass && (encrypt_simd(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    pass = pass && (encrypt_simd(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    pass = pass && (encrypt_simd(\"a\")==\"e\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_LOWERCASE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = encrypt(s);\n        auto res_simd = encrypt_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const std::string charset = CHARSET_LOWERCASE;\n    size_t length = state.range(0);\n    std::string s = \"\";\n    for(int i=0; i<length; ++i) s.push_back(charset[i%charset.length()]);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, encrypt)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, encrypt_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/89", "entrypoint_scalar": "encrypt", "entrypoint_simd": "encrypt_simd"}
{"task_id": "SimdBench_106_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n}", "solution_scalar": "std::string encode(const std::string & message){\n    std::string vowels=\"aeiouAEIOU\";\n    std::string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (encode_simd(\"TEST\") == \"tgst\");\n    pass = pass && (encode_simd(\"Mudasir\") == \"mWDCSKR\");\n    pass = pass && (encode_simd(\"YES\") == \"ygs\");\n    pass = pass && (encode_simd(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    pass = pass && (encode_simd(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_LOWERCASE + CHARSET_UPPERCASE + \" \";\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = encode(s);\n        auto res_simd = encode_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const std::string charset = CHARSET_LOWERCASE;\n    size_t length = state.range(0);\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, encode)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, encode_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/93", "entrypoint_scalar": "encode", "entrypoint_simd": "encode_simd"}
{"task_id": "SimdBench_107_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a map, return true if all keys are strings in lower \ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given map is empty.\nExamples:\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n}", "solution_scalar": "bool check_dict_case(std::map<std::string, std::string> dict) {\n    std::map<std::string, std::string>::const_iterator it;\n    int islower = 0, isupper = 0;\n    if (dict.size() == 0) return false;\n    for (it = dict.begin(); it != dict.end(); it++) {\n        std::string key = it->first;\n\n        for (size_t i = 0; i < key.size(); i++) {\n            if (key[i] < 65 || (key[i] > 90 && key[i] < 97) || key[i] > 122) return false;\n            if (key[i] >= 65 && key[i] <= 90) isupper = 1;\n            if (key[i] >= 97 && key[i] <= 122) islower = 1;\n            if (isupper + islower == 2) return false;\n        }\n    }\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (check_dict_case_simd({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    pass = pass && (check_dict_case_simd({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    pass = pass && (check_dict_case_simd({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    pass = pass && (check_dict_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    pass = pass && (check_dict_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    pass = pass && (check_dict_case_simd({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    pass = pass && (check_dict_case_simd({}) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        int type = rng.randint<int>() % 6;\n        std::string charset;\n        if(type==0) charset = CHARSET_LOWERCASE;\n        else if(type==1) charset = CHARSET_UPPERCASE;\n        else if(type==2) charset = CHARSET_ALPHANUMERIC;\n        else if(type==3) charset = CHARSET_PRINTABLE;\n        else if(type==4) charset = CHARSET_HEX;\n        else charset = CHARSET_ALPHA;\n\n        std::map<std::string, std::string> dict;\n        for (size_t j = 0; j < length; j++) {\n            std::string key = rng.random_string(charset, rng.randint<size_t>(1, 20));\n            std::string value = rng.random_string(charset, rng.randint<size_t>(1, 20));\n            dict[key] = value;\n        }\n        \n        bool result = check_dict_case(dict);\n        bool result_simd = check_dict_case_simd(dict);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::map<std::string, std::string>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    const std::string charset = CHARSET_UPPERCASE;\n    std::map<std::string, std::string> dict;\n    for (size_t j = 0; j < length; j++) {\n        std::string key = rng.random_string(charset, rng.randint<size_t>(1, 20));\n        std::string value = rng.random_string(charset, rng.randint<size_t>(1, 20));\n        dict[key] = value;\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(dict));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, check_dict_case)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, check_dict_case_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/95", "entrypoint_scalar": "check_dict_case", "entrypoint_simd": "check_dict_case_simd"}
{"task_id": "SimdBench_108_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n){\n}", "solution_scalar": "std::vector<int> count_up_to(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<int> out(n);\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        bool isp = true;\n        for (int j = 0; j < count && out[j] * out[j] <= i; j++) {\n            if (i % out[j] == 0) {\n                isp = false;\n                break;\n            }\n        }\n\n        if (isp) {\n            out[count] = i;\n            count++;\n        }\n    }\n    out.resize(count);\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(count_up_to_simd(5), {2,3}));\n    pass = pass && (allclose(count_up_to_simd(6), {2,3,5}));\n    pass = pass && (allclose(count_up_to_simd(7), {2,3,5}));\n    pass = pass && (allclose(count_up_to_simd(10), {2,3,5,7}));\n    pass = pass && (allclose(count_up_to_simd(0), {}));\n    pass = pass && (allclose(count_up_to_simd(22), {2,3,5,7,11,13,17,19}));\n    pass = pass && (allclose(count_up_to_simd(1), {}));\n    pass = pass && (allclose(count_up_to_simd(18), {2,3,5,7,11,13,17}));\n    pass = pass && (allclose(count_up_to_simd(47), {2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n    pass = pass && (allclose(count_up_to_simd(101), {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(2, 1 << 14);\n        \n        std::vector<int> result = count_up_to(n);\n        std::vector<int> result_simd = count_up_to_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const int n = state.range(0);\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, count_up_to)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, count_up_to_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/96", "entrypoint_scalar": "count_up_to", "entrypoint_simd": "count_up_to_simd"}
{"task_id": "SimdBench_109_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n}", "solution_scalar": "int count_upper(const std::string & s){\n    std::string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (count_upper_simd(\"aBCdEf\")  == 1);\n    pass = pass && (count_upper_simd(\"abcdefg\") == 0);\n    pass = pass && (count_upper_simd(\"dBBE\") == 0);\n    pass = pass && (count_upper_simd(\"B\")  == 0);\n    pass = pass && (count_upper_simd(\"U\")  == 1);\n    pass = pass && (count_upper_simd(\"\") == 0);\n    pass = pass && (count_upper_simd(\"EEEE\") == 2);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_ALPHANUMERIC;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = count_upper(s);\n        auto res_simd = count_upper_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_ALPHANUMERIC;\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, count_upper)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, count_upper_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/98", "entrypoint_scalar": "count_upper", "entrypoint_simd": "count_upper_simd"}
{"task_id": "SimdBench_110_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\nReturn the number of stones in each level in a vector, where element at index\ni represents the number of stones in the level (i+1).\n\nExamples:\n>>> make_a_pile_simd(3)\n{3, 5, 7}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> make_a_pile_simd(int n){\n}", "solution_scalar": "std::vector<int> make_a_pile(int n) {\n    std::vector<int> out(n);\n    out[0] = n;\n    for (int i = 1; i < n; i++) {\n        out[i] = out[i - 1] + 2;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(make_a_pile_simd(5), {5, 7, 9, 11, 13}));\n    pass = pass && (allclose(make_a_pile_simd(6), {6, 8, 10, 12, 14, 16}));\n    pass = pass && (allclose(make_a_pile_simd(7), {7, 9, 11, 13, 15, 17, 19}));\n    pass = pass && (allclose(make_a_pile_simd(10), {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}));\n    pass = pass && (allclose(make_a_pile_simd(1), {1}));\n    pass = pass && (allclose(make_a_pile_simd(3), {3, 5, 7}));\n    pass = pass && (allclose(make_a_pile_simd(4), {4, 6, 8, 10}));\n    pass = pass && (allclose(make_a_pile_simd(8), {8, 10, 12, 14, 16, 18, 20, 22}));\n    pass = pass && (allclose(make_a_pile_simd(9), {9, 11, 13, 15, 17, 19, 21, 23, 25}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(1, 1024);\n        \n        std::vector<int> result = make_a_pile(n);\n        std::vector<int> result_simd = make_a_pile_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool res =correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", res ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const int n = state.range(0);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, make_a_pile)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, make_a_pile_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/100", "entrypoint_scalar": "make_a_pile", "entrypoint_simd": "make_a_pile_simd"}
{"task_id": "SimdBench_111_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n}", "solution_scalar": "std::string rounded_avg(int64_t n, int64_t m){\n    if (n>m) return \"-1\";\n    \n    int64_t sum = 0;\n    for(int64_t i = n; i<=m; ++i) {sum += i;}\n    sum /= m - n + 1;\n\n    std::string out=\"\";\n    while (sum>0){\n        out=std::to_string(sum%2)+out;\n        sum=sum/2;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (rounded_avg_simd(1, 5) == \"11\");\n    pass = pass && (rounded_avg_simd(7, 13) == \"1010\");\n    pass = pass && (rounded_avg_simd(964,977) == \"1111001010\");\n    pass = pass && (rounded_avg_simd(996,997) == \"1111100100\");\n    pass = pass && (rounded_avg_simd(560,851) == \"1011000001\");  \n    pass = pass && (rounded_avg_simd(185,546) == \"101101101\");\n    pass = pass && (rounded_avg_simd(362,496) == \"110101101\");\n    pass = pass && (rounded_avg_simd(350,902) == \"1001110010\");\n    pass = pass && (rounded_avg_simd(197,233) == \"11010111\");\n    pass = pass && (rounded_avg_simd(7, 5) == \"-1\");\n    pass = pass && (rounded_avg_simd(5, 1) == \"-1\");\n    pass = pass && (rounded_avg_simd(5, 5) == \"101\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int64_t a = rng.randint<int64_t>(1, 10000);\n        int64_t b = rng.randint<int64_t>(1, 10000);\n              \n        auto res_scalar = rounded_avg(a, b);\n        auto res_simd = rounded_avg_simd(a, b);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(int64_t, int64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    int64_t a = state.range(0);\n    int64_t b = state.range(0)*2;\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(a, b));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, rounded_avg)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, rounded_avg_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/103", "entrypoint_scalar": "rounded_avg", "entrypoint_simd": "rounded_avg_simd"}
{"task_id": "SimdBench_112_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nImplement the function f that takes n as a parameter,\nand returns a vector of size n, such that the value of the element at index i is the factorial of i modulo 10,000 if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\nExample:\nfunc_simd(5) == {1, 2, 6, 24, 15}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> func_simd(int n){\n}", "solution_scalar": "std::vector<int> func(int n) {\n    // Create a vector of size n\n    std::vector<int> result(n);\n\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even indices\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n                factorial %= 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum of numbers from 1 to i for odd indices\n            int sum = i * (i + 1) / 2; // Use the formula for sum of first i natural numbers\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(func_simd(5), {1, 2, 6, 24, 15}));\n    pass = pass && (allclose(func_simd(7), {1, 2, 6, 24, 15, 720, 28}));\n    pass = pass && (allclose(func_simd(1), {1}));\n    pass = pass && (allclose(func_simd(3), {1, 2, 6}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = Small_Arg_1D;\n        \n        std::vector<int> result = func(n);\n        std::vector<int> result_simd = func_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const int n = state.range(0);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, func)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, func_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/106", "entrypoint_scalar": "func", "entrypoint_simd": "func_simd"}
{"task_id": "SimdBench_113_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n){\n}", "solution_scalar": "std::vector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        std::string w=std::to_string(i);\n        std::string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(even_odd_palindrome_simd(123), {8, 13}));\n    pass = pass && (allclose(even_odd_palindrome_simd(12), {4, 6}));\n    pass = pass && (allclose(even_odd_palindrome_simd(3), {1, 2}));\n    pass = pass && (allclose(even_odd_palindrome_simd(63), {6, 8}));\n    pass = pass && (allclose(even_odd_palindrome_simd(25), {5, 6}));\n    pass = pass && (allclose(even_odd_palindrome_simd(19), {4, 6}));\n    pass = pass && (allclose(even_odd_palindrome_simd(9), {4, 5}));\n    pass = pass && (allclose(even_odd_palindrome_simd(1), {0, 1}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = Small_Arg_1D;\n        \n        std::vector<int> result = even_odd_palindrome(n);\n        std::vector<int> result_simd = even_odd_palindrome_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    //const int n = state.range(0);\n    const int n = 1024;\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, even_odd_palindrome)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, even_odd_palindrome_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/107", "entrypoint_scalar": "even_odd_palindrome", "entrypoint_simd": "even_odd_palindrome_simd"}
{"task_id": "SimdBench_114_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n}", "solution_scalar": "int count_nums(std::vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (count_nums_simd({}) == 0);\n    pass = pass && (count_nums_simd({-1, -2, 0}) == 0);\n    pass = pass && (count_nums_simd({1, 1, 2, -2, 3, 4, 5}) == 6);\n    pass = pass && (count_nums_simd({1, 6, 9, -6, 0, 1, 5}) == 5);\n    pass = pass && (count_nums_simd({1, 100, 98, -7, 1, -1}) == 4);\n    pass = pass && (count_nums_simd({12, 23, 34, -45, -56, 0}) == 5);\n    pass = pass && (count_nums_simd({-0, 1}) == 1);\n    pass = pass && (count_nums_simd({1}) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> numbers(length);\n        for(auto & number: numbers){\n            number = rng.randint<int>(-200, 200);\n        }\n        \n        int result = count_nums(numbers);\n        int result_simd = count_nums_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, count_nums)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, count_nums_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/108", "entrypoint_scalar": "count_nums", "entrypoint_simd": "count_nums_simd"}
{"task_id": "SimdBench_115_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n}", "solution_scalar": "bool move_one_ball(std::vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (move_one_ball_simd({3, 4, 5, 1, 2}) == true);\n    pass = pass && (move_one_ball_simd({3, 5, 10, 1, 2}) == true);\n    pass = pass && (move_one_ball_simd({4, 3, 1, 2}) == false);\n    pass = pass && (move_one_ball_simd({3, 5, 4, 1, 2}) == false);\n    pass = pass && (move_one_ball_simd({}) == true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> arr(length);\n        rng.initialize_vector_with_random_values(arr);\n        \n        bool result = move_one_ball(arr);\n        bool result_simd = move_one_ball_simd(arr);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> arr(length);\n    rng.initialize_vector_with_random_values(arr);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, move_one_ball)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, move_one_ball_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/109", "entrypoint_scalar": "move_one_ball", "entrypoint_simd": "move_one_ball_simd"}
{"task_id": "SimdBench_116_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n}", "solution_scalar": "std::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (myexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    pass = pass && (myexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    pass = pass && (myexchange_simd({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\");\n    pass = pass && (myexchange_simd({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    pass = pass && (myexchange_simd({5, 7, 3}, {2, 6, 3}) == \"NO\");\n    pass = pass && (myexchange_simd({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    pass = pass && (myexchange_simd({100, 200}, {200, 200}) == \"YES\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        std::vector<int> lst1(rng.randint<size_t>(1, 100));\n        std::vector<int> lst2(rng.randint<size_t>(1, 100));\n        rng.initialize_vector_with_random_values(lst1);\n        rng.initialize_vector_with_random_values(lst2);\n        \n        std::string result = myexchange(lst1, lst2);\n        std::string result_simd = myexchange_simd(lst1, lst2);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::vector<int>&, const std::vector<int>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> lst1(length);\n    std::vector<int> lst2(length);\n    rng.initialize_vector_with_random_values(lst1);\n    rng.initialize_vector_with_random_values(lst2);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst1, lst2));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, myexchange)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, myexchange_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/110", "entrypoint_scalar": "myexchange", "entrypoint_simd": "myexchange_simd"}
{"task_id": "SimdBench_117_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of strings, where each string consists of only digits, return a vector.\nEach element i of the output should be 'the number of odd elements in the\nstring i of the input.\" where all the i's should be replaced by the number\nof odd digits in the i'th string of the input.\n\n>>> odd_count_simd({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count_simd({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n}", "solution_scalar": "std::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    // Pre-allocate the output vector with the same size as the input\n    std::vector<std::string> out(lst.size());\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int sum = 0;\n\n        // Count the number of odd digits in the current string\n        for (int j = 0; j < lst[i].length(); j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1) {\n                sum += 1;\n            }\n        }\n\n        // Construct the output string with the number of odd digits\n        std::string s = \"the number of odd elements in the string i of the input.\";\n        std::string s2 = \"\";\n        for (int j = 0; j < s.length(); j++) {\n            if (s[j] == 'i') {\n                s2 += std::to_string(sum);\n            } else {\n                s2 += s[j];\n            }\n        }\n\n        // Assign the result to the pre-allocated output vector\n        out[i] = s2;\n    }\n\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (allclose(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    pass = pass && (allclose(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    pass = pass && (allclose(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_DIGITS;\n\n        std::vector<std::string> lst;\n        for(int i=0; i<length; ++i){\n            std::string s = rng.random_string(charset, rng.randint<int>(0, 20));\n            lst.push_back(s);\n        }\n              \n        auto res_scalar = odd_count(lst);\n        auto res_simd = odd_count_simd(lst);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<std::string> (*Func)(const std::vector<std::string> &)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_DIGITS;\n\n    std::vector<std::string> lst;\n    for(int i=0; i<length; ++i){\n        std::string s = rng.random_string(charset, rng.randint<int>(0, 20));\n        lst.push_back(s);\n    }\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, odd_count)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, odd_count_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/113", "entrypoint_scalar": "odd_count", "entrypoint_simd": "odd_count_simd"}
{"task_id": "SimdBench_118_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n}", "solution_scalar": "int64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t current, min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (minSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1);\n    pass = pass && (minSubArraySum_simd({-1, -2, -3}) == -6);\n    pass = pass && (minSubArraySum_simd({-1, -2, -3, 2, -10}) == -14);\n    pass = pass && (minSubArraySum_simd({-9999999999999999}) == -9999999999999999);\n    pass = pass && (minSubArraySum_simd({0, 10, 20, 1000000}) == 0);\n    pass = pass && (minSubArraySum_simd({-1, -2, -3, 10, -5}) == -6);\n    pass = pass && (minSubArraySum_simd({100, -1, -2, -3, 10, -5}) == -6);\n    pass = pass && (minSubArraySum_simd({10, 11, 13, 8, 3, 4}) == 3);\n    pass = pass && (minSubArraySum_simd({100, -33, 32, -1, 0, -2}) == -33);\n    pass = pass && (minSubArraySum_simd({-10}) == -10);\n    pass = pass && (minSubArraySum_simd({7}) == 7);\n    pass = pass && (minSubArraySum_simd({1, -1}) == -1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> nums(length);\n        for(auto& number: nums){\n            number = rng.randint<int64_t>(-1024, 1024);\n        }\n        \n        int64_t result = minSubArraySum(nums);\n        int64_t result_simd = minSubArraySum_simd(nums);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const std::vector<int64_t>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int64_t> nums(length);\n    for(auto& number: nums){\n        number = rng.randint<int64_t>(-1024, 1024);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(nums));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, minSubArraySum)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, minSubArraySum_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/114", "entrypoint_scalar": "minSubArraySum", "entrypoint_simd": "minSubArraySum_simd"}
{"task_id": "SimdBench_119_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n}", "solution_scalar": "int max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (max_fill_simd({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    pass = pass && (max_fill_simd({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    pass = pass && (max_fill_simd({{0,0,0}, {0,0,0}}, 5) == 0);\n    pass = pass && (max_fill_simd({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    pass = pass && (max_fill_simd({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        int capacity = rng.randint<int>(1, 10);\n        \n        std::vector<std::vector<int>> grid(rows, std::vector<int>(cols));\n        for (auto& row : grid) {\n            rng.initialize_vector_with_random_values(row, true);\n        }\n        \n        int result = max_fill(grid, capacity);\n        int result_simd = max_fill_simd(grid, capacity);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<std::vector<int> > &, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t rows = state.range(0);\n    const size_t cols = state.range(1);\n    Random rng;\n    const int capacity = rng.randint<int>(1, 10);\n    std::vector<std::vector<int>> grid(rows, std::vector<int>(cols));\n    for (auto& row : grid) {\n        rng.initialize_vector_with_random_values(row, true);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(grid, capacity));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, max_fill)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, max_fill_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/115", "entrypoint_scalar": "max_fill", "entrypoint_simd": "max_fill_simd"}
{"task_id": "SimdBench_120_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n}", "solution_scalar": "int64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (solution_simd({5, 8, 7, 1}) == 12);\n    pass = pass && (solution_simd({3, 3, 3, 3, 3}) == 9);\n    pass = pass && (solution_simd({30, 13, 24, 321}) == 0);\n    pass = pass && (solution_simd({5, 9}) == 5);\n    pass = pass && (solution_simd({2, 4, 8}) == 0);\n    pass = pass && (solution_simd({30, 13, 23, 32}) == 23);\n    pass = pass && (solution_simd({3, 13, 2, 9}) == 3);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int16_t> lst(length);\n        rng.initialize_vector_with_random_values(lst);\n        \n        int result = solution(lst);\n        int result_simd = solution_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const std::vector<int16_t>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int16_t> lst(length);\n    rng.initialize_vector_with_random_values(lst);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, solution)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, solution_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/121", "entrypoint_scalar": "solution", "entrypoint_simd": "solution_simd"}
{"task_id": "SimdBench_121_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n}", "solution_scalar": "int add_elements(std::vector<int> arr, int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (add_elements_simd({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    pass = pass && (add_elements_simd({111,121,3,4000,5,6}, 2) == 0);\n    pass = pass && (add_elements_simd({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    pass = pass && (add_elements_simd({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    pass = pass && (add_elements_simd({1}, 1) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        int k = rng.randint<int>(1, length);\n        std::vector<int> arr(length);\n        for(auto & num: arr){\n            num = rng.randint(-500, 500);\n        }\n        \n        int result = add_elements(arr, k);\n        int result_simd = add_elements_simd(arr, k);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    const int k = length/2;\n    Random rng;\n    std::vector<int> arr(length);\n    rng.initialize_vector_with_random_values(arr);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr, k));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, add_elements)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, add_elements_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/122", "entrypoint_scalar": "add_elements", "entrypoint_simd": "add_elements_simd"}
{"task_id": "SimdBench_122_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n}", "solution_scalar": "bool is_sorted(const std::vector<int> & lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_sorted_simd({5}) == true);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4, 5}) == true);\n    pass = pass && (is_sorted_simd({1, 3, 2, 4, 5}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4, 5, 6}) == true);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4, 5, 6, 7}) == true);\n    pass = pass && (is_sorted_simd({1, 3, 2, 4, 5, 6, 7}) == false);\n    pass = pass && (is_sorted_simd({}) == true);\n    pass = pass && (is_sorted_simd({1}) == true);\n    pass = pass && (is_sorted_simd({3, 2, 1}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 2, 2, 3, 4}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 3, 3, 3, 4}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 2, 3, 3, 4}) == true);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4}) == true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(1024));\n        std::vector<int> lst(length);\n        if(rng.randint<int>() % 2) {\n\n            for(size_t j = 0; j < length; j++) {\n                lst[j] = static_cast<int>(j);\n            }\n\n            if(rng.randint<int>() % 2) {\n                for(size_t j = 1; j < length; j++) {\n                    if(rng.randint<int>() % 3 == 0) { \n                        lst[j] = lst[j-1];\n                    }\n                }\n            }\n        } else {\n            rng.initialize_vector_with_random_values(lst);\n        }\n        \n        bool result = is_sorted(lst);\n        bool result_simd = is_sorted_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> lst(length);\n    for(size_t i = 0; i < length; i++) {\n        lst[i] = static_cast<int>(i);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_sorted)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_sorted_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/126", "entrypoint_scalar": "is_sorted", "entrypoint_simd": "is_sorted_simd"}
{"task_id": "SimdBench_123_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n}", "solution_scalar": "int prod_signs(const std::vector<int> & arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++){\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n    }\n   return sum*prods;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (prod_signs_simd({1, 2, 2, -4}) == -9);\n    pass = pass && (prod_signs_simd({0, 1}) == 0);\n    pass = pass && (prod_signs_simd({1, 1, 1, 2, 3, -1, 1}) == -10);\n    pass = pass && (prod_signs_simd({}) == -32768);\n    pass = pass && (prod_signs_simd({2, 4, 1, 2, -1, -1, 9}) == 20);\n    pass = pass && (prod_signs_simd({-1, 1, -1, 1}) == 4);\n    pass = pass && (prod_signs_simd({-1, 1, 1, 1}) == -4);\n    pass = pass && (prod_signs_simd({-1, 1, 1, 0}) == 0);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> arr(length);\n        rng.initialize_vector_with_random_values(arr);\n        \n        int result = prod_signs(arr);\n        int result_simd = prod_signs_simd(arr);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> arr(length);\n    std::vector<int> choiceset = {-2, -1, 0, 1, 2};\n    for(auto& num: arr){\n        num = rng.choice(choiceset);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, prod_signs)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, prod_signs_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/128", "entrypoint_scalar": "prod_signs", "entrypoint_simd": "prod_signs_simd"}
{"task_id": "SimdBench_124_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a grid with N rows and N columns (N >= 2) and a positive integer k, \neach cell of the grid contains a value. Every integer in the range [1, N * N]\ninclusive appears exactly once on the cells of the grid.\n\nYou have to find the minimum path of length k in the grid. You can start\nfrom any cell, and in each step you can move to any of the neighbor cells,\nin other words, you can go to cells which share an edge with you current\ncell.\nPlease note that a path of length k means visiting exactly k cells (not\nnecessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if\nafter making the ordered vectors of the values on the cells that A and B go\nthrough (let's call them lst_A and lst_B), lst_A is lexicographically less\nthan lst_B, in other words, there exist an integer index i (1 <= i <= k)\nsuch that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\nlst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered vector of the values on the cells that the minimum path go through.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n}", "solution_scalar": "std::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int x, y, minValue;\n\n    // Find the position of the cell with value 1\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    // Find the smallest neighbor of the cell containing 1\n    minValue = INT_MAX;\n\n    if (x > 0 && grid[x - 1][y] < minValue) {\n        minValue = grid[x - 1][y];\n    }\n    if (x < n - 1 && grid[x + 1][y] < minValue) {\n        minValue = grid[x + 1][y];\n    }\n    if (y > 0 && grid[x][y - 1] < minValue) {\n        minValue = grid[x][y - 1];\n    }\n    if (y < n - 1 && grid[x][y + 1] < minValue) {\n        minValue = grid[x][y + 1];\n    }\n\n    // Pre-allocate the output vector and directly assign values\n    std::vector<int> out(k);\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            out[i] = 1;\n        } else {\n            out[i] = minValue;\n        }\n    }\n\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && allclose(minPath_simd({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1});\n    pass = pass && allclose(minPath_simd({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1});\n    pass = pass && allclose(minPath_simd({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4), {1, 2, 1, 2});\n    pass = pass && allclose(minPath_simd({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1});\n    pass = pass && allclose(minPath_simd({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5), {1, 7, 1, 7, 1});\n    pass = pass && allclose(minPath_simd({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1, 6, 1});\n    pass = pass && allclose(minPath_simd({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6});\n    pass = pass && allclose(minPath_simd({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3});\n    pass = pass && allclose(minPath_simd({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5});\n    pass = pass && allclose(minPath_simd({{1, 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2});\n    pass = pass && allclose(minPath_simd({{1, 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3});\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t n = rng.randint<size_t>(2, 16);\n        int k = rng.randint<int>(1, 16);\n        \n        std::vector<int> permutation(n * n);\n        for (int i = 0; i < n * n; ++i) {\n            permutation[i] = i + 1;\n        }\n        rng.shuffle(permutation);\n        std::vector<std::vector<int>> grid(n, std::vector<int>(n));\n        for (size_t idx = 0; idx < permutation.size(); ++idx) {\n            size_t row = idx / n;\n            size_t col = idx % n;\n            grid[row][col] = permutation[idx];\n        }\n        \n        auto result = minPath(grid, k);\n        auto result_simd = minPath_simd(grid, k);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(const std::vector<std::vector<int>> &, int)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    const size_t n = sqrt(state.range(0)); \n    const int k = 32;\n\n    std::vector<int> permutation(n * n);\n    for (int i = 0; i < n * n; ++i) {\n        permutation[i] = i + 1;\n    }\n    rng.shuffle(permutation);\n    std::vector<std::vector<int>> grid(n, std::vector<int>(n));\n    for (size_t idx = 0; idx < permutation.size(); ++idx) {\n        size_t row = idx / n;\n        size_t col = idx % n;\n        grid[row][col] = permutation[idx];\n    }\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(grid, k));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, minPath)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, minPath_simd)->Name(\"SIMD\")->Large_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/129", "entrypoint_scalar": "minPath", "entrypoint_simd": "minPath_simd"}
{"task_id": "SimdBench_125_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n}", "solution_scalar": "uint64_t digits(uint64_t n){\n    uint64_t prod=1,has=0;\n    std::string s=std::to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (digits_simd(5) == 5);\n    pass = pass && (digits_simd(54) == 5);\n    pass = pass && (digits_simd(120) ==1);\n    pass = pass && (digits_simd(5014) == 5);\n    pass = pass && (digits_simd(98765) == 315);\n    pass = pass && (digits_simd(5576543) == 2625);\n    pass = pass && (digits_simd(2468) == 0);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n\n        uint64_t n = rng.randint<uint64_t>(1);\n        auto result = digits(n);\n        auto result_simd = digits_simd(n);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    uint64_t n = rng.randint<uint64_t>(1);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, digits)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, digits_simd)->Name(\"SIMD\")->Large_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/131", "entrypoint_scalar": "digits", "entrypoint_simd": "digits_simd"}
{"task_id": "SimdBench_126_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n}", "solution_scalar": "uint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && fabs(sum_squares_simd({1,2,3}) - 14) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({1.0,2,3}) - 14) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({1,3,5,7}) - 84) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({1.4,4.2,0}) - 29) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-2.4,1,1}) - 6) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({100,1,15,2}) - 10230) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({10000,10000}) - 200000000) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1.4,4.6,6.3}) - 75) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1.4,17.9,18.9,19.9}) - 1086) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({0}) - 0) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1}) - 1) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1,1,0}) - 2) < 1e-6;\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<float> lst(length);\n        rng.initialize_vector_with_random_values(lst);\n        \n        float result = sum_squares(lst);\n        float result_simd = sum_squares_simd(lst);\n        \n        if(fabs(result - result_simd) > 1e-6){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(const std::vector<float> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> lst(length);\n    rng.initialize_vector_with_random_values(lst);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sum_squares)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sum_squares_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/133", "entrypoint_scalar": "sum_squares", "entrypoint_simd": "sum_squares_simd"}
{"task_id": "SimdBench_127_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n}", "solution_scalar": "int can_arrange(const std::vector<int> & arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (can_arrange_simd({1,2,4,3,5}) == 3);\n    pass = pass && (can_arrange_simd({1,2,4,5}) == -1);\n    pass = pass && (can_arrange_simd({1,4,2,5,6,7,8,9,10}) == 2);\n    pass = pass && (can_arrange_simd({4,8,5,7,3}) == 4);\n    pass = pass && (can_arrange_simd({}) == -1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> arr(length);\n        rng.initialize_vector_with_random_values(arr);\n        \n        int result = can_arrange(arr);\n        int result_simd = can_arrange_simd(arr);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> & )>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> arr(length);\n    rng.initialize_vector_with_random_values(arr);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, can_arrange)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, can_arrange_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/135", "entrypoint_scalar": "can_arrange", "entrypoint_simd": "can_arrange_simd"}
{"task_id": "SimdBench_128_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n}", "solution_scalar": "std::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && allclose(largest_smallest_integers_simd({2, 4, 1, 3, 5, 7}), {0, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({2, 4, 1, 3, 5, 7, 0}), {0, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({1, 3, 2, 4, 5, 6, -2}), {-2, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({4, 5, 3, 6, 2, 7, -7}), {-7, 2});\n    pass = pass && allclose(largest_smallest_integers_simd({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2});\n    pass = pass && allclose(largest_smallest_integers_simd({}), {0, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({0}), {0, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({-1, -3, -5, -6}), {-1, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({-1, -3, -5, -6, 0}), {-1, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({-6, -4, -4, -3, 1}), {-3, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({-6, -4, -4, -3, -100, 1}), {-3, 1});\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> lst(length);\n        rng.initialize_vector_with_random_values(lst);\n        \n        auto result = largest_smallest_integers(lst);\n        auto result_simd = largest_smallest_integers_simd(lst);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(const std::vector<int>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> lst(length);\n    rng.initialize_vector_with_random_values(lst);\n    \n    // Ensure we have both positive and negative numbers\n    if (length > 1) {\n        lst[0] = -abs(lst[0]);\n        lst[1] = abs(lst[1]);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, largest_smallest_integers)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, largest_smallest_integers_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/136", "entrypoint_scalar": "largest_smallest_integers", "entrypoint_simd": "largest_smallest_integers_simd"}
{"task_id": "SimdBench_129_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n}", "solution_scalar": "uint64_t special_factorial(uint64_t n){\n    uint64_t fact=1,bfact=1;\n    for (int i=1;i<=n;i++){\n        fact=fact*i;\n        bfact=bfact*fact % 100000;\n    }\n    return bfact;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (special_factorial_simd(4) == 288);\n    pass = pass && (special_factorial_simd(5) == 34560);\n    pass = pass && (special_factorial_simd(7) == 125411328000 % 100000);\n    pass = pass && (special_factorial_simd(1) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t n = rng.randint<uint64_t>(1, 64);\n        auto result = special_factorial(n);\n        auto result_simd = special_factorial_simd(n);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    uint64_t n = state.range(0);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, special_factorial)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, special_factorial_simd)->Name(\"SIMD\")->Large_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/139", "entrypoint_scalar": "special_factorial", "entrypoint_simd": "special_factorial_simd"}
{"task_id": "SimdBench_130_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n}", "solution_scalar": "int sum_squares(const std::vector<int> & lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (sum_squares_simd({1,2,3}) == 6);\n    pass = pass && (sum_squares_simd({1,4,9}) == 14);\n    pass = pass && (sum_squares_simd({}) == 0);\n    pass = pass && (sum_squares_simd({1,1,1,1,1,1,1,1,1}) == 9);\n    pass = pass && (sum_squares_simd({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    pass = pass && (sum_squares_simd({0}) == 0);\n    pass = pass && (sum_squares_simd({-1,-5,2,-1,-5}) == -126);\n    pass = pass && (sum_squares_simd({-56,-99,1,0,-2}) == 3030);\n    pass = pass && (sum_squares_simd({-1,0,0,0,0,0,0,0,-1}) == 0);\n    pass = pass && (sum_squares_simd({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    pass = pass && (sum_squares_simd({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> lst(length);\n        for(auto & num: lst){\n            num = rng.randint<int>(-100, 100);\n        }\n        \n        int result = sum_squares(lst);\n        int result_simd = sum_squares_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> lst(length);\n    std::vector<int> choiceset = {-2, -1, 0, 1, 2};\n    for(auto& num: lst){\n        num = rng.choice(choiceset);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sum_squares)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sum_squares_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/142", "entrypoint_scalar": "sum_squares", "entrypoint_simd": "sum_squares_simd"}
{"task_id": "SimdBench_131_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a vector of numbers as input and returns \nthe number of elements in the vector that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter_simd({15, -73, 14, -15}) => 1 \nspecialFilter_simd({33, -2, -3, 45, 21, 109}) => 2\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint specialFilter_simd(const std::vector<int> & nums){\n}", "solution_scalar": "int specialFilter(const std::vector<int> & nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        std::string w=std::to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (specialFilter_simd({5, -2, 1, -5}) == 0);\n    pass = pass && (specialFilter_simd({15, -73, 14, -15}) == 1);\n    pass = pass && (specialFilter_simd({33, -2, -3, 45, 21, 109}) == 2);\n    pass = pass && (specialFilter_simd({43, -12, 93, 125, 121, 109}) == 4);\n    pass = pass && (specialFilter_simd({71, -2, -33, 75, 21, 19}) == 3);\n    pass = pass && (specialFilter_simd({1}) == 0);\n    pass = pass && (specialFilter_simd({}) == 0);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> nums(length);\n        rng.initialize_vector_with_random_values(nums);\n        \n        int result = specialFilter(nums);\n        int result_simd = specialFilter_simd(nums);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> nums(length);\n    rng.initialize_vector_with_random_values(nums);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(nums));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, specialFilter)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, specialFilter_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/146", "entrypoint_scalar": "specialFilter", "entrypoint_simd": "specialFilter_simd"}
{"task_id": "SimdBench_132_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n}", "solution_scalar": "uint64_t get_max_triples(uint64_t n) {\n    // Pre-allocate the vector `a` of size n\n    std::vector<int> a(n);\n\n    // Pre-allocate the `sum` and `sum2` vectors with size (n + 1) \u00d7 3, initialized to 0\n    std::vector<std::vector<int> > sum(n + 1, std::vector<int>(3, 0));\n    std::vector<std::vector<int> > sum2(n + 1, std::vector<int>(3, 0));\n\n    // Fill the vector `a` with the formula (i^2 - i + 1) % 3\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n    }\n\n    // Compute the cumulative counts of remainders for `sum`\n    for (int i = 1; i <= n; i++) {\n        sum[i] = sum[i - 1];  // Copy the previous cumulative counts\n        sum[i][a[i - 1]] += 1;  // Increment the count for the current value of `a[i-1]`\n    }\n\n    // Perform two rounds of cumulative count updates using `sum2`\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            sum2[i] = sum2[i - 1];  // Copy the previous cumulative counts\n\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n\n        // Update `sum` with the new cumulative counts from `sum2`\n        sum = sum2;\n\n        // Reset `sum2` to zero for the next round\n        for (int i = 0; i <= n; i++) {\n            sum2[i] = {0, 0, 0};\n        }\n    }\n\n    // Return the count of triples where the sum is divisible by 3\n    return sum[n][0];\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (get_max_triples_simd(5) == 1);\n    pass = pass && (get_max_triples_simd(6) == 4);\n    pass = pass && (get_max_triples_simd(10) == 36);\n    pass = pass && (get_max_triples_simd(100) == 53361);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t n = rng.randint<uint64_t>(1, 64);\n        auto result = get_max_triples(n);\n        auto result_simd = get_max_triples_simd(n);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    uint64_t n = state.range(0);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, get_max_triples)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, get_max_triples_simd)->Name(\"SIMD\")->Medium_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/147", "entrypoint_scalar": "get_max_triples", "entrypoint_simd": "get_max_triples_simd"}
{"task_id": "SimdBench_133_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n}", "solution_scalar": "int x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (x_or_y_simd(7, 34, 12) == 34);\n    pass = pass && (x_or_y_simd(15, 8, 5) == 5);\n    pass = pass && (x_or_y_simd(3, 33, 5212) == 33);\n    pass = pass && (x_or_y_simd(1259, 3, 52) == 3);\n    pass = pass && (x_or_y_simd(7919, -1, 12) == -1);\n    pass = pass && (x_or_y_simd(3609, 1245, 583) == 583);\n    pass = pass && (x_or_y_simd(91, 56, 129) == 129);\n    pass = pass && (x_or_y_simd(6, 34, 1234) == 1234);\n    pass = pass && (x_or_y_simd(1, 2, 0) == 0);\n    pass = pass && (x_or_y_simd(2, 2, 0) == 2);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(1, 64);\n        int x = rng.randint<int>();\n        int y = rng.randint<int>();\n        auto result = x_or_y(n,x,y);\n        auto result_simd = x_or_y_simd(n,x,y);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(int, int, int)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    std::vector<int> large_primes = {20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609, 57885161};\n    int n = rng.choice(large_primes);\n    int x = rng.randint<int>();\n    int y = rng.randint<int>();\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n,x,y));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, x_or_y)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, x_or_y_simd)->Name(\"SIMD\")->Medium_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/150", "entrypoint_scalar": "x_or_y", "entrypoint_simd": "x_or_y_simd"}
{"task_id": "SimdBench_134_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n}", "solution_scalar": "uint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (double_the_difference_simd({}) == 0);\n    pass = pass && (double_the_difference_simd({5, 4}) == 25);\n    pass = pass && (double_the_difference_simd({0.1, 0.2, 0.3}) == 0);\n    pass = pass && (double_the_difference_simd({-10, -20, -30}) == 0);\n    pass = pass && (double_the_difference_simd({-1, -2, 8}) == 0);\n    pass = pass && (double_the_difference_simd({0.2, 3, 5}) == 34);\n    \n    long long odd_sum = 0;\n    std::vector<float> lst;\n    for (int i = -99; i < 100; i += 2) {\n        lst.push_back(i + 0.0f);\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n    pass = pass && (double_the_difference_simd(lst) == odd_sum);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<float> lst(length);\n        \n        for (auto& num : lst) {\n            num = rng.uniform<float>(-100.0f, 100.0f);\n            if (rng.randint<int>() % 10 != 0) {\n                num = round(num);\n            }\n        }\n        \n        long long result = double_the_difference(lst);\n        long long result_simd = double_the_difference_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(const std::vector<float> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> lst(length);\n    \n    for (auto& num : lst) {\n        num = rng.uniform<float>(-100.0f, 100.0f);\n        if (rng.randint<int>() % 4 == 0) {\n            num = round(num);\n        }\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, double_the_difference)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, double_the_difference_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/151", "entrypoint_scalar": "double_the_difference", "entrypoint_simd": "double_the_difference_simd"}
{"task_id": "SimdBench_135_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nI think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two vectors of scores and guesses of equal length, where each index shows a match. \nReturn a vector of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\nExample:\ncompare_simd({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare_simd({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n}", "solution_scalar": "std::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> out(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        out[i] = std::abs(game[i] - guess[i]);\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && allclose(compare_simd({1,2,3,4,5,1}, {1,2,3,4,2,-2}), {0,0,0,0,3,3});\n    pass = pass && allclose(compare_simd({0,5,0,0,0,4}, {4,1,1,0,0,-2}), {4,4,1,0,0,6});\n    pass = pass && allclose(compare_simd({1,2,3,4,5,1}, {1,2,3,4,2,-2}), {0,0,0,0,3,3});\n    pass = pass && allclose(compare_simd({0,0,0,0,0,0}, {0,0,0,0,0,0}), {0,0,0,0,0,0});\n    pass = pass && allclose(compare_simd({1,2,3}, {-1,-2,-3}), {2,4,6});\n    pass = pass && allclose(compare_simd({1,2,3,5}, {-1,2,3,4}), {2,0,0,1});\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> game(length);\n        std::vector<int> guess(length);\n        for( int i=0; i< length; ++i){\n            game[i] = rng.randint<int>(-1000, 1000);\n            guess[i] = rng.randint<int>(-1000, 1000);\n        }\n        auto result = compare(game, guess);\n        auto result_simd = compare_simd(game, guess);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(const std::vector<int>&, const std::vector<int>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> game(length);\n    std::vector<int> guess(length);\n    for( int i=0; i< length; ++i){\n        game[i] = rng.randint<int>(-1000, 1000);\n        guess[i] = rng.randint<int>(-1000, 1000);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(game, guess));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, compare)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, compare_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/152", "entrypoint_scalar": "compare", "entrypoint_simd": "compare_simd"}
{"task_id": "tsvc_s000_AVX", "prompt": "/*\nThis function takes a destination float array 'a', a source float array 'b', and their length 'n'.\nIt performs the element-wise operation: a[i] = b[i] + 1.0f;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s000_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s000_scalar(float *a, const float *b, size_t n) {\n    for (size_t i = 0; i < n; i++) {\n        a[i] = b[i] + 1.0f;\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n// Assume Random.h and allclose.h are available in the include path\n#include \"Random.h\"\n#include \"allclose.h\"\n\n// Define constants from common.h\n#define LEN_1D 32000\n#define ITERATIONS 1 // For correctness, one iteration is enough\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s000_scalar(float *a, const float *b, size_t n);\nvoid s000_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    std::vector<float> b_input(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s000 from initialise_arrays()\n        for (size_t i = 0; i < length; ++i) {\n            b_input[i] = 2.0f + static_cast<float>(i);\n        }\n        // Initialize output arrays to a known-bad value\n        std::fill(a_scalar.begin(), a_scalar.end(), std::nanf(\"\"));\n        std::fill(a_simd.begin(), a_simd.end(), std::nanf(\"\"));\n\n        s000_scalar(a_scalar.data(), b_input.data(), length);\n        s000_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s000!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n// Assume Random.h is available\n#include \"Random.h\"\n\n// Define constants\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s000_scalar(float *a, const float *b, size_t n);\nvoid s000_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s000(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n\n    // Ported Initialization Logic for s000\n    for (size_t i = 0; i < length; ++i) {\n         b_input[i] = 2.0f + static_cast<float>(i);\n    }\n\n    for (auto _ : state) {\n        Func(a_output.data(), b_input.data(), length);\n        benchmark::DoNotOptimize(a_output.data());\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s000, s000_scalar)->Name(\"Scalar_s000\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s000, s000_simd)->Name(\"SIMD_s000\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s000", "entrypoint_scalar": "s000_scalar", "entrypoint_simd": "s000_simd"}
{"task_id": "tsvc_s111_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs an element-wise operation with a stride of 2: a[i] = a[i - 1] + b[i];\nThis loop has a read-after-write dependency that is broken by the stride.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s111_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s111_scalar(float *a, const float *b, size_t n) {\n    for (size_t i = 1; i < n; i += 2) {\n        a[i] = a[i - 1] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s111_scalar(float *a, const float *b, size_t n);\nvoid s111_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s111\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n        }\n        // Copy initial state for both runs\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s111_scalar(a_scalar.data(), b_input.data(), length);\n        s111_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s111!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s111_scalar(float *a, const float *b, size_t n);\nvoid s111_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s111(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s111\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n    }\n\n    for (auto _ : state) {\n        // Reset 'a' to initial state for each run\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory(); // Ensure writes are committed\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // Approx 1 read (b), 1 read/write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s111, s111_scalar)->Name(\"Scalar_s111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s111, s111_simd)->Name(\"SIMD_s111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s111", "entrypoint_scalar": "s111_scalar", "entrypoint_simd": "s111_simd"}
{"task_id": "tsvc_s1111_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a strided write: a[2*i] = c[i]*b[i] + d[i]*b[i] + c[i]*c[i] + d[i]*b[i] + d[i]*c[i];\nIt loops 'n/2' times.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n    size_t len_half = n / 2;\n    for (size_t i = 0; i < len_half; i++) {\n        a[2*i] = c[i] * b[i] + d[i] * b[i] + c[i] * c[i] + d[i] * b[i] + d[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1111 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s1111_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n        s1111_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1111!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s1111_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s1111_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1111(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s1111 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length/2) * sizeof(float) * 4); // 3 reads, 1 write (approx)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1111, s1111_scalar)->Name(\"Scalar_s1111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1111, s1111_simd)->Name(\"SIMD_s1111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1111", "entrypoint_scalar": "s1111_scalar", "entrypoint_simd": "s1111_simd"}
{"task_id": "tsvc_s112_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs an operation in a reverse loop: a[i+1] = a[i] + b[i];\nThis tests dependency analysis in a backwards loop.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s112_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s112_scalar(float *a, const float *b, size_t n) {\n    for (long long i = (long long)n - 2; i >= 0; --i) {\n        a[i+1] = a[i] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s112_scalar(float *a, const float *b, size_t n);\nvoid s112_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s112\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s112_scalar(a_scalar.data(), b_input.data(), length);\n        s112_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s112!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s112_scalar(float *a, const float *b, size_t n);\nvoid s112_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s112(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s112\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1));\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 3); // 1 read (b), 1 read/write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s112, s112_scalar)->Name(\"Scalar_s112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s112, s112_simd)->Name(\"SIMD_s112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s112", "entrypoint_scalar": "s112_scalar", "entrypoint_simd": "s112_simd"}
{"task_id": "tsvc_s1112_AVX", "prompt": "/*\nThis function takes a destination float array 'a', a source float array 'b', and their length 'n'.\nIt performs an element-wise operation in a reverse loop: a[i] = b[i] + 1.0f;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1112_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s1112_scalar(float *a, const float *b, size_t n) {\n    for (long long i = (long long)n - 1; i >= 0; --i) {\n        a[i] = b[i] + 1.0f;\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n// Forward declare functions\nvoid s1112_scalar(float *a, const float *b, size_t n);\nvoid s1112_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    std::vector<float> b_input(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1112 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            b_input[i] = 1.0f;\n        }\n        std::fill(a_scalar.begin(), a_scalar.end(), std::nanf(\"\"));\n        std::fill(a_simd.begin(), a_simd.end(), std::nanf(\"\"));\n\n        s1112_scalar(a_scalar.data(), b_input.data(), length);\n        s1112_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1112!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n// Forward declare functions\nvoid s1112_scalar(float *a, const float *b, size_t n);\nvoid s1112_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1112(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n\n    // Ported Initialization Logic for s1112 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n         b_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        Func(a_output.data(), b_input.data(), length);\n        benchmark::DoNotOptimize(a_output.data());\n    }\n    state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1112, s1112_scalar)->Name(\"Scalar_s1112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1112, s1112_simd)->Name(\"SIMD_s1112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1112", "entrypoint_scalar": "s1112_scalar", "entrypoint_simd": "s1112_simd"}
{"task_id": "tsvc_s113_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[0] + b[i];\nThis tests dependency on a single broadcasted value (a[0]).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s113_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s113_scalar(float *a, const float *b, size_t n) {\n\u00a0 \u00a0 float a0 = a[0];\n\u00a0 \u00a0 for (size_t i = 1; i < n; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = a0 + b[i];\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s113_scalar(float *a, const float *b, size_t n);\nvoid s113_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t length = Small_Arg_1D;\n\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_scalar(length);\n\u00a0 \u00a0 std::vector<float> a_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s113\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 a_scalar = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 a_simd = a_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s113_scalar(a_scalar.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 s113_simd(a_simd.data(), b_input.data(), length);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(a_scalar, a_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s113!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s113_scalar(float *a, const float *b, size_t n);\nvoid s113_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s113(benchmark::State& state) {\n\u00a0 \u00a0 size_t length = state.range(0);\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> a_output(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s113\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_output = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(a_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(b_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(a_output.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length - 1) * sizeof(float) * 2); // 1 read (b), 1 read/write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s113, s113_scalar)->Name(\"Scalar_s113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s113, s113_simd)->Name(\"SIMD_s113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s113", "entrypoint_scalar": "s113_scalar", "entrypoint_simd": "s113_simd"}
{"task_id": "tsvc_s1113_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[n/2] + b[i];\nThis tests dependency on a single broadcasted value (a[n/2]).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1113_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s1113_scalar(float *a, const float *b, size_t n) {\n\u00a0 \u00a0 float a_mid = a[n/2];\n\u00a0 \u00a0 for (size_t i = 0; i < n; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = a_mid + b[i];\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1113_scalar(float *a, const float *b, size_t n);\nvoid s1113_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t length = Small_Arg_1D;\n\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_scalar(length);\n\u00a0 \u00a0 std::vector<float> a_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s1113 (uses default init())\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 a_scalar = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 a_simd = a_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s1113_scalar(a_scalar.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 s1113_simd(a_simd.data(), b_input.data(), length);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(a_scalar, a_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1113!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1113_scalar(float *a, const float *b, size_t n);\nvoid s1113_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1113(benchmark::State& state) {\n\u00a0 \u00a0 size_t length = state.range(0);\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> a_output(length);\n\u00a0 \u00a0 std::vector<float> b_input(length);\n\u00a0 \u00a0 std::vector<float> a_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s1113 (uses default init())\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 b_input[i] = 1.0f;\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_output = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(a_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(b_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(a_output.data(), b_input.data(), length);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 2); // 1 read (b), 1 write (a)\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1113, s1113_scalar)->Name(\"Scalar_s1113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1113, s1113_simd)->Name(\"SIMD_s1113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1113", "entrypoint_scalar": "s1113_scalar", "entrypoint_simd": "s1113_simd"}
{"task_id": "tsvc_s114_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop operation: aa[i][j] = aa[j][i] + bb[i][j]; for j < i.\nThis tests complex dependencies (transpose vectorization).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n\u00a0 \u00a0 for (size_t i = 0; i < n_2d; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t j = 0; j < i; j++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_flat[i * n_2d + j] = aa_flat[j * n_2d + i] + bb_flat[i * n_2d + j];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t n_2d = Small_Arg_2D;\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 \u00a0 std::vector<float> aa_scalar(length);\n\u00a0 \u00a0 std::vector<float> aa_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s114\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_initial[i] = 1.0f / (float)(i+1); // frac\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\nt \u00a0 \u00a0 \u00a0  }\n\u00a0 \u00a0 \u00a0 \u00a0 aa_scalar = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 aa_simd = aa_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s114_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 s114_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(aa_scalar, aa_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s114!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s114_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s114_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s114(benchmark::State& state) {\n\u00a0 \u00a0 size_t n_2d = state.range(0);\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> aa_output(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s114\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_initial[i] = 1.0f / (float)(i+1); // frac\n\u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_output = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(aa_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(bb_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(aa_output.data(), bb_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // Ops = (n_2d * (n_2d - 1) / 2) * (2 reads + 1 write)\n\u00a0 \u00a0 size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s114, s114_scalar)->Name(\"Scalar_s114\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s114, s114_simd)->Name(\"SIMD_s114\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s114", "entrypoint_scalar": "s114_scalar", "entrypoint_simd": "s114_simd"}
{"task_id": "tsvc_s115_AVX", "prompt": "/*\nThis function takes a 1D float array 'a' (size n_1d) and a flattened 2D float array 'aa' (size n_2d * n_2d).\nIt performs a triangular saxpy loop: a[i] -= aa[j][i] * a[j];\nThis tests complex dependencies.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d) {\n\u00a0 \u00a0 // n_2d = LEN_2D, n_1d = LEN_1D\n\u00a0 \u00a0 for (size_t j = 0; j < n_2d; j++) {\n\u00a0 \u00a0 \u00a0 \u00a0 float a_j = a[j];\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = j + 1; i < n_2d; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a[i] -= aa_flat[j * n_2d + i] * a_j;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n#define Small_Arg_1D LEN_1D\n\nvoid s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t n_2d = Small_Arg_2D;\n\u00a0 \u00a0 size_t length_2d = n_2d * n_2d;\n\u00a0 \u00a0 size_t length_1d = Small_Arg_1D;\n\n\u00a0 \u00a0 std::vector<float> a_initial(length_1d);\n\u00a0 \u00a0 std::vector<float> aa_input(length_2d);\n\u00a0 \u00a0 std::vector<float> a_scalar(length_1d);\n\u00a0 \u00a0 std::vector<float> a_simd(length_1d);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s115\n\u00a0 \u00a0 \u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length_1d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length_2d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 a_scalar = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 a_simd = a_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s115_scalar(a_scalar.data(), aa_input.data(), n_2d, length_1d);\n\u00a0 \u00a0 \u00a0 \u00a0 s115_simd(a_simd.data(), aa_input.data(), n_2d, length_1d);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(a_scalar, a_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s115!\" << std::endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s115_scalar(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s115_simd(float *a, const float* aa_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, size_t, size_t)>\nstatic void BM_s115(benchmark::State& state) {\n\u00a0 \u00a0 size_t n_2d = state.range(0);\n\u00a0 \u00a0 size_t length_2d = n_2d * n_2d;\n\u00a0 \u00a0 size_t length_1d = LEN_1D;\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> a_output(length_1d);\n\u00a0 \u00a0 std::vector<float> aa_input(length_2d);\n\u00a0 \u00a0 std::vector<float> a_initial(length_1d);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s115\n\u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 for (size_t i = 0; i < length_1d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_initial[i] = 1.0f;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 for (size_t i = 0; i < length_2d; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_input[i] = small_val;\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 a_output = a_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(a_output.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(aa_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(a_output.data(), aa_input.data(), n_2d, length_1d);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // Ops = (n_2d * (n_2d - 1) / 2) * (1 read + 1 read/write)\n\u00a0 \u00a0 size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n\u00a0 \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s115, s115_scalar)->Name(\"Scalar_s115\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s115, s115_simd)->Name(\"SIMD_s115\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s115", "entrypoint_scalar": "s115_scalar", "entrypoint_simd": "s115_simd"}
{"task_id": "tsvc_s1115_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', and 'cc' (row-major) of size n_2d * n_2d.\nIt performs the operation: aa[i][j] = aa[i][j]*cc[j][i] + bb[i][j];\nThis tests matrix multiplication with mixed indexing.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n\u00a0 \u00a0 for (size_t i = 0; i < n_2d; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t j = 0; j < n_2d; j++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 size_t idx_ij = i * n_2d + j;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 size_t idx_ji = j * n_2d + i;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aa_flat[idx_ij] = aa_flat[idx_ij] * cc_flat[idx_ji] + bb_flat[idx_ij];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n\u00a0 \u00a0 Random rng;\n\u00a0 \u00a0 size_t n_2d = Small_Arg_2D;\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 C \u00a0 std::vector<float> cc_input(length);\n\u00a0 \u00a0 std::vector<float> aa_scalar(length);\n\u00a0 \u00a0 std::vector<float> aa_simd(length);\n\n\u00a0 \u00a0 for (int iter = 0; iter < iterations; ++iter) {\n\u00a0 g \u00a0 \u00a0 \u00a0 // Ported Initialization Logic for s1115\n\u00a0 \u00a0 \u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 \u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\nci \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cc_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 aa_scalar = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 aa_simd = aa_initial;\n\n\u00a0 \u00a0 \u00a0 \u00a0 s1115_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 s1115_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n\u00a0 \u00a0 \u00a0 \u00a0 if (!allclose(aa_scalar, aa_simd)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1115!\" << std::endl;\nA \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\nint main() {\n\u00a0 \u00a0 bool pass = correctness_check(ITERATIONS);\n\u00a0 \u00a0 printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n\u00a0 \u00a0 return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1115_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1115_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s1115(benchmark::State& state) {\nD \u00a0 size_t n_2d = state.range(0);\n\u00a0 \u00a0 size_t length = n_2d * n_2d;\n\u00a0 \u00a0 Random rng(DEFAULT_SEED);\n\n\u00a0 \u00a0 std::vector<float> aa_output(length);\n\u00a0 \u00a0 std::vector<float> bb_input(length);\n\u00a0 \u00a0 std::vector<float> cc_input(length);\n\u00a0 \u00a0 std::vector<float> aa_initial(length);\n\n\u00a0 \u00a0 // Ported Initialization Logic for s1115\n\u00a0 \u00a0 float small_val = 0.000001f;\n\u00a0 \u00a0 for (size_t i = 0; i < length; ++i) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_initial[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 bb_input[i] = small_val;\n\u00a0 \u00a0 \u00a0 \u00a0 cc_input[i] = small_val;\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 for (auto _ : state) {\n\u00a0 \u00a0 \u00a0 \u00a0 aa_output = aa_initial;\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(aa_output.data());\nThis is an executable test containing a number of loops to measure\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(bb_input.data());\n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::DoNotOptimize(cc_input.data());\n\n\u00a0 \u00a0 \u00a0 \u00a0 Func(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 benchmark::ClobberMemory();\n\u00a0 \u00a0 }\n\u00a0 \u00a0 // Ops = (n_2d * n_2d) * (1 read/write + 2 reads)\nA \u00a0 state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1115, s1115_scalar)->Name(\"Scalar_s1115\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1115, s1115_simd)->Name(\"SIMD_s1115\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1115", "entrypoint_scalar": "s1115_scalar", "entrypoint_simd": "s1115_simd"}
{"task_id": "tsvc_s116_AVX", "prompt": "/*\nThis function takes a float array 'a' and its length 'n'.\nIt performs an unrolled loop with dependencies: a[i] = a[i+1] * a[i]; ... 5 times.\nThis tests dependency analysis in unrolled loops.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s116_simd(float *a, size_t n) {\n}", "solution_scalar": "void s116_scalar(float *a, size_t n) {\n \u00a0 \u00a0for (size_t i = 0; i < n - 5; i += 5) {\n \u00a0 \u00a0 \u00a0 \u00a0a[i] = a[i + 1] * a[i];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 1] = a[i + 2] * a[i + 1];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 2] = a[i + 3] * a[i + 2];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 3] = a[i + 4] * a[i + 3];\n \u00a0 \u00a0 \u00a0 \u00a0a[i + 4] = a[i + 5] * a[i + 4];\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s116_scalar(float *a, size_t n);\nvoid s116_simd(float *a, size_t n);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t length = Small_Arg_1D;\n\n \u00a0 \u00a0std::vector<float> a_initial(length);\n \u00a0 \u00a0std::vector<float> a_scalar(length);\n \u00a0 \u00a0std::vector<float> a_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s116\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0a_scalar = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0a_simd = a_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s116_scalar(a_scalar.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0s116_simd(a_simd.data(), length);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(a_scalar, a_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s116!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s116_scalar(float *a, size_t n);\nvoid s116_simd(float *a, size_t n);\n\ntemplate<void (*Func)(float *, size_t)>\nstatic void BM_s116(benchmark::State& state) {\n \u00a0 \u00a0size_t length = state.range(0);\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> a_output(length);\n \u00a0 \u00a0std::vector<float> a_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s116\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0a_output = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(a_output.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(a_output.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// 5 ops per block (2 reads, 1 write) = 15 accesses. (length / 5) blocks.\n \u00a0 \u00a0size_t num_ops = (length - 5) / 5;\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * 15 * sizeof(float));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s116, s116_scalar)->Name(\"Scalar_s116\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s116, s116_simd)->Name(\"SIMD_s116\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s116", "entrypoint_scalar": "s116_scalar", "entrypoint_simd": "s116_simd"}
{"task_id": "tsvc_s118_AVX", "prompt": "/*\nThis function takes a 1D float array 'a' (size n_1d) and a flattened 2D float array 'bb' (size n_2d * n_2d).\nIt performs a complex recursive operation: a[i] += bb[j][i] * a[i-j-1];\nThis tests potential dot product recursion.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d) {\n \u00a0 \u00a0// n_1d is LEN_1D, n_2d is LEN_2D\n \u00a0 \u00a0for (size_t i = 1; i < n_2d; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t j = 0; j <= i - 1; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a[i] += bb_flat[j * n_2d + i] * a[i-j-1];\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n#define Small_Arg_1D LEN_1D\n\nvoid s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t n_2d = Small_Arg_2D;\n \u00a0 \u00a0size_t length_2d = n_2d * n_2d;\n \u00a0 \u00a0size_t length_1d = Small_Arg_1D;\n\n \u00a0 \u00a0std::vector<float> a_initial(length_1d);\n \u00a0 \u00a0std::vector<float> bb_input(length_2d);\n \u00a0 \u00a0std::vector<float> a_scalar(length_1d);\n \u00a0 \u00a0std::vector<float> a_simd(length_1d);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s118\n \u00a0 \u00a0 \u00a0 \u00a0float small_val = 0.000001f;\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length_1d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length_2d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = small_val;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0a_scalar = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0a_simd = a_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s118_scalar(a_scalar.data(), bb_input.data(), n_2d, length_1d);\n \u00a0 \u00a0 \u00a0 \u00a0s118_simd(a_simd.data(), bb_input.data(), n_2d, length_1d);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(a_scalar, a_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s118!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s118_scalar(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s118_simd(float *a, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, size_t, size_t)>\nstatic void BM_s118(benchmark::State& state) {\n \u00a0 \u00a0size_t n_2d = state.range(0);\n \u00a0 \u00a0size_t length_2d = n_2d * n_2d;\n \u00a0 \u00a0size_t length_1d = LEN_1D;\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> a_output(length_1d);\n \u00a0 \u00a0std::vector<float> bb_input(length_2d);\n \u00a0 \u00a0std::vector<float> a_initial(length_1d);\n\n \u00a0 \u00a0// Ported Initialization Logic for s118\n \u00a0 \u00a0float small_val = 0.000001f;\n \u00a0 \u00a0for (size_t i = 0; i < length_1d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0}\n \u00a0 \u00a0for (size_t i = 0; i < length_2d; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = small_val;\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0a_output = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(a_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(bb_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(a_output.data(), bb_input.data(), n_2d, length_1d);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (n_2d * (n_2d - 1) / 2). Each op: 1 R/W(a), 1 R(bb), 1 R(a)\n \u00a0 \u00a0size_t num_ops = (n_2d * (n_2d - 1)) / 2;\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s118, s118_scalar)->Name(\"Scalar_s118\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s118, s118_simd)->Name(\"SIMD_s118\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s118", "entrypoint_scalar": "s118_scalar", "entrypoint_simd": "s118_simd"}
{"task_id": "tsvc_s119_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs the operation: aa[i][j] = aa[i-1][j-1] + bb[i][j];\nThis tests a dependency on a diagonal element.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n \u00a0 \u00a0for (size_t i = 1; i < n_2d; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t j = 1; j < n_2d; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_flat[i * n_2d + j] = aa_flat[(i-1) * n_2d + (j-1)] + bb_flat[i * n_2d + j];\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t n_2d = Small_Arg_2D;\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_scalar(length);\n \u00a0 \u00a0std::vector<float> aa_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s119\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0aa_scalar = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0aa_simd = aa_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s119_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0s119_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(aa_scalar, aa_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s119!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s119(benchmark::State& state) {\n \u00a0 \u00a0size_t n_2d = state.range(0);\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> aa_output(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s119\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_output = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(aa_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(bb_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(aa_output.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (n_2d - 1) * (n_2d - 1). Each op: 1 W(aa), 2 R(aa, bb)\n \u00a0 \u00a0size_t num_ops = (n_2d - 1) * (n_2d - 1);\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s119, s119_scalar)->Name(\"Scalar_s119\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s119, s119_simd)->Name(\"SIMD_s119\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s119", "entrypoint_scalar": "s119_scalar", "entrypoint_simd": "s119_simd"}
{"task_id": "tsvc_s1119_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs the operation: aa[i][j] = aa[i-1][j] + bb[i][j];\nThis tests a dependency on the element directly above.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n \u00a0 \u00a0for (size_t i = 1; i < n_2d; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t j = 0; j < n_2d; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_flat[i * n_2d + j] = aa_flat[(i-1) * n_2d + j] + bb_flat[i * n_2d + j];\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t n_2d = Small_Arg_2D;\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_scalar(length);\n \u00a0 \u00a0std::vector<float> aa_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s1119\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0aa_scalar = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0aa_simd = aa_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s1119_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0s1119_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(aa_scalar, aa_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1119!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1119_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s1119_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s1119(benchmark::State& state) {\n \u00a0 \u00a0size_t n_2d = state.range(0);\n \u00a0 \u00a0size_t length = n_2d * n_2d;\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> aa_output(length);\n \u00a0 \u00a0std::vector<float> bb_input(length);\n \u00a0 \u00a0std::vector<float> aa_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s1119\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0aa_output = aa_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(aa_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(bb_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(aa_output.data(), bb_input.data(), n_2d);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (n_2d - 1) * n_2d. Each op: 1 W(aa), 2 R(aa, bb)\n \u00a0 \u00a0size_t num_ops = (n_2d - 1) * n_2d;\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1119, s1119_scalar)->Name(\"Scalar_s1119\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1119, s1119_simd)->Name(\"SIMD_s1119\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1119", "entrypoint_scalar": "s1119_scalar", "entrypoint_simd": "s1119_simd"}
{"task_id": "tsvc_s121_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[i+1] + b[i];\nThis tests a simple loop-carried dependency (a[i] depends on a[i+1]).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s121_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s121_scalar(float *a, const float *b, size_t n) {\n \u00a0 \u00a0int j;\n \u00a0 \u00a0for (size_t i = 0; i < n - 1; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0j = i + 1;\n \u00a0 \u00a0 \u00a0 \u00a0a[i] = a[j] + b[i];\n \u00a0 \u00a0}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s121_scalar(float *a, const float *b, size_t n);\nvoid s121_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n \u00a0 \u00a0Random rng;\n \u00a0 \u00a0size_t length = Small_Arg_1D;\n\n \u00a0 \u00a0std::vector<float> a_initial(length);\n \u00a0 \u00a0std::vector<float> b_input(length);\n \u00a0 \u00a0std::vector<float> a_scalar(length);\n \u00a0 \u00a0std::vector<float> a_simd(length);\n\n \u00a0 \u00a0for (int iter = 0; iter < iterations; ++iter) {\n \u00a0 \u00a0 \u00a0 \u00a0// Ported Initialization Logic for s121\n \u00a0 \u00a0 \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0a_scalar = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0a_simd = a_initial;\n\n \u00a0 \u00a0 \u00a0 \u00a0s121_scalar(a_scalar.data(), b_input.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0s121_simd(a_simd.data(), b_input.data(), length);\n\n \u00a0 \u00a0 \u00a0 \u00a0if (!allclose(a_scalar, a_simd)) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s121!\" << std::endl;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n \u00a0 \u00a0return true;\n}\n\nint main() {\n \u00a0 \u00a0bool pass = correctness_check(ITERATIONS);\n \u00a0 \u00a0printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n \u00a0 \u00a0return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s121_scalar(float *a, const float *b, size_t n);\nvoid s121_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s121(benchmark::State& state) {\n \u00a0 \u00a0size_t length = state.range(0);\n \u00a0 \u00a0Random rng(DEFAULT_SEED);\n\n \u00a0 \u00a0std::vector<float> a_output(length);\n \u00a0 \u00a0std::vector<float> b_input(length);\n \u00a0 \u00a0std::vector<float> a_initial(length);\n\n \u00a0 \u00a0// Ported Initialization Logic for s121\n \u00a0 \u00a0for (size_t i = 0; i < length; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0a_initial[i] = 1.0f;\n \u00a0 \u00a0 \u00a0 \u00a0b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n \u00a0 \u00a0}\n\n \u00a0 \u00a0for (auto _ : state) {\n \u00a0 \u00a0 \u00a0 \u00a0a_output = a_initial;\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(a_output.data());\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::DoNotOptimize(b_input.data());\n\n \u00a0 \u00a0 \u00a0 \u00a0Func(a_output.data(), b_input.data(), length);\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0benchmark::ClobberMemory();\n \u00a0 \u00a0}\n \u00a0 \u00a0// Ops = (length - 1). Each op: 1 W(a), 2 R(a, b)\n \u00a0 \u00a0state.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length - 1) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s121, s121_scalar)->Name(\"Scalar_s121\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s121, s121_simd)->Name(\"SIMD_s121\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s121", "entrypoint_scalar": "s121_scalar", "entrypoint_simd": "s121_simd"}
{"task_id": "tsvc_s122_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and two integers 'n1' and 'n3'.\nIt performs a complex strided and indexed operation: a[i] += b[n - k];\nThis tests induction variables and irregular access.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s122_simd(float *a, const float *b, size_t n, int n1, int n3) {\n}", "solution_scalar": "void s122_scalar(float *a, const float *b, size_t n, int n1, int n3) {\n    int j, k;\n    j = 1;\n    k = 0;\n    for (size_t i = (size_t)n1 - 1; i < n; i += n3) {\n        k += j;\n        a[i] += b[n - k];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s122_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s122_simd(float *a, const float *b, size_t n, int n1, int n3);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s122\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s122_scalar(a_scalar.data(), b_input.data(), length, n1, n3);\n        s122_simd(a_simd.data(), b_input.data(), length, n1, n3);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s122!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s122_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s122_simd(float *a, const float *b, size_t n, int n1, int n3);\n\ntemplate<void (*Func)(float *, const float *, size_t, int, int)>\nstatic void BM_s122(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    // Ported Initialization Logic for s122\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, n1, n3);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop runs approx (length - n1) / n3 times. Each op: 1 R/W(a), 1 R(b)\n    size_t num_ops = (length - n1) / n3;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s122, s122_scalar)->Name(\"Scalar_s122\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s122, s122_simd)->Name(\"SIMD_s122\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s122", "entrypoint_scalar": "s122_scalar", "entrypoint_simd": "s122_simd"}
{"task_id": "tsvc_s123_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional write: a[j] = ... where 'j' is incremented conditionally.\nThis tests conditional induction variables (a pack/compress pattern).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    int j = -1;\n    for (size_t i = 0; i < (n / 2); i++) {\n        j++;\n        a[j] = b[i] + d[i] * e[i];\n        if (c[i] > 0.0f) {\n            j++;\n            a[j] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s123\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f; // Original test data is all 1.0f, so 'if' is always true\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s123_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s123_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s123!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s123_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s123_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s123(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s123\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_input[i] = 1.0f;\n        c_input[i] = 1.0f; // Original test data is all 1.0f\n        d_input[i] = 1.0f / (float)(i+1);\n        e_input[i] = 1.0f / (float)(i+1);\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n/2). Since c[i] is always true: 6 R (b,d,e,c,d,e), 2 W(a,a)\n    size_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s123, s123_scalar)->Name(\"Scalar_s123\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s123, s123_simd)->Name(\"SIMD_s123\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s123", "entrypoint_scalar": "s123_scalar", "entrypoint_simd": "s123_simd"}
{"task_id": "tsvc_s124_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional write based on b[i]: a[j] = ... where 'j' is incremented in both paths.\nThis tests induction variables in if-then-else.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    int j = -1;\n    for (size_t i = 0; i < n; i++) {\n        if (b[i] > 0.0f) {\n            j++;\n            a[j] = b[i] + d[i] * e[i];\n        } else {\n            j++;\n            a[j] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s124\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f; // Original test data is all 1.0f, so 'if' is always true\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s124_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s124_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s124!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s124_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s124_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s124(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s124\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_input[i] = 1.0f; // Original test data is all 1.0f\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f / (float)(i+1);\n        e_input[i] = 1.0f / (float)(i+1);\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n). Each op: 4 R (b,c,d,e), 1 W(a). (Blend pattern)\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s124, s124_scalar)->Name(\"Scalar_s124\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s124, s124_simd)->Name(\"SIMD_s124\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s124", "entrypoint_scalar": "s124_scalar", "entrypoint_simd": "s124_simd"}
{"task_id": "tsvc_s125_AVX", "prompt": "/*\nThis function flattens a 2D array operation into a 1D array 'flat_2d_array'.\nIt takes 4 flattened 2D arrays and size n_2d.\nOperation: flat_2d_array[k] = aa[i][j] + bb[i][j] * cc[i][j];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n    int k = -1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 0; j < n_2d; j++) {\n            k++;\n            size_t idx_ij = i * n_2d + j;\n            flat_2d_array[k] = aa_flat[idx_ij] + bb_flat[idx_ij] * cc_flat[idx_ij];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t length = n_2d * n_2d;\n\n    std::vector<float> flat_initial(length);\n    std::vector<float> aa_input(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> flat_scalar(length);\n    std::vector<float> flat_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s125\n        for (size_t i = 0; i < length; ++i) {\n            flat_initial[i] = 0.0f;\n            aa_input[i] = 1.0f;\n            bb_input[i] = 0.5f;\n            cc_input[i] = 2.0f;\n        }\n        flat_scalar = flat_initial;\n        flat_simd = flat_initial;\n\n        s125_scalar(flat_scalar.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);\n        s125_simd(flat_simd.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);\n\n        if (!allclose(flat_scalar, flat_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s125!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s125_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s125_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, const float*, size_t)>\nstatic void BM_s125(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t length = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> flat_output(length);\n    std::vector<float> aa_input(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> flat_initial(length);\n\n    // Ported Initialization Logic for s125\n    for (size_t i = 0; i < length; ++i) {\n        flat_initial[i] = 0.0f;\n        aa_input[i] = 1.0f;\n        bb_input[i] = 0.5f;\n        cc_input[i] = 2.0f;\n    }\n\n    for (auto _ : state) {\n        flat_output = flat_initial;\n        benchmark::DoNotOptimize(flat_output.data());\n        benchmark::DoNotOptimize(aa_input.data());\n        benchmark::DoNotOptimize(bb_input.data());\n        benchmark::DoNotOptimize(cc_input.data());\n\n        Func(flat_output.data(), aa_input.data(), bb_input.data(), cc_input.data(), n_2d);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n_2d * n_2d). Each op: 3 R (aa,bb,cc), 1 W(flat)\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(length) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s125, s125_scalar)->Name(\"Scalar_s125\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s125, s125_simd)->Name(\"SIMD_s125\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s125", "entrypoint_scalar": "s125_scalar", "entrypoint_simd": "s125_simd"}
{"task_id": "tsvc_s126_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'bb', 'flat_2d_array', 'cc' and size n_2d.\nIt performs a complex recursive op: bb[j][i] = bb[j-1][i] + flat_2d_array[k-1] * cc[j][i];\nThis tests induction variables and recurrence.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d) {\n    int k = 1;\n    for (size_t i = 0; i < n_2d; i++) {\n        for (size_t j = 1; j < n_2d; j++) {\n            bb_flat[j * n_2d + i] = bb_flat[(j-1) * n_2d + i] + flat_2d_array[k-1] * cc_flat[j * n_2d + i];\n            ++k;\n        }\n        ++k;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\nvoid s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t length = n_2d * n_2d;\n\n    std::vector<float> bb_initial(length);\n    std::vector<float> flat_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> bb_scalar(length);\n    std::vector<float> bb_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s126\n        for (size_t i = 0; i < length; ++i) {\n            bb_initial[i] = 1.0f;\n            flat_input[i] = 1.0f / (float)(i+1); // frac\n            cc_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        bb_scalar = bb_initial;\n        bb_simd = bb_initial;\n\n        s126_scalar(bb_scalar.data(), flat_input.data(), cc_input.data(), n_2d);\n        s126_simd(bb_simd.data(), flat_input.data(), cc_input.data(), n_2d);\n\n        if (!allclose(bb_scalar, bb_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s126!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s126_scalar(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\nvoid s126_simd(float* bb_flat, const float* flat_2d_array, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s126(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t length = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> bb_output(length);\n    std::vector<float> flat_input(length);\n    std::vector<float> cc_input(length);\n    std::vector<float> bb_initial(length);\n\n    // Ported Initialization Logic for s126\n    for (size_t i = 0; i < length; ++i) {\n        bb_initial[i] = 1.0f;\n   \t    flat_input[i] = 1.0f / (float)(i+1); // frac\n        cc_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        bb_output = bb_initial;\n        benchmark::DoNotOptimize(bb_output.data());\n        benchmark::DoNotOptimize(flat_input.data());\n        benchmark::DoNotOptimize(cc_input.data());\n\n        Func(bb_output.data(), flat_input.data(), cc_input.data(), n_2d);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop n_2d * (n_2d - 1). Each op: 3 R (bb, flat, cc), 1 W(bb)\n    size_t num_ops = n_2d * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s126, s126_scalar)->Name(\"Scalar_s126\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s126, s126_simd)->Name(\"SIMD_s126\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s126", "entrypoint_scalar": "s126_scalar", "entrypoint_simd": "s126_simd"}
{"task_id": "tsvc_s127_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs an operation with multiple increments to the index 'j': a[j++] = ...; a[j++] = ...;\nThis tests induction variables with multiple increments.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n) {\n    int j = -1;\n    for (size_t i = 0; i < n / 2; i++) {\n        j++;\n        a[j] = b[i] + c[i] * d[i];\n        j++;\n        a[j] = b[i] + d[i] * e[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s127\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s127_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s127_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s127!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s127_scalar(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s127_simd(float *a, const float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s127(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s127\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_input[i] = 1.0f;\n        c_input[i] = 1.0f / (float)(i+1);\n        d_input[i] = 1.0f / (float)(i+1);\n        e_input[i] = 1.0f / (float)(i+1);\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n/2). Each op: 5 R (b,c,d,b,e), 2 W(a,a)\n ->  size_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s127, s127_scalar)->Name(\"Scalar_s127\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s127, s127_simd)->Name(\"SIMD_s127\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s127", "entrypoint_scalar": "s127_scalar", "entrypoint_simd": "s127_simd"}
{"task_id": "tsvc_s128_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a coupled induction variable update: a[i] = b[k] - d[i]; b[k] = a[i] + c[k];\nThis tests dependency analysis in coupled loops.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s128_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s128_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    int j = -1;\n    int k;\n    for (size_t i = 0; i < n / 2; i++) {\n        k = j + 1;\n        a[i] = b[k] - d[i];\n        j = k + 1;\n        b[k] = a[i] + c[k];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s128_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s128_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    std::vector<float> b_scalar(length);\n    std::vector<float> b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s128\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_initial[i] = 2.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s128_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s128_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        // Must check both 'a' and 'b' arrays as they are both modified\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n Team          if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s128!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s128_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s128_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s128(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s128\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_initial[i] = 2.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f;\n   ci}\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n       \tbenchmark::ClobberMemory();\n    }\n    // Loop (n/2). Each op: 4 R (b,d,a,c), 2 W (a,b)\n   \tsize_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s128, s128_scalar)->Name(\"Scalar_s128\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s128, s128_simd)->Name(\"SIMD_s128\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s128", "entrypoint_scalar": "s128_scalar", "entrypoint_simd": "s128_simd"}
{"task_id": "tsvc_s131_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[i + 1] + b[i]; (with m=1 hardcoded).\nThis tests forward substitution dependency.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s131_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s131_scalar(float *a, const float *b, size_t n) {\n    int m  = 1;\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = a[i + m] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s131_scalar(float *a, const float *b, size_t n);\nvoid s131_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s131\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s131_scalar(a_scalar.data(), b_input.data(), length);\n        s131_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s131!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s131_scalar(float *a, const float *b, size_t n);\nvoid s131_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s131(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s131\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s131, s131_scalar)->Name(\"Scalar_s131\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s131, s131_simd)->Name(\"SIMD_s131\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s131", "entrypoint_scalar": "s131_scalar", "entrypoint_simd": "s131_simd"}
{"task_id": "tsvc_s132_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major), 1D arrays 'b' and 'c', and the 2D dimension 'n_2d'.\nIt performs the operation: aa[0][i] = aa[1][i-1] + b[i] * c[1]; (with j=0, k=1 hardcoded).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d) {\n    // n_2d = LEN_2D, n_1d = LEN_1D\n    int m = 0;\n    int j = m;   // j = 0\n    int k = m+1; // k = 1\n    float c1 = c[1]; // Hoist c[1]\n    for (size_t i = 1; i < n_2d; i++) {\n        // aa[j][i] = aa[k][i-1] + b[i] * c[1];\n        aa_flat[j * n_2d + i] = aa_flat[k * n_2d + (i-1)] + b[i] * c1;\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n#define Small_Arg_1D LEN_1D\n\nvoid s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\nvoid s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t n_1d = Small_Arg_1D;\n    size_t length_2d = n_2d * n_2d;\n\n    std::vector<float> aa_initial(length_2d);\n    std::vector<float> b_input(n_1d);\n    std::vector<float> c_input(n_1d);\n    std::vector<float> aa_scalar(length_2d);\n    std::vector<float> aa_simd(length_2d);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s132\n        for (size_t i = 0; i < length_2d; ++i) {\n            aa_initial[i] = 1.0f;\n        }\n        for (size_t i = 0; i < n_1d; ++i) {\n            b_input[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        aa_scalar = aa_initial;\n        aa_simd = aa_initial;\n\n        s132_scalar(aa_scalar.data(), b_input.data(), c_input.data(), n_2d, n_1d);\n        s132_simd(aa_simd.data(), b_input.data(), c_input.data(), n_2d, n_1d);\n\n        if (!allclose(aa_scalar, aa_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s132!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s132_scalar(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\nvoid s132_simd(float* aa_flat, const float* b, const float* c, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t, size_t)>\nstatic void BM_s132(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t n_1d = LEN_1D;\n    size_t length_2d = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> aa_output(length_2d);\n    std::vector<float> b_input(n_1d);\n    std::vector<float> c_input(n_1d);\n    std::vector<float> aa_initial(length_2d);\n\n    // Ported Initialization Logic for s132\n    for (size_t i = 0; i < length_2d; ++i) {\n        aa_initial[i] = 1.0f;\n    }\n    for (size_t i = 0; i < n_1d; ++i) {\n        b_input[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        aa_output = aa_initial;\n        benchmark::DoNotOptimize(aa_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n\n        Func(aa_output.data(), b_input.data(), c_input.data(), n_2d, n_1d);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s132, s132_scalar)->Name(\"Scalar_s132\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s132, s132_simd)->Name(\"SIMD_s132\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s132", "entrypoint_scalar": "s132_scalar", "entrypoint_simd": "s132_simd"}
{"task_id": "tsvc_s141_AVX", "prompt": "/*\nThis function takes a 1D float array 'flat_2d_array' and a flattened 2D float array 'bb' (row-major) of size n_2d * n_2d.\nIt performs a complex non-linear operation, walking a row in a symmetric packed array.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d) {\n    int k;\n    for (size_t i = 0; i < n_2d; i++) {\n        k = (i+1) * (i) / 2 + i;\n        for (size_t j = i; j < n_2d; j++) {\n            // flat_2d_array[k] += bb[j][i];\n            flat_2d_array[k] += bb_flat[j * n_2d + i];\n            k += j+1;\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d);\nvoid s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t n_2d = Small_Arg_2D;\n    size_t length = n_2d * n_2d;\n\n    std::vector<float> flat_initial(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> flat_scalar(length);\n    std::vector<float> flat_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s141\n        for (size_t i = 0; i < length; ++i) {\n            flat_initial[i] = 1.0f;\n            bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        flat_scalar = flat_initial;\n        flat_simd = flat_initial;\n\n        s141_scalar(flat_scalar.data(), bb_input.data(), n_2d);\n        s141_simd(flat_simd.data(), bb_input.data(), n_2d);\n\n        if (!allclose(flat_scalar, flat_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s141!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s141_scalar(float* flat_2d_array, const float* bb_flat, size_t n_2d);\nvoid s141_simd(float* flat_2d_array, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s141(benchmark::State& state) {\n    size_t n_2d = state.range(0);\n    size_t length = n_2d * n_2d;\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> flat_output(length);\n    std::vector<float> bb_input(length);\n    std::vector<float> flat_initial(length);\n\n    // Ported Initialization Logic for s141\n    for (size_t i = 0; i < length; ++i) {\n        flat_initial[i] = 1.0f;\n        bb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        flat_output = flat_initial;\n        benchmark::DoNotOptimize(flat_output.data());\n        benchmark::DoNotOptimize(bb_input.data());\n\n        Func(flat_output.data(), bb_input.data(), n_2d);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s141, s141_scalar)->Name(\"Scalar_s141\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s141, s141_simd)->Name(\"SIMD_s141\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s141", "entrypoint_scalar": "s141_scalar", "entrypoint_simd": "s141_simd"}
{"task_id": "tsvc_s151_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and their length 'n'.\nIt performs the operation: a[i] = a[i + 1] + b[i]; (with m=1 hardcoded).\nThis is an interprocedural test, but the core logic is what matters.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s151_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "// This scalar solution is the inlined logic of s151s(a, b, 1)\nvoid s151_scalar(float *a, const float *b, size_t n) {\n    int m = 1;\n    // Assuming n corresponds to LEN_1D\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = a[i + m] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s151_scalar(float *a, const float *b, size_t n);\nvoid s151_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s151\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s151_scalar(a_scalar.data(), b_input.data(), length);\n        s151_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s151!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s151_scalar(float *a, const float *b, size_t n);\nvoid s151_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s151(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s151\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s151, s151_scalar)->Name(\"Scalar_s151\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s151, s151_simd)->Name(\"SIMD_s151\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s151", "entrypoint_scalar": "s151_scalar", "entrypoint_simd": "s151_simd"}
{"task_id": "tsvc_s152_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs two inlined operations: \n1. b[i] = d[i] * e[i];\n2. a[i] += b[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    // Inlined logic from s152 and s152s\n    for (size_t i = 0; i < n; i++) {\n        b[i] = d[i] * e[i];\n        a[i] += b[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s152\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 0.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s152_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s152_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s152!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s152_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s152_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s152(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s152\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 0.0f;\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n        e_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s152, s152_scalar)->Name(\"Scalar_s152\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s152, s152_simd)->Name(\"SIMD_s152\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s152", "entrypoint_scalar": "s152_scalar", "entrypoint_simd": "s152_simd"}
{"task_id": "tsvc_s161_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional operation based on b[i]:\nIf b[i] < 0, it calculates: c[i+1] = a[i] + d[i] * d[i];\nOtherwise, it calculates: a[i] = c[i] + d[i] * e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n    for (size_t i = 0; i < n - 1; ++i) {\n        if (b[i] < 0.0f) {\n            c[i+1] = a[i] + d[i] * d[i];\n        } else {\n            a[i] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_initial(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> c_scalar(length), c_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s161\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Alternating 1.0 and -1.0\n            c_initial[i] = 1.0f;\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        c_scalar = c_initial;\n        c_simd = c_initial;\n\n        s161_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n        s161_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s161!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s161_scalar(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s161_simd(float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, const float *, size_t)>\nstatic void BM_s161(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_output(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> c_initial(length);\n\n    // Ported Initialization Logic for s161\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = (i % 2 == 0) ? 1.0f : -1.0f;\n        c_initial[i] = 1.0f;\n        d_input[i] = 1.0f / (float)(i+1); // frac\n        e_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        c_output = c_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_output.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_input.data(), c_output.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s161, s161_scalar)->Name(\"Scalar_s161\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s161, s161_simd)->Name(\"SIMD_s161\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s161", "entrypoint_scalar": "s161_scalar", "entrypoint_simd": "s161_simd"}
{"task_id": "tsvc_s1161_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a conditional operation based on c[i]:\nIf c[i] < 0, it calculates: b[i] = a[i] + d[i] * d[i];\nOtherwise, it calculates: a[i] = c[i] + d[i] * e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    for (size_t i = 0; i < n - 1; ++i) {\n        if (c[i] < 0.0f) {\n            b[i] = a[i] + d[i] * d[i];\n        } else {\n            a[i] = c[i] + d[i] * e[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1161 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f;\n            c_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Mix for condition\n            d_input[i] = 1.0f;\n            e_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s1161_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s1161_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1161!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1161_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1161_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1161(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s1161 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f;\n        c_input[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Mix for condition\n        d_input[i] = 1.0f;\n        e_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1161, s1161_scalar)->Name(\"Scalar_s1161\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1161, s1161_simd)->Name(\"SIMD_s1161\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1161", "entrypoint_scalar": "s1161_scalar", "entrypoint_simd": "s1161_simd"}
{"task_id": "tsvc_s162_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', length 'n', and an integer 'k'.\nIf k > 0, it performs the operation: a[i] = a[i + k] + b[i] * c[i];\nThis tests conditional execution based on a scalar argument.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s162_simd(float *a, const float *b, const float *c, size_t n, int k) {\n}", "solution_scalar": "void s162_scalar(float *a, const float *b, const float *c, size_t n, int k) {\n    if (k > 0) {\n        for (size_t i = 0; i < n - 1; i++) {\n            a[i] = a[i + k] + b[i] * c[i];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s162_scalar(float *a, const float *b, const float *c, size_t n, int k);\nvoid s162_simd(float *a, const float *b, const float *c, size_t n, int k);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int k = 1; // From tsvc.c main(), n1 is 1\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s162\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s162_scalar(a_scalar.data(), b_input.data(), c_input.data(), length, k);\n        s162_simd(a_simd.data(), b_input.data(), c_input.data(), length, k);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s162!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s162_scalar(float *a, const float *b, const float *c, size_t n, int k);\nvoid s162_simd(float *a, const float *b, const float *c, size_t n, int k);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t, int)>\nstatic void BM_s162(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_initial(length);\n    int k = 1; // From tsvc.c main(), n1 is 1\n\n    // Ported Initialization Logic for s162\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), length, k);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s162, s162_scalar)->Name(\"Scalar_s162\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s162, s162_simd)->Name(\"SIMD_s162\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s162", "entrypoint_scalar": "s162_scalar", "entrypoint_simd": "s162_simd"}
{"task_id": "tsvc_s171_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and an integer 'inc'.\nIt performs a strided write operation: a[i * inc] += b[i];\nThis tests symbolic dependence and strided access.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s171_simd(float *a, const float *b, size_t n, int inc) {\n}", "solution_scalar": "void s171_scalar(float *a, const float *b, size_t n, int inc) {\n    for (size_t i = 0; i < n; i++) {\n        a[i * inc] += b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s171_scalar(float *a, const float *b, size_t n, int inc);\nvoid s171_simd(float *a, const float *b, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s171\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s171_scalar(a_scalar.data(), b_input.data(), length, inc);\n        s171_simd(a_simd.data(), b_input.data(), length, inc);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s171!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s171_scalar(float *a, const float *b, size_t n, int inc);\nvoid s171_simd(float *a, const float *b, size_t n, int inc);\n\ntemplate<void (*Func)(float *, const float *, size_t, int)>\nstatic void BM_s171(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    // Ported Initialization Logic for s171\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, inc);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s171, s171_scalar)->Name(\"Scalar_s171\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s171, s171_simd)->Name(\"SIMD_s171\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s171", "entrypoint_scalar": "s171_scalar", "entrypoint_simd": "s171_simd"}
{"task_id": "tsvc_s172_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and two integers 'n1' and 'n3'.\nIt performs a strided operation: a[i] += b[i];\nThe loop starts at n1-1 and increments by n3.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s172_simd(float *a, const float *b, size_t n, int n1, int n3) {\n}", "solution_scalar": "void s172_scalar(float *a, const float *b, size_t n, int n1, int n3) {\n    // n = LEN_1D\n    for (size_t i = n1 - 1; i < n; i += n3) {\n        a[i] += b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s172_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s172_simd(float *a, const float *b, size_t n, int n1, int n3);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s172\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s172_scalar(a_scalar.data(), b_input.data(), length, n1, n3);\n        s172_simd(a_simd.data(), b_input.data(), length, n1, n3);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s172!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s172_scalar(float *a, const float *b, size_t n, int n1, int n3);\nvoid s172_simd(float *a, const float *b, size_t n, int n1, int n3);\n\ntemplate<void (*Func)(float *, const float *, size_t, int, int)>\nstatic void BM_s172(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int n1 = 1; // From tsvc.c main()\n    int n3 = 1; // From tsvc.c main()\n\n    // Ported Initialization Logic for s172\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, n1, n3);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s172, s172_scalar)->Name(\"Scalar_s172\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s172, s172_simd)->Name(\"SIMD_s172\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s172", "entrypoint_scalar": "s172_scalar", "entrypoint_simd": "s172_simd"}
{"task_id": "tsvc_s173_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', and length 'n'.\nIt performs the operation: a[i+k] = a[i] + b[i]; where k = n/2.\nThis tests expressions in loop bounds and subscripts.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s173_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s173_scalar(float *a, const float *b, size_t n) {\n    // n = LEN_1D\n    int k = n / 2;\n    for (size_t i = 0; i < n / 2; i++) {\n        a[i+k] = a[i] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s173_scalar(float *a, const float *b, size_t n);\nvoid s173_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s173\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s173_scalar(a_scalar.data(), b_input.data(), length);\n        s173_simd(a_simd.data(), b_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s173!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s173_scalar(float *a, const float *b, size_t n);\nvoid s173_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s173(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s173\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s173, s173_scalar)->Name(\"Scalar_s173\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s173, s173_simd)->Name(\"SIMD_s173\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s173", "entrypoint_scalar": "s173_scalar", "entrypoint_simd": "s173_simd"}
{"task_id": "tsvc_s174_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and an integer 'M'.\nIt performs the operation: a[i+M] = a[i] + b[i]; for i < M.\nThis tests symbolic subscripts.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s174_simd(float *a, const float *b, size_t n, int M) {\n}", "solution_scalar": "void s174_scalar(float *a, const float *b, size_t n, int M) {\n    // n = LEN_1D. M = n/2 from main().\n    for (size_t i = 0; i < M; i++) {\n        a[i+M] = a[i] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s174_scalar(float *a, const float *b, size_t n, int M);\nvoid s174_simd(float *a, const float *b, size_t n, int M);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int M = length / 2; // From tsvc.c main()\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s174\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s174_scalar(a_scalar.data(), b_input.data(), length, M);\n        s174_simd(a_simd.data(), b_input.data(), length, M);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s174!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s174_scalar(float *a, const float *b, size_t n, int M);\nvoid s174_simd(float *a, const float *b, size_t n, int M);\n\ntemplate<void (*Func)(float *, const float *, size_t, int)>\nstatic void BM_s174(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int M = length / 2; // From tsvc.c main()\n\n    // Ported Initialization Logic for s174\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, M);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s174, s174_scalar)->Name(\"Scalar_s174\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s174, s174_simd)->Name(\"SIMD_s174\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s174", "entrypoint_scalar": "s174_scalar", "entrypoint_simd": "s174_simd"}
{"task_id": "tsvc_s175_AVX", "prompt": "/*\nThis function takes a float array 'a', a const float array 'b', length 'n', and an integer 'inc'.\nIt performs a strided operation: a[i] = a[i + inc] + b[i];\nThis tests symbolic dependence.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s175_simd(float *a, const float *b, size_t n, int inc) {\n}", "solution_scalar": "void s175_scalar(float *a, const float *b, size_t n, int inc) {\n    // n = LEN_1D\n    for (size_t i = 0; i < n - inc; i += inc) {\n        a[i] = a[i + inc] + b[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s175_scalar(float *a, const float *b, size_t n, int inc);\nvoid s175_simd(float *a, const float *b, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s175\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s175_scalar(a_scalar.data(), b_input.data(), length, inc);\n        s175_simd(a_simd.data(), b_input.data(), length, inc);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s175!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s175_scalar(float *a, const float *b, size_t n, int inc);\nvoid s175_simd(float *a, const float *b, size_t n, int inc);\n\ntemplate<void (*Func)(float *, const float *, size_t, int)>\nstatic void BM_s175(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> a_initial(length);\n    int inc = 1; // From tsvc.c main(), n1 is 1\n\n    // Ported Initialization Logic for s175\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n\n        Func(a_output.data(), b_input.data(), length, inc);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s175, s175_scalar)->Name(\"Scalar_s175\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s175, s175_simd)->Name(\"SIMD_s175\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s175", "entrypoint_scalar": "s175_scalar", "entrypoint_simd": "s175_simd"}
{"task_id": "tsvc_s176_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a 2D convolution operation: a[i] += b[i+m-j-1] * c[j]; where m = n/2.\nThis tests a complex dependency pattern (convolution).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s176_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s176_scalar(float *a, const float *b, const float *c, size_t n) {\n    // n = LEN_1D\n    int m = n / 2;\n    for (size_t j = 0; j < (n / 2); j++) {\n        for (size_t i = 0; i < m; i++) {\n            a[i] += b[i+m-j-1] * c[j];\n        }\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s176_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s176_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_scalar(length);\n    std::vector<float> a_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s176\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_input[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n\n        s176_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n        s176_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s176!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s176_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s176_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s176(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> a_initial(length);\n\n    // Ported Initialization Logic for s176\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_input[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_input.data());\n        benchmark::DoNotOptimize(c_input.data());\n\n        Func(a_output.data(), b_input.data(), c_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s176, s176_scalar)->Name(\"Scalar_s176\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s176, s176_simd)->Name(\"SIMD_s176\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s176", "entrypoint_scalar": "s176_scalar", "entrypoint_simd": "s176_simd"}
{"task_id": "tsvc_s211_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a statement reordering task with dependencies:\n1. a[i] = b[i - 1] + c[i] * d[i];\n2. b[i] = b[i + 1] - e[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n    for (size_t i = 1; i < n - 1; i++) {\n        a[i] = b[i - 1] + c[i] * d[i];\n        b[i] = b[i + 1] - e[i] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s211\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_initial[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n            e_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s211_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        s211_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s211!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s211_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s211_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s211(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> e_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s211\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 0.0f;\n        b_initial[i] = 1.0f;\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n        e_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n        benchmark::DoNotOptimize(e_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-2). Each op: 6R (b,c,d,b,e,d), 2W (a,b)\n    size_t num_ops = length - 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s211, s211_scalar)->Name(\"Scalar_s211\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s211, s211_simd)->Name(\"SIMD_s211\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s211", "entrypoint_scalar": "s211_scalar", "entrypoint_simd": "s211_simd"}
{"task_id": "tsvc_s212_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a task with dependency needing a temporary variable:\n1. a[i] *= c[i];\n2. b[i] += a[i + 1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s212_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s212_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] *= c[i];\n        b[i] += a[i + 1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s212_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s212_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s212\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f / (float)(i+1); // frac\n            b_initial[i] = 1.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s212_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s212_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s212!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s212_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s212_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s212(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s212\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f / (float)(i+1); // frac\n        b_initial[i] = 1.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-1). Each op: 5R (a,c,b,a,d), 2W (a,b)\n    size_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s212, s212_scalar)->Name(\"Scalar_s212\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s212, s212_simd)->Name(\"SIMD_s212\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s212", "entrypoint_scalar": "s212_scalar", "entrypoint_simd": "s212_simd"}
{"task_id": "tsvc_s1213_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a dependency needing a temporary variable:\n1. a[i] = b[i-1] + c[i];\n2. b[i] = a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1213_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 1; i < n - 1; i++) {\n        a[i] = b[i-1] + c[i];\n        b[i] = a[i+1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s1213_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s1213 (uses default init())\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f;\n            c_input[i] = 1.0f;\n            d_input[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s1213_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s1213_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1213!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1213_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s1213_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s1213(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s1213 (uses default init())\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f;\n        c_input[i] = 1.0f;\n        d_input[i] = 1.0f;\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-2). Each op: 4R (b,c,a,d), 2W (a,b)\n    size_t num_ops = length - 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1213, s1213_scalar)->Name(\"Scalar_s1213\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1213, s1213_simd)->Name(\"SIMD_s1213\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1213", "entrypoint_scalar": "s1213_scalar", "entrypoint_simd": "s1213_simd"}
{"task_id": "tsvc_s221_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a partially recursive operation (loop distribution):\n1. a[i] += c[i] * d[i];\n2. b[i] = b[i - 1] + a[i] + d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s221_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        a[i] += c[i] * d[i];\n        b[i] = b[i - 1] + a[i] + d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s221_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s221\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 1.0f;\n            b_initial[i] = 1.0f / (float)(i+1); // frac\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            d_input[i] = 1.0f / (float)(i+1); // frac\n        }\n        a_scalar = a_initial;\n        a_simd = a_initial;\n        b_scalar = b_initial;\n        b_simd = b_initial;\n\n        s221_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n        s221_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n        if (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s221!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s221_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s221_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s221(benchmark::State& state) {\n    size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n\n    std::vector<float> a_output(length);\n    std::vector<float> b_output(length);\n    std::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n\n    // Ported Initialization Logic for s221\n    for (size_t i = 0; i < length; ++i) {\n        a_initial[i] = 1.0f;\n        b_initial[i] = 1.0f / (float)(i+1); // frac\n        c_input[i] = 1.0f / (float)(i+1); // frac\n        d_input[i] = 1.0f / (float)(i+1); // frac\n    }\n\n    for (auto _ : state) {\n        a_output = a_initial;\n        b_output = b_initial;\n        benchmark::DoNotOptimize(a_output.data());\n        benchmark::DoNotOptimize(b_output.data());\n        benchmark::DoNotOptimize(c_input.data());\n        benchmark::DoNotOptimize(d_input.data());\n\n        Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n        \n        benchmark::ClobberMemory();\n    }\n    // Loop (n-1). Each op: 6R (a,c,d,b,a,d), 2W (a,b)\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s221, s221_scalar)->Name(\"Scalar_s221\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s221, s221_simd)->Name(\"SIMD_s221\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s221", "entrypoint_scalar": "s221_scalar", "entrypoint_simd": "s221_simd"}
{"task_id": "tsvc_s1221_AVX", "prompt": "/*\nThis function takes float arrays 'a' and 'b' and length 'n'.\nIt performs a recurrence: b[i] = b[i - 4] + a[i];\nThis tests loop-carried dependencies with a fixed stride.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1221_simd(const float *a, float *b, size_t n) {\n}", "solution_scalar": "void s1221_scalar(const float *a, float *b, size_t n) {\n    for (size_t i = 4; i < n; i++) {\n        b[i] = b[i - 4] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1221_scalar(const float *a, float *b, size_t n);\nvoid s1221_simd(const float *a, float *b, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_input(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> b_scalar(length);\n    std::vector<float> b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1221 (uses default init())\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1221_scalar(a_input.data(), b_scalar.data(), length);\n       \ts1221_simd(a_input.data(), b_simd.data(), length);\n\n       \tif (!allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1221!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1221_scalar(const float *a, float *b, size_t n);\nvoid s1221_simd(const float *a, float *b, size_t n);\n\ntemplate<void (*Func)(const float *, float *, size_t)>\nstatic void BM_s1221(benchmark::State& state) {\n -> \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1221 (uses default init())\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n\n       \tFunc(a_input.data(), b_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n -> \t// Loop (n-4). Each op: 2R (b,a), 1W (b)\n   \tsize_t num_ops = length - 4;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1221, s1221_scalar)->Name(\"Scalar_s1221\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1221, s1221_simd)->Name(\"SIMD_s1221\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1221", "entrypoint_scalar": "s1221_scalar", "entrypoint_simd": "s1221_simd"}
{"task_id": "tsvc_s222_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'e' and length 'n'.\nIt performs a partially recursive operation:\n1. a[i] += b[i] * c[i];\n2. e[i] = e[i - 1] * e[i - 1]; // Recurrence\n3. a[i] -= b[i] * c[i];\nImplement this using AVX intrinsics. The 'e' loop has a dependency.\n*/\n#include <immintrin.h>\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n) {\n}", "solution_scalar": "void s222_scalar(float *a, const float *b, const float *c, float *e, size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        a[i] += b[i] * c[i];\n        e[i] = e[i - 1] * e[i - 1];\n        a[i] -= b[i] * c[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s222_scalar(float *a, const float *b, const float *c, float *e, size_t n);\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_input(length);\n    std::vector<float> c_input(length);\n    std::vector<float> e_initial(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> e_scalar(length), e_simd(length);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        // Ported Initialization Logic for s222\n        for (size_t i = 0; i < length; ++i) {\n            a_initial[i] = 0.0f;\n            b_input[i] = 1.0f;\n            c_input[i] = 1.0f / (float)(i+1); // frac\n            e_initial[i] = 1.0f;\n        }\n        a_scalar = a_initial;\n       \ta_simd = a_initial;\n       \te_scalar = e_initial;\n       \te_simd = e_initial;\n\n       \ts222_scalar(a_scalar.data(), b_input.data(), c_input.data(), e_scalar.data(), length);\n       \ts222_simd(a_simd.data(), b_input.data(), c_input.data(), e_simd.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(e_scalar, e_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s222!\" << std::endl;\n            return false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s222_scalar(float *a, const float *b, const float *c, float *e, size_t n);\nvoid s222_simd(float *a, const float *b, const float *c, float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, float *, size_t)>\nstatic void BM_s222(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> e_output(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> e_initial(length);\n\n   \t// Ported Initialization Logic for s222\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \te_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \te_output = e_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(e_output.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), e_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2 R/W(a), 4 R(b,c,b,c), 1 R/W(e), 1 R(e). Total: 10 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s222, s222_scalar)->Name(\"Scalar_s222\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s222, s222_simd)->Name(\"SIMD_s222\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s222", "entrypoint_scalar": "s222_scalar", "entrypoint_simd": "s222_simd"}
{"task_id": "tsvc_s231_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a column-wise recurrence: aa[j][i] = aa[j - 1][i] + bb[j][i];\nThis tests dependencies in the inner loop with non-unit stride.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; ++i) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + bb[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_scalar(length);\n   \tstd::vector<float> aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s231\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f;\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts231_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n       \ts231_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s231!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s231_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s231_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s231(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s231\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f;\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop n_2d * (n_2d - 1). Each op: 2R (aa, bb), 1W (aa)\n   \tsize_t num_ops = n_2d * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s231, s231_scalar)->Name(\"Scalar_s231\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s231, s231_simd)->Name(\"SIMD_s231\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s231", "entrypoint_scalar": "s231_scalar", "entrypoint_simd": "s231_simd"}
{"task_id": "tsvc_s232_AVX", "prompt": "/*\nThis function takes two flattened 2D float arrays 'aa' and 'bb' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop with recurrence: aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i];\nThis tests recurrence in the inner loop.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d) {\n   \tfor (size_t j = 1; j < n_2d; j++) {\n       \tfor (size_t i = 1; i <= j; i++) {\n           \t// aa[j][i] = aa[j][i-1]*aa[j][i-1]+bb[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_i_1 = j * n_2d + (i - 1);\n           \tfloat temp = aa_flat[idx_j_i_1];\n           \taa_flat[idx_ji] = temp * temp + bb_flat[idx_ji];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_scalar(length);\n   \tstd::vector<float> aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s232\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts232_scalar(aa_scalar.data(), bb_input.data(), n_2d);\n       \ts232_simd(aa_simd.data(), bb_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s232!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s232_scalar(float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s232_simd(float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s232(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s232\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d * (n_2d - 1)) / 2. Each op: 3R (aa, aa, bb), 1W (aa)\n   \tsize_t num_ops = (n_2d * (n_2d - 1)) / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s232, s232_scalar)->Name(\"Scalar_s232\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s232, s232_simd)->Name(\"SIMD_s232\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s232", "entrypoint_scalar": "s232_scalar", "entrypoint_simd": "s232_simd"}
{"task_id": "tsvc_s1232_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt performs a triangular loop, column-wise: aa[i][j] = bb[i][j] + cc[i][j];\nThis tests non-unit stride (strided) memory access.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t j = 0; j < n_2d; j++) {\n       \tfor (size_t i = j; i < n_2d; i++) {\n           \t// aa[i][j] = bb[i][j] + cc[i][j]\n           \tsize_t idx_ij = i * n_2d + j;\n           \taa_flat[idx_ij] = bb_flat[idx_ij] + cc_flat[idx_ij];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length);\n   \tstd::vector<float> aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1232\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 0.0f;\n           \tbb_input[i] = 1.0f / (float)(i+1); // frac\n           \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts1232_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       \ts1232_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1232!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s1232_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s1232_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s1232(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s1232\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 0.0f;\n       \tbb_input[i] = 1.0f / (float)(i+1); // frac\n       \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d * (n_2d + 1)) / 2. Each op: 2R (bb, cc), 1W (aa)\n   \tsize_t num_ops = (n_2d * (n_2d + 1)) / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s1232, s1232_scalar)->Name(\"Scalar_s1232\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s1232, s1232_simd)->Name(\"SIMD_s1232\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1232", "entrypoint_scalar": "s1232_scalar", "entrypoint_simd": "s1232_simd"}
{"task_id": "tsvc_s233_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt contains two inner loops with different dependencies:\n1. aa[j][i] = aa[j-1][i] + cc[j][i]; (Column-wise recurrence)\n2. bb[j][i] = bb[j][i-1] + cc[j][i]; (Column-wise recurrence)\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 1; i < n_2d; i++) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + cc[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + cc_flat[idx_ji];\n       \t}\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// bb[j][i] = bb[j][i-1] + cc[j][i]  -- NOTE: TSVC source has bb[j][i-1], this is column-wise\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_i_1 = j * n_2d + (i - 1);\n           \tbb_flat[idx_ji] = bb_flat[idx_j_i_1] + cc_flat[idx_ji];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n   \tstd::vector<float> bb_scalar(length), bb_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s233\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n       \tbb_scalar = bb_initial;\n       \tbb_simd = bb_initial;\n\n       \ts233_scalar(aa_scalar.data(), bb_scalar.data(), cc_input.data(), n_2d);\n       \ts233_simd(aa_simd.data(), bb_simd.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd) || !allclose(bb_scalar, bb_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s233!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t)>\nstatic void BM_s233(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_output(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n\n   \t// Ported Initialization Logic for s233\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbb_output = bb_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_output.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_output.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// (n_2d - 1) * (n_2d - 1) ops for each loop. Each op = 2R, 1W. Total = 6 accesses.\n   \tsize_t num_ops = (n_2d - 1) * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s233, s233_scalar)->Name(\"Scalar_s233\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s233, s233_simd)->Name(\"SIMD_s233\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s233", "entrypoint_scalar": "s233_scalar", "entrypoint_simd": "s233_simd"}
{"task_id": "tsvc_s2233_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt contains two inner loops with different dependencies:\n1. aa[j][i] = aa[j-1][i] + cc[j][i]; (Column-wise recurrence)\n2. bb[i][j] = bb[i-1][j] + cc[i][j]; (Row-wise recurrence)\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 1; i < n_2d; i++) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + cc[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + cc_flat[idx_ji];\n       \t}\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// bb[i][j] = bb[i-1][j] + cc[i][j]\n           \tsize_t idx_ij = i * n_2d + j;\n           \tsize_t idx_i_1_j = (i - 1) * n_2d + j;\n           \tbb_flat[idx_ij] = bb_flat[idx_i_1_j] + cc_flat[idx_ij];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n   \tstd::vector<float> bb_scalar(length), bb_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2233 (same as s233)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n       \tbb_scalar = bb_initial;\n       \tbb_simd = bb_initial;\n\n       \ts2233_scalar(aa_scalar.data(), bb_scalar.data(), cc_input.data(), n_2d);\n       \ts2233_simd(aa_simd.data(), bb_simd.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd) || !allclose(bb_scalar, bb_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2233!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2233_scalar(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2233_simd(float* aa_flat, float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t)>\nstatic void BM_s2233(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_output(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_initial(length);\n\n   \t// Ported Initialization Logic for s2233 (same as s233)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tcc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbb_output = bb_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_output.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_output.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// (n_2d - 1) * (n_2d - 1) ops for each loop. Each op = 2R, 1W. Total = 6 accesses.\n   \tsize_t num_ops = (n_2d - 1) * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2233, s2233_scalar)->Name(\"Scalar_s2233\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2233, s2233_simd)->Name(\"SIMD_s2233\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2233", "entrypoint_scalar": "s2233_scalar", "entrypoint_simd": "s2233_simd"}
{"task_id": "tsvc_s235_AVX", "prompt": "/*\nThis function is imperfectly nested. It takes 1D arrays 'a', 'b', 'c' and 2D arrays 'aa', 'bb'.\n1. a[i] += b[i] * c[i];\n2. Inner loop: aa[j][i] = aa[j-1][i] + bb[j][i] * a[i];\nThis tests loop interchange on imperfectly nested loops.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \ta[i] += b[i] * c[i];\n       \tfloat a_i = a[i]; // Hoist for inner loop\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j-1][i] + bb[j][i] * a_i\n           \tsize_t idx_ji = j * n_2d + i;\n           \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji] * a_i;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s235\n       \tfor(size_t i = 0; i < n_1d; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \tfor(size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts235_scalar(a_scalar.data(), b_input.data(), c_input.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n       \ts235_simd(a_simd.data(), b_input.data(), c_input.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s235!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s235_scalar(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s235_simd(float* a, const float* b, const float* c, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, float*, const float*, size_t, size_t)>\nstatic void BM_s235(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s235\n   \tfor(size_t i = 0; i < n_1d; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n   \tfor(size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n Z     \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Ops: n_2d * (3 accesses) + n_2d * (n_2d - 1) * (4 accesses)\n   \tsize_t outer_ops = n_2d;\n   \tsize_t inner_ops = n_2d * (n_2d - 1);\n   \tint64_t bytes = (int64_t(outer_ops) * 3 + int64_t(inner_ops) * 4) * sizeof(float);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s235, s235_scalar)->Name(\"Scalar_s235\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s235, s235_simd)->Name(\"SIMD_s235\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s235", "entrypoint_scalar": "s235_scalar", "entrypoint_simd": "s235_simd"}
{"task_id": "tsvc_s241_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a node-splitting task with dependencies:\n1. a[i] = b[i] * c[i] * d[i];\n2. b[i] = a[i] * a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s241_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n    for (size_t i = 0; i < n - 1; i++) {\n        a[i] = b[i] * c[i] * d[i];\n        b[i] = a[i] * a[i + 1] * d[i];\n    }\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s241_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n    Random rng;\n    size_t length = Small_Arg_1D;\n\n    std::vector<float> a_initial(length);\n    std::vector<float> b_initial(length);\n    std::vector<float> c_input(length);\n    std::vector<float> d_input(length);\n    std::vector<float> a_scalar(length), a_simd(length);\n    std::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s241\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts241_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n       \ts241_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s241!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s241_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s241_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s241(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s241\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 5R (b,c,d,a[i+1],d), 1 R/W (a), 1W (b). Total: 8 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s241, s241_scalar)->Name(\"Scalar_s241\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s241, s241_simd)->Name(\"SIMD_s241\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s241", "entrypoint_scalar": "s241_scalar", "entrypoint_simd": "s241_simd"}
{"task_id": "tsvc_s242_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', length 'n', and two scalars 's1', 's2'.\nIt performs a recurrence: a[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n}", "solution_scalar": "void s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2) {\n   \tfor (size_t i = 1; i < n; ++i) {\n       \ta[i] = a[i - 1] + s1 + s2 + b[i] + c[i] + d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tfloat s1 = 1.2f;\n   \tfloat s2 = 2.1f;\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s242 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts242_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n       \ts242_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s242!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s242_scalar(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\nvoid s242_simd(float *a, const float *b, const float *c, const float *d, size_t n, float s1, float s2);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t, float, float)>\nstatic void BM_s242(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tfloat s1 = 1.2f;\n   \tfloat s2 = 2.1f;\n\n   \t// Ported Initialization Logic for s242 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length, s1, s2);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 4R (a[i-1], b, c, d), 1W (a[i]). Total: 5 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s242, s242_scalar)->Name(\"Scalar_s242\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s242, s242_simd)->Name(\"SIMD_s242\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s242", "entrypoint_scalar": "s242_scalar", "entrypoint_simd": "s242_simd"}
{"task_id": "tsvc_s243_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a node-splitting task with false dependencies:\n1. a[i] = b[i] + c[i] * d[i];\n2. b[i] = a[i] + d[i] * e[i];\n3. a[i] = b[i] + a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i] = b[i] + c[i] * d[i];\n       \tb[i] = a[i] + d[i] * e[i];\n       \ta[i] = b[i] + a[i + 1] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s243 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts243_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts243_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s243!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s243_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s243_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s243(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s243 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 5R (b,c,d,e,a[i+1]), 2 R/W (a,b). Total: 9 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s243, s243_scalar)->Name(\"Scalar_s243\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s243, s243_simd)->Name(\"SIMD_s243\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s243", "entrypoint_scalar": "s243_scalar", "entrypoint_simd": "s243_simd"}
{"task_id": "tsvc_s244_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a node-splitting task with false dependencies:\n1. a[i] = b[i] + c[i] * d[i];\n2. b[i] = c[i] + b[i];\n3. a[i+1] = b[i] + a[i+1] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s244_scalar(float *a, float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; ++i) {\n       \ta[i] = b[i] + c[i] * d[i];\n       \tb[i] = c[i] + b[i];\n       \ta[i + 1] = b[i] + a[i + 1] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s244_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s244 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts244_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), length);\n       \ts244_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s244!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s244_scalar(float *a, float *b, const float *c, const float *d, size_t n);\nvoid s244_simd(float *a, float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, size_t)>\nstatic void BM_s244(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s244 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (c,d), 2 R/W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s244, s244_scalar)->Name(\"Scalar_s244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s244, s244_simd)->Name(\"SIMD_s244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s244", "entrypoint_scalar": "s244_scalar", "entrypoint_simd": "s244_simd"}
{"task_id": "tsvc_s1244_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a task with true and anti-dependencies:\n1. a[i] = b[i] + c[i] * c[i] + b[i]*b[i] + c[i];\n2. d[i] = a[i] + a[i+1];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n) {\n}", "solution_scalar": "void s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i] = b[i] + c[i] * c[i] + b[i] * b[i] + c[i];\n       \td[i] = a[i] + a[i + 1];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n);\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_initial(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> d_scalar(length), d_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1244 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_initial[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \td_scalar = d_initial;\n       \td_simd = d_initial;\n\n       \ts1244_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_scalar.data(), length);\n       \ts1244_simd(a_simd.data(), b_input.data(), c_input.data(), d_simd.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(d_scalar, d_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1244!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1244_scalar(float *a, const float *b, const float *c, float *d, size_t n);\nvoid s1244_simd(float *a, const float *b, const float *c, float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, float *, size_t)>\nstatic void BM_s1244(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_output(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> d_initial(length);\n\n   \t// Ported Initialization Logic for s1244 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \td_output = d_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_output.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 7R (b,c,c,b,c, a[i], a[i+1]), 2W (a,d). Total: 9 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1244, s1244_scalar)->Name(\"Scalar_s1244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1244, s1244_simd)->Name(\"SIMD_s1244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1244", "entrypoint_scalar": "s1244_scalar", "entrypoint_simd": "s1244_simd"}
{"task_id": "tsvc_s2244_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'e' and length 'n'.\nIt performs a node-splitting task:\n1. a[i+1] = b[i] + e[i];\n2. a[i] = b[i] + c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n) {\n}", "solution_scalar": "void s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i + 1] = b[i] + e[i];\n       \ta[i] = b[i] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n);\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2244 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts2244_scalar(a_scalar.data(), b_input.data(), c_input.data(), e_input.data(), length);\n       \ts2244_simd(a_simd.data(), b_input.data(), c_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2244!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2244_scalar(float *a, const float *b, const float *c, const float *e, size_t n);\nvoid s2244_simd(float *a, const float *b, const float *c, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s2244(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s2244 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 4R (b,e,b,c), 2W (a,a). Total: 6 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2244, s2244_scalar)->Name(\"Scalar_s2244\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2244, s2244_simd)->Name(\"SIMD_s2244\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2244", "entrypoint_scalar": "s2244_scalar", "entrypoint_simd": "s2244_simd"}
{"task_id": "tsvc_s251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a scalar expansion task:\n1. s = b[i] + c[i] * d[i];\n2. a[i] = s * s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat s = b[i] + c[i] * d[i];\n       \ta[i] = s * s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s251\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts251_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts251_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s251_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s251_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s251\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,c,d), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s251, s251_scalar)->Name(\"Scalar_s251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s251, s251_simd)->Name(\"SIMD_s251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s251", "entrypoint_scalar": "s251_scalar", "entrypoint_simd": "s251_simd"}
{"task_id": "tsvc_s1251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task:\n1. s = b[i]+c[i];\n2. b[i] = a[i]+d[i];\n3. a[i] = s*e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat s = b[i] + c[i];\n       \tb[i] = a[i] + d[i];\n       \ta[i] = s * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1251\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts1251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n s  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1251\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (b,c,a,d,e), 2W (b,a). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1251, s1251_scalar)->Name(\"Scalar_s1251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1251, s1251_simd)->Name(\"SIMD_s1251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1251", "entrypoint_scalar": "s1251_scalar", "entrypoint_simd": "s1251_simd"}
{"task_id": "tsvc_s2251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task with a loop-carried dependency:\n1. a[i] = s*e[i];\n2. s = b[i]+c[i];\n3. b[i] = a[i]+d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfloat s = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = s * e[i];\n       \ts = b[i] + c[i];\n       \tb[i] = a[i] + d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2251\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts2251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts2251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2251_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s2251_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s2251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s2251\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (e,b,c,a,d), 2W (a,b). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2251, s2251_scalar)->Name(\"Scalar_s2251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2251, s2251_simd)->Name(\"SIMD_s2251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2251", "entrypoint_scalar": "s2251_scalar", "entrypoint_simd": "s2251_simd"}
{"task_id": "tsvc_s3251_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion task with dependencies:\n1. a[i+1] = b[i]+c[i];\n2. b[i] = c[i]*e[i];\n3. d[i] = a[i]*e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \ta[i + 1] = b[i] + c[i];\n       \tb[i] = c[i] * e[i];\n       \td[i] = a[i] * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n);\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_initial(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> d_scalar(length), d_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3251 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_initial[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \td_scalar = d_initial;\n       \td_simd = d_initial;\n\n       \ts3251_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_scalar.data(), e_input.data(), length);\n       \ts3251_simd(a_simd.data(), b_simd.data(), c_input.data(), d_simd.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(d_scalar, d_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3251!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s3251_scalar(float *a, float *b, const float *c, float *d, const float *e, size_t n);\nvoid s3251_simd(float *a, float *b, const float *c, float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, float *, const float *, size_t)>\nstatic void BM_s3251(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_output(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> d_initial(length);\n\n   \t// Ported Initialization Logic for s3251 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_initial[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \td_output = d_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_output.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_output.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 6R (b,c,c,e,a,e), 3W (a,b,d). Total: 9 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3251, s3251_scalar)->Name(\"Scalar_s3251\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3251, s3251_simd)->Name(\"SIMD_s3251\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3251", "entrypoint_scalar": "s3251_scalar", "entrypoint_simd": "s3251_simd"}
{"task_id": "tsvc_s252_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a scalar expansion with a loop-carried dependency:\n1. s = b[i] * c[i];\n2. a[i] = s + t; (where t = s from previous iteration)\n3. t = s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s252_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s252_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfloat t = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat s = b[i] * c[i];\n       \ta[i] = s + t;\n       \tt = s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s252_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s252_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s252 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts252_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts252_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s252!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s252_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s252_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s252(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s252 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s252, s252_scalar)->Name(\"Scalar_s252\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s252, s252_simd)->Name(\"SIMD_s252\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s252", "entrypoint_scalar": "s252_scalar", "entrypoint_simd": "s252_simd"}
{"task_id": "tsvc_s253_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a conditional scalar expansion and update:\nif (a[i] > b[i]) { s = a[i] - b[i] * d[i]; c[i] += s; a[i] = s; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s253_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > b[i]) {\n           \tfloat s = a[i] - b[i] * d[i];\n           \tc[i] += s;\n           \ta[i] = s;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s253_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s253\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts253_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), length);\n       \ts253_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s253!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s253_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s253_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, size_t)>\nstatic void BM_s253(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s253\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_output.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 4R (a,b,c,d), 2W (c,a). Total: 6 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 6);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s253, s253_scalar)->Name(\"Scalar_s253\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s253, s253_simd)->Name(\"SIMD_s253\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s253", "entrypoint_scalar": "s253_scalar", "entrypoint_simd": "s253_simd"}
{"task_id": "tsvc_s254_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a scalar expansion with a carry-around variable:\na[i] = (b[i] + x) * 0.5f; (where x = b[i-1])\nx = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s254_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s254_scalar(float *a, const float *b, size_t n) {\n   \tfloat x = b[n - 1];\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + x) * 0.5f;\n       \tx = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s254_scalar(float *a, const float *b, size_t n);\nvoid s254_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s254\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts254_scalar(a_scalar.data(), b_input.data(), length);\n       \ts254_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s254!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s254_scalar(float *a, const float *b, size_t n);\nvoid s254_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s254(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s254\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b[i], x=b[i-1]), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s254, s254_scalar)->Name(\"Scalar_s254\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s254, s254_simd)->Name(\"SIMD_s254\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s254", "entrypoint_scalar": "s254_scalar", "entrypoint_simd": "s254_simd"}
{"task_id": "tsvc_s255_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a scalar expansion with 2-level carry-around variables:\na[i] = (b[i] + x + y) * 0.333f; (where x=b[i-1], y=b[i-2])\ny = x; x = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s255_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s255_scalar(float *a, const float *b, size_t n) {\n   \tfloat x = b[n - 1];\n   \tfloat y = b[n - 2];\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + x + y) * 0.333f;\n       \ty = x;\n       \tx = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s255_scalar(float *a, const float *b, size_t n);\nvoid s255_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s255\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts255_scalar(a_scalar.data(), b_input.data(), length);\n       \ts255_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s255!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s255_scalar(float *a, const float *b, size_t n);\nvoid s255_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s255(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s255\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b[i], x=b[i-1], y=b[i-2]), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s255, s255_scalar)->Name(\"Scalar_s255\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s255, s255_simd)->Name(\"SIMD_s255\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s255", "entrypoint_scalar": "s255_scalar", "entrypoint_simd": "s255_simd"}
{"task_id": "tsvc_s256_AVX", "prompt": "/*\nThis function tests array expansion. It takes 1D arrays 'a', 'd' and 2D arrays 'aa', 'bb'.\nInner loop: \n1. a[j] = 1.0f - a[j - 1];\n2. aa[j][i] = a[j] + bb[j][i] * d[j];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 1; j < n_2d; j++) {\n           \ta[j] = 1.0f - a[j - 1];\n           \t// aa[j][i] = a[j] + bb[j][i]*d[j]\n           \taa_flat[j * n_2d + i] = a[j] + bb_flat[j * n_2d + i] * d[j];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s256\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts256_scalar(a_scalar.data(), d_input.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n       \ts256_simd(a_simd.data(), d_input.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s256!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s256_scalar(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s256_simd(float *a, const float *d, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float *, const float *, float*, const float*, size_t, size_t)>\nstatic void BM_s256(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s256\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(a_output.data(), d_input.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop n_2d * (n_2d - 1). Ops: 1R/W(a), 1R(a[j-1]), 2R(bb,d), 1W(aa). Total: 5 accesses.\n   \tsize_t num_ops = n_2d * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s256, s256_scalar)->Name(\"Scalar_s256\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s256, s256_simd)->Name(\"SIMD_s256\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s256", "entrypoint_scalar": "s256_scalar", "entrypoint_simd": "s256_simd"}
{"task_id": "tsvc_s257_AVX", "prompt": "/*\nThis function tests array expansion. It takes 1D array 'a' and 2D arrays 'aa', 'bb'.\nInner loop: \n1. a[i] = aa[j][i] - a[i-1];\n2. aa[j][i] = a[i] + bb[j][i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 1; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \t// a[i] = aa[j][i] - a[i-1]\n           \ta[i] = aa_flat[j * n_2d + i] - a[i - 1];\n           \t// aa[j][i] = a[i] + bb[j][i]\n           \taa_flat[j * n_2d + i] = a[i] + bb_flat[j * n_2d + i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s257\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts257_scalar(a_scalar.data(), aa_scalar.data(), bb_input.data(), n_2d, n_1d);\n g     \ts257_simd(a_simd.data(), aa_simd.data(), bb_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s257!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s257_scalar(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\nvoid s257_simd(float* a, float* aa_flat, const float* bb_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, float*, const float*, size_t, size_t)>\nstatic void BM_s257(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s257\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(a_output.data(), aa_output.data(), bb_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d - 1) * n_2d. Ops: 1R/W(aa), 1R(a[i-1]), 1R(bb), 1R/W(a). Total: 5 accesses.\n   \tsize_t num_ops = (n_2d - 1) * n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s257, s257_scalar)->Name(\"Scalar_s257\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s257, s257_simd)->Name(\"SIMD_s257\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s257", "entrypoint_scalar": "s257_scalar", "entrypoint_simd": "s257_simd"}
{"task_id": "tsvc_s258_AVX", "prompt": "/*\nThis function tests a wrap-around scalar dependency under an if.\nScalar 's' is updated conditionally and used in subsequent iterations.\n1. if (a[i] > 0.) { s = d[i] * d[i]; }\n2. b[i] = s * c[i] + d[i];\n3. e[i] = (s + 1.0f) * aa[0][i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D. Loop is to n_2d\n   \tfloat s = 0.0f;\n   \tfor (size_t i = 0; i < n_2d; ++i) {\n       \tif (a[i] > 0.0f) {\n           \ts = d[i] * d[i];\n       \t}\n       \tb[i] = s * c[i] + d[i];\n       \te[i] = (s + 1.0f) * aa_flat[0 * n_2d + i]; // aa[0][i]\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> b_initial(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> e_initial(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<float> b_scalar(length_1d), b_simd(length_1d);\n   \tstd::vector<float> e_scalar(length_1d), e_simd(length_1d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s258\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_initial[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \te_scalar = e_initial;\n       \te_simd = e_initial;\n\n       \ts258_scalar(a_input.data(), b_scalar.data(), c_input.data(), d_input.data(), e_scalar.data(), aa_input.data(), n_2d, n_1d);\n       \ts258_simd(a_input.data(), b_simd.data(), c_input.data(), d_input.data(), e_simd.data(), aa_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(b_scalar, b_simd) || !allclose(e_scalar, e_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s258!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n T  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s258_scalar(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\nvoid s258_simd(const float *a, float *b, const float *c, const float *d, float *e, const float* aa_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(const float *, float *, const float *, const float *, float *, const float*, size_t, size_t)>\nstatic void BM_s258(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> b_output(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> e_output(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<float> b_initial(length_1d);\n   \tstd::vector<float> e_initial(length_1d);\n\n   \t// Ported Initialization Logic for s258\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_initial[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \te_output = e_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_output.data());\n       \tbenchmark::DoNotOptimize(aa_input.data());\n\n       \tFunc(a_input.data(), b_output.data(), c_input.data(), d_input.data(), e_output.data(), aa_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d). Ops: 5R (a, d, c, d, aa), 2W (b, e). Total: 7 accesses.\n   \tsize_t num_ops = n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s258, s258_scalar)->Name(\"Scalar_s258\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s258, s258_simd)->Name(\"SIMD_s258\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s258", "entrypoint_scalar": "s258_scalar", "entrypoint_simd": "s258_simd"}
{"task_id": "tsvc_s261_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt tests scalar variable reuse:\n1. t = a[i] + b[i];\n2. a[i] = t + c[i-1];\n3. t = c[i] * d[i];\n4. c[i] = t;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s261_scalar(float *a, const float *b, float *c, const float *d, size_t n) {\n   \tfor (size_t i = 1; i < n; ++i) {\n       \tfloat t = a[i] + b[i];\n       \ta[i] = t + c[i - 1];\n       \tt = c[i] * d[i];\n       \tc[i] = t;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s261_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s261\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts261_scalar(a_scalar.data(), b_input.data(), c_scalar.data(), d_input.data(), length);\n       \ts261_simd(a_simd.data(), b_input.data(), c_simd.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s261!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s261_scalar(float *a, const float *b, float *c, const float *d, size_t n);\nvoid s261_simd(float *a, const float *b, float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float *, const float *, size_t)>\nstatic void BM_s261(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s261\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_output.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 3R (b,c[i-1],d), 2 R/W (a,c). Total: 7 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s261, s261_scalar)->Name(\"Scalar_s261\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s261, s261_simd)->Name(\"SIMD_s261\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s261", "entrypoint_scalar": "s261_scalar", "entrypoint_simd": "s261_simd"}
{"task_id": "tsvc_s271_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple conditional operation (masked write):\nif (b[i] > 0.0f) { a[i] += b[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s271_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s271_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] > 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s271_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s271_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s271\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts271_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts271_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s271!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s271_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s271_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s271(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s271\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,a,c), 1W (a). Total: 4 accesses. (b[i] > 0 always true)\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s271, s271_scalar)->Name(\"Scalar_s271\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s271, s271_simd)->Name(\"SIMD_s271\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s271", "entrypoint_scalar": "s271_scalar", "entrypoint_simd": "s271_simd"}
{"task_id": "tsvc_s272_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', length 'n' and an int 't'.\nIt performs two conditional operations under a single check:\nif (e[i] >= t) { a[i] += c[i] * d[i]; b[i] += c[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int) {\n}", "solution_scalar": "void s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int) {\n   \tfloat t = (float)t_int;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (e[i] >= t) {\n           \ta[i] += c[i] * d[i];\n           \tb[i] += c[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint t = 1; // From tsvc.c\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n -> \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s272\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f; // e[i] >= t (1.0) is always true\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts272_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n       \ts272_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s272!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s272_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\nvoid s272_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n, int t_int);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t, int)>\nstatic void BM_s272(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n   \tint t = 1; // From tsvc.c\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s272\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f; // e[i] >= t (1.0) is always true\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length, t);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 6R (e,a,c,d,b,c), 2W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s272, s272_scalar)->Name(\"Scalar_s272\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s272, s272_simd)->Name(\"SIMD_s272\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s272", "entrypoint_scalar": "s272_scalar", "entrypoint_simd": "s272_simd"}
{"task_id": "tsvc_s273_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a dependent conditional operation:\n1. a[i] += d[i] * e[i];\n2. if (a[i] < 0.0f) { b[i] += d[i] * e[i]; }\n3. c[i] += a[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += d[i] * e[i];\n       \tif (a[i] < 0.0f)\n           \tb[i] += d[i] * e[i];\n       \tc[i] += a[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s273\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? (1.0f / (float)(i+1)) : (-1.0f / (float)(i+1)); // frac, alternating sign\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts273_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts273_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s273!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s273_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s273_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s273(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s273\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? (1.0f / (float)(i+1)) : (-1.0f / (float)(i+1)); // frac, alternating sign\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 4R(d,e,d,a), 1R/W(a), 1R/W(b), 1R/W(c) + 2R(d,e) in 'if'. ~10 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s273, s273_scalar)->Name(\"Scalar_s273\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s273, s273_simd)->Name(\"SIMD_s273\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s273", "entrypoint_scalar": "s273_scalar", "entrypoint_simd": "s273_simd"}
{"task_id": "tsvc_s274_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a complex conditional (if-then-else) operation:\n1. a[i] = c[i] + e[i] * d[i];\n2. if (a[i] > 0.0f) { b[i] = a[i] + b[i]; } else { a[i] = d[i] * e[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = c[i] + e[i] * d[i];\n       \tif (a[i] > 0.0f) {\n           \tb[i] = a[i] + b[i];\n       \t} else {\n           \ta[i] = d[i] * e[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s274\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts274_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts274_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s274!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n Type  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s274_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s274_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s274(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s274\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R(c,e,d). Blend: 2R(a,b),1W(b) OR 2R(d,e),1W(a). R/W(a), R/W(b). Total ~7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s274, s274_scalar)->Name(\"Scalar_s274\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s274, s274_simd)->Name(\"SIMD_s274\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s274", "entrypoint_scalar": "s274_scalar", "entrypoint_simd": "s274_simd"}
{"task_id": "tsvc_s275_AVX", "prompt": "/*\nThis function takes 2D float arrays 'aa', 'bb', 'cc' (flattened, row-major) of size n_2d * n_2d.\nIt performs a conditional inner loop (if around inner loop):\nif (aa[0][i] > 0.0f) { for (j=1..n_2d-1) aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tif (aa_flat[0 * n_2d + i] > 0.0f) { // aa[0][i]\n           \tfor (size_t j = 1; j < n_2d; j++) {\n             \t// aa[j][i] = aa[j-1][i] + bb[j][i] * cc[j][i]\n             \tsize_t idx_ji = j * n_2d + i;\n             \tsize_t idx_j_1_i = (j - 1) * n_2d + i;\n             \taa_flat[idx_ji] = aa_flat[idx_j_1_i] + bb_flat[idx_ji] * cc_flat[idx_ji];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s275\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tcc_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts275_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       \ts275_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s275!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s275_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s275_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s275(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s275\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tcc_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop n_2d * (n_2d - 1). Each op: 3R (aa,bb,cc), 1W (aa). (if is always true)\n   \tsize_t num_ops = n_2d * (n_2d - 1);\n   \tint64_t bytes = (int64_t(num_ops) * 4 + int64_t(n_2d)) * sizeof(float); // 4 accesses in inner, 1 in outer 'if'\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s275, s275_scalar)->Name(\"Scalar_s275\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s275, s275_simd)->Name(\"SIMD_s275\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s275", "entrypoint_scalar": "s275_scalar", "entrypoint_simd": "s275_simd"}
{"task_id": "tsvc_s2275_AVX", "prompt": "/*\nThis function is imperfectly nested. It takes 1D arrays 'a', 'b', 'c', 'd' and 2D 'aa', 'bb', 'cc'.\n1. Inner: aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i];\n2. Outer: a[i] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d) {\n}", "solution_scalar": "void s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d) {\n   \t// n_1d = LEN_1D, n_2d = LEN_2D\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \t// aa[j][i] = aa[j][i] + bb[j][i] * cc[j][i]\n           \tsize_t idx_ji = j * n_2d + i;\n           \taa_flat[idx_ji] = aa_flat[idx_ji] + bb_flat[idx_ji] * cc_flat[idx_ji];\n       \t}\n       \ta[i] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> cc_input(length_2d);\n   \tstd::vector<float> a_scalar(length_1d), a_simd(length_1d);\n   \tstd::vector<float> aa_scalar(length_2d), aa_simd(length_2d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2275\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tcc_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2275_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n       \ts2275_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), aa_simd.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2275!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2275_scalar(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\nvoid s2275_simd(float* a, const float* b, const float* c, const float* d, float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d, size_t n_1d);\n\ntemplate<void (*Func)(float*, const float*, const float*, const float*, float*, const float*, const float*, size_t, size_t)>\nstatic void BM_s2275(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t n_1d = LEN_1D;\n   \tsize_t length_1d = n_1d;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length_1d);\n   \tstd::vector<float> b_input(length_1d);\n   \tstd::vector<float> c_input(length_1d);\n   \tstd::vector<float> d_input(length_1d);\n   \tstd::vector<float> aa_output(length_2d);\n   \tstd::vector<float> bb_input(length_2d);\n   \tstd::vector<float> cc_input(length_2d);\n   \tstd::vector<float> a_initial(length_1d);\n   \tstd::vector<float> aa_initial(length_2d);\n\n   \t// Ported Initialization Logic for s2275\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tcc_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), aa_output.data(), bb_input.data(), cc_input.data(), n_2d, n_1d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Inner: n_2d*n_2d ops * 3 accesses. Outer: n_2d ops * 4 accesses.\n   \tsize_t inner_ops = n_2d * n_2d;\n   \tsize_t outer_ops = n_2d;\n   \tint64_t bytes = (int64_t(inner_ops) * 3 + int64_t(outer_ops) * 4) * sizeof(float);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * bytes);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2275, s2275_scalar)->Name(\"Scalar_s2275\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2275, s2275_simd)->Name(\"SIMD_s2275\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2275", "entrypoint_scalar": "s2275_scalar", "entrypoint_simd": "s2275_simd"}
{"task_id": "tsvc_s276_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a conditional operation based on the loop index 'i':\nif (i+1 < mid) { a[i] += b[i] * c[i]; } else { a[i] += b[i] * d[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tsize_t mid = n / 2;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (i + 1 < mid) {\n           \ta[i] += b[i] * c[i];\n       \t} else {\n           \ta[i] += b[i] * d[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s276\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts276_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts276_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s276!\" << std::endl;\n t       \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s276_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s276_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s276(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s276\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,c,d), 1 R/W(a). Total: 5 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s276, s276_scalar)->Name(\"Scalar_s276\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s276, s276_simd)->Name(\"SIMD_s276\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s276", "entrypoint_scalar": "s276_scalar", "entrypoint_simd": "s276_simd"}
{"task_id": "tsvc_s277_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs conditional operations with goto statements:\nif (a[i] >= 0.0f) goto L20;\nif (b[i] >= 0.0f) goto L30;\na[i] += c[i] * d[i];\nL30: b[i+1] = c[i] + d[i] * e[i];\nL20: ;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tif (a[i] >= 0.0f) {\n           \tgoto L20;\n       \t}\n       \tif (b[i] >= 0.0f) {\n           \tgoto L30;\n       \t}\n       \ta[i] += c[i] * d[i];\nL30:\n       \tb[i + 1] = c[i] + d[i] * e[i];\nL20:\n       \t;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s277\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = -1.0f; // Force first 'if' to fail\n           \tb_initial[i] = -1.0f; // Force second 'if' to fail\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts277_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts277_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s277!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s277_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s277_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s277(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s277\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = -1.0f; // Force first 'if' to fail\n       \tb_initial[i] = -1.0f; // Force second 'if' to fail\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Worst case (both 'if's fail): 7R (a,b,a,c,d,c,d,e), 1W (b), 1R/W(a). Total 10 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s277, s277_scalar)->Name(\"Scalar_s277\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s277, s277_simd)->Name(\"SIMD_s277\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s277", "entrypoint_scalar": "s277_scalar", "entrypoint_simd": "s277_simd"}
{"task_id": "tsvc_s278_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs an if-then-else pattern using goto:\nif (a[i] > 0.0f) goto L20;\nb[i] = -b[i] + d[i] * e[i];\ngoto L30;\nL20: c[i] = -c[i] + d[i] * e[i];\nL30: a[i] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tgoto L20;\n       \t}\n       \tb[i] = -b[i] + d[i] * e[i];\n       \tgoto L30;\nL20:\n       \tc[i] = -c[i] + d[i] * e[i];\nL30:\n       \ta[i] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s278\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts278_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts278_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s278!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s278_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s278_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s278(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s278\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 6R(a,b,d,e,b,c,d) 1W(b or c) 1R/W(a). Total ~9 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 9);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s278, s278_scalar)->Name(\"Scalar_s278\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s278, s278_simd)->Name(\"SIMD_s278\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s278", "entrypoint_scalar": "s278_scalar", "entrypoint_simd": "s278_simd"}
{"task_id": "tsvc_s279_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs complex conditional logic with gotos:\nif (a[i] > 0.0f) goto L20;\nb[i] = -b[i] + d[i] * d[i];\nif (b[i] <= a[i]) goto L30;\nc[i] += d[i] * e[i];\ngoto L30;\nL20: c[i] = -c[i] + e[i] * e[i];\nL30: a[i] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tgoto L20;\n       \t}\n       \tb[i] = -b[i] + d[i] * d[i];\n       \tif (b[i] <= a[i]) {\n           \tgoto L30;\n       \t}\n       \tc[i] += d[i] * e[i];\n       \tgoto L30;\nL20:\n       \tc[i] = -c[i] + e[i] * e[i];\nL30:\n       \ta[i] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s279\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts279_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts279_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s279!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s279_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n);\nvoid s279_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t)>\nstatic void BM_s279(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s279\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? 1.0f : -1.0f; // Test both paths\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n ->   \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Very complex, worst case ~10-12 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 12);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s279, s279_scalar)->Name(\"Scalar_s279\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s279, s279_simd)->Name(\"SIMD_s279\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s279", "entrypoint_scalar": "s279_scalar", "entrypoint_simd": "s279_simd"}
{"task_id": "tsvc_s1279_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a nested conditional operation:\nif (a[i] < 0.0f) { if (b[i] > a[i]) { c[i] += d[i] * e[i]; } }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] < 0.0f) {\n           \tif (b[i] > a[i]) {\n             \tc[i] += d[i] * e[i];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1279\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = -1.0f / (float)(i+1); // frac neg\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 pos\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts1279_scalar(a_input.data(), b_input.data(), c_scalar.data(), d_input.data(), e_input.data(), length);\n       \ts1279_simd(a_input.data(), b_input.data(), c_simd.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1279!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1279_scalar(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\nvoid s1279_simd(const float *a, const float *b, float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(const float *, const float *, float *, const float *, const float *, size_t)>\nstatic void BM_s1279(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s1279\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = -1.0f / (float)(i+1); // frac neg\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 pos\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_input.data(), b_input.data(), c_output.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (a,b,a,d,e), 1 R/W(c). Total: 7 accesses. (all ifs true)\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1279, s1279_scalar)->Name(\"Scalar_s1279\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1279, s1279_simd)->Name(\"SIMD_s1279\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1279", "entrypoint_scalar": "s1279_scalar", "entrypoint_simd": "s1279_simd"}
{"task_id": "tsvc_s2710_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', length 'n' and a scalar int 'x'.\nIt performs complex nested conditional logic:\nif (a[i] > b[i]) {\n  a[i] += b[i] * d[i];\n  if (n > 10) c[i] += d[i] * d[i]; else c[i] = d[i] * e[i] + 1.0f;\n} else {\n  b[i] = a[i] + e[i] * e[i];\n  if (x > 0) c[i] = a[i] + d[i] * d[i]; else c[i] += e[i] * e[i];\n}\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x) {\n}", "solution_scalar": "void s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > b[i]) {\n           \ta[i] += b[i] * d[i];\n           \tif (n > 10) { // This will be true for benchmark runs\n             \tc[i] += d[i] * d[i];\n           \t} else {\n             \tc[i] = d[i] * e[i] + 1.0f;\n           \t}\n       \t} else {\n           \tb[i] = a[i] + e[i] * e[i];\n           \tif (x > 0) { // This is true for the test case\n             \tc[i] = a[i] + d[i] * d[i];\n           \t} else {\n             \tc[i] += e[i] * e[i];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint x = 1; // From tsvc.c\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n   \tstd::vector<float> c_scalar(length), c_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2710\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = (i % 2 == 0) ? 1.0f : 0.5f; // Test both paths\n           \tb_initial[i] = 0.8f;\n           \tc_initial[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n       \tc_scalar = c_initial;\n       \tc_simd = c_initial;\n\n       \ts2710_scalar(a_scalar.data(), b_scalar.data(), c_scalar.data(), d_input.data(), e_input.data(), length, x);\n       \ts2710_simd(a_simd.data(), b_simd.data(), c_simd.data(), d_input.data(), e_input.data(), length, x);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd) || !allclose(c_scalar, c_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2710!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2710_scalar(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\nvoid s2710_simd(float *a, float *b, float *c, const float *d, const float *e, size_t n, int x);\n\ntemplate<void (*Func)(float *, float *, float *, const float *, const float *, size_t, int)>\nstatic void BM_s2710(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n   \tint x = 1; // From tsvc.c\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_output(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_initial(length);\n\n   \t// Ported Initialization Logic for s2710\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = (i % 2 == 0) ? 1.0f : 0.5f; // Test both paths\n       \tb_initial[i] = 0.8f;\n       \tc_initial[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tc_output = c_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_output.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_output.data(), d_input.data(), e_input.data(), length, x);\n g     \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Complex blend. ~10 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 10);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2710, s2710_scalar)->Name(\"Scalar_s2710\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2710, s2710_simd)->Name(\"SIMD_s2710\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2710", "entrypoint_scalar": "s2710_scalar", "entrypoint_simd": "s2710_simd"}
{"task_id": "tsvc_s2711_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a conditional operation (masked write):\nif (b[i] != 0.0f) { a[i] += b[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s2711_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] != 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2711_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2711\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = (float)(i % 2); // Mix of 0.0 and 1.0\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts2711_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts2711_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2711!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2711_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2711_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s2711(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s2711\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = (float)(i % 2); // Mix of 0.0 and 1.0\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,a,c), 1W (a). Total: 4 accesses (worst case).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2711, s2711_scalar)->Name(\"Scalar_s2711\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2711, s2711_simd)->Name(\"SIMD_s2711\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2711", "entrypoint_scalar": "s2711_scalar", "entrypoint_simd": "s2711_simd"}
{"task_id": "tsvc_s2712_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple conditional operation (masked write):\nif (a[i] > b[i]) { a[i] += b[i] * c[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s2712_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > b[i]) {\n           \ta[i] += b[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s2712_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2712 (same as s271 init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2 (a > b is true for i > 0)\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts2712_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts2712_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2712!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s2712_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s2712_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s2712(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s2712\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (a,b,c), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s2712, s2712_scalar)->Name(\"Scalar_s2712\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s2712, s2712_simd)->Name(\"SIMD_s2712\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2712", "entrypoint_scalar": "s2712_scalar", "entrypoint_simd": "s2712_simd"}
{"task_id": "tsvc_s281_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs an operation with a reverse-index read:\n1. x = a[n-i-1] + b[i] * c[i];\n2. a[i] = x - 1.0f;\n3. b[i] = x;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s281_simd(float *a, float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s281_scalar(float *a, float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat x = a[n - i - 1] + b[i] * c[i];\n       \ta[i] = x - 1.0f;\n       \tb[i] = x;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s281_scalar(float *a, float *b, const float *c, size_t n);\nvoid s281_simd(float *a, float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s281\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts281_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), length);\n       \ts281_simd(a_simd.data(), b_simd.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s281!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s281_scalar(float *a, float *b, const float *c, size_t n);\nvoid s281_simd(float *a, float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, size_t)>\nstatic void BM_s281(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s281\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (a_rev, b, c), 2W (a, b). Total: 5 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s281, s281_scalar)->Name(\"Scalar_s281\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s281, s281_simd)->Name(\"SIMD_s281\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s281", "entrypoint_scalar": "s281_scalar", "entrypoint_simd": "s281_simd"}
{"task_id": "tsvc_s1281_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a scalar expansion:\n1. x = b[i]*c[i] + a[i]*d[i] + e[i];\n2. a[i] = x - 1.0f;\n3. b[i] = x;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tfloat x = b[i] * c[i] + a[i] * d[i] + e[i];\n       \ta[i] = x - 1.0f;\n       \tb[i] = x;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1281 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_initial[i] = 1.0f;\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1281_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts1281_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1281!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1281_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s1281_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s1281(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1281 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_initial[i] = 1.0f;\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 5R (b,c,a,d,e), 2W (a,b). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1281, s1281_scalar)->Name(\"Scalar_s1281\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1281, s1281_simd)->Name(\"SIMD_s1281\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1281", "entrypoint_scalar": "s1281_scalar", "entrypoint_simd": "s1281_simd"}
{"task_id": "tsvc_s291_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a loop peeling / wrap-around variable task:\na[i] = (b[i] + b[im1]) * 0.5f; (where im1 = i-1, and b[-1] = b[n-1])\nim1 = i;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s291_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s291_scalar(float *a, const float *b, size_t n) {\n   \tsize_t im1 = n - 1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + b[im1]) * 0.5f;\n       \tim1 = i;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s291_scalar(float *a, const float *b, size_t n);\nvoid s291_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s291 (same as s254)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts291_scalar(a_scalar.data(), b_input.data(), length);\n       \ts291_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s291!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s291_scalar(float *a, const float *b, size_t n);\nvoid s291_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s291(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s291\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b[i], b[im1]), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s291, s291_scalar)->Name(\"Scalar_s291\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s291, s291_simd)->Name(\"SIMD_s291\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s291", "entrypoint_scalar": "s291_scalar", "entrypoint_simd": "s291_simd"}
{"task_id": "tsvc_s292_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a 2-level wrap-around variable task:\na[i] = (b[i] + b[im1] + b[im2]) * 0.333f; (im1 = i-1, im2 = i-2)\nim2 = im1; im1 = i;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s292_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s292_scalar(float *a, const float *b, size_t n) {\n   \tsize_t im1 = n - 1;\n   \tsize_t im2 = n - 2;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = (b[i] + b[im1] + b[im2]) * 0.333f;\n       \tim2 = im1;\n       \tim1 = i;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s292_scalar(float *a, const float *b, size_t n);\nvoid s292_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s292 (same as s255)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts292_scalar(a_scalar.data(), b_input.data(), length);\n       \ts292_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s292!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s292_scalar(float *a, const float *b, size_t n);\nvoid s292_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s292(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s292\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b[i], b[im1], b[im2]), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s292, s292_scalar)->Name(\"Scalar_s292\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s292, s292_simd)->Name(\"SIMD_s292\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s292", "entrypoint_scalar": "s292_scalar", "entrypoint_simd": "s292_simd"}
{"task_id": "tsvc_s293_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a broadcast operation: a[i] = a[0];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s293_simd(float *a, size_t n) {\n}", "solution_scalar": "void s293_scalar(float *a, size_t n) {\n   \tfloat a0 = a[0];\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = a0;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s293_scalar(float *a, size_t n);\nvoid s293_simd(float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s293 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts293_scalar(a_scalar.data(), length);\n       \ts293_simd(a_simd.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s293!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s293_scalar(float *a, size_t n);\nvoid s293_simd(float *a, size_t n);\n\ntemplate<void (*Func)(float *, size_t)>\nstatic void BM_s293(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s293 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n\n       \tFunc(a_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (a[0] - hoisted), 1W (a[i]). Total: 2 accesses (or 1 in loop).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s293, s293_scalar)->Name(\"Scalar_s293\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s293, s293_simd)->Name(\"SIMD_s293\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s293", "entrypoint_scalar": "s293_scalar", "entrypoint_simd": "s293_simd"}
{"task_id": "tsvc_s2101_AVX", "prompt": "/*\nThis function takes three flattened 2D float arrays 'aa', 'bb', 'cc' (row-major) of size n_2d * n_2d.\nIt performs a main diagonal operation: aa[i][i] += bb[i][i] * cc[i][i];\nThis tests strided memory access.\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n}", "solution_scalar": "void s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tsize_t idx_ii = i * n_2d + i;\n       \taa_flat[idx_ii] += bb_flat[idx_ii] * cc_flat[idx_ii];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2101\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tcc_input[i] = 1.0f;\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2101_scalar(aa_scalar.data(), bb_input.data(), cc_input.data(), n_2d);\n       \ts2101_simd(aa_simd.data(), bb_input.data(), cc_input.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2101!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2101_scalar(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\nvoid s2101_simd(float* aa_flat, const float* bb_flat, const float* cc_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s2101(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> cc_input(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s2101\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tcc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n       \tbenchmark::DoNotOptimize(cc_input.data());\n\n       \tFunc(aa_output.data(), bb_input.data(), cc_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d). Ops: 1 R/W(aa), 2R(bb,cc). Total: 4 accesses.\n   \tsize_t num_ops = n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2101, s2101_scalar)->Name(\"Scalar_s2101\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2101, s2101_simd)->Name(\"SIMD_s2101\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2101", "entrypoint_scalar": "s2101_scalar", "entrypoint_simd": "s2101_simd"}
{"task_id": "tsvc_s2102_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt creates an identity matrix by first zeroing columns, then setting the diagonal.\n1. Inner loop: aa[j][i] = 0.0f;\n2. Outer loop: aa[i][i] = 1.0f;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2102_simd(float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "void s2102_scalar(float* aa_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \taa_flat[j * n_2d + i] = 0.0f;\n       \t}\n       \taa_flat[i * n_2d + i] = 1.0f;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2102_scalar(float* aa_flat, size_t n_2d);\nvoid s2102_simd(float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2102\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 123.0f; // Fill with non-zero/one\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2102_scalar(aa_scalar.data(), n_2d);\n       \ts2102_simd(aa_simd.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2102!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2102_scalar(float* aa_flat, size_t n_2d);\nvoid s2102_simd(float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, size_t)>\nstatic void BM_s2102(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s2102\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 123.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n\n       \tFunc(aa_output.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d * n_2d) writes + n_2d writes. Total (n_2d^2 + n_2d) writes.\n   \tsize_t num_ops = (n_2d * n_2d) + n_2d;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2102, s2102_scalar)->Name(\"Scalar_s2102\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2102, s2102_simd)->Name(\"SIMD_s2102\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2102", "entrypoint_scalar": "s2102_scalar", "entrypoint_simd": "s2102_simd"}
{"task_id": "tsvc_s2111_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt performs a wavefront computation (2D recurrence):\naa[j][i] = (aa[j][i-1] + aa[j-1][i]) / 1.9f;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s2111_simd(float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "void s2111_scalar(float* aa_flat, size_t n_2d) {\n   \tfor (size_t j = 1; j < n_2d; j++) {\n       \tfor (size_t i = 1; i < n_2d; i++) {\n           \taa_flat[j * n_2d + i] = (aa_flat[j * n_2d + (i - 1)] + aa_flat[(j - 1) * n_2d + i]) / 1.9f;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s2111_scalar(float* aa_flat, size_t n_2d);\nvoid s2111_simd(float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_initial(length);\n   \tstd::vector<float> aa_scalar(length), aa_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s2111 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_initial[i] = 1.0f;\n       \t}\n       \taa_scalar = aa_initial;\n       \taa_simd = aa_initial;\n\n       \ts2111_scalar(aa_scalar.data(), n_2d);\n       \ts2111_simd(aa_simd.data(), n_2d);\n\n       \tif (!allclose(aa_scalar, aa_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s2111!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s2111_scalar(float* aa_flat, size_t n_2d);\nvoid s2111_simd(float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, size_t)>\nstatic void BM_s2111(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_output(length);\n   \tstd::vector<float> aa_initial(length);\n\n   \t// Ported Initialization Logic for s2111 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_initial[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \taa_output = aa_initial;\n       \tbenchmark::DoNotOptimize(aa_output.data());\n\n       \tFunc(aa_output.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d-1) * (n_2d-1). Ops: 2R(aa), 1W(aa). Total: 3 accesses.\n   \tsize_t num_ops = (n_2d - 1) * (n_2d - 1);\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s2111, s2111_scalar)->Name(\"Scalar_s2111\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s2111, s2111_simd)->Name(\"SIMD_s2111\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s2111", "entrypoint_scalar": "s2111_scalar", "entrypoint_simd": "s2111_simd"}
{"task_id": "tsvc_s311_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a sum reduction: sum += a[i];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s311_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s311_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s311_scalar(const float *a, size_t n);\nfloat s311_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s311\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat sum_scalar = s311_scalar(a_input.data(), length);\n       \tfloat sum_simd = s311_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s311!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s311_scalar(const float *a, size_t n);\nfloat s311_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s311(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s311\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s311, s311_scalar)->Name(\"Scalar_s311\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s311, s311_simd)->Name(\"SIMD_s311\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s311", "entrypoint_scalar": "s311_scalar", "entrypoint_simd": "s311_simd"}
{"task_id": "tsvc_s31111_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a sum reduction over the first 32 elements of 'a' using a helper.\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s31111_simd(const float *a, size_t n) {\n}", "solution_scalar": "static float test_scalar(const float* A) {\n   \tfloat s = 0.0f;\n   \tfor (int i = 0; i < 4; i++)\n     \ts += A[i];\n   \treturn s;\n}\n\nfloat s31111_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tsum += test_scalar(a);\n   \tsum += test_scalar(&a[4]);\n   \tsum += test_scalar(&a[8]);\n   \tsum += test_scalar(&a[12]);\n   \tsum += test_scalar(&a[16]);\n   \tsum += test_scalar(&a[20]);\n   \tsum += test_scalar(&a[24]);\n   \tsum += test_scalar(&a[28]);\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstatic float test_scalar(const float* A) {\n   \tfloat s = 0.0f;\n   \tfor (int i = 0; i < 4; i++)\n     \ts += A[i];\n   \treturn s;\n}\nfloat s31111_scalar(const float *a, size_t n);\nfloat s31111_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s31111\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat sum_scalar = s31111_scalar(a_input.data(), length);\n       \tfloat sum_simd = s31111_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s31111!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s31111_scalar(const float *a, size_t n);\nfloat s31111_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s31111(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s31111\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Ops: 32 Reads (8 calls * 4 reads/call)\n   \tsize_t num_ops = 32;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s31111, s31111_scalar)->Name(\"Scalar_s31111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s31111, s31111_simd)->Name(\"SIMD_s31111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s31111", "entrypoint_scalar": "s31111_scalar", "entrypoint_simd": "s31111_simd"}
{"task_id": "tsvc_s312_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a product reduction: prod *= a[i];\nImplement this using AVX intrinsics. The function should return the product.\n*/\n#include <immintrin.h>\nfloat s312_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s312_scalar(const float *a, size_t n) {\n   \tfloat prod = 1.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tprod *= a[i];\n   \t}\n   \treturn prod;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s312_scalar(const float *a, size_t n);\nfloat s312_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s312\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f + 1.0f / (float)(i+1); // 1 + frac to avoid zero/denormal\n       \t}\n\n       \tfloat prod_scalar = s312_scalar(a_input.data(), length);\n       \tfloat prod_simd = s312_simd(a_input.data(), length);\n\n       \tif (!allclose(prod_scalar, prod_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s312!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s312_scalar(const float *a, size_t n);\nfloat s312_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s312(benchmark::State& state) {\n g  \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s312\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f + 1.0f / (float)(i+1); // 1 + frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat prod = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(prod);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s312, s312_scalar)->Name(\"Scalar_s312\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s312, s312_simd)->Name(\"SIMD_s312\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s312", "entrypoint_scalar": "s312_scalar", "entrypoint_simd": "s312_simd"}
{"task_id": "tsvc_s313_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a dot product reduction: dot += a[i] * b[i];\nImplement this using AVX intrinsics. The function should return the dot product.\n*/\n#include <immintrin.h>\nfloat s313_simd(const float *a, const float *b, size_t n) {\n}", "solution_scalar": "float s313_scalar(const float *a, const float *b, size_t n) {\n   \tfloat dot = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tdot += a[i] * b[i];\n   \t}\n   \treturn dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s313_scalar(const float *a, const float *b, size_t n);\nfloat s313_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s313\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat dot_scalar = s313_scalar(a_input.data(), b_input.data(), length);\n       \tfloat dot_simd = s313_simd(a_input.data(), b_input.data(), length);\n\n       \tif (!allclose(dot_scalar, dot_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s313!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s313_scalar(const float *a, const float *b, size_t n);\nfloat s313_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_s313(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \t// Ported Initialization Logic for s313\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tfloat dot = Func(a_input.data(), b_input.data(), length);\n       \tbenchmark::DoNotOptimize(dot);\n   \t}\n   \t// Loop (n). Ops: 2R (a, b).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s313, s313_scalar)->Name(\"Scalar_s313\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s313, s313_simd)->Name(\"SIMD_s313\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s313", "entrypoint_scalar": "s313_scalar", "entrypoint_simd": "s313_simd"}
{"task_id": "tsvc_s314_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a max reduction: x = max(x, a[i]);\nImplement this using AVX intrinsics. The function should return the max value.\n*/\n#include <immintrin.h>\n#include <limits>\nfloat s314_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s314_scalar(const float *a, size_t n) {\n   \tfloat x = a[0];\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > x) {\n           \tx = a[i];\n       \t}\n   \t}\n   \treturn x;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s314_scalar(const float *a, size_t n);\nfloat s314_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s314\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat max_scalar = s314_scalar(a_input.data(), length);\n       \tfloat max_simd = s314_simd(a_input.data(), length);\n\n       \tif (!allclose(max_scalar, max_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s314!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s314_scalar(const float *a, size_t n);\nfloat s314_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s314(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s314\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat max_val = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(max_val);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s314, s314_scalar)->Name(\"Scalar_s314\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s314, s314_simd)->Name(\"SIMD_s314\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s314", "entrypoint_scalar": "s314_scalar", "entrypoint_simd": "s314_simd"}
{"task_id": "tsvc_s315_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt finds the max value and the index of that max value.\nImplement this using AVX intrinsics. The function should return a pair of {max_value, index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <utility>\nstd::pair<float, int> s315_simd(const float *a, size_t n) {\n}", "solution_scalar": "#include <utility>\nstd::pair<float, int> s315_scalar(const float *a, size_t n) {\n   \tfloat x = a[0];\n   \tint index = 0;\n   \tfor (size_t i = 0; i < n; ++i) {\n       \tif (a[i] > x) {\n           \tx = a[i];\n           \tindex = (int)i;\n       \t}\n   \t}\n   \treturn {x, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s315_scalar(const float *a, size_t n);\nstd::pair<float, int> s315_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s315\n       \tfor (size_t i = 0; i < length; ++i)\n           \ta_input[i] = (float)((i * 7) % length);\n\n       \tstd::pair<float, int> res_scalar = s315_scalar(a_input.data(), length);\n       \tstd::pair<float, int> res_simd = s315_simd(a_input.data(), length);\n\n       \tif (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s315!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s315_scalar(const float *a, size_t n);\nstd::pair<float, int> s315_simd(const float *a, size_t n);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t)>\nstatic void BM_s315(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s315\n   \tfor (size_t i = 0; i < length; ++i)\n       \ta_input[i] = (float)((i * 7) % length);\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tstd::pair<float, int> res = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s315, s315_scalar)->Name(\"Scalar_s315\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s315, s315_simd)->Name(\"SIMD_s315\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s315", "entrypoint_scalar": "s315_scalar", "entrypoint_simd": "s315_simd"}
{"task_id": "tsvc_s316_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a min reduction: x = min(x, a[i]);\nImplement this using AVX intrinsics. The function should return the min value.\n*/\n#include <immintrin.h>\n#include <limits>\nfloat s316_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s316_scalar(const float *a, size_t n) {\n   \tfloat x = a[0];\n   \tfor (size_t i = 1; i < n; ++i) {\n       \tif (a[i] < x) {\n           \tx = a[i];\n       \t}\n   \t}\n   \treturn x;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s316_scalar(const float *a, size_t n);\nfloat s316_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s316 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat min_scalar = s316_scalar(a_input.data(), length);\n       \tfloat min_simd = s316_simd(a_input.data(), length);\n\n       \tif (!allclose(min_scalar, min_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s316!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s316_scalar(const float *a, size_t n);\nfloat s316_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s316(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s316 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat min_val = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(min_val);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s316, s316_scalar)->Name(\"Scalar_s316\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s316, s316_simd)->Name(\"SIMD_s316\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s316", "entrypoint_scalar": "s316_scalar", "entrypoint_simd": "s316_simd"}
{"task_id": "tsvc_s317_AVX", "prompt": "/*\nThis function takes length 'n' (n/2 iterations).\nIt performs a product reduction of a constant: q *= 0.99f;\nImplement this using AVX intrinsics. The function should return the product.\n*/\n#include <immintrin.h>\n#include <cmath>\nfloat s317_simd(size_t n) {\n}", "solution_scalar": "float s317_scalar(size_t n) {\n   \tfloat q = 1.0f;\n   \tfor (size_t i = 0; i < n / 2; i++) {\n       \tq *= 0.99f;\n   \t}\n   \treturn q;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s317_scalar(size_t n);\nfloat s317_simd(size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \tfloat prod_scalar = s317_scalar(length);\n       \tfloat prod_simd = s317_simd(length);\n\n       \tif (!allclose(prod_scalar, prod_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s317!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s317_scalar(size_t n);\nfloat s317_simd(size_t n);\n\ntemplate<float (*Func)(size_t)>\nstatic void BM_s317(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tfor (auto _ : state) {\n       \tfloat prod = Func(length);\n       \tbenchmark::DoNotOptimize(prod);\n   \t}\n   \t// Loop (n/2). No memory ops.\n   \tstate.SetBytesProcessed(0);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s317, s317_scalar)->Name(\"Scalar_s317\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s317, s317_simd)->Name(\"SIMD_s317\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s317", "entrypoint_scalar": "s317_scalar", "entrypoint_simd": "s317_simd"}
{"task_id": "tsvc_s318_AVX", "prompt": "/*\nThis function takes a float array 'a', length 'n', and an increment 'inc'.\nIt performs an ISAMAX (index of max absolute value) reduction with a stride 'inc'.\nImplement this using AVX intrinsics. The function should return a pair of {max_abs_value, index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <cmath>\n#include <utility>\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc) {\n}", "solution_scalar": "#include <cmath>\n#include <utility>\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc) {\n   \tint k = 0;\n   \tint index = 0;\n   \tfloat max = std::abs(a[0]);\n   \tk += inc;\n   \tfor (size_t i = 1; i < n; i++) {\n       \tif (std::abs(a[k]) > max) {\n           \tindex = (int)i;\n           \tmax = std::abs(a[k]);\n       \t}\n       \tk += inc;\n   \t}\n   \treturn {max, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc);\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint inc = 1; // From tsvc.c\n\n   \tstd::vector<float> a_input(length * inc); // Ensure enough space for max index\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s318\n       \tfor (size_t i = 0; i < a_input.size(); ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \t// Ensure a negative value is present\n       \tif (length > 10) a_input[10] = -2.0f;\n\n       \tstd::pair<float, int> res_scalar = s318_scalar(a_input.data(), length, inc);\n       \tstd::pair<float, int> res_simd = s318_simd(a_input.data(), length, inc);\n\n       \tif (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s318!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s318_scalar(const float *a, size_t n, int inc);\nstd::pair<float, int> s318_simd(const float *a, size_t n, int inc);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t, int)>\nstatic void BM_s318(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint inc = 1; // From tsvc.c\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length * inc + 1);\n\n   \t// Ported Initialization Logic for s318\n   \tfor (size_t i = 0; i < a_input.size(); ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (length > 10) a_input[10] = -2.0f;\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tstd::pair<float, int> res = Func(a_input.data(), length, inc);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n-1). Ops: 1R (a[k]).\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s318, s318_scalar)->Name(\"Scalar_s318\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s318, s318_simd)->Name(\"SIMD_s318\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s318", "entrypoint_scalar": "s318_scalar", "entrypoint_simd": "s318_simd"}
{"task_id": "tsvc_s319_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a coupled reduction:\n1. a[i] = c[i] + d[i];\n2. sum += a[i];\n3. b[i] = c[i] + e[i];\n4. sum += b[i];\nImplement this using AVX intrinsics. The function should return the final sum.\n*/\n#include <immintrin.h>\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "float s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = c[i] + d[i];\n       \tsum += a[i];\n       \tb[i] = c[i] + e[i];\n       \tsum += b[i];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s319\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_initial[i] = 0.0f;\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \tfloat sum_scalar = s319_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \tfloat sum_simd = s319_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd) || !allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s319!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s319_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nfloat s319_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<float (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s319(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s319\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_initial[i] = 0.0f;\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tfloat sum = Func(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 6R (c,d,a,c,e,b), 2W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s319, s319_scalar)->Name(\"Scalar_s319\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s319, s319_simd)->Name(\"SIMD_s319\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s319", "entrypoint_scalar": "s319_scalar", "entrypoint_simd": "s319_simd"}
{"task_id": "tsvc_s3110_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt finds the max value and its 2D indices (xindex, yindex).\nImplement this using AVX intrinsics. The function should return a tuple of {max_value, x_index, y_index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <tuple>\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "#include <tuple>\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d) {\n   \tfloat max = aa_flat[0]; // aa[0][0]\n   \tint xindex = 0;\n   \tint yindex = 0;\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \tfloat val = aa_flat[i * n_2d + j];\n           \tif (val > max) {\n             \tmax = val;\n             \txindex = (int)i;\n             \tyindex = (int)j;\n           \t}\n       \t}\n   \t}\n   \treturn std::make_tuple(max, xindex, yindex);\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3110 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \t// Ensure a specific max value\n       \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n \n       \tstd::tuple<float, int, int> res_scalar = s3110_scalar(aa_input.data(), n_2d);\n       \tstd::tuple<float, int, int> res_simd = s3110_simd(aa_input.data(), n_2d);\n\n       \tif (!allclose(std::get<0>(res_scalar), std::get<0>(res_simd)) || \n           \tstd::get<1>(res_scalar) != std::get<1>(res_simd) || \n           \tstd::get<2>(res_scalar) != std::get<2>(res_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3110!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <tuple>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nstd::tuple<float, int, int> s3110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s3110_simd(const float* aa_flat, size_t n_2d);\n\ntemplate<std::tuple<float, int, int> (*Func)(const float*, size_t)>\nstatic void BM_s3110(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_input(length);\n\n   \t// Ported Initialization Logic for s3110 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tstd::tuple<float, int, int> res = Func(aa_input.data(), n_2d);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n_2d * n_2d). Ops: 1R (aa).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s3110, s3110_scalar)->Name(\"Scalar_s3110\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s3110, s3110_simd)->Name(\"SIMD_s3110\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3110", "entrypoint_scalar": "s3110_scalar", "entrypoint_simd": "s3110_simd"}
{"task_id": "tsvc_s13110_AVX", "prompt": "/*\nThis function takes a flattened 2D float array 'aa' (row-major) of size n_2d * n_2d.\nIt finds the max value and its 2D indices (xindex, yindex). (Identical to s3110)\nImplement this using AVX intrinsics. The function should return a tuple of {max_value, x_index, y_index}.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <tuple>\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "#include <tuple>\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d) {\n   \tfloat max = aa_flat[0]; // aa[0][0]\n   \tint xindex = 0;\n   \tint yindex = 0;\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \tfloat val = aa_flat[i * n_2d + j];\n           \tif (val > max) {\n             \tmax = val;\n             \txindex = (int)i;\n             \tyindex = (int)j;\n           \t}\n       \t}\n   \t}\n   \treturn std::make_tuple(max, xindex, yindex);\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> aa_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s13110 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \t// Ensure a specific max value\n       \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n \n       \tstd::tuple<float, int, int> res_scalar = s13110_scalar(aa_input.data(), n_2d);\n       \tstd::tuple<float, int, int> res_simd = s13110_simd(aa_input.data(), n_2d);\n\n       \tif (!allclose(std::get<0>(res_scalar), std::get<0>(res_simd)) || \n           \tstd::get<1>(res_scalar) != std::get<1>(res_simd) || \n           \tstd::get<2>(res_scalar) != std::get<2>(res_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s13110!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <tuple>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nstd::tuple<float, int, int> s13110_scalar(const float* aa_flat, size_t n_2d);\nstd::tuple<float, int, int> s13110_simd(const float* aa_flat, size_t n_2d);\n\ntemplate<std::tuple<float, int, int> (*Func)(const float*, size_t)>\nstatic void BM_s13110(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> aa_input(length);\n\n   \t// Ported Initialization Logic for s13110 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (n_2d > 10) aa_input[5 * n_2d + 10] = 2.0f; // aa[5][10]\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tstd::tuple<float, int, int> res = Func(aa_input.data(), n_2d);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n_2d * n_2d). Ops: 1R (aa).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s13110, s13110_scalar)->Name(\"Scalar_s13110\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s13110, s13110_simd)->Name(\"SIMD_s13110\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s13110", "entrypoint_scalar": "s13110_scalar", "entrypoint_simd": "s13110_simd"}
{"task_id": "tsvc_s3111_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a conditional sum reduction: if (a[i] > 0.0f) { sum += a[i]; }\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s3111_simd(const float *a, size_t n) {\n}", "solution_scalar": "float s3111_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tsum += a[i];\n       \t}\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3111_scalar(const float *a, size_t n);\nfloat s3111_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3111\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \t}\n\n       \tfloat sum_scalar = s3111_scalar(a_input.data(), length);\n       \tfloat sum_simd = s3111_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3111!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3111_scalar(const float *a, size_t n);\nfloat s3111_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s3111(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s3111\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3111, s3111_scalar)->Name(\"Scalar_s3111\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3111, s3111_simd)->Name(\"SIMD_s3111\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3111", "entrypoint_scalar": "s3111_scalar", "entrypoint_simd": "s3111_simd"}
{"task_id": "tsvc_s3112_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a sum reduction while saving the running sum to 'b':\n1. sum += a[i];\n2. b[i] = sum;\nImplement this using AVX intrinsics. The function should return the final sum.\n*/\n#include <immintrin.h>\nfloat s3112_simd(const float *a, float *b, size_t n) {\n}", "solution_scalar": "float s3112_scalar(const float *a, float *b, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i];\n       \tb[i] = sum;\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3112_scalar(const float *a, float *b, size_t n);\nfloat s3112_simd(const float *a, float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3112\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 0.0f;\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \tfloat sum_scalar = s3112_scalar(a_input.data(), b_scalar.data(), length);\n       \tfloat sum_simd = s3112_simd(a_input.data(), b_simd.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3112!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3112_scalar(const float *a, float *b, size_t n);\nfloat s3112_simd(const float *a, float *b, size_t n);\n\ntemplate<float (*Func)(const float *, float *, size_t)>\nstatic void BM_s3112(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s3112\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 0.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n\n       \tfloat sum = Func(a_input.data(), b_output.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a), 1W (b).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3112, s3112_scalar)->Name(\"Scalar_s3112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3112, s3112_simd)->Name(\"SIMD_s3112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3112", "entrypoint_scalar": "s3112_scalar", "entrypoint_simd": "s3112_simd"}
{"task_id": "tsvc_s3113_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a max absolute value reduction: max = max(max, abs(a[i]));\nImplement this using AVX intrinsics. The function should return the max absolute value.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <cmath>\nfloat s3113_simd(const float *a, size_t n) {\n}", "solution_scalar": "#include <cmath>\nfloat s3113_scalar(const float *a, size_t n) {\n   \tfloat max = std::abs(a[0]);\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (std::abs(a[i]) > max) {\n           \tmax = std::abs(a[i]);\n       \t}\n   \t}\n   \treturn max;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s3113_scalar(const float *a, size_t n);\nfloat s3113_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s3113 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tif (length > 10) a_input[10] = -2.0f; // Add a negative value\n\n       \tfloat max_scalar = s3113_scalar(a_input.data(), length);\n       \tfloat max_simd = s3113_simd(a_input.data(), length);\n\n       \tif (!allclose(max_scalar, max_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s3113!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s3113_scalar(const float *a, size_t n);\nfloat s3113_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_s3113(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s3113 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tif (length > 10) a_input[10] = -2.0f; // Add a negative value\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat max_val = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(max_val);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s3113, s3113_scalar)->Name(\"Scalar_s3113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s3113, s3113_simd)->Name(\"SIMD_s3113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s3113", "entrypoint_scalar": "s3113_scalar", "entrypoint_simd": "s3113_simd"}
{"task_id": "tsvc_s321_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a first-order linear recurrence: a[i] += a[i-1] * b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s321_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s321_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 1; i < n; i++) {\n       \ta[i] += a[i - 1] * b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s321_scalar(float *a, const float *b, size_t n);\nvoid s321_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s321\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts321_scalar(a_scalar.data(), b_input.data(), length);\n       \ts321_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s321!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s321_scalar(float *a, const float *b, size_t n);\nvoid s321_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s321(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s321\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 1 R/W(a), 1R(a[i-1]), 1R(b). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s321, s321_scalar)->Name(\"Scalar_s321\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s321, s321_simd)->Name(\"SIMD_s321\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s321", "entrypoint_scalar": "s321_scalar", "entrypoint_simd": "s321_simd"}
{"task_id": "tsvc_s322_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a second-order linear recurrence:\na[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s322_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s322_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 2; i < n; i++) {\n       \ta[i] = a[i] + a[i - 1] * b[i] + a[i - 2] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s322_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s322_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s322\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts322_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts322_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s322!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s322_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s322_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s322(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s322\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-2). Ops: 1 R/W(a), 2R(a), 2R(b,c). Total: 5 accesses.\n   \tsize_t num_ops = length - 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 5);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s322, s322_scalar)->Name(\"Scalar_s322\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s322, s322_simd)->Name(\"SIMD_s322\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s322", "entrypoint_scalar": "s322_scalar", "entrypoint_simd": "s322_simd"}
{"task_id": "tsvc_s323_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e' and length 'n'.\nIt performs a coupled recurrence:\n1. a[i] = b[i-1] + c[i] * d[i];\n2. b[i] = a[i] + c[i] * e[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 1; i < n; i++) {\n       \ta[i] = b[i - 1] + c[i] * d[i];\n       \tb[i] = a[i] + c[i] * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s323\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts323_scalar(a_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts323_simd(a_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s323!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s323_scalar(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s323_simd(float *a, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s323(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s323\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(a_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 6R (b,c,d,a,c,e), 2W (a,b). Total: 8 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 8);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s323, s323_scalar)->Name(\"Scalar_s323\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s323, s323_simd)->Name(\"SIMD_s323\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s323", "entrypoint_scalar": "s323_scalar", "entrypoint_simd": "s323_simd"}
{"task_id": "tsvc_s331_AVX", "prompt": "/*\nThis function takes a float array 'a' and length 'n'.\nIt performs a search loop to find the *last* index i where a[i] < 0.\nImplement this using AVX intrinsics. The function should return the last index found, or -1.\n*/\n#include <immintrin.h>\n#include <limits>\nint s331_simd(const float *a, size_t n) {\n}", "solution_scalar": "int s331_scalar(const float *a, size_t n) {\n   \tint j = -1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] < 0.0f) {\n           \tj = (int)i;\n       \t}\n   \t}\n   \treturn j;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nint s331_scalar(const float *a, size_t n);\nint s331_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s331\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 0.5f - (float)i; // Will be negative for i > 0\n       \t}\n       \tif (length > 0) a_input[0] = 1.0f; // Ensure first is not negative\n\n       \tint j_scalar = s331_scalar(a_input.data(), length);\n       \tint j_simd = s331_simd(a_input.data(), length);\n\n       \tif (j_scalar != j_simd) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s331!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nint s331_scalar(const float *a, size_t n);\nint s331_simd(const float *a, size_t n);\n\ntemplate<int (*Func)(const float *, size_t)>\nstatic void BM_s331(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s331\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 0.5f - (float)i; // Will be negative for i > 0\n   \t}\n   \tif (length > 0) a_input[0] = 1.0f;\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tint j = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(j);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s331, s331_scalar)->Name(\"Scalar_s331\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s331, s331_simd)->Name(\"SIMD_s331\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s331", "entrypoint_scalar": "s331_scalar", "entrypoint_simd": "s331_simd"}
{"task_id": "tsvc_s332_AVX", "prompt": "/*\nThis function takes a float array 'a', length 'n', and a threshold 't'.\nIt finds the *first* value and index where a[i] > t.\nImplement this using AVX intrinsics. The function should return a pair of {value, index}.\nReturns {-1.0f, -2} if not found.\n*/\n#include <immintrin.h>\n#include <limits>\n#include <utility>\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int) {\n}", "solution_scalar": "#include <utility>\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int) {\n   \tfloat t = (float)t_int;\n   \tint index = -2;\n   \tfloat value = -1.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > t) {\n           \tindex = (int)i;\n           \tvalue = a[i];\n           \tbreak;\n       \t}\n   \t}\n   \treturn {value, index};\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n#include <utility>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int);\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint t = (int)(length / 2); // Set threshold t\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s332\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = (float)i;\n       \t}\n\n       \tstd::pair<float, int> res_scalar = s332_scalar(a_input.data(), length, t);\n       \tstd::pair<float, int> res_simd = s332_simd(a_input.data(), length, t);\n\n       \tif (!allclose(res_scalar.first, res_simd.first) || res_scalar.second != res_simd.second) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s332!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <utility>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nstd::pair<float, int> s332_scalar(const float *a, size_t n, int t_int);\nstd::pair<float, int> s332_simd(const float *a, size_t n, int t_int);\n\ntemplate<std::pair<float, int> (*Func)(const float *, size_t, int)>\nstatic void BM_s332(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint t = (int)(length / 2);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for s332\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = (float)i;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tstd::pair<float, int> res = Func(a_input.data(), length, t);\n       \tbenchmark::DoNotOptimize(res);\n   \t}\n   \t// Loop (n). Ops: 1R (a). (Breaks early, but n is worst-case).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s332, s332_scalar)->Name(\"Scalar_s332\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s332, s332_simd)->Name(\"SIMD_s332\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s332", "entrypoint_scalar": "s332_scalar", "entrypoint_simd": "s332_simd"}
{"task_id": "tsvc_s341_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a pack operation (compresses 'b' into 'a'):\nif (b[i] > 0.0f) { a[j++] = b[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s341_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s341_scalar(float *a, const float *b, size_t n) {\n   \tint j = -1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] > 0.0f) {\n           \tj++;\n           \ta[j] = b[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s341_scalar(float *a, const float *b, size_t n);\nvoid s341_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s341\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts341_scalar(a_scalar.data(), b_input.data(), length);\n       \ts341_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s341!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s341_scalar(float *a, const float *b, size_t n);\nvoid s341_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s341(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s341\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (b), 1W (a) (since if is always true). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s341, s341_scalar)->Name(\"Scalar_s341\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s341, s341_simd)->Name(\"SIMD_s341\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s341", "entrypoint_scalar": "s341_scalar", "entrypoint_simd": "s341_simd"}
{"task_id": "tsvc_s342_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an unpack operation (scatters 'b' into 'a'):\nif (a[i] > 0.0f) { a[i] = b[j++]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s342_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s342_scalar(float *a, const float *b, size_t n) {\n   \tint j = -1;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (a[i] > 0.0f) {\n           \tj++;\n           \ta[i] = b[j];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s342_scalar(float *a, const float *b, size_t n);\nvoid s342_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s342\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts342_scalar(a_scalar.data(), b_input.data(), length);\n       \ts342_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s342!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s342_scalar(float *a, const float *b, size_t n);\nvoid s342_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s342(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s342\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(a), 1R(b), 1W(a) (since if is always true). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s342, s342_scalar)->Name(\"Scalar_s342\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s342, s342_simd)->Name(\"SIMD_s342\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s342", "entrypoint_scalar": "s342_scalar", "entrypoint_simd": "s342_simd"}
{"task_id": "tsvc_s343_AVX", "prompt": "/*\nThis function packs a 2D array 'aa' into a 1D array 'flat_2d_array'.\nIt packs elements from 'aa' where 'bb' is positive.\nif (bb[j][i] > 0.0f) { flat_2d_array[k++] = aa[j][i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n}", "solution_scalar": "void s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d) {\n   \tint k = -1;\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfor (size_t j = 0; j < n_2d; j++) {\n           \tif (bb_flat[j * n_2d + i] > 0.0f) {\n             \tk++;\n             \tflat_2d_array[k] = aa_flat[j * n_2d + i];\n           \t}\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_2D LEN_2D\n\nvoid s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length = n_2d * n_2d;\n\n   \tstd::vector<float> flat_initial(length);\n   \tstd::vector<float> aa_input(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> flat_scalar(length), flat_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s343\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tflat_initial[i] = 0.0f;\n           \taa_input[i] = 1.0f / (float)(i+1); // frac\n           \tbb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts343_scalar(flat_scalar.data(), aa_input.data(), bb_input.data(), n_2d);\n       \ts343_simd(flat_simd.data(), aa_input.data(), bb_input.data(), n_2d);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s343!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid s343_scalar(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\nvoid s343_simd(float* flat_2d_array, const float* aa_flat, const float* bb_flat, size_t n_2d);\n\ntemplate<void (*Func)(float*, const float*, const float*, size_t)>\nstatic void BM_s343(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length = n_2d * n_2d;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length);\n   \tstd::vector<float> aa_input(length);\n   \tstd::vector<float> bb_input(length);\n   \tstd::vector<float> flat_initial(length);\n\n   \t// Ported Initialization Logic for s343\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tflat_initial[i] = 0.0f;\n       \taa_input[i] = 1.0f / (float)(i+1); // frac\n       \tbb_input[i] = 1.0f / (float)(i+1); // frac (all > 0)\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tbenchmark::DoNotOptimize(bb_input.data());\n\n       \tFunc(flat_output.data(), aa_input.data(), bb_input.data(), n_2d);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d*n_2d). Ops: 2R(bb,aa), 1W(flat) (since if is always true). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s343, s343_scalar)->Name(\"Scalar_s343\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s343, s343_simd)->Name(\"SIMD_s343\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s343", "entrypoint_scalar": "s343_scalar", "entrypoint_simd": "s343_simd"}
{"task_id": "tsvc_s351_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs an unrolled SAXPY operation (loop rerolling).\na[i+k] += alpha * b[i+k]; for k=0..4\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s351_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s351_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfloat alpha = c[0];\n   \tfor (size_t i = 0; i < n; i += 5) {\n       \ta[i] += alpha * b[i];\n       \ta[i + 1] += alpha * b[i + 1];\n       \ta[i + 2] += alpha * b[i + 2];\n       \ta[i + 3] += alpha * b[i + 3];\n       \ta[i + 4] += alpha * b[i + 4];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s351_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s351\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts351_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts351_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s351!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s351_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s351(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s351\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n/5) blocks. 5 ops * (1R/W(a), 1R(b)) = 15 accesses. Total n*3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s351, s351_scalar)->Name(\"Scalar_s351\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s351, s351_simd)->Name(\"SIMD_s351\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s351", "entrypoint_scalar": "s351_scalar", "entrypoint_simd": "s351_simd"}
{"task_id": "tsvc_s1351_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a simple vector add: a[i] = b[i] + c[i];\nThis tests induction pointer recognition (A++, B++, C++).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s1351_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1351\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts1351_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts1351_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1351!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1351_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s1351_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s1351(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s1351\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1351, s1351_scalar)->Name(\"Scalar_s1351\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1351, s1351_simd)->Name(\"SIMD_s1351\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1351", "entrypoint_scalar": "s1351_scalar", "entrypoint_simd": "s1351_simd"}
{"task_id": "tsvc_s352_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an unrolled dot product reduction (loop rerolling).\ndot += a[i]*b[i] + ... + a[i+4]*b[i+4];\nImplement this using AVX intrinsics. The function should return the dot product.\n*/\n#include <immintrin.h>\nfloat s352_simd(const float *a, const float *b, size_t n) {\n}", "solution_scalar": "float s352_scalar(const float *a, const float *b, size_t n) {\n   \tfloat dot = 0.0f;\n   \tfor (size_t i = 0; i < n; i += 5) {\n       \tdot = dot + a[i] * b[i] + a[i + 1] * b[i + 1] + a[i + 2]\n             * b[i + 2] + a[i + 3] * b[i + 3] + a[i + 4] * b[i + 4];\n   \t}\n   \treturn dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s352_scalar(const float *a, const float *b, size_t n);\nfloat s352_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s352 (same as s313)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat dot_scalar = s352_scalar(a_input.data(), b_input.data(), length);\n       \tfloat dot_simd = s352_simd(a_input.data(), b_input.data(), length);\n\n       \tif (!allclose(dot_scalar, dot_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s352!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s352_scalar(const float *a, const float *b, size_t n);\nfloat s352_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_s352(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \t// Ported Initialization Logic for s352 (same as s313)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tfloat dot = Func(a_input.data(), b_input.data(), length);\n       \tbenchmark::DoNotOptimize(dot);\n   \t}\n   \t// Loop (n/5) blocks. 5 ops * 2R = 10R per block. Total n*2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s352, s352_scalar)->Name(\"Scalar_s352\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s352, s352_simd)->Name(\"SIMD_s352\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s352", "entrypoint_scalar": "s352_scalar", "entrypoint_simd": "s352_simd"}
{"task_id": "tsvc_s353_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and an int array 'ip' (indices).\nIt performs an unrolled sparse SAXPY (a gather operation).\na[i+k] += alpha * b[ip[i+k]]; for k=0..4\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n) {\n}", "solution_scalar": "void s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n) {\n   \tfloat alpha = c[0];\n   \tfor (size_t i = 0; i < n; i += 5) {\n       \ta[i] += alpha * b[ip[i]];\n       \ta[i + 1] += alpha * b[ip[i + 1]];\n       \ta[i + 2] += alpha * b[ip[i + 2]];\n       \ta[i + 3] += alpha * b[ip[i + 3]];\n       \ta[i + 4] += alpha * b[ip[i + 4]];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n);\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s353\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts353_scalar(a_scalar.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       \ts353_simd(a_simd.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s353!\" << std::endl;\n Next         \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s353_scalar(float *a, const float *b, const float *c, const int *ip, size_t n);\nvoid s353_simd(float *a, const float *b, const float *c, const int *ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const int *, size_t)>\nstatic void BM_s353(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s353\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n _simd     \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n/5) blocks. 5 ops * (1R/W(a) + 1R(b) + 1R(ip)) = 15 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * (sizeof(float)*2 + sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s353, s353_scalar)->Name(\"Scalar_s353\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s353, s353_simd)->Name(\"SIMD_s353\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s353", "entrypoint_scalar": "s353_scalar", "entrypoint_simd": "s353_simd"}
{"task_id": "tsvc_s421_AVX", "prompt": "/*\nThis function takes a 1D float array 'a' and a 1D float array 'flat_2d_array'.\nIt performs a recurrence: flat_2d_array[i] = flat_2d_array[i+1] + a[i];\n(Based on xx = flat_2d_array, yy = xx, xx[i] = yy[i+1] + a[i])\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s421_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \t// Original: xx = flat_2d_array, yy = xx. Loop: xx[i] = yy[i+1] + a[i]\n   \t// This simplifies to: flat_2d_array[i] = flat_2d_array[i+1] + a[i]\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tflat_2d_array[i] = flat_2d_array[i + 1] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s421_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> flat_initial(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length), flat_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s421\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tflat_initial[i] = 1.0f;\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts421_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts421_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s421!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s421_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s421_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s421(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length);\n\n   \t// Ported Initialization Logic for s421\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tflat_initial[i] = 1.0f;\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (flat[i+1], a[i]), 1W (flat[i]). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s421, s421_scalar)->Name(\"Scalar_s421\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s421, s421_simd)->Name(\"SIMD_s421\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s421", "entrypoint_scalar": "s421_scalar", "entrypoint_simd": "s421_simd"}
{"task_id": "tsvc_s1421_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs an operation with aliased pointers:\nb[i] = xx[i] + a[i]; (where xx = &b[n/2])\nThis simplifies to: b[i] = b[n/2 + i] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s1421_simd(float *b, const float *a, size_t n) {\n}", "solution_scalar": "void s1421_scalar(float *b, const float *a, size_t n) {\n   \t// Original: xx = &b[n/2]. Loop: b[i] = xx[i] + a[i]\n   \tsize_t half_n = n / 2;\n   \tfor (size_t i = 0; i < half_n; i++) {\n       \tb[i] = b[half_n + i] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s1421_scalar(float *b, const float *a, size_t n);\nvoid s1421_simd(float *b, const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s1421\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts1421_scalar(b_scalar.data(), a_input.data(), length);\n       \ts1421_simd(b_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s1421!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s1421_scalar(float *b, const float *a, size_t n);\nvoid s1421_simd(float *b, const float *a, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s1421(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s1421\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_initial[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n\n       \tFunc(b_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n/2). Ops: 2R (b[half+i], a[i]), 1W (b[i]). Total: 3 accesses.\n   \tsize_t num_ops = length / 2;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s1421, s1421_scalar)->Name(\"Scalar_s1421\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s1421, s1421_simd)->Name(\"SIMD_s1421\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s1421", "entrypoint_scalar": "s1421_scalar", "entrypoint_simd": "s1421_simd"}
{"task_id": "tsvc_s422_AVX", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', and length 'n'.\nIt performs an operation with aliased pointers and offsets:\nxx = flat_2d_array + 4; xx[i] = flat_2d_array[i + 8] + a[i];\nThis simplifies to: flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s422_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \t// Original: xx = flat_2d_array + 4. Loop: xx[i] = flat_2d_array[i + 8] + a[i]\n   \t// This simplifies to: flat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i]\n   \tfor (size_t i = 0; i < n; i++) {\n       \tflat_2d_array[i + 4] = flat_2d_array[i + 8] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s422_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> flat_initial(length + 8); // Ensure space for offsets\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length + 8), flat_simd(length + 8);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s422\n       \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n           \tflat_initial[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts422_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts422_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s422!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s422_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s422_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s422(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length + 8);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length + 8);\n\n   \t// Ported Initialization Logic for s422\n   \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n       \tflat_initial[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (flat[i+8], a[i]), 1W (flat[i+4]). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s422, s422_scalar)->Name(\"Scalar_s422\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s422, s422_simd)->Name(\"SIMD_s422\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s422", "entrypoint_scalar": "s422_scalar", "entrypoint_simd": "s422_simd"}
{"task_id": "tsvc_s423_AVX", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', length 'n', and 'vl' (offset).\nIt performs an operation with aliased pointers and offsets:\nxx = flat_2d_array + vl; flat_2d_array[i+1] = xx[i] + a[i]; (vl=64)\nThis simplifies to: flat_2d_array[i+1] = flat_2d_array[i + 64] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s423_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \tint vl = 64;\n   \t// Original: xx = flat_2d_array + vl. Loop: flat_2d_array[i+1] = xx[i] + a[i]\n   \t// This simplifies to: flat_2d_array[i + 1] = flat_2d_array[i + vl] + a[i]\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tflat_2d_array[i + 1] = flat_2d_array[i + vl] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s423_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint vl = 64;\n\n   \tstd::vector<float> flat_initial(length + vl); // Ensure space for offsets\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length + vl), flat_simd(length + vl);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s423\n       \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n           \tflat_initial[i] = 1.0f;\n       \t}\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts423_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts423_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s423!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s423_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s423_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s423(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint vl = 64;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length + vl);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length + vl);\n\n   \t// Ported Initialization Logic for s423\n   \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n       \tflat_initial[i] = 1.0f;\n   \t}\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (flat[i+vl], a[i]), 1W (flat[i+1]). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s423, s423_scalar)->Name(\"Scalar_s423\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s423, s423_simd)->Name(\"SIMD_s423\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s423", "entrypoint_scalar": "s423_scalar", "entrypoint_simd": "s423_simd"}
{"task_id": "tsvc_s424_AVX", "prompt": "/*\nThis function takes 'flat_2d_array', 'a', length 'n', and 'vl' (offset).\nIt performs a recurrence with aliased pointers:\nxx = flat_2d_array + vl; xx[i+1] = flat_2d_array[i] + a[i]; (vl=63)\nThis simplifies to: flat_2d_array[i + 64] = flat_2d_array[i] + a[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n) {\n}", "solution_scalar": "void s424_scalar(float* flat_2d_array, const float* a, size_t n) {\n   \tint vl = 63;\n   \t// Original: xx = flat_2d_array + vl. Loop: xx[i+1] = flat_2d_array[i] + a[i]\n   \t// This simplifies to: flat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i]\n   \tfor (size_t i = 0; i < n - 1; i++) {\n       \tflat_2d_array[i + 1 + vl] = flat_2d_array[i] + a[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s424_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint vl = 63;\n\n   \tstd::vector<float> flat_initial(length + vl + 1); // Ensure space for offsets\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_scalar(length + vl + 1), flat_simd(length + vl + 1);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s424\n       \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n           \tflat_initial[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \tflat_scalar = flat_initial;\n       \tflat_simd = flat_initial;\n\n       \ts424_scalar(flat_scalar.data(), a_input.data(), length);\n       \ts424_simd(flat_simd.data(), a_input.data(), length);\n\n       \tif (!allclose(flat_scalar, flat_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s424!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s424_scalar(float* flat_2d_array, const float* a, size_t n);\nvoid s424_simd(float* flat_2d_array, const float* a, size_t n);\n\ntemplate<void (*Func)(float*, const float*, size_t)>\nstatic void BM_s424(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint vl = 63;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> flat_output(length + vl + 1);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> flat_initial(length + vl + 1);\n\n   \t// Ported Initialization Logic for s424\n   \tfor (size_t i = 0; i < flat_initial.size(); ++i) {\n       \tflat_initial[i] = 1.0f / (float)(i+1); // frac\n   \t}\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tflat_output = flat_initial;\n       \tbenchmark::DoNotOptimize(flat_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n\n       \tFunc(flat_output.data(), a_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-1). Ops: 2R (flat[i], a[i]), 1W (flat[i+1+vl]). Total: 3 accesses.\n   \tsize_t num_ops = length - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s424, s424_scalar)->Name(\"Scalar_s424\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s424, s424_simd)->Name(\"SIMD_s424\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s424", "entrypoint_scalar": "s424_scalar", "entrypoint_simd": "s424_simd"}
{"task_id": "tsvc_s431_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs: a[i] = a[i+k] + b[i]; (where k=0)\nThis simplifies to: a[i] += b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s431_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s431_scalar(float *a, const float *b, size_t n) {\n   \tint k = 0;\n   \tfor (size_t i = 0; i < n; i++) {\n       \t// a[i] = a[i+k] + b[i] simplifies to a[i] = a[i] + b[i]\n       \ta[i] += b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s431_scalar(float *a, const float *b, size_t n);\nvoid s431_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s431\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts431_scalar(a_scalar.data(), b_input.data(), length);\n       \ts431_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s431!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s431_scalar(float *a, const float *b, size_t n);\nvoid s431_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s431(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s431\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1 R/W (a), 1R (b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s431, s431_scalar)->Name(\"Scalar_s431\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s431, s431_simd)->Name(\"SIMD_s431\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s431", "entrypoint_scalar": "s431_scalar", "entrypoint_simd": "s431_simd"}
{"task_id": "tsvc_s441_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a 3-way conditional operation (arithmetic if):\nif (d[i] < 0) a[i] += b[i] * c[i];\nelse if (d[i] == 0) a[i] += b[i] * b[i];\nelse a[i] += c[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (d[i] < 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t} else if (d[i] == 0.0f) {\n           \ta[i] += b[i] * b[i];\n       \t} else {\n           \ta[i] += c[i] * c[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s441\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = (float)(i % 3) - 1.0f; // -1, 0, 1\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts441_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts441_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s441!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s441_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s441_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s441(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s441\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = (float)(i % 3) - 1.0f; // -1, 0, 1\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (d), 1 R/W (a), 2R (b/c). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s441, s441_scalar)->Name(\"Scalar_s441\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s441, s441_simd)->Name(\"SIMD_s441\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s441", "entrypoint_scalar": "s441_scalar", "entrypoint_simd": "s441_simd"}
{"task_id": "tsvc_s442_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'e', 'indx' and length 'n'.\nIt performs a computed goto (switch-case) operation:\nswitch (indx[i]) {\n  case 1: a[i] += b[i] * b[i]; break;\n  case 2: a[i] += c[i] * c[i]; break;\n  case 3: a[i] += d[i] * d[i]; break;\n  case 4: a[i] += e[i] * e[i]; break;\n}\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n) {\n}", "solution_scalar": "void s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tswitch (indx[i]) {\n           \tcase 1:\n             \ta[i] += b[i] * b[i];\n             \tbreak;\n           \tcase 2:\n             \ta[i] += c[i] * c[i];\n             \tbreak;\n           \tcase 3:\n             \ta[i] += d[i] * d[i];\n             \tbreak;\n           \tcase 4:\n             \ta[i] += e[i] * e[i];\n             \tbreak;\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<int> indx_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s442\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f;\n           \tindx_input[i] = (int)(i % 4) + 1; // 1, 2, 3, 4\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts442_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n       \ts442_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s442!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s442_scalar(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\nvoid s442_simd(float *a, const float *b, const float *c, const float *d, const float *e, const int* indx, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s442(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<int> indx_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s442\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f;\n       \tindx_input[i] = (int)(i % 4) + 1; // 1, 2, 3, 4\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n       \tbenchmark::DoNotOptimize(indx_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), indx_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(indx), 1 R/W(a), 2R(b/c/d/e). Total: 4 accesses (3 float, 1 int).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 3 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s442, s442_scalar)->Name(\"Scalar_s442\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s442, s442_simd)->Name(\"SIMD_s442\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s442", "entrypoint_scalar": "s442_scalar", "entrypoint_simd": "s442_simd"}
{"task_id": "tsvc_s443_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs a 2-way conditional (arithmetic if):\nif (d[i] <= 0) { a[i] += b[i] * c[i]; }\nelse { a[i] += b[i] * b[i]; }\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (d[i] <= 0.0f) {\n           \ta[i] += b[i] * c[i];\n       \t} else {\n           \ta[i] += b[i] * b[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s443\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = (float)(i % 2) - 0.5f; // -0.5, 0.5\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts443_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts443_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s443!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s443_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s443_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s443(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s443\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = (float)(i % 2) - 0.5f; // -0.5, 0.5\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(d), 1R/W(a), 2R(b,c). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s443, s443_scalar)->Name(\"Scalar_s443\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s443, s443_simd)->Name(\"SIMD_s443\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s443", "entrypoint_scalar": "s443_scalar", "entrypoint_simd": "s443_simd"}
{"task_id": "tsvc_s451_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs intrinsic math functions: a[i] = sinf(b[i]) + cosf(c[i]);\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\n#include <cmath>\nvoid s451_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "#include <cmath>\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = std::sin(b[i]) + std::cos(c[i]);\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s451_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s451\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts451_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts451_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s451!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n#include <cmath>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s451_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s451_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s451(benchmark::State& state) {\n g  \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s451\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s451, s451_scalar)->Name(\"Scalar_s451\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s451, s451_simd)->Name(\"SIMD_s451\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s451", "entrypoint_scalar": "s451_scalar", "entrypoint_simd": "s451_simd"}
{"task_id": "tsvc_s452_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] = b[i] + c[i] * (float)(i + 1);\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s452_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s452_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i] + c[i] * (float)(i + 1);\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s452_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s452_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s452\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts452_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts452_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s452!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n g  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s452_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s452_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s452(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n i  // Ported Initialization Logic for s452\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n A   \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R (b,c), 1W (a). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s452, s452_scalar)->Name(\"Scalar_s452\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s452, s452_simd)->Name(\"SIMD_s452\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s452", "entrypoint_scalar": "s452_scalar", "entrypoint_simd": "s452_simd"}
{"task_id": "tsvc_s453_AVX", "prompt": "/* This function takes float arrays 'a', 'b' and length 'n'.\nIt performs an operation using an induction variable 's':s = 0.0f;\nfor (i=0..n) { s += 2.0f; a[i] = s * b[i]; }\nImplement this using AVX intrinsics.\n*/#include <immintrin.h>\nvoid s453_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void s453_scalar(float *a, const float *b, size_t n) {\n   \tfloat s = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \ts += 2.0f;\n       \ta[i] = s * b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s453_scalar(float *a, const float *b, size_t n);\nvoid s453_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s453 (default init)\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts453_scalar(a_scalar.data(), b_input.data(), length);\n       \ts453_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s453!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s453_scalar(float *a, const float *b, size_t n);\nvoid s453_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_s453(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s453 (default init)\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R (b), 1W (a). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s453, s453_scalar)->Name(\"Scalar_s453\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s453, s453_simd)->Name(\"SIMD_s453\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s453", "entrypoint_scalar": "s453_scalar", "entrypoint_simd": "s453_simd"}
{"task_id": "tsvc_s471_AVX", "prompt": "/*\nThis function takes float arrays 'x', 'b', 'c', 'd', 'e' and length 'n'.\nIt tests loop distribution dependencies:\n1. x[i] = b[i] + d[i] * d[i];\n2. b[i] = c[i] + d[i] * e[i];\n(Original code had a dummy s471s() call between lines).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n}", "solution_scalar": "void s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tx[i] = b[i] + d[i] * d[i];\n       \t// s471s() dummy call removed\n       \tb[i] = c[i] + d[i] * e[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> x_initial(length);\n   \tstd::vector<float> b_initial(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> x_scalar(length), x_simd(length);\n   \tstd::vector<float> b_scalar(length), b_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s471\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tx_initial[i] = 0.0f;\n           \tb_initial[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \te_input[i] = 1.0f;\n       \t}\n       \tx_scalar = x_initial;\n       \tx_simd = x_initial;\n       \tb_scalar = b_initial;\n       \tb_simd = b_initial;\n\n       \ts471_scalar(x_scalar.data(), b_scalar.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \ts471_simd(x_simd.data(), b_simd.data(), c_input.data(), d_input.data(), e_input.data(), length);\n\n       \tif (!allclose(x_scalar, x_simd) || !allclose(b_scalar, b_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s471!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n D  \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s471_scalar(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\nvoid s471_simd(float *x, float *b, const float *c, const float *d, const float *e, size_t n);\n\ntemplate<void (*Func)(float *, float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s471(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> x_output(length);\n   \tstd::vector<float> b_output(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> x_initial(length);\n   \tstd::vector<float> b_initial(length);\n\n   \t// Ported Initialization Logic for s471\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tx_initial[i] = 0.0f;\n       \tb_initial[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \te_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \tx_output = x_initial;\n       \tb_output = b_initial;\n       \tbenchmark::DoNotOptimize(x_output.data());\n       \tbenchmark::DoNotOptimize(b_output.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n\n       \tFunc(x_output.data(), b_output.data(), c_input.data(), d_input.data(), e_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b), 2R(d), 1W(x), 1R(c), 1R(e), 1W(b). Total: 5R, 2W = 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s471, s471_scalar)->Name(\"Scalar_s471\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s471, s471_simd)->Name(\"SIMD_s471\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s471", "entrypoint_scalar": "s471_scalar", "entrypoint_simd": "s471_simd"}
{"task_id": "tsvc_s481_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs: if (d[i] < 0) break; a[i] += b[i] * c[i];\n(Original code had exit(0), translated to break).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (d[i] < 0.0f) {\n           \tbreak;\n       \t}\n       \ta[i] += b[i] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s481\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n           \td_input[i] = 1.0f / (float)(i+1); // frac (all positive, no break)\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts481_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \ts481_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s481!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s481_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s481_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s481(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s481\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n       \td_input[i] = 1.0f / (float)(i+1); // frac (all positive, no break)\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(d), 1R/W(a), 2R(b,c). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s481, s481_scalar)->Name(\"Scalar_s481\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s481, s481_simd)->Name(\"SIMD_s481\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s481", "entrypoint_scalar": "s481_scalar", "entrypoint_simd": "s481_simd"}
{"task_id": "tsvc_s482_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] += b[i] * c[i]; if (c[i] > b[i]) break;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s482_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void s482_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] * c[i];\n       \tif (c[i] > b[i]) break;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s482_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s482_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s482\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tc_input[i] = 1.0f;\n       \t}\n       \t// c[i] > b[i] will be true for i > 0, so loop breaks at i=1\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts482_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts482_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s482!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s482_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s482_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s482(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s482\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tc_input[i] = 1.0f;\n   \t}\n   \t// c[i] > b[i] will be true for i > 0, so loop breaks at i=1\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop breaks early, but worst case is (n). Ops: 1R/W(a), 3R(b,c,c,b). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s482, s482_scalar)->Name(\"Scalar_s482\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s482, s482_simd)->Name(\"SIMD_s482\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s482", "entrypoint_scalar": "s482_scalar", "entrypoint_simd": "s482_simd"}
{"task_id": "tsvc_s491_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'ip' and length 'n'.\nIt performs a scatter operation: a[ip[i]] = b[i] + c[i] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n) {\n}", "solution_scalar": "void s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[ip[i]] = b[i] + c[i] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s491\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts491_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n       \ts491_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s491!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s491_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\nvoid s491_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s491(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s491\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R(b,c,d), 1R(ip), 1W(a). Total: 4 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 4 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s491, s491_scalar)->Name(\"Scalar_s491\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s491, s491_simd)->Name(\"SIMD_s491\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s491", "entrypoint_scalar": "s491_scalar", "entrypoint_simd": "s491_simd"}
{"task_id": "tsvc_s4112_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', an int array 'ip', float 's' and length 'n'.\nIt performs a sparse SAXPY (gather operation): a[i] += b[ip[i]] * s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n) {\n}", "solution_scalar": "void s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[ip[i]] * s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n);\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tfloat s = 2.0f;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4112\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4112_scalar(a_scalar.data(), b_input.data(), ip_input.data(), s, length);\n       \ts4112_simd(a_simd.data(), b_input.data(), ip_input.data(), s, length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4112!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4112_scalar(float *a, const float *b, const int* ip, float s, size_t n);\nvoid s4112_simd(float *a, const float *b, const int* ip, float s, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, float, size_t)>\nstatic void BM_s4112(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tfloat s = 2.0f;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4112\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), ip_input.data(), s, length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4112, s4112_scalar)->Name(\"Scalar_s4112\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4112, s4112_simd)->Name(\"SIMD_s4112\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4112", "entrypoint_scalar": "s4112_scalar", "entrypoint_simd": "s4112_simd"}
{"task_id": "tsvc_s4113_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'ip' and length 'n'.\nIt performs a gather-scatter operation: a[ip[i]] = b[ip[i]] + c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n) {\n}", "solution_scalar": "void s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[ip[i]] = b[ip[i]] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n);\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4113\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       S   \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4113_scalar(a_scalar.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       \ts4113_simd(a_simd.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4113!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4113_scalar(float *a, const float *b, const float *c, const int* ip, size_t n);\nvoid s4113_simd(float *a, const float *b, const float *c, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const int*, size_t)>\nstatic void BM_s4113(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4113\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b via ip), 1R(c), 1R(ip), 1W(a via ip). Total: 3 float, 2 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 3 + int64_t(num_ops) * sizeof(int) * 2));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4113, s4113_scalar)->Name(\"Scalar_s4113\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4113, s4113_simd)->Name(\"SIMD_s4113\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4113", "entrypoint_scalar": "s4113_scalar", "entrypoint_simd": "s4113_simd"}
{"task_id": "tsvc_s4114_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd', 'ip' and length 'n', 'n1'.\nIt performs a gather operation with complex indexing:\na[i] = b[i] + c[n - k - 1] * d[i]; (k = ip[i])\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1) {\n}", "solution_scalar": "void s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1) {\n   \tfor (size_t i = (size_t)n1 - 1; i < n; i++) {\n       \tint k = ip[i];\n       \t// Original: c[LEN_1D-k+1-2] -> c[n-k-1]\n       \ta[i] = b[i] + c[n - k - 1] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tint n1 = 1;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4114\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n           \tip_input[i] = (int)((i * 7) % (length / 2)); // Scrambled indices, ensure n-k-1 is valid\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4114_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n       \ts4114_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4114!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4114_scalar(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\nvoid s4114_simd(float *a, const float *b, const float *c, const float *d, const int* ip, size_t n, int n1);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const int*, size_t, int)>\nstatic void BM_s4114(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tint n1 = 1;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4114\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n       \tip_input[i] = (int)((i * 7) % (length / 2)); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), ip_input.data(), length, n1);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n-n1+1). Ops: 3R(b,c via ip,d), 1R(ip), 1W(a). Total: 4 float, 1 int access.\n   \tsize_t num_ops = length - n1 + 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 4 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4114, s4114_scalar)->Name(\"Scalar_s4114\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4114, s4114_simd)->Name(\"SIMD_s4114\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4114", "entrypoint_scalar": "s4114_scalar", "entrypoint_simd": "s4114_simd"}
{"task_id": "tsvc_s4115_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'ip' and length 'n'.\nIt performs a sparse dot product (gather): sum += a[i] * b[ip[i]];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n) {\n}", "solution_scalar": "float s4115_scalar(const float *a, const float *b, const int* ip, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i] * b[ip[i]];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat s4115_scalar(const float *a, const float *b, const int* ip, size_t n);\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4115\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n\n       \tfloat sum_scalar = s4115_scalar(a_input.data(), b_input.data(), ip_input.data(), length);\n       \tfloat sum_simd = s4115_simd(a_input.data(), b_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4115!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat s4115_scalar(const float *a, const float *b, const int* ip, size_t n);\nfloat s4115_simd(const float *a, const float *b, const int* ip, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, const int*, size_t)>\nstatic void BM_s4115(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n\n   \t// Ported Initialization Logic for s4115\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tfloat sum = Func(a_input.data(), b_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R(a), 1R(b via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4115, s4115_scalar)->Name(\"Scalar_s4115\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4115, s4115_simd)->Name(\"SIMD_s4115\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4115", "entrypoint_scalar": "s4115_scalar", "entrypoint_simd": "s4115_simd"}
{"task_id": "tsvc_s4116_AVX", "prompt": "/*\nThis function takes float array 'a', flattened 2D array 'aa', 'ip', 'n_2d', 'j', 'inc'.\nIt performs a sparse dot product (gather): sum += a[i+inc] * aa[j-1][ip[i]];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc) {\n}", "solution_scalar": "float s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n_2d - 1; i++) {\n       \tint off = inc + (int)i;\n       \tsum += a[off] * aa_flat[(j - 1) * n_2d + ip[i]];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nfloat s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length_1d = Small_Arg_1D;\n   \tsize_t n_2d = Small_Arg_2D;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tint j = 1; \n   \tint inc = 1;\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<int> ip_input(length_1d);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4116\n       \tfor (size_t i = 0; i < length_1d; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tip_input[i] = (int)((i * 7) % n_2d); // Scrambled indices within one row\n       \t}\n       \tfor (size_t i = 0; i < length_2d; ++i) {\n           \taa_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat sum_scalar = s4116_scalar(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n       \tfloat sum_simd = s4116_simd(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4116!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nfloat s4116_scalar(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\nfloat s4116_simd(const float *a, const float* aa_flat, const int* ip, size_t n_2d, int j, int inc);\n\ntemplate<float (*Func)(const float *, const float*, const int*, size_t, int, int)>\nstatic void BM_s4116(benchmark::State& state) {\n   \tsize_t n_2d = state.range(0);\n   \tsize_t length_1d = LEN_1D;\n   \tsize_t length_2d = n_2d * n_2d;\n   \tint j = 1; \n   \tint inc = 1;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length_1d);\n   \tstd::vector<float> aa_input(length_2d);\n   \tstd::vector<int> ip_input(length_1d);\n\n   \t// Ported Initialization Logic for s4116\n   \tfor (size_t i = 0; i < length_1d; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tip_input[i] = (int)((i * 7) % n_2d); // Scrambled indices\n   \t}\n   \tfor (size_t i = 0; i < length_2d; ++i) {\n       \taa_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(aa_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tfloat sum = Func(a_input.data(), aa_input.data(), ip_input.data(), n_2d, j, inc);\n       \t\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n_2d-1). Ops: 1R(a), 1R(aa via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = n_2d - 1;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_s4116, s4116_scalar)->Name(\"Scalar_s4116\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_s4116, s4116_simd)->Name(\"SIMD_s4116\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4116", "entrypoint_scalar": "s4116_scalar", "entrypoint_simd": "s4116_simd"}
{"task_id": "tsvc_s4117_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c', 'd' and length 'n'.\nIt performs: a[i] = b[i] + c[i / 2] * d[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n) {\n}", "solution_scalar": "void s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i] + c[i / 2] * d[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4117\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n           \td_input[i] = 1.0f;\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4117_scalar(a_scalar.data(), b_input.data(), c_input.data(), d_input.data(), length);\n S   \ts4117_simd(a_simd.data(), b_input.data(), c_input.data(), d_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4117!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n S \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid s4117_scalar(float *a, const float *b, const float *c, const float *d, size_t n);\nvoid s4117_simd(float *a, const float *b, const float *c, const float *d, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, size_t)>\nstatic void BM_s4117(benchmark::State& state) {\n I \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4117\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \td_input[i] = 1.0f;\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n       \tbenchmark::DoNotOptimize(d_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), d_input.data(), length);\n C   \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 3R (b,c,d), 1W (a). Total: 4 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 4);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4117, s4117_scalar)->Name(\"Scalar_s4117\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4117, s4117_simd)->Name(\"SIMD_s4117\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4117", "entrypoint_scalar": "s4117_scalar", "entrypoint_simd": "s4117_simd"}
{"task_id": "tsvc_s4121_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs: a[i] += f(b[i], c[i]); where f(a,b) is a*b.\nThis tests statement functions (inlined).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\n\n// Helper function\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += f(b[i], c[i]);\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\n/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for s4121\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \ts4121_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \ts4121_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_s4121!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\n/* Helper function */\nstatic inline float f(float a, float b) {\n    return a * b;\n}\n\nvoid s4121_scalar(float *a, const float *b, const float *c, size_t n);\nvoid s4121_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_s4121(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for s4121\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_s4121, s4121_scalar)->Name(\"Scalar_s4121\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_s4121, s4121_simd)->Name(\"SIMD_s4121\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "s4121", "entrypoint_scalar": "s4121_scalar", "entrypoint_simd": "s4121_simd"}
{"task_id": "tsvc_va_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector assignment: a[i] = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid va_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void va_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid va_scalar(float *a, const float *b, size_t n);\nvoid va_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for va\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tva_scalar(a_scalar.data(), b_input.data(), length);\n       \tva_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_va!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid va_scalar(float *a, const float *b, size_t n);\nvoid va_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_va(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for va\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b), 1W(a). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_va, va_scalar)->Name(\"Scalar_va\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_va, va_simd)->Name(\"SIMD_va\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "va", "entrypoint_scalar": "va_scalar", "entrypoint_simd": "va_simd"}
{"task_id": "tsvc_vag_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', int array 'ip' and length 'n'.\nIt performs a vector assignment (gather): a[i] = b[ip[i]];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n) {\n}", "solution_scalar": "void vag_scalar(float *a, const float *b, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = b[ip[i]];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vag_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vag\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvag_scalar(a_scalar.data(), b_input.data(), ip_input.data(), length);\n       \tvag_simd(a_simd.data(), b_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vag!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vag_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vag_simd(float *a, const float *b, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, size_t)>\nstatic void BM_vag(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vag\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b via ip), 1W(a), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vag, vag_scalar)->Name(\"Scalar_vag\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vag, vag_simd)->Name(\"SIMD_vag\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vag", "entrypoint_scalar": "vag_scalar", "entrypoint_simd": "vag_simd"}
{"task_id": "tsvc_vas_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', int array 'ip' and length 'n'.\nIt performs a vector assignment (scatter): a[ip[i]] = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n) {\n}", "solution_scalar": "void vas_scalar(float *a, const float *b, const int* ip, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[ip[i]] = b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vas_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vas\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 0.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvas_scalar(a_scalar.data(), b_input.data(), ip_input.data(), length);\n       \tvas_simd(a_simd.data(), b_input.data(), ip_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vas!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vas_scalar(float *a, const float *b, const int* ip, size_t n);\nvoid vas_simd(float *a, const float *b, const int* ip, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const int*, size_t)>\nstatic void BM_vas(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<int> ip_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vas\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 0.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tip_input[i] = (int)((i * 7) % length); // Scrambled indices\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(ip_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), ip_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R(b), 1W(a via ip), 1R(ip). Total: 2 float, 1 int access.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * (int64_t(num_ops) * sizeof(float) * 2 + int64_t(num_ops) * sizeof(int)));\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vas, vas_scalar)->Name(\"Scalar_vas\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vas, vas_simd)->Name(\"SIMD_vas\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vas", "entrypoint_scalar": "vas_scalar", "entrypoint_simd": "vas_simd"}
{"task_id": "tsvc_vif_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a conditional vector assignment: if (b[i] > 0.0f) a[i] = b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vif_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void vif_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \tif (b[i] > 0.0f) {\n           \ta[i] = b[i];\n       \t}\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vif_scalar(float *a, const float *b, size_t n);\nvoid vif_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vif\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = (float)(i % 10) - 5.0f; // Mix of positive and negative\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvif_scalar(a_scalar.data(), b_input.data(), length);\n       \tvif_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vif!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vif_scalar(float *a, const float *b, size_t n);\nvoid vif_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vif(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vif\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = (float)(i % 10) - 5.0f; // Mix of positive and negative\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 2R(b,b), 1W(a). Total: 3 accesses (worst case).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vif, vif_scalar)->Name(\"Scalar_vif\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vif, vif_simd)->Name(\"SIMD_vif\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vif", "entrypoint_scalar": "vif_scalar", "entrypoint_simd": "vif_simd"}
{"task_id": "tsvc_vpv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector plus vector: a[i] += b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpv_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void vpv_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpv_scalar(float *a, const float *b, size_t n);\nvoid vpv_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpv_scalar(a_scalar.data(), b_input.data(), length);\n       \tvpv_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpv_scalar(float *a, const float *b, size_t n);\nvoid vpv_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vpv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpv, vpv_scalar)->Name(\"Scalar_vpv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpv, vpv_simd)->Name(\"SIMD_vpv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpv", "entrypoint_scalar": "vpv_scalar", "entrypoint_simd": "vpv_simd"}
{"task_id": "tsvc_vtv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector times vector: a[i] *= b[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vtv_simd(float *a, const float *b, size_t n) {\n}", "solution_scalar": "void vtv_scalar(float *a, const float *b, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] *= b[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vtv_scalar(float *a, const float *b, size_t n);\nvoid vtv_simd(float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vtv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvtv_scalar(a_scalar.data(), b_input.data(), length);\n       \tvtv_simd(a_simd.data(), b_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vtv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vtv_scalar(float *a, const float *b, size_t n);\nvoid vtv_simd(float *a, const float *b, size_t n);\n\ntemplate<void (*Func)(float *, const float *, size_t)>\nstatic void BM_vtv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vtv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n s \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vtv, vtv_scalar)->Name(\"Scalar_vtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vtv, vtv_simd)->Name(\"SIMD_vtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vtv", "entrypoint_scalar": "vtv_scalar", "entrypoint_simd": "vtv_simd"}
{"task_id": "tsvc_vpvtv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector plus vector times vector: a[i] += b[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void vpvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpvtv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpvtv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \tvpvtv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvtv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvtv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vpvtv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpvtv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvtv, vpvtv_scalar)->Name(\"Scalar_vpvtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvtv, vpvtv_simd)->Name(\"SIMD_vpvtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvtv", "entrypoint_scalar": "vpvtv_scalar", "entrypoint_simd": "vpvtv_simd"}
{"task_id": "tsvc_vpvts_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', a scalar 's' and length 'n'.\nIt performs a vector plus vector times scalar: a[i] += b[i] * s;\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpvts_simd(float *a, const float *b, float s, size_t n) {\n}", "solution_scalar": "void vpvts_scalar(float *a, const float *b, float s, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] * s;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvts_scalar(float *a, const float *b, float s, size_t n);\nvoid vpvts_simd(float *a, const float *b, float s, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n   \tfloat s = 2.0f;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpvts\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpvts_scalar(a_scalar.data(), b_input.data(), s, length);\n       \tvpvts_simd(a_simd.data(), b_input.data(), s, length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvts!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvts_scalar(float *a, const float *b, float s, size_t n);\nvoid vpvts_simd(float *a, const float *b, float s, size_t n);\n\ntemplate<void (*Func)(float *, const float *, float, size_t)>\nstatic void BM_vpvts(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tfloat s = 2.0f;\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpvts\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), s, length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 1R(b). Total: 2 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvts, vpvts_scalar)->Name(\"Scalar_vpvts\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvts, vpvts_simd)->Name(\"SIMD_vpvts\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvts", "entrypoint_scalar": "vpvts_scalar", "entrypoint_simd": "vpvts_simd"}
{"task_id": "tsvc_vpvpv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector plus vector plus vector: a[i] += b[i] + c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void vpvpv_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] += b[i] + c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vpvpv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vpvpv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvpvpv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \tvpvpv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vpvpv!\" << std::endl;\n S     \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vpvpv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vpvpv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vpvpv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vpvpv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vpvpv, vpvpv_scalar)->Name(\"Scalar_vpvpv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vpvpv, vpvpv_simd)->Name(\"SIMD_vpvpv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vpvpv", "entrypoint_scalar": "vpvpv_scalar", "entrypoint_simd": "vpvpv_simd"}
{"task_id": "tsvc_vtvtv_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b', 'c' and length 'n'.\nIt performs a vector times vector times vector: a[i] = a[i] * b[i] * c[i];\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n) {\n}", "solution_scalar": "void vtvtv_scalar(float *a, const float *b, const float *c, size_t n) {\n   \tfor (size_t i = 0; i < n; i++) {\n       \ta[i] = a[i] * b[i] * c[i];\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nvoid vtvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_initial(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_scalar(length), a_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vtvtv\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_initial[i] = 1.0f;\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n       \ta_scalar = a_initial;\n       \ta_simd = a_initial;\n\n       \tvtvtv_scalar(a_scalar.data(), b_input.data(), c_input.data(), length);\n       \tvtvtv_simd(a_simd.data(), b_input.data(), c_input.data(), length);\n\n       \tif (!allclose(a_scalar, a_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vtvtv!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nvoid vtvtv_scalar(float *a, const float *b, const float *c, size_t n);\nvoid vtvtv_simd(float *a, const float *b, const float *c, size_t n);\n\ntemplate<void (*Func)(float *, const float *, const float *, size_t)>\nstatic void BM_vtvtv(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_output(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> a_initial(length);\n\n   \t// Ported Initialization Logic for vtvtv\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_initial[i] = 1.0f;\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \ta_output = a_initial;\n       \tbenchmark::DoNotOptimize(a_output.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n\n       \tFunc(a_output.data(), b_input.data(), c_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n). Ops: 1R/W(a), 2R(b,c). Total: 3 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 3);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vtvtv, vtvtv_scalar)->Name(\"Scalar_vtvtv\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vtvtv, vtvtv_simd)->Name(\"SIMD_vtvtv\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vtvtv", "entrypoint_scalar": "vtvtv_scalar", "entrypoint_simd": "vtvtv_simd"}
{"task_id": "tsvc_vsumr_AVX", "prompt": "/*\nThis function takes float array 'a' and length 'n'.\nIt performs a vector sum reduction: sum += a[i];\nImplement this using AVX intrinsics. The function should return the sum.\n*/\n#include <immintrin.h>\nfloat vsumr_simd(const float *a, size_t n) {\n}", "solution_scalar": "float vsumr_scalar(const float *a, size_t n) {\n   \tfloat sum = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tsum += a[i];\n   \t}\n   \treturn sum;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat vsumr_scalar(const float *a, size_t n);\nfloat vsumr_simd(const float *a, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vsumr\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n\n       \tfloat sum_scalar = vsumr_scalar(a_input.data(), length);\n       \tfloat sum_simd = vsumr_simd(a_input.data(), length);\n\n       \tif (!allclose(sum_scalar, sum_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vsumr!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat vsumr_scalar(const float *a, size_t n);\nfloat vsumr_simd(const float *a, size_t n);\n\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM_vsumr(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n\n   \t// Ported Initialization Logic for vsumr\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tfloat sum = Func(a_input.data(), length);\n       \tbenchmark::DoNotOptimize(sum);\n   \t}\n   \t// Loop (n). Ops: 1R (a).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 1);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vsumr, vsumr_scalar)->Name(\"Scalar_vsumr\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vsumr, vsumr_simd)->Name(\"SIMD_vsumr\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vsumr", "entrypoint_scalar": "vsumr_scalar", "entrypoint_simd": "vsumr_simd"}
{"task_id": "tsvc_vdotr_AVX", "prompt": "/*\nThis function takes float arrays 'a', 'b' and length 'n'.\nIt performs a vector dot product reduction: dot += a[i] * b[i];\nImplement this using AVX intrinsics. The function should return the dot product.\n*/\n#include <immintrin.h>\nfloat vdotr_simd(const float *a, const float *b, size_t n) {\n}", "solution_scalar": "float vdotr_scalar(const float *a, const float *b, size_t n) {\n   \tfloat dot = 0.0f;\n   \tfor (size_t i = 0; i < n; i++) {\n       \tdot += a[i] * b[i];\n   \t}\n   \treturn dot;\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n\nfloat vdotr_scalar(const float *a, const float *b, size_t n);\nfloat vdotr_simd(const float *a, const float *b, size_t n);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_1D;\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vdotr\n       \tfor (size_t i = 0; i < length; ++i) {\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n       \t}\n\n       \tfloat dot_scalar = vdotr_scalar(a_input.data(), b_input.data(), length);\n       \tfloat dot_simd = vdotr_simd(a_input.data(), b_input.data(), length);\n\n       \tif (!allclose(dot_scalar, dot_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vdotr!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n t \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define DEFAULT_SEED 12345\n\nfloat vdotr_scalar(const float *a, const float *b, size_t n);\nfloat vdotr_simd(const float *a, const float *b, size_t n);\n\ntemplate<float (*Func)(const float *, const float *, size_t)>\nstatic void BM_vdotr(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n\n   \t// Ported Initialization Logic for vdotr\n   \tfor (size_t i = 0; i < length; ++i) {\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / ((float)(i+1) * (float)(i+1)); // frac2\n   \t}\n\n   \tfor (auto _ : state) {\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tfloat dot = Func(a_input.data(), b_input.data(), length);\n       \tbenchmark::DoNotOptimize(dot);\n   \t}\n   \t// Loop (n). Ops: 2R (a, b).\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 2);\n}\n\n#define Large_Args_1D Arg(LEN_1D / 4)->Arg(LEN_1D / 2)->Arg(LEN_1D)\n\nBENCHMARK_TEMPLATE(BM_vdotr, vdotr_scalar)->Name(\"Scalar_vdotr\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_vdotr, vdotr_simd)->Name(\"SIMD_vdotr\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vdotr", "entrypoint_scalar": "vdotr_scalar", "entrypoint_simd": "vdotr_simd"}
{"task_id": "tsvc_vbor_AVX", "prompt": "/*\nThis function takes float arrays 'x', 'a', 'b', 'c', 'd', 'e', 'aa_flat' and length 'n_2d'.\nIt performs a complex series of arithmetic operations (basic operations rates).\nImplement this using AVX intrinsics.\n*/\n#include <immintrin.h>\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n}", "solution_scalar": "void vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d) {\n   \tfor (size_t i = 0; i < n_2d; i++) {\n       \tfloat a1 = a[i];\n       \tfloat b1 = b[i];\n       \tfloat c1 = c[i];\n       \tfloat d1 = d[i];\n       \tfloat e1 = e[i];\n       \tfloat f1 = aa_flat[i]; // Original was aa[0][i]\n       \ta1 = a1 * b1 * c1 + a1 * b1 * d1 + a1 * b1 * e1 + a1 * b1 * f1 +\n             \ta1 * c1 * d1 + a1 * c1 * e1 + a1 * c1 * f1 + a1 * d1 * e1\n             \t+ a1 * d1 * f1 + a1 * e1 * f1;\n       \tb1 = b1 * c1 * d1 + b1 * c1 * e1 + b1 * c1 * f1 + b1 * d1 * e1 +\n             \tb1 * d1 * f1 + b1 * e1 * f1;\n       \tc1 = c1 * d1 * e1 + c1 * d1 * f1 + c1 * e1 * f1;\n g   \td1 = d1 * e1 * f1;\n       \tx[i] = a1 * b1 * c1 * d1;\n   \t}\n}", "test_correctness": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\n#include \"Random.h\"\n#include \"allclose.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define ITERATIONS 1\n#define ERROR_PRINT 1\n#define Small_Arg_1D LEN_1D\n#define Small_Arg_2D LEN_2D\n\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\n\nbool correctness_check(int iterations) {\n   \tRandom rng;\n   \tsize_t length = Small_Arg_2D;\n\n   \tstd::vector<float> x_initial(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> aa_flat_input(length);\n   \tstd::vector<float> x_scalar(length), x_simd(length);\n\n   \tfor (int iter = 0; iter < iterations; ++iter) {\n       \t// Ported Initialization Logic for vbor\n       \tfor (size_t i = 0; i < length; ++i) {\n           \tx_initial[i] = 0.0f;\n           \ta_input[i] = 1.0f / (float)(i+1); // frac\n           \tb_input[i] = 1.0f / (float)(i+1); // frac\n           \tc_input[i] = 1.0f / (float)(i+1); // frac\n           \td_input[i] = 1.0f / (float)(i+1); // frac\n           \te_input[i] = 1.0f / (float)(i+1); // frac\n           \taa_flat_input[i] = 1.0f / (float)(i+1); // frac\n       \t}\n       \tx_scalar = x_initial;\n       \tx_simd = x_initial;\n\n       \tvbor_scalar(x_scalar.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n       \tvbor_simd(x_simd.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n\n       \tif (!allclose(x_scalar, x_simd)) {\n           \tif (ERROR_PRINT) std::cerr << \"Correctness check failed for tsvc_vbor!\" << std::endl;\n           \treturn false;\n       \t}\n   \t}\n   \treturn true;\n}\n\nint main() {\n   \tbool pass = correctness_check(ITERATIONS);\n   \tprintf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n   \treturn !pass;\n}", "test_performance": "#include <vector>\n#include <numeric>\n#include <benchmark/benchmark.h>\n\n#include \"Random.h\"\n\n#define LEN_1D 32000\n#define LEN_2D 256\n#define DEFAULT_SEED 12345\n\nvoid vbor_scalar(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\nvoid vbor_simd(float *x, const float *a, const float *b, const float *c, const float *d, const float *e, const float* aa_flat, size_t n_2d);\n\ntemplate<void (*Func)(float *, const float *, const float *, const float *, const float *, const float *, const float*, size_t)>\nstatic void BM_vbor(benchmark::State& state) {\n   \tsize_t length = state.range(0);\n   \tRandom rng(DEFAULT_SEED);\n\n   \tstd::vector<float> x_output(length);\n   \tstd::vector<float> a_input(length);\n   \tstd::vector<float> b_input(length);\n   \tstd::vector<float> c_input(length);\n   \tstd::vector<float> d_input(length);\n   \tstd::vector<float> e_input(length);\n   \tstd::vector<float> aa_flat_input(length);\n   \tstd::vector<float> x_initial(length);\n\n   \t// Ported Initialization Logic for vbor\n   \tfor (size_t i = 0; i < length; ++i) {\n       \tx_initial[i] = 0.0f;\n       \ta_input[i] = 1.0f / (float)(i+1); // frac\n       \tb_input[i] = 1.0f / (float)(i+1); // frac\n       \tc_input[i] = 1.0f / (float)(i+1); // frac\n       \td_input[i] = 1.0f / (float)(i+1); // frac\n       \te_input[i] = 1.0f / (float)(i+1); // frac\n       \taa_flat_input[i] = 1.0f / (float)(i+1); // frac\n   \t}\n\n   \tfor (auto _ : state) {\n       \tx_output = x_initial;\n       \tbenchmark::DoNotOptimize(x_output.data());\n       \tbenchmark::DoNotOptimize(a_input.data());\n       \tbenchmark::DoNotOptimize(b_input.data());\n       \tbenchmark::DoNotOptimize(c_input.data());\n D   \tbenchmark::DoNotOptimize(d_input.data());\n       \tbenchmark::DoNotOptimize(e_input.data());\n       \tbenchmark::DoNotOptimize(aa_flat_input.data());\n\n       \tFunc(x_output.data(), a_input.data(), b_input.data(), c_input.data(), d_input.data(), e_input.data(), aa_flat_input.data(), length);\n       \t\n       \tbenchmark::ClobberMemory();\n   \t}\n   \t// Loop (n_2d). Ops: 6R(a,b,c,d,e,aa_flat), 1W(x). Total: 7 accesses.\n   \tsize_t num_ops = length;\n   \tstate.SetBytesProcessed(int64_t(state.iterations()) * int64_t(num_ops) * sizeof(float) * 7);\n}\n\n#define Large_Args_2D Arg(LEN_2D / 4)->Arg(LEN_2D / 2)->Arg(LEN_2D)\n\nBENCHMARK_TEMPLATE(BM_vbor, vbor_scalar)->Name(\"Scalar_vbor\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM_vbor, vbor_simd)->Name(\"SIMD_vbor\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "TSVC", "subtype": "vbor", "entrypoint_scalar": "vbor_scalar", "entrypoint_simd": "vbor_simd"}

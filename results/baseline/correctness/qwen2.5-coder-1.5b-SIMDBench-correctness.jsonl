{"task_id": "SimdBench_0_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8td744ly.cpp: In function \u2018void conditional_move_simd(const int64_t*, int64_t*, const bool*, size_t)\u2019:\n[REDACTED]/tmp8td744ly.cpp:37:32: error: \u2018_mm256_blendv_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_blendv_epi8\u2019?\n   37 |         __m256i result_block = _mm256_blendv_epi64(src_block, dst_block, mask_block);\n      |                                ^~~~~~~~~~~~~~~~~~~\n      |                                _mm256_blendv_epi8\n[REDACTED]/tmp8td744ly.cpp:47:31: error: \u2018_mm_blendv_epi64\u2019 was not declared in this scope; did you mean \u2018_mm_blendv_epi8\u2019?\n   47 |         __m128i result_word = _mm_blendv_epi64(src_word, dst_word, mask_word);\n      |                               ^~~~~~~~~~~~~~~~\n      |                               _mm_blendv_epi8\n"}
{"task_id": "SimdBench_0_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_0_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_0_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_0_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_1_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpks2wh1u0.cpp: In function \u2018void load_modify_store_simd(const int*, int*, int, size_t)\u2019:\n[REDACTED]/tmpks2wh1u0.cpp:27:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i scale_vec = _mm_set_epi32(scale, scale, scale, scale);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpks2wh1u0.cpp:28:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   28 |     __m256i zero_vec = _mm_setzero_si256();\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmpks2wh1u0.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_vec = _mm_loadu_si256((__m256i *)(src + i));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpks2wh1u0.cpp:32:57: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         __m256i tmp1_vec = _mm_srli_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                         ^~~~~~~\n      |                                                         |\n      |                                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpks2wh1u0.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpks2wh1u0.cpp:33:57: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         __m256i tmp2_vec = _mm_slli_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                         ^~~~~~~\n      |                                                         |\n      |                                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpks2wh1u0.cpp:34:81: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                                                                                 ^~~~~~~~\n      |                                                                                 |\n      |                                                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpks2wh1u0.cpp:34:30: error: \u2018_mm_div_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_min_epi32\u2019?\n   34 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_min_epi32\n[REDACTED]/tmpks2wh1u0.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i *)(dst + i), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_1_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphckg23dt.cpp: In function \u2018void load_modify_store_simd(const int*, int*, int, size_t)\u2019:\n[REDACTED]/tmphckg23dt.cpp:27:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i scale_vec = _mm_set_epi32(scale, scale, scale, scale);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmphckg23dt.cpp:28:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   28 |     __m256i zero_vec = _mm_setzero_si256();\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmphckg23dt.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_vec = _mm_loadu_si256((__m256i *)(src + i * 4));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmphckg23dt.cpp:32:56: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         __m256i tmp1_vec = _mm_srl_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                        ^~~~~~~\n      |                                                        |\n      |                                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmphckg23dt.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmphckg23dt.cpp:33:56: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         __m256i tmp2_vec = _mm_sll_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                        ^~~~~~~\n      |                                                        |\n      |                                                        __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmphckg23dt.cpp:34:58: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i result_vec = _mm_add_epi32(_mm_mul_epi32(src_vec, scale_vec), _mm_mul_epi32(tmp1_vec, tmp2_vec));\n      |                                                          ^~~~~~~\n      |                                                          |\n      |                                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmphckg23dt.cpp:34:93: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i result_vec = _mm_add_epi32(_mm_mul_epi32(src_vec, scale_vec), _mm_mul_epi32(tmp1_vec, tmp2_vec));\n      |                                                                                             ^~~~~~~~\n      |                                                                                             |\n      |                                                                                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmphckg23dt.cpp:35:34: error: \u2018_mm_div_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_min_epi32\u2019?\n   35 |         __m256i div_result_vec = _mm_div_epi32(result_vec, _mm_set_epi32(7, 7, 7, 7));\n      |                                  ^~~~~~~~~~~~~\n      |                                  _mm_min_epi32\n[REDACTED]/tmphckg23dt.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i *)(dst + i * 4), div_result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_1_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbtb1cxxc.cpp: In function \u2018void load_modify_store_simd(const int*, int*, int, size_t)\u2019:\n[REDACTED]/tmpbtb1cxxc.cpp:27:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i scale_vec = _mm_set_epi32(scale, scale, scale, scale);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpbtb1cxxc.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_vec = _mm_loadu_si256((__m256i *)(src + i));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpbtb1cxxc.cpp:32:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         tmp1_vec = _mm_srli_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                 ^~~~~~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpbtb1cxxc.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbtb1cxxc.cpp:33:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         tmp2_vec = _mm_slli_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                 ^~~~~~~\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbtb1cxxc.cpp:34:81: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                                                                                 ^~~~~~~~\n      |                                                                                 |\n      |                                                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbtb1cxxc.cpp:34:30: error: \u2018_mm_div_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_min_epi32\u2019?\n   34 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_min_epi32\n[REDACTED]/tmpbtb1cxxc.cpp:35:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   35 |         _mm_storeu_si256((__m256i *)(dst + i), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_1_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbd8i0cah.cpp: In function \u2018void load_modify_store_simd(const int*, int*, int, size_t)\u2019:\n[REDACTED]/tmpbd8i0cah.cpp:30:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   30 |     __m256i scale_vec = _mm_set_epi32(scale, scale, scale, scale);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpbd8i0cah.cpp:31:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   31 |     __m256i zero_vec = _mm_setzero_si256();\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmpbd8i0cah.cpp:34:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   34 |         __m256i src_vec = _mm_loadu_si256((__m256i *)(src + i));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpbd8i0cah.cpp:35:57: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i tmp1_vec = _mm_srli_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                         ^~~~~~~\n      |                                                         |\n      |                                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpbd8i0cah.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbd8i0cah.cpp:36:57: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         __m256i tmp2_vec = _mm_slli_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                         ^~~~~~~\n      |                                                         |\n      |                                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbd8i0cah.cpp:37:81: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                                                                                 ^~~~~~~~\n      |                                                                                 |\n      |                                                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbd8i0cah.cpp:37:30: error: \u2018_mm_div_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_min_epi32\u2019?\n   37 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_min_epi32\n[REDACTED]/tmpbd8i0cah.cpp:39:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   39 |         _mm_storeu_si256((__m256i *)(dst + i), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_1_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpj9s22w8h.cpp: In function \u2018void load_modify_store_simd(const int*, int*, int, size_t)\u2019:\n[REDACTED]/tmpj9s22w8h.cpp:27:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i scale_vec = _mm_set_epi32(scale, scale, scale, scale);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpj9s22w8h.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_vec = _mm_loadu_si256((__m256i *)(&src[i * 4]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpj9s22w8h.cpp:32:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         tmp1_vec = _mm_srl_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                ^~~~~~~\n      |                                                |\n      |                                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpj9s22w8h.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpj9s22w8h.cpp:33:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         tmp2_vec = _mm_sll_epi32(_mm_mul_epi32(src_vec, scale_vec), 3);\n      |                                                ^~~~~~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpj9s22w8h.cpp:34:81: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                                                                                 ^~~~~~~~\n      |                                                                                 |\n      |                                                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpj9s22w8h.cpp:34:30: error: \u2018_mm_div_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_min_epi32\u2019?\n   34 |         __m256i result_vec = _mm_div_epi32(_mm_add_epi32(src_vec, _mm_mul_epi32(tmp1_vec, tmp2_vec)), 7);\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_min_epi32\n[REDACTED]/tmpj9s22w8h.cpp:35:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   35 |         _mm_storeu_si256((__m256i *)(&dst[i * 4]), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_2_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpy1yec_0r.cpp: In function \u2018void strided_load_store_simd(const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpy1yec_0r.cpp:25:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   25 |     __m256i v_stride = _mm_set_epi32(stride, stride, stride, stride);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpy1yec_0r.cpp:26:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   26 |     __m256i v_cols = _mm_set_epi32(cols, cols, cols, cols);\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n[REDACTED]/tmpy1yec_0r.cpp:29:31: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   29 |         const __m256i v_src = _mm_loadu_si256((__m256i *)(&src[r * cols]));\n      |                               ^~~~~~~~~~~~~~~\n      |                               _mm_loadu_si16\n[REDACTED]/tmpy1yec_0r.cpp:32:42: error: cannot convert \u2018const __m256i\u2019 to \u2018__m128i\u2019\n   32 |         __m256i v_result = _mm_add_epi32(v_dst, v_stride);\n      |                                          ^~~~~\n      |                                          |\n      |                                          const __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpy1yec_0r.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpy1yec_0r.cpp:33:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   33 |         _mm_storeu_si256((__m256i *)(&dst[r]), v_result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmpy1yec_0r.cpp:35:31: error: cannot convert \u2018const __m256i\u2019 to \u2018__m128i\u2019\n   35 |         v_dst = _mm_add_epi32(v_dst, v_cols);\n      |                               ^~~~~\n      |                               |\n      |                               const __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_2_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjfry_s_0.cpp: In function \u2018void strided_load_store_simd(const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpjfry_s_0.cpp:28:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i v_stride = _mm_set_epi32(stride, stride, stride, stride);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpjfry_s_0.cpp:29:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i v_cols = _mm_set_epi32(cols, cols, cols, cols);\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n[REDACTED]/tmpjfry_s_0.cpp:32:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   32 |         __m256i v_src = _mm_loadu_si256((__m256i *)(&src[r * cols]));\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmpjfry_s_0.cpp:35:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         v_dst = _mm_add_epi32(v_dst, v_stride);\n      |                               ^~~~~\n      |                               |\n      |                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpjfry_s_0.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpjfry_s_0.cpp:36:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         v_dst = _mm_mul_epi32(v_dst, v_cols);\n      |                               ^~~~~\n      |                               |\n      |                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpjfry_s_0.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpjfry_s_0.cpp:38:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   38 |         _mm_storeu_si256((__m256i *)(&dst[r]), v_dst);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_2_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxel960cr.cpp: In function \u2018void strided_load_store_simd(const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpxel960cr.cpp:25:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   25 |     __m256i v_stride = _mm_set_epi32(stride, stride, stride, stride);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpxel960cr.cpp:26:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   26 |     __m256i v_cols = _mm_set_epi32(cols, cols, cols, cols);\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n[REDACTED]/tmpxel960cr.cpp:29:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   29 |         __m256i v_src = _mm_loadu_si256((__m256i const *)(&src[r * cols]));\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmpxel960cr.cpp:32:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         v_dst = _mm_add_epi32(v_dst, v_stride);\n      |                               ^~~~~\n      |                               |\n      |                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpxel960cr.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpxel960cr.cpp:33:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   33 |         _mm_storeu_si256((__m256i *)(&dst[r]), v_dst);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_2_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzm1qeqi4.cpp: In function \u2018void strided_load_store_simd(const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpzm1qeqi4.cpp:28:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i v_stride = _mm_set_epi32(stride, stride, stride, stride);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpzm1qeqi4.cpp:29:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i v_cols = _mm_set_epi32(cols, cols, cols, cols);\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n"}
{"task_id": "SimdBench_2_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprmlc3s6z.cpp: In function \u2018void strided_load_store_simd(const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmprmlc3s6z.cpp:25:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   25 |     __m256i v_stride = _mm_set_epi32(stride, stride, stride, stride);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmprmlc3s6z.cpp:26:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   26 |     __m256i v_cols = _mm_set_epi32(cols, cols, cols, cols);\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n[REDACTED]/tmprmlc3s6z.cpp:29:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   29 |         __m256i v_src = _mm_loadu_si256((__m256i *)(&src[r * cols]));\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmprmlc3s6z.cpp:32:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         __m256i v_result = _mm_add_epi32(v_dst, v_stride);\n      |                                          ^~~~~\n      |                                          |\n      |                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmprmlc3s6z.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmprmlc3s6z.cpp:33:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   33 |         _mm_storeu_si256((__m256i *)(&dst[r]), v_result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmprmlc3s6z.cpp:38:34: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         v_result = _mm_add_epi32(v_dst, v_stride);\n      |                                  ^~~~~\n      |                                  |\n      |                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmprmlc3s6z.cpp:44:34: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |         v_result = _mm_add_epi32(v_dst, v_stride);\n      |                                  ^~~~~\n      |                                  |\n      |                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_3_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9nbdgbvo.cpp: In function \u2018void indexed_access_simd(const float*, const int*, float*, size_t)\u2019:\n[REDACTED]/tmp9nbdgbvo.cpp:28:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i idx_vec = _mm256_set_epi32(indices[0], indices[1], indices[2], indices[3]);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp9nbdgbvo.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_3_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo_4fau90.cpp: In function \u2018void indexed_access_simd(const float*, const int*, float*, size_t)\u2019:\n[REDACTED]/tmpo_4fau90.cpp:28:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i idx_vec = _mm256_set_epi32(indices[0], indices[1], indices[2], indices[3]);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpo_4fau90.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpo_4fau90.cpp:38:39: error: cannot convert \u2018__m128i\u2019 to \u2018__m128\u2019 in initialization\n   38 |         __m128 idx_vec = _mm_set_epi32(indices[length / 4], indices[length / 4 + 1], indices[length / 4 + 2], indices[length / 4 + 3]);\n      |                          ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmpo_4fau90.cpp:42:46: error: cannot convert \u2018__m128\u2019 to \u2018__m128i\u2019\n   42 |         dst_vec = _mm_permutevar_ps(dst_vec, idx_vec);\n      |                                              ^~~~~~~\n      |                                              |\n      |                                              __m128\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:635:40: note:   initializing argument 2 of \u2018__m128 _mm_permutevar_ps(__m128, __m128i)\u2019\n  635 | _mm_permutevar_ps (__m128 __A, __m128i __C)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_3_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1kow7oxk.cpp: In function \u2018void indexed_access_simd(const float*, const int*, float*, size_t)\u2019:\n[REDACTED]/tmp1kow7oxk.cpp:28:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i idx_vec = _mm256_set_epi32(indices[0], indices[1], indices[2], indices[3]);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp1kow7oxk.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp1kow7oxk.cpp:32:61: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |         idx_vec = _mm256_add_epi32(idx_vec, _mm256_set_epi32(i, i + 1, i + 2, i + 3));\n      |                                             ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_3_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_3_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp52voplj5.cpp: In function \u2018void indexed_access_simd(const float*, const int*, float*, size_t)\u2019:\n[REDACTED]/tmp52voplj5.cpp:28:35: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i idx = _mm256_set_epi32(indices[0], indices[1], indices[2], indices[3]);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp52voplj5.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp52voplj5.cpp:38:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m128\u2019 in initialization\n   38 |         __m128 idx1 = _mm_set_epi32(indices[length - 4], indices[length - 3], indices[length - 2], indices[length - 1]);\n      |                       ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmp52voplj5.cpp:41:61: error: cannot convert \u2018__m128\u2019 to \u2018__m128i\u2019\n   41 |         __m128 dst_vec1 = _mm_maskload_ps(dst + length - 4, idx1);\n      |                                                             ^~~~\n      |                                                             |\n      |                                                             __m128\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:965:44: note:   initializing argument 2 of \u2018__m128 _mm_maskload_ps(const float*, __m128i)\u2019\n  965 | _mm_maskload_ps (float const *__P, __m128i __M)\n      |                                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_4_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp100wn21m.cpp:14:\n[REDACTED]/tmp100wn21m.cpp: In function \u2018void range_reverse_simd(int16_t*, uint64_t, uint64_t)\u2019:\n[REDACTED]/tmp100wn21m.cpp:41:33: error: cannot convert a vector of type \u2018__m128i\u2019 to type \u2018int\u2019 which has different size\n   41 |         __m128i reversed_vec1 = _mm_shuffle_epi32(vec1, vec2);\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp100wn21m.cpp:42:33: error: cannot convert a vector of type \u2018__m128i\u2019 to type \u2018int\u2019 which has different size\n   42 |         __m128i reversed_vec2 = _mm_shuffle_epi32(vec2, vec3);\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp100wn21m.cpp:56:33: error: cannot convert a vector of type \u2018__m128i\u2019 to type \u2018int\u2019 which has different size\n   56 |         __m128i reversed_vec1 = _mm_shuffle_epi32(vec1, vec2);\n      |                                 ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_4_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_4_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpepch82ax.cpp: In function \u2018void range_reverse_simd(int16_t*, uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpepch82ax.cpp:37:78: error: too few arguments to function \u2018__m256i _mm256_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   37 |         __m256i reversed_temp = _mm256_permutevar_epi8(temp, _mm256_setr_epi8(0, 7, 4, 5, 2, 1, 6, 3));\n      |                                                              ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpepch82ax.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1399:1: note: declared here\n 1399 | _mm256_setr_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpepch82ax.cpp:37:33: error: \u2018_mm256_permutevar_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi8\u2019?\n   37 |         __m256i reversed_temp = _mm256_permutevar_epi8(temp, _mm256_setr_epi8(0, 7, 4, 5, 2, 1, 6, 3));\n      |                                 ^~~~~~~~~~~~~~~~~~~~~~\n      |                                 _mm256_permutexvar_epi8\n"}
{"task_id": "SimdBench_4_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpm_1u40zy.cpp: In function \u2018void range_reverse_simd(int16_t*, uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpm_1u40zy.cpp:41:75: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   41 |         __m256i reversed_vec = _mm256_permutevar_epi8(vec, _mm256_set_epi8(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpm_1u40zy.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpm_1u40zy.cpp:41:32: error: \u2018_mm256_permutevar_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi8\u2019?\n   41 |         __m256i reversed_vec = _mm256_permutevar_epi8(vec, _mm256_set_epi8(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                ^~~~~~~~~~~~~~~~~~~~~~\n      |                                _mm256_permutexvar_epi8\n"}
{"task_id": "SimdBench_4_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpe06ba9xh.cpp: In function \u2018void range_reverse_simd(int16_t*, uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpe06ba9xh.cpp:46:84: error: too few arguments to function \u2018__m256i _mm256_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   46 |             __m256i reversed_chunk = _mm256_permutevar_epi8(chunk, _mm256_setr_epi8(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpe06ba9xh.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1399:1: note: declared here\n 1399 | _mm256_setr_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpe06ba9xh.cpp:46:38: error: \u2018_mm256_permutevar_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi8\u2019?\n   46 |             __m256i reversed_chunk = _mm256_permutevar_epi8(chunk, _mm256_setr_epi8(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                      ^~~~~~~~~~~~~~~~~~~~~~\n      |                                      _mm256_permutexvar_epi8\n"}
{"task_id": "SimdBench_5_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_5_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_5_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_5_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_5_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_6_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpkibo2cg6.cpp:14:\n[REDACTED]/tmpkibo2cg6.cpp: In function \u2018void blocked_matrix_transpose_simd(const int16_t*, int16_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpkibo2cg6.cpp:57:73: error: cannot convert a vector of type \u2018__m128i\u2019 to type \u2018int\u2019 which has different size\n   57 |                 _mm_storeu_si128((__m128i *)(dst + j * block_size + k), _mm_shuffle_epi32(row_block[k], col_block[k]));\n      |                                                                         ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_6_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp709srn7r.cpp:14:\n[REDACTED]/tmp709srn7r.cpp: In function \u2018void blocked_matrix_transpose_simd(const int16_t*, int16_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp709srn7r.cpp:54:45: error: cannot convert a vector of type \u2018__m128i\u2019 to type \u2018int\u2019 which has different size\n   54 |                 _mm_storeu_si128(dst_row++, _mm_shuffle_epi32(vec1, vec2));\n      |                                             ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp709srn7r.cpp:55:45: error: cannot convert a vector of type \u2018__m128i\u2019 to type \u2018int\u2019 which has different size\n   55 |                 _mm_storeu_si128(dst_row++, _mm_shuffle_epi32(vec3, vec4));\n      |                                             ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_6_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpfry2dmq5.cpp:36:32: error: \u2018__forceinline\u2019 does not name a type\n   36 | __attribute__((always_inline)) __forceinline void blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n      |                                ^~~~~~~~~~~~~\n[REDACTED]/tmpfry2dmq5.cpp: In function \u2018bool correctness_check(int)\u2019:\n[REDACTED]/tmpfry2dmq5.cpp:64:9: error: \u2018blocked_matrix_transpose_simd\u2019 was not declared in this scope; did you mean \u2018blocked_matrix_transpose\u2019?\n   64 |         blocked_matrix_transpose_simd(src.data(), dst_simd.data(), rows, cols, block_size);\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |         blocked_matrix_transpose\n"}
{"task_id": "SimdBench_6_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_6_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpoqtd1f9f.cpp:45:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   45 |             __m128i transposed_row = _mm_shuffle_epi32(row, row, 0b1010); // Swap elements\n      |                                                                        ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpoqtd1f9f.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpoqtd1f9f.cpp:46:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   46 |             __m128i transposed_col = _mm_shuffle_epi32(col, col, 0b1010);\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpoqtd1f9f.cpp: In function \u2018void blocked_matrix_transpose_simd(const int16_t*, int16_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpoqtd1f9f.cpp:45:38: error: \u2018_mm_shuffle_epi32\u2019 was not declared in this scope\n   45 |             __m128i transposed_row = _mm_shuffle_epi32(row, row, 0b1010); // Swap elements\n      |                                      ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_7_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8h121fh_.cpp: In function \u2018float diagonal_sum_3d_simd(const float*, size_t)\u2019:\n[REDACTED]/tmp8h121fh_.cpp:31:46: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     const __m256i dim_mask = _mm256_set_epi32(dim - 1, dim - 1, dim - 1, dim - 1);\n      |                              ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8h121fh_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp8h121fh_.cpp:32:47: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |     const __m256i dim_shift = _mm256_set_epi32(0, 4, 8, 12);\n      |                               ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp8h121fh_.cpp:37:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i idx = _mm256_set_epi32(i, i + 1, i + 2, i + 3);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp8h121fh_.cpp:38:42: error: invalid operands of types \u2018const float*\u2019 and \u2018__m256i\u2019 to binary \u2018operator+\u2019\n   38 |         __m256 v = _mm256_loadu_ps(array + idx);\n      |                                    ~~~~~ ^ ~~~\n      |                                    |       |\n      |                                    |       __m256i\n      |                                    const float*\n[REDACTED]/tmp8h121fh_.cpp:39:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   39 |         __m256 mask = _mm256_cmpeq_epi32(idx, dim_mask);\n      |                       ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                                         |\n      |                                         __m256i\n[REDACTED]/tmp8h121fh_.cpp:41:16: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   41 |         sum += _mm256_reduce_add_ps(result);\n      |                ^~~~~~~~~~~~~~~~~~~~\n      |                _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_7_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpyjdouhn2.cpp: In function \u2018float diagonal_sum_3d_simd(const float*, size_t)\u2019:\n[REDACTED]/tmpyjdouhn2.cpp:27:46: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   27 |     const __m256i dim_mask = _mm256_set_epi32(dim - 1, dim - 1, dim - 1, dim - 1);\n      |                              ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpyjdouhn2.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpyjdouhn2.cpp:28:43: error: cannot convert \u2018__m256\u2019 to \u2018const __m256i\u2019 in initialization\n   28 |     const __m256i zero = _mm256_setzero_ps();\n      |                          ~~~~~~~~~~~~~~~~~^~\n      |                                           |\n      |                                           __m256\n[REDACTED]/tmpyjdouhn2.cpp:29:18: error: cannot convert \u2018const __m256i\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 sum = zero;\n      |                  ^~~~\n      |                  |\n      |                  const __m256i\n[REDACTED]/tmpyjdouhn2.cpp:32:45: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |         const __m256i idx = _mm256_set_epi32(i, i + 1, i + 2, i + 3);\n      |                             ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpyjdouhn2.cpp:33:48: error: invalid operands of types \u2018const float*\u2019 and \u2018const __m256i\u2019 to binary \u2018operator+\u2019\n   33 |         const __m256 v = _mm256_loadu_ps(array + idx);\n      |                                          ~~~~~ ^ ~~~\n      |                                          |       |\n      |                                          |       const __m256i\n      |                                          const float*\n[REDACTED]/tmpyjdouhn2.cpp:34:47: error: cannot convert \u2018__m256i\u2019 to \u2018const __m256\u2019 in initialization\n   34 |         const __m256 mask = _mm256_cmpeq_epi32(idx, dim_mask);\n      |                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                                               |\n      |                                               __m256i\n[REDACTED]/tmpyjdouhn2.cpp:38:12: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   38 |     return _mm256_reduce_add_ps(sum, _mm256_setzero_ps());\n      |            ^~~~~~~~~~~~~~~~~~~~\n      |            _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_7_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpl5vn0kot.cpp:29:32: error: \u2018__forceinline\u2019 does not name a type\n   29 | __attribute__((always_inline)) __forceinline float diagonal_sum_3d_simd(const float *array, size_t dim) {\n      |                                ^~~~~~~~~~~~~\n[REDACTED]/tmpl5vn0kot.cpp: In function \u2018bool correctness_check(int)\u2019:\n[REDACTED]/tmpl5vn0kot.cpp:54:26: error: \u2018diagonal_sum_3d_simd\u2019 was not declared in this scope; did you mean \u2018diagonal_sum_3d\u2019?\n   54 |         float sum_simd = diagonal_sum_3d_simd(array_simd.data(), length);\n      |                          ^~~~~~~~~~~~~~~~~~~~\n      |                          diagonal_sum_3d\n"}
{"task_id": "SimdBench_7_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_1_9a7cf.cpp:29:42: error: expected constructor, destructor, or type conversion before \u2018(\u2019 token\n   29 | __attribute__((always_inline)) __target__(\"avx2\")\n      |                                          ^\n[REDACTED]/tmp_1_9a7cf.cpp: In function \u2018bool correctness_check(int)\u2019:\n[REDACTED]/tmp_1_9a7cf.cpp:54:26: error: \u2018diagonal_sum_3d_simd\u2019 was not declared in this scope; did you mean \u2018diagonal_sum_3d\u2019?\n   54 |         float sum_simd = diagonal_sum_3d_simd(array_simd.data(), length);\n      |                          ^~~~~~~~~~~~~~~~~~~~\n      |                          diagonal_sum_3d\n"}
{"task_id": "SimdBench_7_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdjsa3_v_.cpp:29:42: error: expected constructor, destructor, or type conversion before \u2018(\u2019 token\n   29 | __attribute__((always_inline)) __target__(\"avx2\")\n      |                                          ^\n[REDACTED]/tmpdjsa3_v_.cpp: In function \u2018bool correctness_check(int)\u2019:\n[REDACTED]/tmpdjsa3_v_.cpp:55:26: error: \u2018diagonal_sum_3d_simd\u2019 was not declared in this scope; did you mean \u2018diagonal_sum_3d\u2019?\n   55 |         float sum_simd = diagonal_sum_3d_simd(array_simd.data(), length);\n      |                          ^~~~~~~~~~~~~~~~~~~~\n      |                          diagonal_sum_3d\n"}
{"task_id": "SimdBench_8_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpk0ho0b_e.cpp: In function \u2018void conditional_scale_simd(const double*, double*, size_t, size_t, double, double)\u2019:\n[REDACTED]/tmpk0ho0b_e.cpp:31:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set1_epi32(0); // Initialize mask with zeros\n      |                    ~~~~~~~~~~~~~~^~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpk0ho0b_e.cpp:37:61: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   37 |                 __m256 scaled_val = _mm_mul_ps(_mm_loadu_ps(&val), _mm_set1_ps(scale));\n      |                                                             ^~~~\n      |                                                             |\n      |                                                             const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpk0ho0b_e.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpk0ho0b_e.cpp:38:31: error: cannot convert \u2018double*\u2019 to \u2018float*\u2019\n   38 |                 _mm_storeu_ps(&dst[i * cols + j], scaled_val);\n      |                               ^~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_8_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqfe1_81y.cpp: In function \u2018void conditional_scale_simd(const double*, double*, size_t, size_t, double, double)\u2019:\n[REDACTED]/tmpqfe1_81y.cpp:34:65: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019\n   34 |                 __m256 scaled_val = _mm256_mul_ps(_mm256_set1_pd(val), _mm256_set1_pd(scale));\n      |                                                   ~~~~~~~~~~~~~~^~~~~\n      |                                                                 |\n      |                                                                 __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqfe1_81y.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpqfe1_81y.cpp:35:54: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   35 |                 _mm256_storeu_pd(dst + i * cols + j, scaled_val);\n      |                                                      ^~~~~~~~~~\n      |                                                      |\n      |                                                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_8_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpom4o048k.cpp: In function \u2018void conditional_scale_simd(const double*, double*, size_t, size_t, double, double)\u2019:\n[REDACTED]/tmpom4o048k.cpp:34:65: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019\n   34 |                 __m256 scaled_val = _mm256_mul_ps(_mm256_set1_pd(val), _mm256_set1_pd(scale));\n      |                                                   ~~~~~~~~~~~~~~^~~~~\n      |                                                                 |\n      |                                                                 __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpom4o048k.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpom4o048k.cpp:35:54: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   35 |                 _mm256_storeu_pd(dst + i * cols + j, scaled_val);\n      |                                                      ^~~~~~~~~~\n      |                                                      |\n      |                                                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_8_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpeui9kcgq.cpp: In function \u2018void conditional_scale_simd(const double*, double*, size_t, size_t, double, double)\u2019:\n[REDACTED]/tmpeui9kcgq.cpp:36:40: error: \u2018_mm256_cmpgt_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_pd\u2019?\n   36 |             const __m256d scaled_val = _mm256_cmpgt_pd(val, _mm256_set1_pd(threshold));\n      |                                        ^~~~~~~~~~~~~~~\n      |                                        _mm256_cmp_pd\n[REDACTED]/tmpeui9kcgq.cpp:37:74: error: cannot convert \u2018__m256i\u2019 to \u2018__m256d\u2019\n   37 |             const __m256d masked_val = _mm256_blendv_pd(scaled_val, val, mask);\n      |                                                                          ^~~~\n      |                                                                          |\n      |                                                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpeui9kcgq.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:219:53: note:   initializing argument 3 of \u2018__m256d _mm256_blendv_pd(__m256d, __m256d, __m256d)\u2019\n  219 | _mm256_blendv_pd (__m256d __X, __m256d __Y, __m256d __M)\n      |                                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_8_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9pkv7vmy.cpp: In function \u2018void conditional_scale_simd(const double*, double*, size_t, size_t, double, double)\u2019:\n[REDACTED]/tmp9pkv7vmy.cpp:34:65: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019\n   34 |                 __m256 scaled_val = _mm256_mul_ps(_mm256_set1_pd(val), _mm256_set1_pd(scale));\n      |                                                   ~~~~~~~~~~~~~~^~~~~\n      |                                                                 |\n      |                                                                 __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp9pkv7vmy.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp9pkv7vmy.cpp:35:54: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   35 |                 _mm256_storeu_pd(dst + i * cols + j, scaled_val);\n      |                                                      ^~~~~~~~~~\n      |                                                      |\n      |                                                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_9_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpt_zbad_f.cpp: In function \u2018void reorder_matrix_rows_simd(const double*, double*, size_t, size_t, const size_t*)\u2019:\n[REDACTED]/tmpt_zbad_f.cpp:33:59: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   33 |         __m256i sorted_indices_vec = _mm256_permutevar_ps(idx_vec, indices_vec);\n      |                                                           ^~~~~~~\n      |                                                           |\n      |                                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpt_zbad_f.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:642:30: note:   initializing argument 1 of \u2018__m256 _mm256_permutevar_ps(__m256, __m256i)\u2019\n  642 | _mm256_permutevar_ps (__m256 __A, __m256i __C)\n      |                       ~~~~~~~^~~\n[REDACTED]/tmpt_zbad_f.cpp:34:72: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   34 |         __m256 sorted_src_vec = _mm256_permutevar_ps(_mm256_loadu_si256((__m256i *)(&src[i])), sorted_indices_vec);\n      |                                                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n      |                                                                        |\n      |                                                                        __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:642:30: note:   initializing argument 1 of \u2018__m256 _mm256_permutevar_ps(__m256, __m256i)\u2019\n  642 | _mm256_permutevar_ps (__m256 __A, __m256i __C)\n      |                       ~~~~~~~^~~\n[REDACTED]/tmpt_zbad_f.cpp:35:51: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   35 |         _mm256_storeu_si256((__m256i *)(&dst[i]), sorted_src_vec);\n      |                                                   ^~~~~~~~~~~~~~\n      |                                                   |\n      |                                                   __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_9_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpnemzvxwe.cpp:36:82: error: macro \"_mm256_shuffle_epi32\" passed 3 arguments, but takes just 2\n   36 |         __m256i dst_indices = _mm256_shuffle_epi32(src_indices, idx_vec, mask_vec);\n      |                                                                                  ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpnemzvxwe.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:616: note: macro \"_mm256_shuffle_epi32\" defined here\n  616 | #define _mm256_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpnemzvxwe.cpp: In function \u2018void reorder_matrix_rows_simd(const double*, double*, size_t, size_t, const size_t*)\u2019:\n[REDACTED]/tmpnemzvxwe.cpp:36:31: error: \u2018_mm256_shuffle_epi32\u2019 was not declared in this scope\n   36 |         __m256i dst_indices = _mm256_shuffle_epi32(src_indices, idx_vec, mask_vec);\n      |                               ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpnemzvxwe.cpp:38:43: error: cannot convert \u2018__m256d*\u2019 to \u2018const double*\u2019\n   38 |         __m256d src_row = _mm256_loadu_pd((__m256d *)(&src[dst_indices[0] * cols]));\n      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                           |\n      |                                           __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpnemzvxwe.cpp:39:43: error: cannot convert \u2018__m256d*\u2019 to \u2018const double*\u2019\n   39 |         __m256d dst_row = _mm256_loadu_pd((__m256d *)(&dst[i * cols]));\n      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                           |\n      |                                           __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpnemzvxwe.cpp:41:26: error: cannot convert \u2018__m256d*\u2019 to \u2018double*\u2019\n   41 |         _mm256_storeu_pd((__m256d *)(&dst[i * cols]), src_row);\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                          |\n      |                          __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:27: note:   initializing argument 1 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_9_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmputqe4i_7.cpp: In function \u2018void reorder_matrix_rows_simd(const double*, double*, size_t, size_t, const size_t*)\u2019:\n[REDACTED]/tmputqe4i_7.cpp:31:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     __m256i idx_vec = _mm256_set_epi32(indices[0], indices[1], indices[2], indices[3]);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmputqe4i_7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmputqe4i_7.cpp:33:32: error: \u2018_mm256_permutevar_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi32\u2019?\n   33 |     __m256i permuted_idx_vec = _mm256_permutevar_epi32(idx_vec, mask_vec);\n      |                                ^~~~~~~~~~~~~~~~~~~~~~~\n      |                                _mm256_permutexvar_epi32\n[REDACTED]/tmputqe4i_7.cpp:36:42: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   36 |         __m256 src_row = _mm256_loadu_ps(&src[i * cols]);\n      |                                          ^~~~~~~~~~~~~~\n      |                                          |\n      |                                          const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmputqe4i_7.cpp:37:42: error: cannot convert \u2018double*\u2019 to \u2018const float*\u2019\n   37 |         __m256 dst_row = _mm256_loadu_ps(&dst[i * cols]);\n      |                                          ^~~~~~~~~~~~~~\n      |                                          |\n      |                                          double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmputqe4i_7.cpp:40:26: error: cannot convert \u2018double*\u2019 to \u2018float*\u2019\n   40 |         _mm256_storeu_ps(&dst[i * cols], permuted_src_row);\n      |                          ^~~~~~~~~~~~~~\n      |                          |\n      |                          double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_9_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprm3llnoa.cpp: In function \u2018void reorder_matrix_rows_simd(const double*, double*, size_t, size_t, const size_t*)\u2019:\n[REDACTED]/tmprm3llnoa.cpp:28:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i idx_vec = _mm256_set_epi32(indices[0], indices[1], indices[2], indices[3]);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmprm3llnoa.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmprm3llnoa.cpp:30:32: error: \u2018_mm256_permutevar_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi32\u2019?\n   30 |     __m256i permuted_idx_vec = _mm256_permutevar_epi32(idx_vec, mask_vec);\n      |                                ^~~~~~~~~~~~~~~~~~~~~~~\n      |                                _mm256_permutexvar_epi32\n[REDACTED]/tmprm3llnoa.cpp:33:42: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   33 |         __m256 src_row = _mm256_loadu_ps(&src[i * cols]);\n      |                                          ^~~~~~~~~~~~~~\n      |                                          |\n      |                                          const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmprm3llnoa.cpp:34:42: error: cannot convert \u2018double*\u2019 to \u2018const float*\u2019\n   34 |         __m256 dst_row = _mm256_loadu_ps(&dst[i * cols]);\n      |                                          ^~~~~~~~~~~~~~\n      |                                          |\n      |                                          double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmprm3llnoa.cpp:37:26: error: cannot convert \u2018double*\u2019 to \u2018float*\u2019\n   37 |         _mm256_storeu_ps(&dst[i * cols], permuted_src_row);\n      |                          ^~~~~~~~~~~~~~\n      |                          |\n      |                          double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_9_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7p833jnj.cpp: In function \u2018void reorder_matrix_rows_simd(const double*, double*, size_t, size_t, const size_t*)\u2019:\n[REDACTED]/tmp7p833jnj.cpp:34:55: error: invalid types \u2018const double*[__m256i]\u2019 for array subscript\n   34 |         src_vec = _mm256_loadu_pd((const double *)&src[idx_vec]);\n      |                                                       ^\n[REDACTED]/tmp7p833jnj.cpp:35:35: error: void value not ignored as it ought to be\n   35 |         dst_vec = _mm256_storeu_pd((double *)&dst[i * cols], src_vec);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_10_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqksst_4b.cpp: In function \u2018void vector_vector_add_simd(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)\u2019:\n[REDACTED]/tmpqksst_4b.cpp:25:26: error: \u2018_mm256_set1_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   25 |     __m256i vec_scalar = _mm256_set1_epi64(scalar);\n      |                          ^~~~~~~~~~~~~~~~~\n      |                          _mm256_set1_epi64x\n"}
{"task_id": "SimdBench_10_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqo07xhl9.cpp: In function \u2018void vector_vector_add_simd(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)\u2019:\n[REDACTED]/tmpqo07xhl9.cpp:31:52: error: \u2018_mm256_set1_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   31 |         __m256i scaled_sum = _mm256_add_epi64(sum, _mm256_set1_epi64(scalar));\n      |                                                    ^~~~~~~~~~~~~~~~~\n      |                                                    _mm256_set1_epi64x\n[REDACTED]/tmpqo07xhl9.cpp:32:62: error: \u2018_MM_FROUND_TOWARD_ZERO\u2019 was not declared in this scope\n   32 |         __m256i rounded_sum = _mm256_round_epi32(scaled_sum, _MM_FROUND_TOWARD_ZERO);\n      |                                                              ^~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpqo07xhl9.cpp:32:31: error: \u2018_mm256_round_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_rorv_epi32\u2019?\n   32 |         __m256i rounded_sum = _mm256_round_epi32(scaled_sum, _MM_FROUND_TOWARD_ZERO);\n      |                               ^~~~~~~~~~~~~~~~~~\n      |                               _mm256_rorv_epi32\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqo07xhl9.cpp:16:\n[REDACTED]/tmpqo07xhl9.cpp:33:22: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019 in assignment\n   33 |         *dst_vec++ = _mm256_extract_epi64(rounded_sum, 0);\n      |                      ^~~~~~~~~~~~~~~~~~~~\n      |                      |\n      |                      long long int\n"}
{"task_id": "SimdBench_10_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6r236rux.cpp: In function \u2018void vector_vector_add_simd(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)\u2019:\n[REDACTED]/tmp6r236rux.cpp:34:37: error: \u2018_mm256_set1_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   34 |         sum = _mm256_add_epi64(sum, _mm256_set1_epi64(scalar));\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm256_set1_epi64x\n[REDACTED]/tmp6r236rux.cpp:35:15: error: \u2018_mm256_div_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi64\u2019?\n   35 |         sum = _mm256_div_epi64(sum, _mm256_set1_epi64(2));\n      |               ^~~~~~~~~~~~~~~~\n      |               _mm256_min_epi64\n"}
{"task_id": "SimdBench_10_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplnumx8qy.cpp: In function \u2018void vector_vector_add_simd(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)\u2019:\n[REDACTED]/tmplnumx8qy.cpp:31:37: error: \u2018_mm256_set1_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   31 |         sum = _mm256_add_epi64(sum, _mm256_set1_epi64(scalar));\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm256_set1_epi64x\n[REDACTED]/tmplnumx8qy.cpp:32:15: error: \u2018_mm256_div_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi64\u2019?\n   32 |         sum = _mm256_div_epi64(sum, _mm256_set1_epi64(2));\n      |               ^~~~~~~~~~~~~~~~\n      |               _mm256_min_epi64\n[REDACTED]/tmplnumx8qy.cpp:38:41: error: cannot convert \u2018__m256i\u2019 to \u2018int64_t\u2019 {aka \u2018long int\u2019} in assignment\n   38 |         *dst++ = (*vec_src1++) + scalar + (*vec_src2++) / 2;\n      |                  ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n      |                                         |\n      |                                         __m256i\n"}
{"task_id": "SimdBench_10_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpg_6jai3x.cpp: In function \u2018void vector_vector_add_simd(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)\u2019:\n[REDACTED]/tmpg_6jai3x.cpp:28:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i vec_scalar = _mm_set_epi64x(scalar, scalar);\n      |                          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmpg_6jai3x.cpp:32:28: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   32 |         __m256i vec_src1 = _mm_loadu_si256((__m256i *)(&src1[i * 8]));\n      |                            ^~~~~~~~~~~~~~~\n      |                            _mm_loadu_si16\n[REDACTED]/tmpg_6jai3x.cpp:35:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         vec_result = _mm_add_epi64(vec_src1, vec_src2);\n      |                                    ^~~~~~~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpg_6jai3x.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1076:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi64(__m128i, __m128i)\u2019\n 1076 | _mm_add_epi64 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpg_6jai3x.cpp:36:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         vec_result = _mm_add_epi64(vec_result, vec_scalar);\n      |                                    ^~~~~~~~~~\n      |                                    |\n      |                                    __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1076:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi64(__m128i, __m128i)\u2019\n 1076 | _mm_add_epi64 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpg_6jai3x.cpp:38:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   38 |         _mm_storeu_si256((__m256i *)(&dst[i * 8]), vec_result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_11_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmc0v_hix.cpp: In function \u2018int vector_even_min_simd(const int*, size_t)\u2019:\n[REDACTED]/tmpmc0v_hix.cpp:38:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |         __m256i current = _mm_loadu_si256((__m256i *)(src + i));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpmc0v_hix.cpp:39:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i even_mask = _mm_and_si256(current, mask);\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpmc0v_hix.cpp:16:\n[REDACTED]/tmpmc0v_hix.cpp:47:19: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   47 |         result |= _mm_extract_epi32(min_even, i);\n      |                   ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_11_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpts9yq1t_.cpp: In function \u2018int vector_even_min_simd(const int*, size_t)\u2019:\n[REDACTED]/tmpts9yq1t_.cpp:36:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   36 |     __m256i mask = _mm256_set_epi32(0, 1, 0, 1);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpts9yq1t_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpts9yq1t_.cpp:39:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i current = _mm_loadu_si256((__m256i *)(src + i));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpts9yq1t_.cpp:40:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   40 |         __m256i even_mask = _mm_and_si256(mask, current);\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpts9yq1t_.cpp:48:19: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   48 |         result |= _mm_extract_epi32(min_even, i);\n      |                   ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_11_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppaw76z2o.cpp: In function \u2018int vector_even_min_simd(const int*, size_t)\u2019:\n[REDACTED]/tmppaw76z2o.cpp:35:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask = _mm256_set_epi32(0, 2, 4, 6);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmppaw76z2o.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmppaw76z2o.cpp:41:76: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   41 |         __m256i even_min = _mm256_min_ps(_mm256_castsi256_ps(even_values), min_even);\n      |                                                                            ^~~~~~~~\n      |                                                                            |\n      |                                                                            __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:306:35: note:   initializing argument 2 of \u2018__m256 _mm256_min_ps(__m256, __m256)\u2019\n  306 | _mm256_min_ps (__m256 __A, __m256 __B)\n      |                            ~~~~~~~^~~\n[REDACTED]/tmppaw76z2o.cpp:42:37: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   42 |         min_even = _mm256_blendv_ps(min_even, even_min, even_mask);\n      |                                     ^~~~~~~~\n      |                                     |\n      |                                     __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:227:26: note:   initializing argument 1 of \u2018__m256 _mm256_blendv_ps(__m256, __m256, __m256)\u2019\n  227 | _mm256_blendv_ps (__m256 __X, __m256 __Y, __m256 __M)\n      |                   ~~~~~~~^~~\n[REDACTED]/tmppaw76z2o.cpp:46:30: error: \u2018_mm256_castps_si32\u2019 was not declared in this scope; did you mean \u2018_mm256_castps_si256\u2019?\n   46 |     _mm_storeu_si32(&result, _mm256_castps_si32(min_even));\n      |                              ^~~~~~~~~~~~~~~~~~\n      |                              _mm256_castps_si256\n"}
{"task_id": "SimdBench_11_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_11_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp19121lap.cpp: In function \u2018int vector_even_min_simd(const int*, size_t)\u2019:\n[REDACTED]/tmp19121lap.cpp:34:42: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     const __m256i mask = _mm256_set_epi32(0, 2, 4, 6);\n      |                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp19121lap.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp19121lap.cpp:40:20: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   40 |         min_even = _mm256_blendv_epi32(min_even, min_even_vec, _mm256_cmpgt_epi32(even_vec, min_even));\n      |                    ^~~~~~~~~~~~~~~~~~~\n      |                    _mm256_blend_epi32\n[REDACTED]/tmp19121lap.cpp:44:30: error: cannot convert \u2018int\u2019 to \u2018__m128i\u2019\n   44 |     _mm_storeu_si32(&result, _mm256_extract_epi32(min_even, 0));\n      |                              ^~~~~~~~~~~~~~~~~~~~\n      |                              |\n      |                              int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp19121lap.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_12_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_12_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqy1f71jn.cpp: In function \u2018void mixed_right_shift_simd(const int*, int*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpqy1f71jn.cpp:34:28: error: \u2018_mm256_castsi256_si32\u2019 was not declared in this scope; did you mean \u2018_mm256_cvtsi256_si32\u2019?\n   34 |     __m256i cast_logical = _mm256_castsi256_si32(logical_shifted);\n      |                            ^~~~~~~~~~~~~~~~~~~~~\n      |                            _mm256_cvtsi256_si32\n[REDACTED]/tmpqy1f71jn.cpp:35:46: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i shifted_back = _mm256_cvtepi32_ps(cast_logical);\n      |                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                              |\n      |                                              __m256\n[REDACTED]/tmpqy1f71jn.cpp:36:39: error: \u2018_mm256_roundps\u2019 was not declared in this scope; did you mean \u2018_mm256_round_ps\u2019?\n   36 |     __m256i logical_shifted_rounded = _mm256_roundps(shifted_back, _MM_FROUND_TO_ZERO);\n      |                                       ^~~~~~~~~~~~~~\n      |                                       _mm256_round_ps\n[REDACTED]/tmpqy1f71jn.cpp:37:37: error: \u2018_mm256_cvtss_si32\u2019 was not declared in this scope; did you mean \u2018_mm256_cvtss_f32\u2019?\n   37 |     __m256i final_logical_shifted = _mm256_cvtss_si32(logical_shifted_rounded);\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm256_cvtss_f32\n"}
{"task_id": "SimdBench_12_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbxqol_xm.cpp: In function \u2018void mixed_right_shift_simd(const int*, int*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpbxqol_xm.cpp:33:70: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019\n   33 |     __m256i logical_shifted = _mm256_srai_epi32(_mm256_cvtepi32_epi16(src_vec), shift);\n      |                                                 ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n      |                                                                      |\n      |                                                                      __m128i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpbxqol_xm.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:724:28: note:   initializing argument 1 of \u2018__m256i _mm256_srai_epi32(__m256i, int)\u2019\n  724 | _mm256_srai_epi32 (__m256i __A, int __B)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpbxqol_xm.cpp:34:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |     logical_shifted = _mm256_cvtepi16_epi32(logical_shifted);\n      |                                             ^~~~~~~~~~~~~~~\n      |                                             |\n      |                                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:461:32: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepi16_epi32(__m128i)\u2019\n  461 | _mm256_cvtepi16_epi32 (__m128i __X)\n      |                        ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_12_AVX", "passed": false, "result": "runtime failed: double free or corruption (out)\n"}
{"task_id": "SimdBench_12_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpoixbltcc.cpp: In function \u2018void mixed_right_shift_simd(const int*, int*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpoixbltcc.cpp:43:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   43 |         src_vec = _mm_loadu_si256((__m256i const *)(src + i));\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n"}
{"task_id": "SimdBench_13_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo90wn8g5.cpp: In function \u2018int64_t matrix_sum_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmpo90wn8g5.cpp:38:20: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   38 |             sum += _mm256_reduce_add_epi64(vec);\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~\n      |                    _mm512_reduce_add_epi64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpo90wn8g5.cpp:16:\n[REDACTED]/tmpo90wn8g5.cpp:42:41: error: cannot convert a value of type \u2018__m128i\u2019 to vector type \u2018__m256i\u2019 which has different size\n   42 |             sum += _mm_reduce_add_epi64(_mm256_extractf128_si256(vec, 0)) +\n      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpo90wn8g5.cpp:42:20: error: \u2018_mm_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   42 |             sum += _mm_reduce_add_epi64(_mm256_extractf128_si256(vec, 0)) +\n      |                    ^~~~~~~~~~~~~~~~~~~~\n      |                    _mm512_reduce_add_epi64\n[REDACTED]/tmpo90wn8g5.cpp:43:41: error: cannot convert a value of type \u2018__m128i\u2019 to vector type \u2018__m256i\u2019 which has different size\n   43 |                    _mm_reduce_add_epi64(_mm256_extractf128_si256(vec, 1));\n      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_13_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp454z0fxw.cpp: In function \u2018int64_t matrix_sum_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmp454z0fxw.cpp:37:16: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   37 |         sum += _mm256_reduce_add_epi64(vec);\n      |                ^~~~~~~~~~~~~~~~~~~~~~~\n      |                _mm512_reduce_add_epi64\n"}
{"task_id": "SimdBench_13_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp5h4hy80y.cpp:16:\n[REDACTED]/tmp5h4hy80y.cpp: In function \u2018int64_t matrix_sum_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmp5h4hy80y.cpp:42:19: error: the last argument must be a 1-bit immediate\n   42 |         result += _mm256_extract_epi64(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmp5h4hy80y.cpp:42:19: error: selector must be an integer constant in the range [0, 1]\n   42 |         result += _mm256_extract_epi64(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_13_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpfl9zota5.cpp:16:\n[REDACTED]/tmpfl9zota5.cpp: In function \u2018int64_t matrix_sum_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmpfl9zota5.cpp:42:19: error: the last argument must be a 1-bit immediate\n   42 |         result += _mm256_extract_epi64(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpfl9zota5.cpp:42:19: error: selector must be an integer constant in the range [0, 1]\n   42 |         result += _mm256_extract_epi64(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_13_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpuzcp8ue5.cpp:16:\n[REDACTED]/tmpuzcp8ue5.cpp: In function \u2018int64_t matrix_sum_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmpuzcp8ue5.cpp:40:43: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   40 |     int64_t result = _mm256_extract_epi64(_mm256_reduce_add_epi64(sum), 0);\n      |                                           ^~~~~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_14_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_dfapt16.cpp: In function \u2018size_t argmax_simd(const int8_t*, size_t)\u2019:\n[REDACTED]/tmp_dfapt16.cpp:35:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i max_val = _mm_set1_epi8(-128); // Initialize max_val to -128 (the smallest possible 8-bit integer)\n      |                       ~~~~~~~~~~~~~^~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmp_dfapt16.cpp:39:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i vec = _mm_loadu_si256((__m256i *)(src + i));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp_dfapt16.cpp:40:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         __m256i cmp = _mm_cmpgt_epi8(vec, max_val);\n      |                                      ^~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_dfapt16.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp_dfapt16.cpp:41:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         __m256i mask = _mm_movemask_epi8(cmp);\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmp_dfapt16.cpp:43:18: error: could not convert \u2018((mask != (__m256i){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   43 |         if (mask != 0) {\n      |             ~~~~~^~~~\n      |                  |\n      |                  __vector(4) long int\n[REDACTED]/tmp_dfapt16.cpp:44:40: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   44 |             size_t idx = __builtin_ctz(mask); // Find the index of the first set bit\n      |                                        ^~~~\n      |                                        |\n      |                                        __m256i\n<built-in>: note:   initializing argument 1 of \u2018int __builtin_ctz(unsigned int)\u2019\n[REDACTED]/tmp_dfapt16.cpp:57:12: error: \u2018i\u2019 was not declared in this scope\n   57 |     for (; i < length; ++i) {\n      |            ^\n"}
{"task_id": "SimdBench_14_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7fgre7iq.cpp: In function \u2018size_t argmax_simd(const int8_t*, size_t)\u2019:\n[REDACTED]/tmp7fgre7iq.cpp:41:44: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   41 |         __m256i mask = _mm256_movemask_epi8(cmp);\n      |                        ~~~~~~~~~~~~~~~~~~~~^~~~~\n      |                                            |\n      |                                            int\n[REDACTED]/tmp7fgre7iq.cpp:43:18: error: could not convert \u2018((mask != (__m256i){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   43 |         if (mask != 0) {\n      |             ~~~~~^~~~\n      |                  |\n      |                  __vector(4) long int\n[REDACTED]/tmp7fgre7iq.cpp:51:12: error: \u2018i\u2019 was not declared in this scope\n   51 |     for (; i < length; ++i) {\n      |            ^\n"}
{"task_id": "SimdBench_14_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpda0qtcgf.cpp: In function \u2018size_t argmax_simd(const int8_t*, size_t)\u2019:\n[REDACTED]/tmpda0qtcgf.cpp:35:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i max_val = _mm_set1_epi8(-128); // Initialize max_val to -128 (the smallest possible 8-bit integer)\n      |                       ~~~~~~~~~~~~~^~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmpda0qtcgf.cpp:39:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i vec = _mm_loadu_si256((__m256i *)(src + i));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpda0qtcgf.cpp:40:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         __m256i cmp = _mm_cmpgt_epi8(vec, max_val);\n      |                                      ^~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpda0qtcgf.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpda0qtcgf.cpp:41:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         __m256i mask = _mm_movemask_epi8(cmp);\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpda0qtcgf.cpp:43:36: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   43 |         size_t idx = __builtin_ctz(mask); // Find the first set bit in the mask\n      |                                    ^~~~\n      |                                    |\n      |                                    __m256i\n<built-in>: note:   initializing argument 1 of \u2018int __builtin_ctz(unsigned int)\u2019\n[REDACTED]/tmpda0qtcgf.cpp:49:12: error: \u2018i\u2019 was not declared in this scope\n   49 |     for (; i < length; ++i) {\n      |            ^\n"}
{"task_id": "SimdBench_14_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi5a52kad.cpp: In function \u2018size_t argmax_simd(const int8_t*, size_t)\u2019:\n[REDACTED]/tmpi5a52kad.cpp:41:62: error: too few arguments to function \u2018__m256i _mm256_setr_epi32(int, int, int, int, int, int, int, int)\u2019\n   41 |         __m256i idx = _mm256_and_si256(cmp, _mm256_setr_epi32(0, 4, 8, 12));\n      |                                             ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpi5a52kad.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1380:1: note: declared here\n 1380 | _mm256_setr_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpi5a52kad.cpp:42:44: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   42 |         __m256i mask = _mm256_movemask_epi8(idx);\n      |                        ~~~~~~~~~~~~~~~~~~~~^~~~~\n      |                                            |\n      |                                            int\n[REDACTED]/tmpi5a52kad.cpp:44:18: error: could not convert \u2018((mask != (__m256i){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   44 |         if (mask != 0) {\n      |             ~~~~~^~~~\n      |                  |\n      |                  __vector(4) long int\n"}
{"task_id": "SimdBench_14_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8ovsltcy.cpp: In function \u2018size_t argmax_simd(const int8_t*, size_t)\u2019:\n[REDACTED]/tmp8ovsltcy.cpp:35:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i max_val = _mm_set1_epi8(-128); // Initialize max_val to -128 (the smallest possible int8_t)\n      |                       ~~~~~~~~~~~~~^~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmp8ovsltcy.cpp:39:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i vec = _mm_loadu_si256((__m256i *)(&src[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp8ovsltcy.cpp:40:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         __m256i cmp = _mm_cmpgt_epi8(vec, max_val);\n      |                                      ^~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp8ovsltcy.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp8ovsltcy.cpp:41:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         __m256i mask = _mm_movemask_epi8(cmp);\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmp8ovsltcy.cpp:43:41: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   43 |         size_t idx = i + _mm_popcnt_u32(mask);\n      |                                         ^~~~\n      |                                         |\n      |                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/x86gprintrin.h:73,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:27,\n                 from [REDACTED]/tmp8ovsltcy.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/popcntintrin.h:35:30: note:   initializing argument 1 of \u2018int _mm_popcnt_u32(unsigned int)\u2019\n   35 | _mm_popcnt_u32 (unsigned int __X)\n      |                 ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp8ovsltcy.cpp:49:12: error: \u2018i\u2019 was not declared in this scope\n   49 |     for (; i < length; ++i) {\n      |            ^\n"}
{"task_id": "SimdBench_15_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw88eepb3.cpp: In function \u2018void vector_blend_simd(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)\u2019:\n[REDACTED]/tmpw88eepb3.cpp:25:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   25 |     __m256i mask_vec = _mm256_set_epi32(mask & 0xFF, mask & 0xFF00, mask & 0xFF0000, mask & 0xFF000000);\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpw88eepb3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_15_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2o1wkj0z.cpp: In function \u2018void vector_blend_simd(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)\u2019:\n[REDACTED]/tmp2o1wkj0z.cpp:25:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   25 |     __m256i mask_vec = _mm_set_epi32(mask & 0xFF, mask & 0xFF, mask & 0xFF, mask & 0xFF);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp2o1wkj0z.cpp:30:20: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         src1_vec = _mm_loadu_si256((__m256i*)(src1 + i));\n      |                    ^~~~~~~~~~~~~~~\n      |                    _mm_loadu_si16\n[REDACTED]/tmp2o1wkj0z.cpp:33:31: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   33 |         __m256i blended_vec = _mm_and_si256(src1_vec, mask_vec);\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_and_si64\n[REDACTED]/tmp2o1wkj0z.cpp:34:30: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   34 |         __m256i result_vec = _mm_or_si256(blended_vec, src2_vec);\n      |                              ^~~~~~~~~~~~\n      |                              _mm_or_si64\n[REDACTED]/tmp2o1wkj0z.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i*)(dst + i), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_15_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmperhhv25e.cpp: In function \u2018void vector_blend_simd(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)\u2019:\n[REDACTED]/tmperhhv25e.cpp:25:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   25 |     __m256i mask_vec = _mm256_set_epi32(mask & 0xFF, mask & 0xFF00, mask & 0xFF0000, mask & 0xFF000000);\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmperhhv25e.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_15_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvvr2f4fv.cpp: In function \u2018void vector_blend_simd(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)\u2019:\n[REDACTED]/tmpvvr2f4fv.cpp:25:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   25 |     __m256i mask_vec = _mm256_set_epi32(mask & 0xFF, mask & 0xFF00, mask & 0xFF0000, mask & 0xFF000000);\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpvvr2f4fv.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_15_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkzn57plj.cpp: In function \u2018void vector_blend_simd(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)\u2019:\n[REDACTED]/tmpkzn57plj.cpp:25:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   25 |     __m256i mask_vec = _mm_set_epi32(mask & 0xFF, mask & 0xFF00, mask & 0xFF0000, mask & 0xFF000000);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpkzn57plj.cpp:30:20: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         src1_vec = _mm_loadu_si256((__m256i*)(&src1[i]));\n      |                    ^~~~~~~~~~~~~~~\n      |                    _mm_loadu_si16\n[REDACTED]/tmpkzn57plj.cpp:33:31: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   33 |         __m256i blended_vec = _mm_and_si256(src1_vec, mask_vec);\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_and_si64\n[REDACTED]/tmpkzn57plj.cpp:34:30: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   34 |         __m256i result_vec = _mm_or_si256(blended_vec, src2_vec);\n      |                              ^~~~~~~~~~~~\n      |                              _mm_or_si64\n[REDACTED]/tmpkzn57plj.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i*)(&dst[i]), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_16_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgguvuqog.cpp: In function \u2018void population_count_simd(const uint32_t*, uint32_t*, size_t)\u2019:\n[REDACTED]/tmpgguvuqog.cpp:31:16: error: comparison between distinct pointer types \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} and \u2018const __m256i*\u2019 lacks a cast [-fpermissive]\n   31 |     while (src < end) {\n      |            ~~~~^~~~~\n[REDACTED]/tmpgguvuqog.cpp:32:40: error: cannot convert \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} to \u2018const __m256i_u*\u2019\n   32 |         __m256i v = _mm256_loadu_si256(src);\n      |                                        ^~~\n      |                                        |\n      |                                        const uint32_t* {aka const unsigned int*}\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpgguvuqog.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpgguvuqog.cpp:33:37: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   33 |         sum = _mm256_add_epi32(sum, _mm256_popcnt_u32(v));\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm_popcnt_u32\n[REDACTED]/tmpgguvuqog.cpp:38:16: error: comparison between distinct pointer types \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} and \u2018const __m256i*\u2019 lacks a cast [-fpermissive]\n   38 |     while (src < end) {\n      |            ~~~~^~~~~\n[REDACTED]/tmpgguvuqog.cpp:39:40: error: cannot convert \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} to \u2018const __m256i_u*\u2019\n   39 |         __m256i v = _mm256_loadu_si256(src);\n      |                                        ^~~\n      |                                        |\n      |                                        const uint32_t* {aka const unsigned int*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpgguvuqog.cpp:40:37: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   40 |         sum = _mm256_add_epi32(sum, _mm256_popcnt_u32(v));\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm_popcnt_u32\n"}
{"task_id": "SimdBench_16_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpry6kkyho.cpp: In function \u2018void population_count_simd(const uint32_t*, uint32_t*, size_t)\u2019:\n[REDACTED]/tmpry6kkyho.cpp:34:16: error: comparison between distinct pointer types \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} and \u2018const __m256i*\u2019 lacks a cast [-fpermissive]\n   34 |     while (src < end) {\n      |            ~~~~^~~~~\n[REDACTED]/tmpry6kkyho.cpp:35:40: error: cannot convert \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} to \u2018const __m256i_u*\u2019\n   35 |         __m256i v = _mm256_loadu_si256(src);\n      |                                        ^~~\n      |                                        |\n      |                                        const uint32_t* {aka const unsigned int*}\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpry6kkyho.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpry6kkyho.cpp:36:37: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   36 |         sum = _mm256_add_epi32(sum, _mm256_popcnt_u32(v));\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm_popcnt_u32\n[REDACTED]/tmpry6kkyho.cpp:42:40: error: cannot convert \u2018const uint32_t*\u2019 {aka \u2018const unsigned int*\u2019} to \u2018const __m256i_u*\u2019\n   42 |         __m256i v = _mm256_loadu_si256(src);\n      |                                        ^~~\n      |                                        |\n      |                                        const uint32_t* {aka const unsigned int*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpry6kkyho.cpp:43:37: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   43 |         sum = _mm256_add_epi32(sum, _mm256_popcnt_u32(v));\n      |                                     ^~~~~~~~~~~~~~~~~\n      |                                     _mm_popcnt_u32\n"}
{"task_id": "SimdBench_16_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpuk63_eus.cpp: In function \u2018void population_count_simd(const uint32_t*, uint32_t*, size_t)\u2019:\n[REDACTED]/tmpuk63_eus.cpp:31:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set_epi32(0x0F, 0x0F, 0x0F, 0x0F); // Mask to extract the least significant 4 bits\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpuk63_eus.cpp:32:19: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   32 |     __m256i sum = _mm_setzero_si256(); // Initialize sum to zero\n      |                   ^~~~~~~~~~~~~~~~~\n      |                   _mm_setzero_si64\n[REDACTED]/tmpuk63_eus.cpp:35:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   35 |         __m256i vec = _mm_loadu_si256((__m256i*)(&src[i])); // Load 8 elements from source into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpuk63_eus.cpp:36:15: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   36 |         vec = _mm_and_si256(vec, mask); // Extract the least significant 4 bits\n      |               ^~~~~~~~~~~~~\n      |               _mm_and_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpuk63_eus.cpp:16:\n[REDACTED]/tmpuk63_eus.cpp:37:30: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   37 |         vec = _mm_popcnt_u32(_mm_extract_epi32(vec, 0)); // Count the number of set bits\n      |                              ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpuk63_eus.cpp:38:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         sum = _mm_add_epi32(sum, vec); // Add the count to the sum\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpuk63_eus.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_16_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2pujiagt.cpp: In function \u2018void population_count_simd(const uint32_t*, uint32_t*, size_t)\u2019:\n[REDACTED]/tmp2pujiagt.cpp:28:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i mask = _mm_set_epi32(0x000000ff, 0x0000ffff, 0x00ffffff, 0xffffffff); // Mask to isolate the least significant byte\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp2pujiagt.cpp:29:19: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   29 |     __m256i sum = _mm_setzero_si256(); // Initialize sum to zero\n      |                   ^~~~~~~~~~~~~~~~~\n      |                   _mm_setzero_si64\n[REDACTED]/tmp2pujiagt.cpp:32:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   32 |         __m256i vec = _mm_loadu_si256((__m256i*)(&src[i])); // Load four elements from the source array into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp2pujiagt.cpp:33:15: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   33 |         vec = _mm_and_si256(vec, mask); // Apply the mask to isolate the least significant byte\n      |               ^~~~~~~~~~~~~\n      |               _mm_and_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp2pujiagt.cpp:16:\n[REDACTED]/tmp2pujiagt.cpp:34:30: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   34 |         vec = _mm_popcnt_u32(_mm_extract_epi32(vec, 0)); // Count the number of set bits in the least significant byte\n      |                              ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp2pujiagt.cpp:35:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         sum = _mm_add_epi32(sum, vec); // Add the count to the sum\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2pujiagt.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_16_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjlbryh0k.cpp: In function \u2018void population_count_simd(const uint32_t*, uint32_t*, size_t)\u2019:\n[REDACTED]/tmpjlbryh0k.cpp:32:42: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |     const __m256i mask = _mm256_set_epi32(0x55555555, 0x55555555, 0x55555555, 0x55555555);\n      |                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpjlbryh0k.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpjlbryh0k.cpp:35:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   35 |         __m256i vec = _mm_loadu_si256((__m256i*)(src + i));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpjlbryh0k.cpp:36:15: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   36 |         vec = _mm_and_si256(vec, mask);\n      |               ^~~~~~~~~~~~~\n      |               _mm_and_si64\n[REDACTED]/tmpjlbryh0k.cpp:37:47: error: \u2018_mm_setzero_si8\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   37 |         vec = _mm_add_epi32(_mm_sad_epu8(vec, _mm_setzero_si8()), _mm_sad_epu8(_mm_shuffle_epi8(vec, vec), _mm_setzero_si8()));\n      |                                               ^~~~~~~~~~~~~~~\n      |                                               _mm_setzero_si64\n[REDACTED]/tmpjlbryh0k.cpp:37:97: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         vec = _mm_add_epi32(_mm_sad_epu8(vec, _mm_setzero_si8()), _mm_sad_epu8(_mm_shuffle_epi8(vec, vec), _mm_setzero_si8()));\n      |                                                                                                 ^~~\n      |                                                                                                 |\n      |                                                                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpjlbryh0k.cpp:38:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         sum = _mm_add_epi32(sum, vec);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpjlbryh0k.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpjlbryh0k.cpp:43:18: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |         *dst++ = _mm_extract_epi32(sum, j);\n      |                  ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_17_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp4kds60y1.cpp: In function \u2018void saturating_add_simd(const uint16_t*, const uint16_t*, uint16_t*, size_t)\u2019:\n[REDACTED]/tmp4kds60y1.cpp:27:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i max_val = _mm_set1_epi16(UINT16_MAX);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp4kds60y1.cpp:30:22: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         __m256i v1 = _mm_loadu_si256((__m256i*)src1 + i);\n      |                      ^~~~~~~~~~~~~~~\n      |                      _mm_loadu_si16\n[REDACTED]/tmp4kds60y1.cpp:32:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |         __m256i saturated_sum = _mm_add_epi16(v1, v2);\n      |                                               ^~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp4kds60y1.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1064:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi16(__m128i, __m128i)\u2019\n 1064 | _mm_add_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp4kds60y1.cpp:33:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         saturated_sum = _mm_max_epi16(saturated_sum, max_val);\n      |                                       ^~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp4kds60y1.cpp:34:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   34 |         _mm_storeu_si256((__m256i*)dst + i, saturated_sum);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_17_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqb0_yrz9.cpp: In function \u2018void saturating_add_simd(const uint16_t*, const uint16_t*, uint16_t*, size_t)\u2019:\n[REDACTED]/tmpqb0_yrz9.cpp:33:22: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         __m256i v1 = _mm_loadu_si256((__m256i*)src1 + i);\n      |                      ^~~~~~~~~~~~~~~\n      |                      _mm_loadu_si16\n[REDACTED]/tmpqb0_yrz9.cpp:35:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i saturated_sum = _mm_adds_epu16(v1, v2);\n      |                                                ^~\n      |                                                |\n      |                                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpqb0_yrz9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1100:25: note:   initializing argument 1 of \u2018__m128i _mm_adds_epu16(__m128i, __m128i)\u2019\n 1100 | _mm_adds_epu16 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpqb0_yrz9.cpp:36:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         saturated_sum = _mm_min_epu16(saturated_sum, max_val);\n      |                                       ^~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpqb0_yrz9.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:288:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epu16(__m128i, __m128i)\u2019\n  288 | _mm_min_epu16 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpqb0_yrz9.cpp:37:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   37 |         _mm_storeu_si256((__m256i*)dst + i, saturated_sum);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_17_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_17_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbgchj_5b.cpp: In function \u2018void saturating_add_simd(const uint16_t*, const uint16_t*, uint16_t*, size_t)\u2019:\n[REDACTED]/tmpbgchj_5b.cpp:30:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         __m256i a = _mm_loadu_si256((__m256i*)(src1 + i));\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmpbgchj_5b.cpp:33:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         __m256i saturated_sum = _mm_add_epi16(a, b);\n      |                                               ^\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpbgchj_5b.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1064:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi16(__m128i, __m128i)\u2019\n 1064 | _mm_add_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbgchj_5b.cpp:34:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         saturated_sum = _mm_max_epi16(saturated_sum, max_val);\n      |                                       ^~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbgchj_5b.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i*)(dst + i), saturated_sum);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_17_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp653cg8o3.cpp: In function \u2018void saturating_add_simd(const uint16_t*, const uint16_t*, uint16_t*, size_t)\u2019:\n[REDACTED]/tmp653cg8o3.cpp:41:36: error: cannot convert \u2018__m128i\u2019 to \u2018uint16_t\u2019 {aka \u2018short unsigned int\u2019} in initialization\n   41 |         uint16_t sum = *ptr_src1++ + *ptr_src2++;\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128i\n"}
{"task_id": "SimdBench_18_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpef02l3n0.cpp: In function \u2018void range_matrix_mul_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpef02l3n0.cpp:38:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   38 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask to skip out-of-range elements\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpef02l3n0.cpp:50:62: error: cannot convert \u2018__m128*\u2019 to \u2018const float*\u2019\n   50 |                 sum += _mm_cvtss_f64(_mm_add_ps(_mm_loadu_ps((__m128*)&A[k * m + i]), _mm_loadu_ps((__m128*)&B[j * n + k])));\n      |                                                              ^~~~~~~~~~~~~~~~~~~~~~\n      |                                                              |\n      |                                                              __m128*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpef02l3n0.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpef02l3n0.cpp:50:100: error: cannot convert \u2018__m128*\u2019 to \u2018const float*\u2019\n   50 |                 sum += _mm_cvtss_f64(_mm_add_ps(_mm_loadu_ps((__m128*)&A[k * m + i]), _mm_loadu_ps((__m128*)&B[j * n + k])));\n      |                                                                                                    ^~~~~~~~~~~~~~~~~~~~~~\n      |                                                                                                    |\n      |                                                                                                    __m128*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpef02l3n0.cpp:50:24: error: \u2018_mm_cvtss_f64\u2019 was not declared in this scope; did you mean \u2018_mm_cvtss_u64\u2019?\n   50 |                 sum += _mm_cvtss_f64(_mm_add_ps(_mm_loadu_ps((__m128*)&A[k * m + i]), _mm_loadu_ps((__m128*)&B[j * n + k])));\n      |                        ^~~~~~~~~~~~~\n      |                        _mm_cvtss_u64\n[REDACTED]/tmpef02l3n0.cpp:52:86: error: cannot convert \u2018double\u2019 to \u2018__m128d\u2019\n   52 |             _mm_storeu_si128((__m128i*)&C[j * m + i], _mm_cvtsd_ss(_mm_setzero_ps(), sum));\n      |                                                                                      ^~~\n      |                                                                                      |\n      |                                                                                      double\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:916:35: note:   initializing argument 2 of \u2018__m128 _mm_cvtsd_ss(__m128, __m128d)\u2019\n  916 | _mm_cvtsd_ss (__m128 __A, __m128d __B)\n      |                           ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_18_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp325m9rg2.cpp: In function \u2018void range_matrix_mul_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp325m9rg2.cpp:44:48: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   44 |                     __m256 a = _mm256_loadu_ps(&A[i * n + k]);\n      |                                                ^~~~~~~~~~~~~\n      |                                                |\n      |                                                const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp325m9rg2.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp325m9rg2.cpp:45:48: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   45 |                     __m256 b = _mm256_loadu_ps(&B[k * p + j]);\n      |                                                ^~~~~~~~~~~~~\n      |                                                |\n      |                                                const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp325m9rg2.cpp:47:28: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   47 |                     sum += _mm256_reduce_add_ps(c);\n      |                            ^~~~~~~~~~~~~~~~~~~~\n      |                            _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_18_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzb_32971.cpp: In function \u2018void range_matrix_mul_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpzb_32971.cpp:35:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask = _mm256_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask to skip out-of-range values\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpzb_32971.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpzb_32971.cpp:43:79: error: cannot convert \u2018__m256i\u2019 to \u2018__m256d\u2019\n   43 |                 sum += _mm256_reduce_add_ps(_mm256_fmadd_pd(_mm256_loadu_si256((__m256i*)&A[i*n + k]), _mm256_loadu_si256((__m256i*)&B[k*p + j]))); // Add element-wise product\n      |                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                                                                               |\n      |                                                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:109:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/fmaintrin.h:47:26: note:   initializing argument 1 of \u2018__m256d _mm256_fmadd_pd(__m256d, __m256d, __m256d)\u2019\n   47 | _mm256_fmadd_pd (__m256d __A, __m256d __B, __m256d __C)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpzb_32971.cpp:43:24: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   43 |                 sum += _mm256_reduce_add_ps(_mm256_fmadd_pd(_mm256_loadu_si256((__m256i*)&A[i*n + k]), _mm256_loadu_si256((__m256i*)&B[k*p + j]))); // Add element-wise product\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n[REDACTED]/tmpzb_32971.cpp:45:73: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   45 |             _mm256_storeu_si256((__m256i*)&C[i*p + j], _mm256_setzero_ps()); // Initialize C[i][j] to zero\n      |                                                        ~~~~~~~~~~~~~~~~~^~\n      |                                                                         |\n      |                                                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n[REDACTED]/tmpzb_32971.cpp:46:69: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   46 |             _mm256_storeu_si256((__m256i*)&C[i*p + j], _mm256_add_ps(_mm256_setzero_ps(), _mm256_set1_ps(sum))); // Store the computed sum\n      |                                                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                                                     |\n      |                                                                     __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_18_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmph4dcu016.cpp: In function \u2018void range_matrix_mul_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmph4dcu016.cpp:38:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   38 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask for values in the range [-100, 100]\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmph4dcu016.cpp:42:41: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   42 |             __m256d sum = _mm_setzero_pd(); // Initialize sum\n      |                           ~~~~~~~~~~~~~~^~\n      |                                         |\n      |                                         __m128d\n[REDACTED]/tmph4dcu016.cpp:45:21: error: \u2018_mm_test_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_set_epi32\u2019?\n   45 |                 if (_mm_test_epi32(_mm_loadu_si128((__m128i*)&A[i*n + k]), mask)) { // Check if element is in the range\n      |                     ^~~~~~~~~~~~~~\n      |                     _mm_set_epi32\n[REDACTED]/tmph4dcu016.cpp:46:45: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   46 |                     __m256d a = _mm_loadu_pd(&A[i*n + k]); // Load element from A\n      |                                 ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                             |\n      |                                             __m128d\n[REDACTED]/tmph4dcu016.cpp:47:45: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   47 |                     __m256d b = _mm_loadu_pd(&B[k*p + j]); // Load element from B\n      |                                 ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                             |\n      |                                             __m128d\n[REDACTED]/tmph4dcu016.cpp:48:54: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   48 |                     sum = _mm_add_pd(sum, _mm_mul_pd(a, b)); // Multiply and add to sum\n      |                                                      ^\n      |                                                      |\n      |                                                      __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmph4dcu016.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:273:21: note:   initializing argument 1 of \u2018__m128d _mm_mul_pd(__m128d, __m128d)\u2019\n  273 | _mm_mul_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmph4dcu016.cpp:52:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   52 |             _mm_storeu_pd(&C[i*p + j], sum); // Store result in C\n      |                                        ^~~\n      |                                        |\n      |                                        __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:174:37: note:   initializing argument 2 of \u2018void _mm_storeu_pd(double*, __m128d)\u2019\n  174 | _mm_storeu_pd (double *__P, __m128d __A)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_18_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5qih_y9m.cpp: In function \u2018void range_matrix_mul_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp5qih_y9m.cpp:47:48: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   47 |                     __m256 a = _mm256_loadu_ps(&A[i * n + k]);\n      |                                                ^~~~~~~~~~~~~\n      |                                                |\n      |                                                const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp5qih_y9m.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp5qih_y9m.cpp:48:48: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   48 |                     __m256 b = _mm256_loadu_ps(&B[k * p + j]);\n      |                                                ^~~~~~~~~~~~~\n      |                                                |\n      |                                                const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp5qih_y9m.cpp:52:27: error: cannot convert \u2018double*\u2019 to \u2018float*\u2019\n   52 |             _mm_storeu_ps(&C[i * p + j], sum);\n      |                           ^~~~~~~~~~~~~\n      |                           |\n      |                           double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp5qih_y9m.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_19_AVX", "passed": false, "result": "runtime failed: double free or corruption (!prev)\n"}
{"task_id": "SimdBench_19_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_19_AVX", "passed": false, "result": "runtime failed: double free or corruption (!prev)\n"}
{"task_id": "SimdBench_19_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_19_AVX", "passed": false, "result": "runtime failed: double free or corruption (!prev)\n"}
{"task_id": "SimdBench_20_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphe7imewk.cpp: In function \u2018void vector_add_round_nearest_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmphe7imewk.cpp:33:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   33 |         __m256f f_src1 = _mm256_castsi256_ps(v_src1);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmphe7imewk.cpp:34:16: error: expected \u2018;\u2019 before \u2018f_src2\u2019\n   34 |         __m256f f_src2 = _mm256_castsi256_ps(v_src2);\n      |                ^~~~~~~\n      |                ;\n[REDACTED]/tmphe7imewk.cpp:36:16: error: expected \u2018;\u2019 before \u2018f_sum\u2019\n   36 |         __m256f f_sum = _mm256_add_ps(f_src1, f_src2);\n      |                ^~~~~~\n      |                ;\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmphe7imewk.cpp:16:\n[REDACTED]/tmphe7imewk.cpp:37:64: error: \u2018f_sum\u2019 was not declared in this scope\n   37 |         __m256i v_rounded = _mm256_cvtps_epi32(_mm256_round_ps(f_sum, _MM_FROUND_TO_NEAREST));\n      |                                                                ^~~~~\n[REDACTED]/tmphe7imewk.cpp:37:71: error: \u2018_MM_FROUND_TO_NEAREST\u2019 was not declared in this scope\n   37 |         __m256i v_rounded = _mm256_cvtps_epi32(_mm256_round_ps(f_sum, _MM_FROUND_TO_NEAREST));\n      |                                                                       ^~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmphe7imewk.cpp:48:9: error: \u2018__m128f\u2019 was not declared in this scope; did you mean \u2018__m128i\u2019?\n   48 |         __m128f f_src1 = _mm_castsi128_ps(v_src1);\n      |         ^~~~~~~\n      |         __m128i\n[REDACTED]/tmphe7imewk.cpp:49:16: error: expected \u2018;\u2019 before \u2018f_src2\u2019\n   49 |         __m128f f_src2 = _mm_castsi128_ps(v_src2);\n      |                ^~~~~~~\n      |                ;\n[REDACTED]/tmphe7imewk.cpp:51:16: error: expected \u2018;\u2019 before \u2018f_sum\u2019\n   51 |         __m128f f_sum = _mm_add_ps(f_src1, f_src2);\n      |                ^~~~~~\n      |                ;\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmphe7imewk.cpp:52:58: error: \u2018f_sum\u2019 was not declared in this scope\n   52 |         __m128i v_rounded = _mm_cvtps_epi32(_mm_round_ps(f_sum, _MM_FROUND_TO_NEAREST));\n      |                                                          ^~~~~\n[REDACTED]/tmphe7imewk.cpp:52:65: error: \u2018_MM_FROUND_TO_NEAREST\u2019 was not declared in this scope\n   52 |         __m128i v_rounded = _mm_cvtps_epi32(_mm_round_ps(f_sum, _MM_FROUND_TO_NEAREST));\n      |                                                                 ^~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmphe7imewk.cpp:53:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   53 |         v_dst = _mm_or_si128(v_dst, v_rounded);\n      |                              ^~~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmphe7imewk.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1327:23: note:   initializing argument 1 of \u2018__m128i _mm_or_si128(__m128i, __m128i)\u2019\n 1327 | _mm_or_si128 (__m128i __A, __m128i __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmphe7imewk.cpp:59:5: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   59 |     _mm_storeu_si256((__m256i*)dst, v_dst);\n      |     ^~~~~~~~~~~~~~~~\n      |     _mm_storeu_si16\n"}
{"task_id": "SimdBench_20_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_20_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_20_AVX", "passed": false, "result": "runtime failed: double free or corruption (out)\n"}
{"task_id": "SimdBench_20_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpx_2n3c2u.cpp: In function \u2018void vector_add_round_nearest_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmpx_2n3c2u.cpp:33:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   33 |         __m256 sum = _mm_add_ps(*ptr_src1++, *ptr_src2++);\n      |                                 ^~~~~~~~~~~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpx_2n3c2u.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:190:20: note:   initializing argument 1 of \u2018__m128 _mm_add_ps(__m128, __m128)\u2019\n  190 | _mm_add_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpx_2n3c2u.cpp:16:\n[REDACTED]/tmpx_2n3c2u.cpp:34:26: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   34 |         __m256 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT);\n      |                          ^~~~~~~~~~~~\n[REDACTED]/tmpx_2n3c2u.cpp:35:36: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   35 |         *ptr_dst++ = _mm_cvtss_f32(rounded);\n      |                                    ^~~~~~~\n      |                                    |\n      |                                    __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:973:23: note:   initializing argument 1 of \u2018float _mm_cvtss_f32(__m128)\u2019\n  973 | _mm_cvtss_f32 (__m128 __A)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpx_2n3c2u.cpp:40:21: error: cannot convert \u2018__m256\u2019 to \u2018float\u2019 in initialization\n   40 |         float sum = *ptr_src1++;\n      |                     ^~~~~~~~~~~\n      |                     |\n      |                     __m256\n[REDACTED]/tmpx_2n3c2u.cpp:42:22: error: cannot convert \u2018float\u2019 to \u2018__m256\u2019 in assignment\n   42 |         *ptr_dst++ = rounded;\n      |                      ^~~~~~~\n      |                      |\n      |                      float\n"}
{"task_id": "SimdBench_21_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpk50agvio.cpp: In function \u2018void vector_mul_round_up_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmpk50agvio.cpp:32:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpk50agvio.cpp:33:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |     __m256 abs_diff = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpk50agvio.cpp:36:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   36 |         __m256 v1 = _mm_loadu_ps(src1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpk50agvio.cpp:37:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 v2 = _mm_loadu_ps(src2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpk50agvio.cpp:40:31: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         abs_diff = _mm_sub_ps(v1, v2);\n      |                               ^~\n      |                               |\n      |                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpk50agvio.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpk50agvio.cpp:41:20: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   41 |         abs_diff = _mm_abs_ps(abs_diff);\n      |                    ^~~~~~~~~~\n      |                    _mm_abs_ph\n[REDACTED]/tmpk50agvio.cpp:44:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         mask = _mm_cmpgt_ps(abs_diff, _mm_set1_ps(50));\n      |                             ^~~~~~~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpk50agvio.cpp:16:\n[REDACTED]/tmpk50agvio.cpp:47:52: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   47 |         __m256 rounded_up = _mm_ceil_ps(_mm_add_ps(v1, v2));\n      |                                                    ^~\n      |                                                    |\n      |                                                    __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:190:20: note:   initializing argument 1 of \u2018__m128 _mm_add_ps(__m128, __m128)\u2019\n  190 | _mm_add_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpk50agvio.cpp:48:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         rounded_up = _mm_and_ps(rounded_up, mask);\n      |                                 ^~~~~~~~~~\n      |                                 |\n      |                                 __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpk50agvio.cpp:51:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   51 |         _mm_storeu_ps(dst + i, rounded_up);\n      |                                ^~~~~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_21_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi1s8he4x.cpp: In function \u2018void vector_mul_round_up_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmpi1s8he4x.cpp:29:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpi1s8he4x.cpp:30:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   30 |     __m256 abs_diff = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpi1s8he4x.cpp:33:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |         __m256 v1 = _mm_loadu_ps(src1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpi1s8he4x.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 v2 = _mm_loadu_ps(src2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpi1s8he4x.cpp:37:31: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   37 |         abs_diff = _mm_sub_ps(v1, v2);\n      |                               ^~\n      |                               |\n      |                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpi1s8he4x.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpi1s8he4x.cpp:38:20: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   38 |         abs_diff = _mm_abs_ps(abs_diff);\n      |                    ^~~~~~~~~~\n      |                    _mm_abs_ph\n[REDACTED]/tmpi1s8he4x.cpp:41:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         mask = _mm_cmpgt_ps(_mm_and_ps(abs_diff, _mm_set1_ps(50)), _mm_setzero_ps());\n      |                                        ^~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpi1s8he4x.cpp:16:\n[REDACTED]/tmpi1s8he4x.cpp:44:51: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         __m256 rounded_up = _mm_ceil_ps(_mm_or_ps(mask, _mm_set1_ps(-1)));\n      |                                                   ^~~~\n      |                                                   |\n      |                                                   __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpi1s8he4x.cpp:47:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   47 |         _mm_storeu_ps(dst + i, rounded_up);\n      |                                ^~~~~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_21_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxlvczwwv.cpp: In function \u2018void vector_mul_round_up_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmpxlvczwwv.cpp:29:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpxlvczwwv.cpp:30:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   30 |     __m256 abs_diff = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpxlvczwwv.cpp:33:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |         __m256 v1 = _mm_loadu_ps(src1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpxlvczwwv.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 v2 = _mm_loadu_ps(src2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpxlvczwwv.cpp:37:31: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   37 |         abs_diff = _mm_sub_ps(v1, v2);\n      |                               ^~\n      |                               |\n      |                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpxlvczwwv.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpxlvczwwv.cpp:38:20: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   38 |         abs_diff = _mm_abs_ps(abs_diff);\n      |                    ^~~~~~~~~~\n      |                    _mm_abs_ph\n[REDACTED]/tmpxlvczwwv.cpp:41:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         mask = _mm_cmpgt_ps(_mm_and_ps(abs_diff, _mm_set1_ps(50)), _mm_setzero_ps());\n      |                                        ^~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpxlvczwwv.cpp:16:\n[REDACTED]/tmpxlvczwwv.cpp:44:26: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   44 |         __m256 rounded = _mm_ceil_ps(v1 * v2);\n      |                          ^~~~~~~~~~~\n[REDACTED]/tmpxlvczwwv.cpp:45:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         rounded = _mm_or_ps(rounded, mask);\n      |                             ^~~~~~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpxlvczwwv.cpp:48:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         _mm_storeu_ps(dst + i, rounded);\n      |                                ^~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_21_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpe7fb1bcj.cpp: In function \u2018void vector_mul_round_up_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmpe7fb1bcj.cpp:29:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpe7fb1bcj.cpp:30:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   30 |     __m256 abs_diff = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpe7fb1bcj.cpp:31:35: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   31 |     __m256 result = _mm_setzero_ps();\n      |                     ~~~~~~~~~~~~~~^~\n      |                                   |\n      |                                   __m128\n[REDACTED]/tmpe7fb1bcj.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 v1 = _mm_loadu_ps(src1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpe7fb1bcj.cpp:35:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |         __m256 v2 = _mm_loadu_ps(src2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpe7fb1bcj.cpp:38:31: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |         abs_diff = _mm_sub_ps(v1, v2);\n      |                               ^~\n      |                               |\n      |                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpe7fb1bcj.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpe7fb1bcj.cpp:39:20: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   39 |         abs_diff = _mm_abs_ps(abs_diff);\n      |                    ^~~~~~~~~~\n      |                    _mm_abs_ph\n[REDACTED]/tmpe7fb1bcj.cpp:42:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         mask = _mm_cmpgt_ps(abs_diff, _mm_set1_ps(50));\n      |                             ^~~~~~~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpe7fb1bcj.cpp:16:\n[REDACTED]/tmpe7fb1bcj.cpp:45:41: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         result = _mm_ceil_ps(_mm_mul_ps(v1, v2));\n      |                                         ^~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpe7fb1bcj.cpp:48:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         _mm_storeu_ps(dst + i, result);\n      |                                ^~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_21_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2eid4743.cpp: In function \u2018void vector_mul_round_up_simd(const float*, const float*, float*, size_t)\u2019:\n[REDACTED]/tmp2eid4743.cpp:29:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp2eid4743.cpp:30:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   30 |     __m256 abs_diff = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmp2eid4743.cpp:33:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |         __m256 v1 = _mm_loadu_ps(src1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp2eid4743.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 v2 = _mm_loadu_ps(src2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp2eid4743.cpp:37:31: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   37 |         abs_diff = _mm_sub_ps(v1, v2);\n      |                               ^~\n      |                               |\n      |                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2eid4743.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp2eid4743.cpp:38:20: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   38 |         abs_diff = _mm_abs_ps(abs_diff);\n      |                    ^~~~~~~~~~\n      |                    _mm_abs_ph\n[REDACTED]/tmp2eid4743.cpp:41:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         mask = _mm_cmpgt_ps(_mm_and_ps(abs_diff, _mm_set1_ps(50)), _mm_setzero_ps());\n      |                                        ^~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp2eid4743.cpp:16:\n[REDACTED]/tmp2eid4743.cpp:44:29: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   44 |         __m256 rounded_up = _mm_ceil_ps(v1 * v2);\n      |                             ^~~~~~~~~~~\n[REDACTED]/tmp2eid4743.cpp:45:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         rounded_up = _mm_or_ps(rounded_up, mask);\n      |                                ^~~~~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmp2eid4743.cpp:48:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         _mm_storeu_ps(dst + i, rounded_up);\n      |                                ^~~~~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_22_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpumdzo6dq.cpp: In function \u2018void matrix_scalar_mul_simd(const double*, double, double*, size_t, size_t)\u2019:\n[REDACTED]/tmpumdzo6dq.cpp:30:42: error: cannot convert \u2018__m128d\u2019 to \u2018const __m256d\u2019 in initialization\n   30 |     const __m256d scalar_vec = _mm_set_pd(scalar, scalar);\n      |                                ~~~~~~~~~~^~~~~~~~~~~~~~~~\n      |                                          |\n      |                                          __m128d\n[REDACTED]/tmpumdzo6dq.cpp:33:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   33 |         __m256d vec1 = _mm_loadu_pd(&mat[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpumdzo6dq.cpp:34:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   34 |         __m256d vec2 = _mm_mul_pd(vec1, scalar_vec);\n      |                                   ^~~~\n      |                                   |\n      |                                   __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpumdzo6dq.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:273:21: note:   initializing argument 1 of \u2018__m128d _mm_mul_pd(__m128d, __m128d)\u2019\n  273 | _mm_mul_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpumdzo6dq.cpp:35:32: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   35 |         _mm_storeu_pd(&dst[i], vec2);\n      |                                ^~~~\n      |                                |\n      |                                __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:174:37: note:   initializing argument 2 of \u2018void _mm_storeu_pd(double*, __m128d)\u2019\n  174 | _mm_storeu_pd (double *__P, __m128d __A)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_22_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzv5jsddi.cpp: In function \u2018void matrix_scalar_mul_simd(const double*, double, double*, size_t, size_t)\u2019:\n[REDACTED]/tmpzv5jsddi.cpp:30:42: error: cannot convert \u2018__m128d\u2019 to \u2018const __m256d\u2019 in initialization\n   30 |     const __m256d scalar_vec = _mm_set_pd(scalar, scalar);\n      |                                ~~~~~~~~~~^~~~~~~~~~~~~~~~\n      |                                          |\n      |                                          __m128d\n[REDACTED]/tmpzv5jsddi.cpp:33:41: error: cannot convert \u2018__m128d\u2019 to \u2018const __m256d\u2019 in initialization\n   33 |         const __m256d vec = _mm_loadu_pd(&mat[i]);\n      |                             ~~~~~~~~~~~~^~~~~~~~~\n      |                                         |\n      |                                         __m128d\n[REDACTED]/tmpzv5jsddi.cpp:34:37: error: cannot convert \u2018const __m256d\u2019 to \u2018__m128d\u2019\n   34 |         __m256d result = _mm_mul_pd(vec, scalar_vec);\n      |                                     ^~~\n      |                                     |\n      |                                     const __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpzv5jsddi.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:273:21: note:   initializing argument 1 of \u2018__m128d _mm_mul_pd(__m128d, __m128d)\u2019\n  273 | _mm_mul_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpzv5jsddi.cpp:35:32: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   35 |         _mm_storeu_pd(&dst[i], result);\n      |                                ^~~~~~\n      |                                |\n      |                                __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:174:37: note:   initializing argument 2 of \u2018void _mm_storeu_pd(double*, __m128d)\u2019\n  174 | _mm_storeu_pd (double *__P, __m128d __A)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_22_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp75uog43k.cpp: In function \u2018void matrix_scalar_mul_simd(const double*, double, double*, size_t, size_t)\u2019:\n[REDACTED]/tmp75uog43k.cpp:27:42: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   27 |     const __m256d scalar_vec = _mm_set_pd(scalar);\n      |                                ~~~~~~~~~~^~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp75uog43k.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmp75uog43k.cpp:30:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   30 |         __m256d vec1 = _mm_loadu_pd(&mat[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmp75uog43k.cpp:31:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   31 |         __m256d vec2 = _mm_mul_pd(vec1, scalar_vec);\n      |                                   ^~~~\n      |                                   |\n      |                                   __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:273:21: note:   initializing argument 1 of \u2018__m128d _mm_mul_pd(__m128d, __m128d)\u2019\n  273 | _mm_mul_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmp75uog43k.cpp:32:32: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   32 |         _mm_storeu_pd(&dst[i], vec2);\n      |                                ^~~~\n      |                                |\n      |                                __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:174:37: note:   initializing argument 2 of \u2018void _mm_storeu_pd(double*, __m128d)\u2019\n  174 | _mm_storeu_pd (double *__P, __m128d __A)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_22_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpax3tirk3.cpp: In function \u2018void matrix_scalar_mul_simd(const double*, double, double*, size_t, size_t)\u2019:\n[REDACTED]/tmpax3tirk3.cpp:30:36: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   30 |     __m256d scalar_vec = _mm_set_pd(scalar);\n      |                          ~~~~~~~~~~^~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpax3tirk3.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmpax3tirk3.cpp:33:41: error: cannot convert \u2018__m128d\u2019 to \u2018const __m256d\u2019 in initialization\n   33 |         const __m256d vec = _mm_loadu_pd(&mat[i]);\n      |                             ~~~~~~~~~~~~^~~~~~~~~\n      |                                         |\n      |                                         __m128d\n[REDACTED]/tmpax3tirk3.cpp:34:37: error: cannot convert \u2018const __m256d\u2019 to \u2018__m128d\u2019\n   34 |         __m256d result = _mm_mul_pd(vec, scalar_vec);\n      |                                     ^~~\n      |                                     |\n      |                                     const __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:273:21: note:   initializing argument 1 of \u2018__m128d _mm_mul_pd(__m128d, __m128d)\u2019\n  273 | _mm_mul_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpax3tirk3.cpp:35:32: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   35 |         _mm_storeu_pd(&dst[i], result);\n      |                                ^~~~~~\n      |                                |\n      |                                __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:174:37: note:   initializing argument 2 of \u2018void _mm_storeu_pd(double*, __m128d)\u2019\n  174 | _mm_storeu_pd (double *__P, __m128d __A)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_22_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmper546hlo.cpp: In function \u2018void matrix_scalar_mul_simd(const double*, double, double*, size_t, size_t)\u2019:\n[REDACTED]/tmper546hlo.cpp:30:36: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   30 |     __m256d scalar_vec = _mm_set_pd(scalar);\n      |                          ~~~~~~~~~~^~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmper546hlo.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmper546hlo.cpp:33:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   33 |         __m256d vec1 = _mm_loadu_pd(&mat[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmper546hlo.cpp:34:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   34 |         __m256d vec2 = _mm_mul_pd(vec1, scalar_vec);\n      |                                   ^~~~\n      |                                   |\n      |                                   __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:273:21: note:   initializing argument 1 of \u2018__m128d _mm_mul_pd(__m128d, __m128d)\u2019\n  273 | _mm_mul_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmper546hlo.cpp:35:32: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   35 |         _mm_storeu_pd(&dst[i], vec2);\n      |                                ^~~~\n      |                                |\n      |                                __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:174:37: note:   initializing argument 2 of \u2018void _mm_storeu_pd(double*, __m128d)\u2019\n  174 | _mm_storeu_pd (double *__P, __m128d __A)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_23_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprup5mpsu.cpp: In function \u2018void matrix_normalize_rows_simd(float*, size_t, size_t)\u2019:\n[REDACTED]/tmprup5mpsu.cpp:51:27: error: \u2018_mm256\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n   51 |         __m256 inv_sqrt = _mm256.rsqrt_ps(squared_magnitude);\n      |                           ^~~~~~\n      |                           __m256\n"}
{"task_id": "SimdBench_23_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_23_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_23_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_23_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptpfndqwg.cpp: In function \u2018void matrix_normalize_rows_simd(float*, size_t, size_t)\u2019:\n[REDACTED]/tmptpfndqwg.cpp:51:27: error: \u2018_mm256\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n   51 |         __m256 inv_sqrt = _mm256.rsqrt_ps(squared_magnitude);\n      |                           ^~~~~~\n      |                           __m256\n"}
{"task_id": "SimdBench_24_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp0y91g8dq.cpp: In function \u2018void matrix_mul_round_int_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp0y91g8dq.cpp:41:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   41 |             __m256 v4 = _mm256_loadu_pd(&mat1[i * n + j]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmp0y91g8dq.cpp:42:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   42 |             __m256 v5 = _mm256_loadu_pd(&mat2[j * p]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmp0y91g8dq.cpp:56:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   56 |             __m256 v4 = _mm256_loadu_pd(&mat1[i * n + j]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmp0y91g8dq.cpp:57:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   57 |             __m256 v5 = _mm256_loadu_pd(&mat2[j * p]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n"}
{"task_id": "SimdBench_24_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpd095s7jq.cpp: In function \u2018void matrix_mul_round_int_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpd095s7jq.cpp:41:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   41 |             __m256 v4 = _mm256_loadu_pd(&mat1[i * n + j]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpd095s7jq.cpp:42:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   42 |             __m256 v5 = _mm256_loadu_pd(&mat2[j * p]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpd095s7jq.cpp:47:47: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   47 |             _mm256_storeu_pd(&dst[i * p + j], v7);\n      |                                               ^~\n      |                                               |\n      |                                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpd095s7jq.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpd095s7jq.cpp:54:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   54 |             __m256 v4 = _mm256_loadu_pd(&mat1[i * n + j]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpd095s7jq.cpp:55:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   55 |             __m256 v5 = _mm256_loadu_pd(&mat2[j * p]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpd095s7jq.cpp:60:47: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   60 |             _mm256_storeu_pd(&dst[i * p + j], v7);\n      |                                               ^~\n      |                                               |\n      |                                               __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_24_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmoxj6fyq.cpp: In function \u2018void matrix_mul_round_int_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpmoxj6fyq.cpp:41:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   41 |             __m256 v4 = _mm256_loadu_pd(&mat1[i * n + j]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpmoxj6fyq.cpp:42:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   42 |             __m256 v5 = _mm256_loadu_pd(&mat2[j * n]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpmoxj6fyq.cpp:47:47: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   47 |             _mm256_storeu_pd(&dst[i * p + j], v7);\n      |                                               ^~\n      |                                               |\n      |                                               __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpmoxj6fyq.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpmoxj6fyq.cpp:54:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   54 |             __m256 v4 = _mm256_loadu_pd(&mat1[i * n + j]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpmoxj6fyq.cpp:55:40: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   55 |             __m256 v5 = _mm256_loadu_pd(&mat2[j * n]);\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256d\n[REDACTED]/tmpmoxj6fyq.cpp:60:47: error: cannot convert \u2018__m256\u2019 to \u2018__m256d\u2019\n   60 |             _mm256_storeu_pd(&dst[i * p + j], v7);\n      |                                               ^~\n      |                                               |\n      |                                               __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:40: note:   initializing argument 2 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_24_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5nvggflg.cpp: In function \u2018void matrix_mul_round_int_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp5nvggflg.cpp:34:34: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i i0 = _mm256_set_epi32(0, 1, 2, 3);\n      |                  ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp5nvggflg.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp5nvggflg.cpp:35:34: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i i1 = _mm256_set_epi32(4, 5, 6, 7);\n      |                  ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_24_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpa_soa4x7.cpp: In function \u2018void matrix_mul_round_int_simd(const double*, const double*, double*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpa_soa4x7.cpp:38:41: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   38 |             __m256 v4 = _mm256_loadu_ps(&mat1[i * n + j]);\n      |                                         ^~~~~~~~~~~~~~~~\n      |                                         |\n      |                                         const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpa_soa4x7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpa_soa4x7.cpp:39:41: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   39 |             __m256 v5 = _mm256_loadu_ps(&mat2[j * p]);\n      |                                         ^~~~~~~~~~~~\n      |                                         |\n      |                                         const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpa_soa4x7.cpp:44:26: error: cannot convert \u2018__vector(8) float\u2019 to \u2018__m256i\u2019 in initialization\n   44 |             __m256i v8 = _mm256_round_ps(v7, _MM_FROUND_TO_NEAREST_INT);\n      |                          ^~~~~~~~~~~~~~~\n      |                          |\n      |                          __vector(8) float\n[REDACTED]/tmpa_soa4x7.cpp:46:30: error: cannot convert \u2018double*\u2019 to \u2018float*\u2019\n   46 |             _mm256_storeu_ps(&dst[i * p + j], v8);\n      |                              ^~~~~~~~~~~~~~~\n      |                              |\n      |                              double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_25_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8e5uwwpv.cpp: In function \u2018void matrix_transpose_round_quarter_simd(const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmp8e5uwwpv.cpp:27:42: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   27 |     const __m256i mask = _mm256_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF); // Mask to keep only the lower 31 bits\n      |                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8e5uwwpv.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp8e5uwwpv.cpp:41:76: error: cannot convert \u2018const __m256i\u2019 to \u2018__m256\u2019\n   41 |             __m256 combined_v1 = _mm256_or_ps(rounded_v1, _mm256_andnot_ps(mask, rounded_v2));\n      |                                                                            ^~~~\n      |                                                                            |\n      |                                                                            const __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:184:26: note:   initializing argument 1 of \u2018__m256 _mm256_andnot_ps(__m256, __m256)\u2019\n  184 | _mm256_andnot_ps (__m256 __A, __m256 __B)\n      |                   ~~~~~~~^~~\n[REDACTED]/tmp8e5uwwpv.cpp:42:76: error: cannot convert \u2018const __m256i\u2019 to \u2018__m256\u2019\n   42 |             __m256 combined_v2 = _mm256_or_ps(rounded_v2, _mm256_andnot_ps(mask, rounded_v3));\n      |                                                                            ^~~~\n      |                                                                            |\n      |                                                                            const __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:184:26: note:   initializing argument 1 of \u2018__m256 _mm256_andnot_ps(__m256, __m256)\u2019\n  184 | _mm256_andnot_ps (__m256 __A, __m256 __B)\n      |                   ~~~~~~~^~~\n[REDACTED]/tmp8e5uwwpv.cpp:43:76: error: cannot convert \u2018const __m256i\u2019 to \u2018__m256\u2019\n   43 |             __m256 combined_v3 = _mm256_or_ps(rounded_v3, _mm256_andnot_ps(mask, rounded_v4));\n      |                                                                            ^~~~\n      |                                                                            |\n      |                                                                            const __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:184:26: note:   initializing argument 1 of \u2018__m256 _mm256_andnot_ps(__m256, __m256)\u2019\n  184 | _mm256_andnot_ps (__m256 __A, __m256 __B)\n      |                   ~~~~~~~^~~\n[REDACTED]/tmp8e5uwwpv.cpp:48:56: error: \u2018combined_v4\u2019 was not declared in this scope; did you mean \u2018combined_v3\u2019?\n   48 |             _mm256_storeu_ps(&dst[(j + 3) * rows + i], combined_v4);\n      |                                                        ^~~~~~~~~~~\n      |                                                        combined_v3\n"}
{"task_id": "SimdBench_25_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbnddkhy7.cpp: In function \u2018void matrix_transpose_round_quarter_simd(const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpbnddkhy7.cpp:27:42: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   27 |     const __m256i mask = _mm256_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF); // Mask to keep only the lower 31 bits\n      |                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbnddkhy7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpbnddkhy7.cpp:33:40: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   33 |             rounded = _mm256_and_si256(rounded, mask);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:179:27: note:   initializing argument 1 of \u2018__m256i _mm256_and_si256(__m256i, __m256i)\u2019\n  179 | _mm256_and_si256 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_25_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvdg5b0op.cpp: In function \u2018void matrix_transpose_round_quarter_simd(const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpvdg5b0op.cpp:32:13: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   32 |             __m256f src_vec = _mm256_loadu_ps(&src[i * cols + j]);\n      |             ^~~~~~~\n      |             __m256i\n[REDACTED]/tmpvdg5b0op.cpp:33:20: error: expected \u2018;\u2019 before \u2018rounded_vec\u2019\n   33 |             __m256f rounded_vec = _mm256_round_ps(src_vec, _MM_FROUND_TO_NEAREST_INT);\n      |                    ^~~~~~~~~~~~\n      |                    ;\n[REDACTED]/tmpvdg5b0op.cpp:34:58: error: \u2018rounded_vec\u2019 was not declared in this scope; did you mean \u2018roundeven\u2019?\n   34 |             __m256i rounded_int_vec = _mm256_cvtps_epi32(rounded_vec);\n      |                                                          ^~~~~~~~~~~\n      |                                                          roundeven\n[REDACTED]/tmpvdg5b0op.cpp:37:20: error: expected \u2018;\u2019 before \u2018unshifted_float_vec\u2019\n   37 |             __m256f unshifted_float_vec = _mm256_cvtpi2ps(masked_int_vec);\n      |                    ^~~~~~~~~~~~~~~~~~~~\n      |                    ;\n[REDACTED]/tmpvdg5b0op.cpp:38:50: error: \u2018unshifted_float_vec\u2019 was not declared in this scope; did you mean \u2018shifted_int_vec\u2019?\n   38 |             _mm256_storeu_ps(&dst[j * rows + i], unshifted_float_vec);\n      |                                                  ^~~~~~~~~~~~~~~~~~~\n      |                                                  shifted_int_vec\n"}
{"task_id": "SimdBench_25_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpv3zhyws3.cpp: In function \u2018void matrix_transpose_round_quarter_simd(const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpv3zhyws3.cpp:30:39: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   30 |     const __m256i mask = _mm_set_epi32(1, 0, 1, 0); // Mask to extract even and odd elements\n      |                          ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmpv3zhyws3.cpp:34:13: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   34 |             __m256f src_row = _mm_loadu_ps(&src[i * cols + 2 * j]);\n      |             ^~~~~~~\n      |             __m256i\n[REDACTED]/tmpv3zhyws3.cpp:35:20: error: expected \u2018;\u2019 before \u2018src_col\u2019\n   35 |             __m256f src_col = _mm_loadu_ps(&src[2 * j * cols + i]);\n      |                    ^~~~~~~~\n      |                    ;\n[REDACTED]/tmpv3zhyws3.cpp:37:20: error: expected \u2018;\u2019 before \u2018transposed_row\u2019\n   37 |             __m256f transposed_row = _mm_shuffle_ps(src_row, src_col, 0b0101);\n      |                    ^~~~~~~~~~~~~~~\n      |                    ;\n[REDACTED]/tmpv3zhyws3.cpp:38:20: error: expected \u2018;\u2019 before \u2018transposed_col\u2019\n   38 |             __m256f transposed_col = _mm_shuffle_ps(src_row, src_col, 0b1010);\n      |                    ^~~~~~~~~~~~~~~\n      |                    ;\n[REDACTED]/tmpv3zhyws3.cpp:40:20: error: expected \u2018;\u2019 before \u2018rounded_row\u2019\n   40 |             __m256f rounded_row = _mm_round_ps(transposed_row, _MM_FROUND_TO_NEAREST_INT);\n      |                    ^~~~~~~~~~~~\n      |                    ;\n[REDACTED]/tmpv3zhyws3.cpp:41:20: error: expected \u2018;\u2019 before \u2018rounded_col\u2019\n   41 |             __m256f rounded_col = _mm_round_ps(transposed_col, _MM_FROUND_TO_NEAREST_INT);\n      |                    ^~~~~~~~~~~~\n      |                    ;\n[REDACTED]/tmpv3zhyws3.cpp:43:47: error: \u2018rounded_row\u2019 was not declared in this scope\n   43 |             _mm_storeu_ps(&dst[j * rows + i], rounded_row);\n      |                                               ^~~~~~~~~~~\n[REDACTED]/tmpv3zhyws3.cpp:44:58: error: \u2018rounded_col\u2019 was not declared in this scope\n   44 |             _mm_storeu_ps(&dst[j * rows + i + cols / 2], rounded_col);\n      |                                                          ^~~~~~~~~~~\n"}
{"task_id": "SimdBench_25_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpemq5y9z_.cpp: In function \u2018void matrix_transpose_round_quarter_simd(const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpemq5y9z_.cpp:27:42: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   27 |     const __m256i mask = _mm256_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF); // Mask to keep only the lower 31 bits\n      |                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpemq5y9z_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpemq5y9z_.cpp:33:40: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   33 |             rounded = _mm256_and_si256(rounded, mask);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:179:27: note:   initializing argument 1 of \u2018__m256i _mm256_and_si256(__m256i, __m256i)\u2019\n  179 | _mm256_and_si256 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpemq5y9z_.cpp:42:40: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   42 |             rounded = _mm256_and_si256(rounded, mask);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:179:27: note:   initializing argument 1 of \u2018__m256i _mm256_and_si256(__m256i, __m256i)\u2019\n  179 | _mm256_and_si256 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_26_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpj2qbzhqb.cpp: In function \u2018void tensor3d_sub_round_zero_simd(const float*, const float*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpj2qbzhqb.cpp:30:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   30 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask to keep all bits set\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpj2qbzhqb.cpp:33:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   33 |         __m256f t1 = _mm_loadu_ps(tensor1 + i);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpj2qbzhqb.cpp:34:16: error: expected \u2018;\u2019 before \u2018t2\u2019\n   34 |         __m256f t2 = _mm_loadu_ps(tensor2 + i);\n      |                ^~~\n      |                ;\n[REDACTED]/tmpj2qbzhqb.cpp:36:16: error: expected \u2018;\u2019 before \u2018diff\u2019\n   36 |         __m256f diff = _mm_sub_ps(t1, t2);\n      |                ^~~~~\n      |                ;\n[REDACTED]/tmpj2qbzhqb.cpp:37:16: error: expected \u2018;\u2019 before \u2018rounded_diff\u2019\n   37 |         __m256f rounded_diff = _mm_floor_ps(diff);\n      |                ^~~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmpj2qbzhqb.cpp:39:32: error: \u2018rounded_diff\u2019 was not declared in this scope\n   39 |         _mm_storeu_ps(dst + i, rounded_diff);\n      |                                ^~~~~~~~~~~~\n"}
{"task_id": "SimdBench_26_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp34ruczdo.cpp: In function \u2018void tensor3d_sub_round_zero_simd(const float*, const float*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp34ruczdo.cpp:30:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   30 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask for rounding towards zero\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp34ruczdo.cpp:33:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |         __m256 v1 = _mm_loadu_ps(tensor1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp34ruczdo.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 v2 = _mm_loadu_ps(tensor2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp34ruczdo.cpp:36:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   36 |         __m256 sub = _mm_sub_ps(v1, v2);\n      |                                 ^~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp34ruczdo.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp34ruczdo.cpp:16:\n[REDACTED]/tmp34ruczdo.cpp:37:26: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   37 |         __m256 rounded = _mm_round_ps(sub, mask);\n      |                          ^~~~~~~~~~~~\n[REDACTED]/tmp34ruczdo.cpp:37:26: error: cannot convert a vector of type \u2018__m256i\u2019 to type \u2018int\u2019 which has different size\n   37 |         __m256 rounded = _mm_round_ps(sub, mask);\n      |                          ^~~~~~~~~~~~\n[REDACTED]/tmp34ruczdo.cpp:39:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         _mm_storeu_ps(dst + i, rounded);\n      |                                ^~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_26_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9sig_7qt.cpp: In function \u2018void tensor3d_sub_round_zero_simd(const float*, const float*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp9sig_7qt.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask for rounding towards zero\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp9sig_7qt.cpp:36:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   36 |         __m256 v1 = _mm_loadu_ps(tensor1 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp9sig_7qt.cpp:37:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 v2 = _mm_loadu_ps(tensor2 + i);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp9sig_7qt.cpp:39:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 sub = _mm_sub_ps(v1, v2);\n      |                                 ^~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp9sig_7qt.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp9sig_7qt.cpp:16:\n[REDACTED]/tmp9sig_7qt.cpp:40:26: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   40 |         __m256 rounded = _mm_round_ps(sub, mask);\n      |                          ^~~~~~~~~~~~\n[REDACTED]/tmp9sig_7qt.cpp:40:26: error: cannot convert a vector of type \u2018__m256i\u2019 to type \u2018int\u2019 which has different size\n   40 |         __m256 rounded = _mm_round_ps(sub, mask);\n      |                          ^~~~~~~~~~~~\n[REDACTED]/tmp9sig_7qt.cpp:42:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         _mm_storeu_ps(dst + i, rounded);\n      |                                ^~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_26_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmxjmfet5.cpp: In function \u2018void tensor3d_sub_round_zero_simd(const float*, const float*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpmxjmfet5.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask to set all bits to 1\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpmxjmfet5.cpp:36:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   36 |         __m256 v1 = _mm_loadu_ps(&tensor1[i]);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpmxjmfet5.cpp:37:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 v2 = _mm_loadu_ps(&tensor2[i]);\n      |                     ~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpmxjmfet5.cpp:39:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 sub = _mm_sub_ps(v1, v2);\n      |                                 ^~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpmxjmfet5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpmxjmfet5.cpp:16:\n[REDACTED]/tmpmxjmfet5.cpp:41:26: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   41 |         __m256 rounded = _mm_round_ps(sub, _MM_FROUND_TO_ZERO);\n      |                          ^~~~~~~~~~~~\n[REDACTED]/tmpmxjmfet5.cpp:43:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         _mm_storeu_ps(&dst[i], rounded);\n      |                                ^~~~~~~\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_26_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpcerqzkwv.cpp: In function \u2018void tensor3d_sub_round_zero_simd(const float*, const float*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpcerqzkwv.cpp:38:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   38 |         __m256 v1 = _mm256_loadu_ps(t1 + i);\n      |                                     ~~~^~~\n      |                                        |\n      |                                        __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpcerqzkwv.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpcerqzkwv.cpp:39:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   39 |         __m256 v2 = _mm256_loadu_ps(t2 + i);\n      |                                     ~~~^~~\n      |                                        |\n      |                                        __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpcerqzkwv.cpp:48:28: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   48 |         _mm256_storeu_ps(d + i, rounded);\n      |                          ~~^~~\n      |                            |\n      |                            __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_27_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_27_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_27_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_27_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3z_tcbl8.cpp: In function \u2018void matrix_hadamard_product_simd(const double*, const double*, double*, size_t, size_t)\u2019:\n[REDACTED]/tmp3z_tcbl8.cpp:36:44: error: cannot convert \u2018__m256d*\u2019 to \u2018const double*\u2019\n   36 |             __m256d vec1 = _mm256_loadu_pd(&mat1_vec[i * n + j]);\n      |                                            ^~~~~~~~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp3z_tcbl8.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp3z_tcbl8.cpp:37:44: error: cannot convert \u2018__m256d*\u2019 to \u2018const double*\u2019\n   37 |             __m256d vec2 = _mm256_loadu_pd(&mat2_vec[i * n + j]);\n      |                                            ^~~~~~~~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp3z_tcbl8.cpp:39:30: error: cannot convert \u2018__m256d*\u2019 to \u2018double*\u2019\n   39 |             _mm256_storeu_pd(&dst_vec[i * n + j], result);\n      |                              ^~~~~~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:897:27: note:   initializing argument 1 of \u2018void _mm256_storeu_pd(double*, __m256d)\u2019\n  897 | _mm256_storeu_pd (double *__P, __m256d __A)\n      |                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_27_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_28_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpghearbt_.cpp: In function \u2018void matrix_vector_mul_simd(const float*, const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpghearbt_.cpp:34:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 sum = _mm_setzero_ps();\n      |                      ~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpghearbt_.cpp:36:56: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   36 |             __m256 row = _mm_loadu_ps(mat_ptr[i * n + j]);\n      |                                       ~~~~~~~~~~~~~~~~~^\n      |                                                        |\n      |                                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpghearbt_.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpghearbt_.cpp:37:48: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   37 |             __m256 col = _mm_loadu_ps(vec_ptr[j]);\n      |                                       ~~~~~~~~~^\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpghearbt_.cpp:38:46: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |             sum = _mm_add_ps(sum, _mm_mul_ps(row, col));\n      |                                              ^~~\n      |                                              |\n      |                                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpghearbt_.cpp:40:32: error: cannot convert \u2018__m256\u2019 to \u2018float*\u2019\n   40 |         _mm_storeu_ps(dst_ptr[i], sum);\n      |                       ~~~~~~~~~^\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_28_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmper3cn0nc.cpp: In function \u2018void matrix_vector_mul_simd(const float*, const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmper3cn0nc.cpp:34:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 sum = _mm_setzero_ps();\n      |                      ~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmper3cn0nc.cpp:36:56: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   36 |             __m256 row = _mm_loadu_ps(mat_ptr[i * n + j]);\n      |                                       ~~~~~~~~~~~~~~~~~^\n      |                                                        |\n      |                                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmper3cn0nc.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmper3cn0nc.cpp:37:48: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   37 |             __m256 col = _mm_loadu_ps(vec_ptr[j]);\n      |                                       ~~~~~~~~~^\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmper3cn0nc.cpp:38:46: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |             sum = _mm_add_ps(sum, _mm_mul_ps(row, col));\n      |                                              ^~~\n      |                                              |\n      |                                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmper3cn0nc.cpp:40:31: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   40 |         _mm_storeu_ps(dst_ptr + i, sum);\n      |                       ~~~~~~~~^~~\n      |                               |\n      |                               __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_28_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9mnrpf2p.cpp: In function \u2018void matrix_vector_mul_simd(const float*, const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmp9mnrpf2p.cpp:37:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 sum = _mm_setzero_ps();\n      |                      ~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmp9mnrpf2p.cpp:39:39: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   39 |             __m256 row = _mm_loadu_ps(&mat_ptr[i * n + j]);\n      |                                       ^~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp9mnrpf2p.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp9mnrpf2p.cpp:40:39: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   40 |             __m256 col = _mm_loadu_ps(&vec_ptr[j]);\n      |                                       ^~~~~~~~~~~\n      |                                       |\n      |                                       __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp9mnrpf2p.cpp:41:46: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |             sum = _mm_add_ps(sum, _mm_mul_ps(row, col));\n      |                                              ^~~\n      |                                              |\n      |                                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp9mnrpf2p.cpp:43:23: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm_storeu_ps(&dst_ptr[i], sum);\n      |                       ^~~~~~~~~~~\n      |                       |\n      |                       __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_28_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvxnad3ks.cpp: In function \u2018void matrix_vector_mul_simd(const float*, const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpvxnad3ks.cpp:37:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 sum = _mm_setzero_ps();\n      |                      ~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpvxnad3ks.cpp:39:56: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   39 |             __m256 row = _mm_loadu_ps(mat_ptr[i * n + j]);\n      |                                       ~~~~~~~~~~~~~~~~~^\n      |                                                        |\n      |                                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpvxnad3ks.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpvxnad3ks.cpp:40:48: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   40 |             __m256 col = _mm_loadu_ps(vec_ptr[j]);\n      |                                       ~~~~~~~~~^\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpvxnad3ks.cpp:41:46: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |             sum = _mm_add_ps(sum, _mm_mul_ps(row, col));\n      |                                              ^~~\n      |                                              |\n      |                                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpvxnad3ks.cpp:43:31: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm_storeu_ps(dst_ptr + i, sum);\n      |                       ~~~~~~~~^~~\n      |                               |\n      |                               __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_28_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvop4yf0g.cpp: In function \u2018void matrix_vector_mul_simd(const float*, const float*, float*, size_t, size_t)\u2019:\n[REDACTED]/tmpvop4yf0g.cpp:37:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 sum = _mm_setzero_ps();\n      |                      ~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpvop4yf0g.cpp:39:56: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   39 |             __m256 row = _mm_loadu_ps(mat_ptr[i * n + j]);\n      |                                       ~~~~~~~~~~~~~~~~~^\n      |                                                        |\n      |                                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpvop4yf0g.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpvop4yf0g.cpp:40:48: error: cannot convert \u2018__m256\u2019 to \u2018const float*\u2019\n   40 |             __m256 col = _mm_loadu_ps(vec_ptr[j]);\n      |                                       ~~~~~~~~~^\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpvop4yf0g.cpp:41:46: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |             sum = _mm_add_ps(sum, _mm_mul_ps(row, col));\n      |                                              ^~~\n      |                                              |\n      |                                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpvop4yf0g.cpp:43:31: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm_storeu_ps(dst_ptr + i, sum);\n      |                       ~~~~~~~~^~~\n      |                               |\n      |                               __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_29_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphsnf7u0t.cpp: In function \u2018double matrix_average_simd(const double*, size_t, size_t)\u2019:\n[REDACTED]/tmphsnf7u0t.cpp:33:43: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   33 |         __m256d row = _mm256_loadu_pd(ptr + i);\n      |                                       ~~~~^~~\n      |                                           |\n      |                                           const __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmphsnf7u0t.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmphsnf7u0t.cpp:42:24: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   42 |     _mm_store_sd(&avg, sum);\n      |                        ^~~\n      |                        |\n      |                        __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmphsnf7u0t.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:181:36: note:   initializing argument 2 of \u2018void _mm_store_sd(double*, __m128d)\u2019\n  181 | _mm_store_sd (double *__P, __m128d __A)\n      |                            ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_29_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpej3va057.cpp: In function \u2018double matrix_average_simd(const double*, size_t, size_t)\u2019:\n[REDACTED]/tmpej3va057.cpp:34:66: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   34 |             sum = _mm256_add_pd(sum, _mm256_loadu_pd(ptr + i * 4 + j));\n      |                                                      ~~~~~~~~~~~~^~~\n      |                                                                  |\n      |                                                                  const __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpej3va057.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpej3va057.cpp:40:50: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   40 |         sum = _mm256_add_pd(sum, _mm256_loadu_pd(&ptr[i]));\n      |                                                  ^~~~~~~\n      |                                                  |\n      |                                                  const __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpej3va057.cpp:43:21: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   43 |     double result = _mm256_reduce_add_pd(sum);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_29_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3dwmxs70.cpp: In function \u2018double matrix_average_simd(const double*, size_t, size_t)\u2019:\n[REDACTED]/tmp3dwmxs70.cpp:34:55: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   34 |             __m256d vec = _mm256_loadu_pd(ptr + i * n + j);\n      |                                           ~~~~~~~~~~~~^~~\n      |                                                       |\n      |                                                       const __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp3dwmxs70.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp3dwmxs70.cpp:39:24: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   39 |     double total_sum = _mm256_reduce_add_pd(sum);\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_29_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8fdrt16g.cpp: In function \u2018double matrix_average_simd(const double*, size_t, size_t)\u2019:\n[REDACTED]/tmp8fdrt16g.cpp:34:66: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   34 |             sum = _mm256_add_pd(sum, _mm256_loadu_pd(ptr + i * 4 + j));\n      |                                                      ~~~~~~~~~~~~^~~\n      |                                                                  |\n      |                                                                  const __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8fdrt16g.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp8fdrt16g.cpp:37:66: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   37 |             sum = _mm256_add_pd(sum, _mm256_loadu_pd(ptr + i * 4 + n / 4));\n      |                                                      ~~~~~~~~~~~~^~~~~~~\n      |                                                                  |\n      |                                                                  const __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp8fdrt16g.cpp:41:24: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   41 |     double total_sum = _mm256_reduce_add_pd(sum);\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_29_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgoi4zihr.cpp: In function \u2018double matrix_average_simd(const double*, size_t, size_t)\u2019:\n[REDACTED]/tmpgoi4zihr.cpp:34:66: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   34 |             sum = _mm256_add_pd(sum, _mm256_loadu_pd(ptr + i * 4 + j));\n      |                                                      ~~~~~~~~~~~~^~~\n      |                                                                  |\n      |                                                                  const __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpgoi4zihr.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpgoi4zihr.cpp:40:50: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   40 |         sum = _mm256_add_pd(sum, _mm256_loadu_pd(&ptr[i]));\n      |                                                  ^~~~~~~\n      |                                                  |\n      |                                                  const __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpgoi4zihr.cpp:43:18: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   43 |     double avg = _mm256_reduce_add_ps(sum, _mm256_set1_pd(1.0)) / (double)m;\n      |                  ^~~~~~~~~~~~~~~~~~~~\n      |                  _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_30_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpntuzwz2g.cpp: In function \u2018bool matrix_rows_sorted_verify_simd(const int*, const bool*, size_t, size_t)\u2019:\n[REDACTED]/tmpntuzwz2g.cpp:49:34: error: \u2018_mm256_cmplt_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi16\u2019?\n   49 |         if (_mm256_movemask_epi8(_mm256_cmplt_epi16(vec_row, _mm256_setzero_si256())) != 0 && vec_sort_dir[0]) {\n      |                                  ^~~~~~~~~~~~~~~~~~\n      |                                  _mm256_cmpgt_epi16\n"}
{"task_id": "SimdBench_30_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_30_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpohphsuzx.cpp: In function \u2018bool matrix_rows_sorted_verify_simd(const int*, const bool*, size_t, size_t)\u2019:\n[REDACTED]/tmpohphsuzx.cpp:36:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i mask = _mm_set1_epi32(0xFFFFFFFF); // Initialize mask to all ones\n      |                    ~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpohphsuzx.cpp:39:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i row = _mm_loadu_si256((__m256i*)(&matrix[i * cols]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpohphsuzx.cpp:43:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |             sorted_row = _mm_cmpgt_epi32(row, mask); // Compare row elements with mask\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpohphsuzx.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1387:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi32(__m128i, __m128i)\u2019\n 1387 | _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpohphsuzx.cpp:45:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |             sorted_row = _mm_cmplt_epi32(row, mask); // Compare row elements with mask\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1369:26: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi32(__m128i, __m128i)\u2019\n 1369 | _mm_cmplt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpohphsuzx.cpp:48:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |         if (_mm_movemask_epi8(sorted_row) != 0xFFFFFFFF) { // Check if any element is out of order\n      |                               ^~~~~~~~~~\n      |                               |\n      |                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_30_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpup4rkvyq.cpp: In function \u2018bool matrix_rows_sorted_verify_simd(const int*, const bool*, size_t, size_t)\u2019:\n[REDACTED]/tmpup4rkvyq.cpp:51:45: error: \u2018_mm256_cmplt_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   51 |                 vec_mask = _mm256_and_si256(_mm256_cmplt_epi32(vec_col1, vec_col2), vec_mask);\n      |                                             ^~~~~~~~~~~~~~~~~~\n      |                                             _mm256_cmpgt_epi32\n"}
{"task_id": "SimdBench_30_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpado6ssxa.cpp: In function \u2018bool matrix_rows_sorted_verify_simd(const int*, const bool*, size_t, size_t)\u2019:\n[REDACTED]/tmpado6ssxa.cpp:43:62: error: cannot convert \u2018__m256i\u2019 to \u2018const __m256i_u*\u2019\n   43 |             __m256i vec_current = _mm256_loadu_si256(vec_row + j);\n      |                                                      ~~~~~~~~^~~\n      |                                                              |\n      |                                                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpado6ssxa.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpado6ssxa.cpp:44:63: error: cannot convert \u2018__m256i\u2019 to \u2018const __m256i_u*\u2019\n   44 |             __m256i vec_next = _mm256_loadu_si256(vec_row + j + 1);\n      |                                                   ~~~~~~~~~~~~^~~\n      |                                                               |\n      |                                                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpado6ssxa.cpp:47:39: error: could not convert \u2018_mm256_cmpgt_epi32(vec_current, vec_next)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   47 |                 if (_mm256_cmpgt_epi32(vec_current, vec_next)) {\n      |                     ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256i\n[REDACTED]/tmpado6ssxa.cpp:51:21: error: \u2018_mm256_cmplt_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   51 |                 if (_mm256_cmplt_epi32(vec_current, vec_next)) {\n      |                     ^~~~~~~~~~~~~~~~~~\n      |                     _mm256_cmpgt_epi32\n"}
{"task_id": "SimdBench_31_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6f7sug75.cpp: In function \u2018void nearest_multiple_simd(const int16_t*, int16_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmp6f7sug75.cpp:27:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i base_vec = _mm_set1_epi8(base); // Create a vector containing the base value\n      |                        ~~~~~~~~~~~~~^~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp6f7sug75.cpp:28:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   28 |     __m256i mask_vec = _mm_setzero_si256(); // Create a zero vector\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmp6f7sug75.cpp:31:29: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_chunk = _mm_loadu_si256((__m256i*)(&src[i])); // Load 4 elements from src into a vector\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp6f7sug75.cpp:16:\n[REDACTED]/tmp6f7sug75.cpp:32:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128\u2019 which has different size\n   32 |         __m256i rounded_chunk = _mm_round_ps(src_chunk, _MM_FROUND_TO_NEAREST_INT); // Round each element to the nearest integer\n      |                                 ^~~~~~~~~~~~\n[REDACTED]/tmp6f7sug75.cpp:33:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         __m256i remainder_chunk = _mm_sub_epi16(rounded_chunk, src_chunk); // Calculate the remainder of each rounded element\n      |                                                 ^~~~~~~~~~~~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp6f7sug75.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1112:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi16(__m128i, __m128i)\u2019\n 1112 | _mm_sub_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp6f7sug75.cpp:34:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i adjusted_chunk = _mm_add_epi16(remainder_chunk, base_vec); // Add the base value to the remainder\n      |                                                ^~~~~~~~~~~~~~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1064:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi16(__m128i, __m128i)\u2019\n 1064 | _mm_add_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp6f7sug75.cpp:35:46: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i result_chunk = _mm_min_epi16(adjusted_chunk, src_chunk); // Clamp the result to the original value\n      |                                              ^~~~~~~~~~~~~~\n      |                                              |\n      |                                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp6f7sug75.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i*)(&dst[i]), result_chunk); // Store the result back to dst\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_31_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpey_69d98.cpp: In function \u2018void nearest_multiple_simd(const int16_t*, int16_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpey_69d98.cpp:27:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i base_vec = _mm_set1_epi8(base); // Create a vector containing the base value\n      |                        ~~~~~~~~~~~~~^~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpey_69d98.cpp:28:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   28 |     __m256i mask_vec = _mm_setzero_si256(); // Create a zero vector\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmpey_69d98.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[i])); // Load 4 elements from src into a vector\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpey_69d98.cpp:16:\n[REDACTED]/tmpey_69d98.cpp:32:31: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128\u2019 which has different size\n   32 |         __m256i rounded_vec = _mm_round_ps(src_vec, _MM_FROUND_TO_NEAREST_INT); // Round the values to the nearest integer\n      |                               ^~~~~~~~~~~~\n[REDACTED]/tmpey_69d98.cpp:33:31: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   33 |         __m256i aligned_vec = _mm_and_si256(rounded_vec, base_vec); // Align the rounded values to the base value\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_and_si64\n[REDACTED]/tmpey_69d98.cpp:34:30: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   34 |         __m256i result_vec = _mm_or_si256(aligned_vec, mask_vec); // Ensure the result does not exceed the original value\n      |                              ^~~~~~~~~~~~\n      |                              _mm_or_si64\n[REDACTED]/tmpey_69d98.cpp:35:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   35 |         _mm_storeu_si256((__m256i*)(&dst[i]), result_vec); // Store the results back to dst\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_31_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp93751fsj.cpp: In function \u2018void nearest_multiple_simd(const int16_t*, int16_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmp93751fsj.cpp:27:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i base_vec = _mm_set1_epi8(base); // Create a vector containing the base value repeated 4 times\n      |                        ~~~~~~~~~~~~~^~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp93751fsj.cpp:31:15: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |     src_vec = _mm_loadu_si256((__m256i*)src);\n      |               ^~~~~~~~~~~~~~~\n      |               _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp93751fsj.cpp:16:\n[REDACTED]/tmp93751fsj.cpp:34:27: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128\u2019 which has different size\n   34 |     __m256i rounded_src = _mm_round_ps(src_vec, _MM_FROUND_TO_NEAREST_INT); // Round each element to the nearest integer\n      |                           ^~~~~~~~~~~~\n[REDACTED]/tmp93751fsj.cpp:35:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |     __m256i nearest_multiple = _mm_mullo_epi16(rounded_src, base_vec); // Multiply by the base vector\n      |                                                ^~~~~~~~~~~\n      |                                                |\n      |                                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp93751fsj.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1166:26: note:   initializing argument 1 of \u2018__m128i _mm_mullo_epi16(__m128i, __m128i)\u2019\n 1166 | _mm_mullo_epi16 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmp93751fsj.cpp:38:5: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   38 |     _mm_storeu_si256((__m256i*)dst, nearest_multiple);\n      |     ^~~~~~~~~~~~~~~~\n      |     _mm_storeu_si16\n[REDACTED]/tmp93751fsj.cpp:44:23: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128\u2019 which has different size\n   44 |         rounded_src = _mm_round_ps(src_vec, _MM_FROUND_TO_NEAREST_INT); // Round each element to the nearest integer\n      |                       ^~~~~~~~~~~~\n[REDACTED]/tmp93751fsj.cpp:45:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |         nearest_multiple = _mm_mullo_epi16(rounded_src, base_vec); // Multiply by the base vector\n      |                                            ^~~~~~~~~~~\n      |                                            |\n      |                                            __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1166:26: note:   initializing argument 1 of \u2018__m128i _mm_mullo_epi16(__m128i, __m128i)\u2019\n 1166 | _mm_mullo_epi16 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_31_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5t75onof.cpp: In function \u2018void nearest_multiple_simd(const int16_t*, int16_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmp5t75onof.cpp:27:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i base_vec = _mm_set1_epi8(base); // Create a vector containing the base value\n      |                        ~~~~~~~~~~~~~^~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp5t75onof.cpp:28:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   28 |     __m256i mask_vec = _mm_setzero_si256(); // Create a zero vector\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmp5t75onof.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[i])); // Load 4 elements from src into a vector\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp5t75onof.cpp:16:\n[REDACTED]/tmp5t75onof.cpp:32:31: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128\u2019 which has different size\n   32 |         __m256i rounded_vec = _mm_round_ps(src_vec, _MM_FROUND_TO_NEAREST_INT); // Round each element to the nearest integer\n      |                               ^~~~~~~~~~~~\n[REDACTED]/tmp5t75onof.cpp:33:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         __m256i remainder_vec = _mm_sub_epi16(rounded_vec, src_vec); // Calculate the remainder of each rounded element\n      |                                               ^~~~~~~~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp5t75onof.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1112:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi16(__m128i, __m128i)\u2019\n 1112 | _mm_sub_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp5t75onof.cpp:34:42: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   34 |         __m256i adjusted_remainder_vec = _mm_and_si256(remainder_vec, mask_vec); // Mask out the remainder if it's greater than half the base\n      |                                          ^~~~~~~~~~~~~\n      |                                          _mm_and_si64\n[REDACTED]/tmp5t75onof.cpp:35:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i adjusted_rounded_vec = _mm_add_epi16(rounded_vec, adjusted_remainder_vec); // Adjust the rounded element by adding the remainder\n      |                                                      ^~~~~~~~~~~\n      |                                                      |\n      |                                                      __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1064:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi16(__m128i, __m128i)\u2019\n 1064 | _mm_add_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp5t75onof.cpp:36:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         __m256i result_vec = _mm_min_epi16(adjusted_rounded_vec, src_vec); // Clamp the result to the original value\n      |                                            ^~~~~~~~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp5t75onof.cpp:37:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   37 |         _mm_storeu_si256((__m256i*)(&dst[i]), result_vec); // Store the result back to dst\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_31_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9f2wruqa.cpp: In function \u2018void nearest_multiple_simd(const int16_t*, int16_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmp9f2wruqa.cpp:27:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i base_vec = _mm_set1_epi8(base); // Load base into a vector\n      |                        ~~~~~~~~~~~~~^~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp9f2wruqa.cpp:31:29: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i src_chunk = _mm_loadu_si256((__m256i*)(&src[i])); // Load 4 elements from src\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp9f2wruqa.cpp:16:\n[REDACTED]/tmp9f2wruqa.cpp:32:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128\u2019 which has different size\n   32 |         __m256i rounded_chunk = _mm_round_ps(src_chunk, _MM_FROUND_TO_NEAREST_INT); // Round each element\n      |                                 ^~~~~~~~~~~~\n[REDACTED]/tmp9f2wruqa.cpp:35:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i multiplied_chunk = _mm_mullo_epi16(rounded_chunk, base_vec);\n      |                                                    ^~~~~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp9f2wruqa.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1166:26: note:   initializing argument 1 of \u2018__m128i _mm_mullo_epi16(__m128i, __m128i)\u2019\n 1166 | _mm_mullo_epi16 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmp9f2wruqa.cpp:38:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         __m256i nearest_chunk = _mm_sub_epi16(multiplied_chunk, base_vec);\n      |                                               ^~~~~~~~~~~~~~~~\n      |                                               |\n      |                                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1112:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi16(__m128i, __m128i)\u2019\n 1112 | _mm_sub_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp9f2wruqa.cpp:41:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   41 |         _mm_storeu_si256((__m256i*)(&dst[i]), nearest_chunk);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_32_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwl0qch13.cpp: In function \u2018bool matrix_has_row_simd(const double*, const double*, size_t, size_t)\u2019:\n[REDACTED]/tmpwl0qch13.cpp:36:39: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   36 |     __m256 v_vector = _mm256_loadu_ps(vector); // Load the vector into a 256-bit register\n      |                                       ^~~~~~\n      |                                       |\n      |                                       const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpwl0qch13.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpwl0qch13.cpp:39:54: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   39 |         __m256 v_matrix_row = _mm256_loadu_ps(matrix + i * cols); // Load the current row into a 256-bit register\n      |                                               ~~~~~~~^~~~~~~~~~\n      |                                                      |\n      |                                                      const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_32_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp88a_lelw.cpp: In function \u2018bool matrix_has_row_simd(const double*, const double*, size_t, size_t)\u2019:\n[REDACTED]/tmp88a_lelw.cpp:36:38: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   36 |     __m256 v_vector = _mm256_loadu_pd(vector);\n      |                       ~~~~~~~~~~~~~~~^~~~~~~~\n      |                                      |\n      |                                      __m256d\n[REDACTED]/tmp88a_lelw.cpp:38:46: error: cannot convert \u2018__m256d\u2019 to \u2018__m256\u2019 in initialization\n   38 |         __m256 v_matrix_row = _mm256_loadu_pd(matrix + i * cols);\n      |                               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n      |                                              |\n      |                                              __m256d\n[REDACTED]/tmp88a_lelw.cpp:39:25: error: \u2018_mm256_cmpneq_ps\u2019 was not declared in this scope; did you mean \u2018_mm_cmpneq_ps\u2019?\n   39 |         __m256 result = _mm256_cmpneq_ps(v_matrix_row, v_vector);\n      |                         ^~~~~~~~~~~~~~~~\n      |                         _mm_cmpneq_ps\n[REDACTED]/tmp88a_lelw.cpp:40:34: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   40 |         if (_mm256_movemask_epi8(result) != 0) {\n      |                                  ^~~~~~\n      |                                  |\n      |                                  __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmp88a_lelw.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:433:31: note:   initializing argument 1 of \u2018int _mm256_movemask_epi8(__m256i)\u2019\n  433 | _mm256_movemask_epi8 (__m256i __A)\n      |                       ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_32_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6n99l1zf.cpp: In function \u2018bool matrix_has_row_simd(const double*, const double*, size_t, size_t)\u2019:\n[REDACTED]/tmp6n99l1zf.cpp:33:29: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   33 |     __m256 v = _mm_loadu_ps(vector); // Load the vector into a 256-bit register\n      |                             ^~~~~~\n      |                             |\n      |                             const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp6n99l1zf.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp6n99l1zf.cpp:36:40: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   36 |         __m256 m = _mm_loadu_ps(matrix + i * cols); // Load a row from the matrix into a 256-bit register\n      |                                 ~~~~~~~^~~~~~~~~~\n      |                                        |\n      |                                        const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp6n99l1zf.cpp:37:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   37 |         __m256 result = _mm_cmpeq_ps(m, v); // Compare each element of the row with the vector\n      |                                      ^\n      |                                      |\n      |                                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:366:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpeq_ps(__m128, __m128)\u2019\n  366 | _mm_cmpeq_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmp6n99l1zf.cpp:38:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |         if (_mm_movemask_ps(result) != 0) { // Check if there is at least one matching element\n      |                             ^~~~~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\n"}
{"task_id": "SimdBench_32_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplsom5q3z.cpp: In function \u2018bool matrix_has_row_simd(const double*, const double*, size_t, size_t)\u2019:\n[REDACTED]/tmplsom5q3z.cpp:39:26: error: \u2018_mm256_cmpneq_pd\u2019 was not declared in this scope; did you mean \u2018_mm_cmpneq_pd\u2019?\n   39 |         __m256d result = _mm256_cmpneq_pd(v_matrix, v_vector);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm_cmpneq_pd\n[REDACTED]/tmplsom5q3z.cpp:40:34: error: cannot convert \u2018__m256d\u2019 to \u2018__m256i\u2019\n   40 |         if (_mm256_movemask_epi8(result) != 0) {\n      |                                  ^~~~~~\n      |                                  |\n      |                                  __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmplsom5q3z.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:433:31: note:   initializing argument 1 of \u2018int _mm256_movemask_epi8(__m256i)\u2019\n  433 | _mm256_movemask_epi8 (__m256i __A)\n      |                       ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_32_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmped6qrqu4.cpp: In function \u2018bool matrix_has_row_simd(const double*, const double*, size_t, size_t)\u2019:\n[REDACTED]/tmped6qrqu4.cpp:39:26: error: \u2018_mm256_cmpneq_pd\u2019 was not declared in this scope; did you mean \u2018_mm_cmpneq_pd\u2019?\n   39 |         __m256d result = _mm256_cmpneq_pd(v_matrix, v_vector);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm_cmpneq_pd\n[REDACTED]/tmped6qrqu4.cpp:40:34: error: cannot convert \u2018__m256d\u2019 to \u2018__m256i\u2019\n   40 |         if (_mm256_movemask_epi8(result) != 0) {\n      |                                  ^~~~~~\n      |                                  |\n      |                                  __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmped6qrqu4.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:433:31: note:   initializing argument 1 of \u2018int _mm256_movemask_epi8(__m256i)\u2019\n  433 | _mm256_movemask_epi8 (__m256i __A)\n      |                       ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_33_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkprm_s5v.cpp: In function \u2018size_t tensor_4d_equal_count_simd(const uint8_t*, const uint8_t*, const size_t*)\u2019:\n[REDACTED]/tmpkprm_s5v.cpp:43:36: error: \u2018_mm256_cmpneq_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi8\u2019?\n   43 |                     __m256i mask = _mm256_cmpneq_epi8(diff, _mm256_setzero_si256());\n      |                                    ^~~~~~~~~~~~~~~~~~\n      |                                    _mm256_cmpeq_epi8\n[REDACTED]/tmpkprm_s5v.cpp:46:36: error: \u2018_mm256_reduce_add_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   46 |                     total_count += _mm256_reduce_add_epi8(sum);\n      |                                    ^~~~~~~~~~~~~~~~~~~~~~\n      |                                    _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_33_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_33_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3k2wgdcj.cpp: In function \u2018size_t tensor_4d_equal_count_simd(const uint8_t*, const uint8_t*, const size_t*)\u2019:\n[REDACTED]/tmp3k2wgdcj.cpp:47:24: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   47 |         total_count += _mm256_reduce_add_epi32(count_result);\n      |                        ^~~~~~~~~~~~~~~~~~~~~~~\n      |                        _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_33_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpv5iaffpu.cpp: In function \u2018size_t tensor_4d_equal_count_simd(const uint8_t*, const uint8_t*, const size_t*)\u2019:\n[REDACTED]/tmpv5iaffpu.cpp:43:51: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   43 |                     __m256 cmp = _mm256_cmpeq_epi8(a, b);\n      |                                  ~~~~~~~~~~~~~~~~~^~~~~~\n      |                                                   |\n      |                                                   __m256i\n[REDACTED]/tmpv5iaffpu.cpp:46:36: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   46 |                     total_count += _mm256_popcnt_u32(_mm256_extract_epi32(cmp, 0)) +\n      |                                    ^~~~~~~~~~~~~~~~~\n      |                                    _mm_popcnt_u32\n"}
{"task_id": "SimdBench_33_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_34_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxvviwr47.cpp: In function \u2018void axm_abs_simd(size_t, int64_t, const int64_t*, int64_t*)\u2019:\n[REDACTED]/tmpxvviwr47.cpp:29:26: error: \u2018_mm256_mul_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi64\u2019?\n   29 |     __m256i result_vec = _mm256_mul_epi64(a_vec, abs_x_vec);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm256_sub_epi64\n"}
{"task_id": "SimdBench_34_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5yer9etv.cpp: In function \u2018void axm_abs_simd(size_t, int64_t, const int64_t*, int64_t*)\u2019:\n[REDACTED]/tmp5yer9etv.cpp:29:26: error: \u2018_mm256_mul_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi64\u2019?\n   29 |     __m256i result_vec = _mm256_mul_epi64(a_vec, abs_x_vec);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm256_sub_epi64\n"}
{"task_id": "SimdBench_34_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpsa49xb3z.cpp: In function \u2018void axm_abs_simd(size_t, int64_t, const int64_t*, int64_t*)\u2019:\n[REDACTED]/tmpsa49xb3z.cpp:29:26: error: \u2018_mm256_mul_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi64\u2019?\n   29 |     __m256i result_vec = _mm256_mul_epi64(a_vec, abs_x_vec);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm256_sub_epi64\n"}
{"task_id": "SimdBench_34_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8oau3dsf.cpp: In function \u2018void axm_abs_simd(size_t, int64_t, const int64_t*, int64_t*)\u2019:\n[REDACTED]/tmp8oau3dsf.cpp:29:26: error: \u2018_mm256_mul_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi64\u2019?\n   29 |     __m256i result_vec = _mm256_mul_epi64(a_vec, abs_x_vec);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm256_sub_epi64\n"}
{"task_id": "SimdBench_34_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi0ee1rfd.cpp: In function \u2018void axm_abs_simd(size_t, int64_t, const int64_t*, int64_t*)\u2019:\n[REDACTED]/tmpi0ee1rfd.cpp:25:21: error: \u2018_mm256_set1_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   25 |     __m256i a_vec = _mm256_set1_epi64(a);\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm256_set1_epi64x\n"}
{"task_id": "SimdBench_35_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1hqou_la.cpp:49:3: error: conflicting declaration \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   49 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmp1hqou_la.cpp:22:3: note: previous declaration as \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   22 | } MinMaxPair;\n      |   ^~~~~~~~~~\n"}
{"task_id": "SimdBench_35_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqr6iyo7a.cpp:49:3: error: conflicting declaration \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   49 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmpqr6iyo7a.cpp:22:3: note: previous declaration as \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   22 | } MinMaxPair;\n      |   ^~~~~~~~~~\n"}
{"task_id": "SimdBench_35_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbw9684eh.cpp:49:3: error: conflicting declaration \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   49 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmpbw9684eh.cpp:22:3: note: previous declaration as \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   22 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmpbw9684eh.cpp: In function \u2018MinMaxPair min_max_pair_simd(const int16_t*, size_t)\u2019:\n[REDACTED]/tmpbw9684eh.cpp:52:17: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   52 |     __m256i v = _mm_loadu_si256((__m256i*)vec);\n      |                 ^~~~~~~~~~~~~~~\n      |                 _mm_loadu_si16\n[REDACTED]/tmpbw9684eh.cpp:53:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   53 |     __m256i min_v = _mm_min_epi16(v, v);\n      |                                   ^\n      |                                   |\n      |                                   __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpbw9684eh.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:54:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   54 |     __m256i max_v = _mm_max_epi16(v, v);\n      |                                   ^\n      |                                   |\n      |                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:58:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   58 |         min_v = _mm_min_epi16(min_v, v);\n      |                               ^~~~~\n      |                               |\n      |                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:59:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   59 |         max_v = _mm_max_epi16(max_v, v);\n      |                               ^~~~~\n      |                               |\n      |                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:63:27: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   63 |     min_v = _mm_min_epi16(min_v, last_v);\n      |                           ^~~~~\n      |                           |\n      |                           __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:64:27: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   64 |     max_v = _mm_max_epi16(max_v, last_v);\n      |                           ^~~~~\n      |                           |\n      |                           __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:66:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   66 |     __m128i min_m = _mm_cvtepi32_epi16(_mm_min_epi16(min_v, _mm_setzero_si128()));\n      |                                                      ^~~~~\n      |                                                      |\n      |                                                      __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpbw9684eh.cpp:67:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   67 |     __m128i max_m = _mm_cvtepi32_epi16(_mm_max_epi16(max_v, _mm_setzero_si128()));\n      |                                                      ^~~~~\n      |                                                      |\n      |                                                      __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_35_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpa9d6t57m.cpp:49:3: error: conflicting declaration \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   49 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmpa9d6t57m.cpp:22:3: note: previous declaration as \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   22 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmpa9d6t57m.cpp: In function \u2018MinMaxPair min_max_pair_simd(const int16_t*, size_t)\u2019:\n[REDACTED]/tmpa9d6t57m.cpp:52:17: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   52 |     __m256i v = _mm_loadu_si256((__m256i*)vec);\n      |                 ^~~~~~~~~~~~~~~\n      |                 _mm_loadu_si16\n[REDACTED]/tmpa9d6t57m.cpp:53:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   53 |     __m256i min_v = _mm_min_epi16(v, v);\n      |                                   ^\n      |                                   |\n      |                                   __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpa9d6t57m.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpa9d6t57m.cpp:54:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   54 |     __m256i max_v = _mm_max_epi16(v, v);\n      |                                   ^\n      |                                   |\n      |                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpa9d6t57m.cpp:58:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   58 |         __m256i min_v = _mm_min_epi16(min_v, v);\n      |                                       ^~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpa9d6t57m.cpp:59:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   59 |         __m256i max_v = _mm_max_epi16(max_v, v);\n      |                                       ^~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpa9d6t57m.cpp:62:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   62 |     __m256i min_final = _mm_min_epi16(min_v, min_v);\n      |                                       ^~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1425:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi16(__m128i, __m128i)\u2019\n 1425 | _mm_min_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpa9d6t57m.cpp:63:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   63 |     __m256i max_final = _mm_max_epi16(max_v, max_v);\n      |                                       ^~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1413:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi16(__m128i, __m128i)\u2019\n 1413 | _mm_max_epi16 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpa9d6t57m.cpp:65:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   65 |     int16_t min_num = _mm_cvtsi128_si32(_mm_extract_epi16(min_final, 0));\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpa9d6t57m.cpp:66:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   66 |     int16_t max_num = _mm_cvtsi128_si32(_mm_extract_epi16(max_final, 0));\n      |                                         ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_35_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpk0mdfa6y.cpp:49:3: error: conflicting declaration \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   49 | } MinMaxPair;\n      |   ^~~~~~~~~~\n[REDACTED]/tmpk0mdfa6y.cpp:22:3: note: previous declaration as \u2018typedef struct MinMaxPair MinMaxPair\u2019\n   22 | } MinMaxPair;\n      |   ^~~~~~~~~~\n"}
{"task_id": "SimdBench_36_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptnhlkt5w.cpp: In function \u2018bool matrix_rows_strictly_increasing_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmptnhlkt5w.cpp:46:31: error: could not convert \u2018_mm256_cmpgt_epi32(current_row, next_row)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   46 |         if (_mm256_cmpgt_epi32(current_row, next_row)) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n"}
{"task_id": "SimdBench_36_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9x9bwrro.cpp: In function \u2018bool matrix_rows_strictly_increasing_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmp9x9bwrro.cpp:43:31: error: could not convert \u2018_mm256_cmpgt_epi32(current_row, next_row)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   43 |         if (_mm256_cmpgt_epi32(current_row, next_row)) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n[REDACTED]/tmp9x9bwrro.cpp:55:32: error: could not convert \u2018((__m256i{((long long int [4])current_row)[i], ((long long int [4])current_row)[i], ((long long int [4])current_row)[i], ((long long int [4])current_row)[i]} <= ((__m256i)(*(ptr + ((sizetype)(i * 32)))))) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   55 |             if (current_row[i] <= *(ptr + i)) {\n      |                 ~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                |\n      |                                __vector(4) long int\n"}
{"task_id": "SimdBench_36_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpcabwbezh.cpp: In function \u2018bool matrix_rows_strictly_increasing_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmpcabwbezh.cpp:43:31: error: could not convert \u2018_mm256_cmpgt_epi32(current_row, next_row)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   43 |         if (_mm256_cmpgt_epi32(current_row, next_row)) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n[REDACTED]/tmpcabwbezh.cpp:52:18: error: could not convert \u2018((((__m256i)(* ptr)) >= ((__m256i)(*(ptr + 32)))) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   52 |         if (*ptr >= *(ptr + 1)) {\n      |             ~~~~~^~~~~~~~~~~~~\n      |                  |\n      |                  __vector(4) long int\n"}
{"task_id": "SimdBench_36_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpu_brefge.cpp: In function \u2018bool matrix_rows_strictly_increasing_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmpu_brefge.cpp:46:31: error: could not convert \u2018_mm256_cmpgt_epi32(current_row, next_row)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   46 |         if (_mm256_cmpgt_epi32(current_row, next_row)) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n"}
{"task_id": "SimdBench_36_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpn2p5idz5.cpp: In function \u2018bool matrix_rows_strictly_increasing_simd(const int*, size_t, size_t)\u2019:\n[REDACTED]/tmpn2p5idz5.cpp:41:33: error: invalid conversion from \u2018const __m256i*\u2019 to \u2018__m256i*\u2019 [-fpermissive]\n   41 |     for (__m256i* current_row = row_start; current_row != end; ++current_row) {\n      |                                 ^~~~~~~~~\n      |                                 |\n      |                                 const __m256i*\n[REDACTED]/tmpn2p5idz5.cpp:46:31: error: could not convert \u2018_mm256_cmpgt_epi32(prev_row, next_row)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   46 |         if (_mm256_cmpgt_epi32(prev_row, next_row)) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n[REDACTED]/tmpn2p5idz5.cpp:52:12: error: \u2018current_row\u2019 was not declared in this scope\n   52 |     for (; current_row != row_start + rows / 4; ++current_row) {\n      |            ^~~~~~~~~~~\n[REDACTED]/tmpn2p5idz5.cpp:57:31: error: could not convert \u2018_mm256_cmpgt_epi32(prev_row, next_row)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   57 |         if (_mm256_cmpgt_epi32(prev_row, next_row)) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n"}
{"task_id": "SimdBench_37_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpa62sohpe.cpp: In function \u2018bool matrix_blocks_equal_simd(const int*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpa62sohpe.cpp:45:41: error: \u2018min\u2019 was not declared in this scope; did you mean \u2018std::min\u2019?\n   45 |     if (block_size == 0 || block_size > min(rows, cols)) {\n      |                                         ^~~\n      |                                         std::min\nIn file included from /usr/include/c++/13/algorithm:61,\n                 from [REDACTED]/utils.hpp:8,\n                 from [REDACTED]/tmpa62sohpe.cpp:14:\n/usr/include/c++/13/bits/stl_algo.h:5785:5: note: \u2018std::min\u2019 declared here\n 5785 |     min(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^~~\n[REDACTED]/tmpa62sohpe.cpp:51:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   51 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpa62sohpe.cpp:58:26: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   58 |         __m256i block1 = _mm_loadu_si256((__m256i*)(matrix + row_start * cols + col_start));\n      |                          ^~~~~~~~~~~~~~~\n      |                          _mm_loadu_si16\n[REDACTED]/tmpa62sohpe.cpp:61:55: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   61 |         result = _mm_or_si256(result, _mm_cmpeq_epi32(block1, block2));\n      |                                                       ^~~~~~\n      |                                                       |\n      |                                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpa62sohpe.cpp:61:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   61 |         result = _mm_or_si256(result, _mm_cmpeq_epi32(block1, block2));\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmpa62sohpe.cpp:64:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   64 |     return _mm_movemask_epi8(result) != 0;\n      |                              ^~~~~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_37_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmvore5mb.cpp: In function \u2018bool matrix_blocks_equal_simd(const int*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpmvore5mb.cpp:51:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   51 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpmvore5mb.cpp:58:26: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   58 |         __m256i block1 = _mm_loadu_si256(reinterpret_cast<const __m256i*>(matrix + row_start * cols + col_start));\n      |                          ^~~~~~~~~~~~~~~\n      |                          _mm_loadu_si16\n[REDACTED]/tmpmvore5mb.cpp:61:55: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   61 |         result = _mm_or_si256(result, _mm_cmpeq_epi32(block1, block2));\n      |                                                       ^~~~~~\n      |                                                       |\n      |                                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpmvore5mb.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpmvore5mb.cpp:61:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   61 |         result = _mm_or_si256(result, _mm_cmpeq_epi32(block1, block2));\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmpmvore5mb.cpp:64:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   64 |     return _mm_movemask_epi8(result) != 0;\n      |                              ^~~~~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_37_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpm9_kkt8j.cpp: In function \u2018bool matrix_blocks_equal_simd(const int*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpm9_kkt8j.cpp:51:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   51 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpm9_kkt8j.cpp:58:26: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   58 |         __m256i block1 = _mm_loadu_si256((__m256i*)(matrix + row_start * cols + col_start));\n      |                          ^~~~~~~~~~~~~~~\n      |                          _mm_loadu_si16\n[REDACTED]/tmpm9_kkt8j.cpp:61:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   61 |         diff_mask = _mm_sub_epi32(block1, block2);\n      |                                   ^~~~~~\n      |                                   |\n      |                                   __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpm9_kkt8j.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpm9_kkt8j.cpp:63:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   63 |         mask = _mm_or_si256(mask, diff_mask);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpm9_kkt8j.cpp:66:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   66 |     return _mm_movemask_epi8(mask) == 0;\n      |                              ^~~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_37_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7ulj7rs7.cpp: In function \u2018bool matrix_blocks_equal_simd(const int*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp7ulj7rs7.cpp:49:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   49 |     __m256i mask = _mm_set1_epi32(0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmp7ulj7rs7.cpp:54:35: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   54 |             const __m256i block = _mm_loadu_si256((__m256i*)block_start);\n      |                                   ^~~~~~~~~~~~~~~\n      |                                   _mm_loadu_si16\n[REDACTED]/tmp7ulj7rs7.cpp:58:25: error: \u2018_mm_test_all_eq\u2019 was not declared in this scope; did you mean \u2018_mm_test_all_ones\u2019?\n   58 |                     if (_mm_test_all_eq(block, _mm_set1_epi32(matrix[i * block_size * cols + j * block_size + k * block_size + l]))) {\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_test_all_ones\n"}
{"task_id": "SimdBench_37_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpj0543pcf.cpp: In function \u2018bool matrix_blocks_equal_simd(const int*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpj0543pcf.cpp:51:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   51 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpj0543pcf.cpp:58:26: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   58 |         __m256i block1 = _mm_loadu_si256(reinterpret_cast<const __m256i*>(matrix + row_start * cols + col_start));\n      |                          ^~~~~~~~~~~~~~~\n      |                          _mm_loadu_si16\n[REDACTED]/tmpj0543pcf.cpp:61:55: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   61 |         result = _mm_or_si256(result, _mm_cmpeq_epi32(block1, block2));\n      |                                                       ^~~~~~\n      |                                                       |\n      |                                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpj0543pcf.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpj0543pcf.cpp:61:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   61 |         result = _mm_or_si256(result, _mm_cmpeq_epi32(block1, block2));\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmpj0543pcf.cpp:64:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   64 |     return _mm_movemask_epi8(result) != 0;\n      |                              ^~~~~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_38_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvpw7_7ls.cpp: In function \u2018bool vector_block_equal_simd(const double*, double, size_t, size_t)\u2019:\n[REDACTED]/tmpvpw7_7ls.cpp:47:42: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   47 |         __m256d block1 = _mm256_loadu_pd(v);\n      |                                          ^\n      |                                          |\n      |                                          const __m256d*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpvpw7_7ls.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpvpw7_7ls.cpp:48:57: error: cannot convert \u2018const __m256d*\u2019 to \u2018const double*\u2019\n   48 |         __m256d block2 = _mm256_loadu_pd(v + block_size - 1);\n      |                                          ~~~~~~~~~~~~~~~^~~\n      |                                                         |\n      |                                                         const __m256d*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:891:32: note:   initializing argument 1 of \u2018__m256d _mm256_loadu_pd(const double*)\u2019\n  891 | _mm256_loadu_pd (double const *__P)\n      |                  ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpvpw7_7ls.cpp:51:28: error: \u2018_mm256_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   51 |         __m256d abs_diff = _mm256_abs_pd(diff);\n      |                            ^~~~~~~~~~~~~\n      |                            _mm256_abs_ph\n"}
{"task_id": "SimdBench_38_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9hdo_d0r.cpp: In function \u2018bool vector_block_equal_simd(const double*, double, size_t, size_t)\u2019:\n[REDACTED]/tmp9hdo_d0r.cpp:42:45: error: cannot convert \u2018__m128d\u2019 to \u2018const __m256\u2019 in initialization\n   42 |     const __m256 tolerance_vec = _mm_set1_pd(tolerance);\n      |                                  ~~~~~~~~~~~^~~~~~~~~~~\n      |                                             |\n      |                                             __m128d\n[REDACTED]/tmp9hdo_d0r.cpp:45:42: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   45 |         __m256 block1 = _mm_loadu_ps(vec + i);\n      |                                      ~~~~^~~\n      |                                          |\n      |                                          const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp9hdo_d0r.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp9hdo_d0r.cpp:46:46: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   46 |         __m256 block2 = _mm_loadu_ps(vec + i + block_size / 2);\n      |                                      ~~~~~~~~^~~~~~~~~~~~~~~~\n      |                                              |\n      |                                              const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp9hdo_d0r.cpp:48:34: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         __m256 diff = _mm_sub_ps(block1, block2);\n      |                                  ^~~~~~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp9hdo_d0r.cpp:49:27: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   49 |         __m256 abs_diff = _mm_abs_ps(diff);\n      |                           ^~~~~~~~~~\n      |                           _mm_abs_ph\n[REDACTED]/tmp9hdo_d0r.cpp:50:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   50 |         __m256 max_diff = _mm_max_ps(abs_diff, tolerance_vec);\n      |                                      ^~~~~~~~\n      |                                      |\n      |                                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:238:20: note:   initializing argument 1 of \u2018__m128 _mm_max_ps(__m128, __m128)\u2019\n  238 | _mm_max_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp9hdo_d0r.cpp:52:42: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   52 |         if (_mm_movemask_ps(_mm_cmpge_ps(max_diff, tolerance_vec)) != 0) {\n      |                                          ^~~~~~~~\n      |                                          |\n      |                                          __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:390:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpge_ps(__m128, __m128)\u2019\n  390 | _mm_cmpge_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n"}
{"task_id": "SimdBench_38_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp229ehn24.cpp: In function \u2018bool vector_block_equal_simd(const double*, double, size_t, size_t)\u2019:\n[REDACTED]/tmp229ehn24.cpp:42:39: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   42 |     const __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask for checking equality\n      |                          ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmp229ehn24.cpp:45:38: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   45 |         __m256 v1 = _mm_loadu_ps(vec + i);\n      |                                  ~~~~^~~\n      |                                      |\n      |                                      const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp229ehn24.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp229ehn24.cpp:46:38: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   46 |         __m256 v2 = _mm_loadu_ps(vec + i);\n      |                                  ~~~~^~~\n      |                                      |\n      |                                      const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp229ehn24.cpp:48:34: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         __m256 diff = _mm_sub_ps(v1, v2);\n      |                                  ^~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp229ehn24.cpp:49:27: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   49 |         __m256 abs_diff = _mm_abs_ps(diff);\n      |                           ^~~~~~~~~~\n      |                           _mm_abs_ph\n[REDACTED]/tmp229ehn24.cpp:51:39: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   51 |         __m256 threshold = _mm_set1_ps(tolerance);\n      |                            ~~~~~~~~~~~^~~~~~~~~~~\n      |                                       |\n      |                                       __m128\n[REDACTED]/tmp229ehn24.cpp:52:41: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   52 |         __m256 condition = _mm_cmpgt_ps(abs_diff, threshold);\n      |                                         ^~~~~~~~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmp229ehn24.cpp:54:25: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   54 |         __m256 result = _mm_andnot_si256(condition, mask);\n      |                         ^~~~~~~~~~~~~~~~\n      |                         _mm_andnot_si64\n[REDACTED]/tmp229ehn24.cpp:55:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   55 |         if (_mm_movemask_ps(result) != 0) {\n      |                             ^~~~~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\n"}
{"task_id": "SimdBench_38_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2i4etg6v.cpp: In function \u2018bool vector_block_equal_simd(const double*, double, size_t, size_t)\u2019:\n[REDACTED]/tmp2i4etg6v.cpp:39:40: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   39 |     const __m256i mask = _mm_set1_epi32(-1); // Mask to compare all elements\n      |                          ~~~~~~~~~~~~~~^~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmp2i4etg6v.cpp:42:38: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   42 |         __m256 v1 = _mm_loadu_ps(vec + i);\n      |                                  ~~~~^~~\n      |                                      |\n      |                                      const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2i4etg6v.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp2i4etg6v.cpp:43:38: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   43 |         __m256 v2 = _mm_loadu_ps(vec + i);\n      |                                  ~~~~^~~\n      |                                      |\n      |                                      const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp2i4etg6v.cpp:45:34: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         __m256 diff = _mm_sub_ps(v1, v2);\n      |                                  ^~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp2i4etg6v.cpp:46:27: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   46 |         __m256 abs_diff = _mm_abs_ps(diff);\n      |                           ^~~~~~~~~~\n      |                           _mm_abs_ph\n[REDACTED]/tmp2i4etg6v.cpp:48:39: error: cannot convert \u2018__m128d\u2019 to \u2018__m256\u2019 in initialization\n   48 |         __m256 threshold = _mm_set1_pd(tolerance);\n      |                            ~~~~~~~~~~~^~~~~~~~~~~\n      |                                       |\n      |                                       __m128d\n[REDACTED]/tmp2i4etg6v.cpp:49:41: error: cannot convert \u2018__m256\u2019 to \u2018__m128d\u2019\n   49 |         __m256 condition = _mm_cmpgt_pd(abs_diff, threshold);\n      |                                         ^~~~~~~~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmp2i4etg6v.cpp:51:25: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   51 |         __m256 result = _mm_andnot_si256(condition, mask);\n      |                         ^~~~~~~~~~~~~~~~\n      |                         _mm_andnot_si64\n[REDACTED]/tmp2i4etg6v.cpp:52:31: error: cannot convert \u2018__m256\u2019 to \u2018__m128i\u2019\n   52 |         if (_mm_movemask_epi8(result) != 0) {\n      |                               ^~~~~~\n      |                               |\n      |                               __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_38_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5fg8fxp9.cpp: In function \u2018bool vector_block_equal_simd(const double*, double, size_t, size_t)\u2019:\n[REDACTED]/tmp5fg8fxp9.cpp:42:40: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   42 |     const __m256i mask = _mm_set1_epi32(-1); // Mask to compare all elements\n      |                          ~~~~~~~~~~~~~~^~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmp5fg8fxp9.cpp:45:38: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   45 |         __m256d block1 = _mm_loadu_pd(&vec[i]);\n      |                          ~~~~~~~~~~~~^~~~~~~~~\n      |                                      |\n      |                                      __m128d\n[REDACTED]/tmp5fg8fxp9.cpp:46:38: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   46 |         __m256d block2 = _mm_loadu_pd(&vec[i]);\n      |                          ~~~~~~~~~~~~^~~~~~~~~\n      |                                      |\n      |                                      __m128d\n[REDACTED]/tmp5fg8fxp9.cpp:48:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   48 |         __m256d diff = _mm_sub_pd(block1, block2);\n      |                                   ^~~~~~\n      |                                   |\n      |                                   __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp5fg8fxp9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:261:21: note:   initializing argument 1 of \u2018__m128d _mm_sub_pd(__m128d, __m128d)\u2019\n  261 | _mm_sub_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmp5fg8fxp9.cpp:49:28: error: \u2018_mm_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   49 |         __m256d abs_diff = _mm_abs_pd(diff);\n      |                            ^~~~~~~~~~\n      |                            _mm_abs_ph\n[REDACTED]/tmp5fg8fxp9.cpp:51:40: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   51 |         __m256d threshold = _mm_set1_pd(tolerance);\n      |                             ~~~~~~~~~~~^~~~~~~~~~~\n      |                                        |\n      |                                        __m128d\n[REDACTED]/tmp5fg8fxp9.cpp:52:36: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   52 |         __m256 cond = _mm_cmpgt_pd(abs_diff, threshold);\n      |                                    ^~~~~~~~\n      |                                    |\n      |                                    __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmp5fg8fxp9.cpp:54:42: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   54 |         __m256i result = _mm_movemask_ps(cond);\n      |                                          ^~~~\n      |                                          |\n      |                                          __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\n[REDACTED]/tmp5fg8fxp9.cpp:55:32: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   55 |         if (__builtin_popcount(result) > 0) {\n      |                                ^~~~~~\n      |                                |\n      |                                __m256i\n<built-in>: note:   initializing argument 1 of \u2018int __builtin_popcount(unsigned int)\u2019\n"}
{"task_id": "SimdBench_39_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8enr2a5q.cpp: In function \u2018void matrix_row_norm_compare_simd(const double*, const double*, size_t, size_t, bool*)\u2019:\n[REDACTED]/tmp8enr2a5q.cpp:31:36: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i sum = _mm256_setzero_ps();\n      |                   ~~~~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m256\n[REDACTED]/tmp8enr2a5q.cpp:34:45: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   34 |         __m256 vec = _mm256_loadu_ps(matrix + i * cols);\n      |                                      ~~~~~~~^~~~~~~~~~\n      |                                             |\n      |                                             const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8enr2a5q.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp8enr2a5q.cpp:40:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   40 |         sum = _mm256_add_ps(sum, squared_vec);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp8enr2a5q.cpp:43:55: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   43 |         __m256 threshold = _mm256_loadu_ps(thresholds + i);\n      |                                            ~~~~~~~~~~~^~~\n      |                                                       |\n      |                                                       const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp8enr2a5q.cpp:44:29: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   44 |         __m256 comparison = _mm256_cmpgt_ps(sum, threshold);\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm256_cmp_ps\n[REDACTED]/tmp8enr2a5q.cpp:47:51: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   47 |         _mm256_storeu_si256((__m256i*)result + i, comparison);\n      |                                                   ^~~~~~~~~~\n      |                                                   |\n      |                                                   __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_39_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp841ebjdn.cpp: In function \u2018void matrix_row_norm_compare_simd(const double*, const double*, size_t, size_t, bool*)\u2019:\n[REDACTED]/tmp841ebjdn.cpp:34:36: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   34 |     __m256i sum = _mm256_setzero_ps();\n      |                   ~~~~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m256\n[REDACTED]/tmp841ebjdn.cpp:37:43: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   37 |         __m256 v = _mm256_loadu_ps(matrix + i * cols);\n      |                                    ~~~~~~~^~~~~~~~~~\n      |                                           |\n      |                                           const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp841ebjdn.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp841ebjdn.cpp:39:72: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   39 |         __m256 comp = _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + i));\n      |                                                             ~~~~~~~~~~~^~~\n      |                                                                        |\n      |                                                                        const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp841ebjdn.cpp:39:23: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   39 |         __m256 comp = _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + i));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm256_cmp_ps\n[REDACTED]/tmp841ebjdn.cpp:41:14: error: invalid operands to binary | (have \u2018__m256i\u2019 and \u2018__m256\u2019)\n   41 |         mask |= comp;\n      |         ~~~~~^~~~~~~\n[REDACTED]/tmp841ebjdn.cpp:41:14: note:   in evaluation of \u2018operator|=(__m256i, __m256)\u2019\n[REDACTED]/tmp841ebjdn.cpp:42:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   42 |         sum = _mm256_add_ps(sum, norm);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp841ebjdn.cpp:46:43: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   46 |         __m256 v = _mm256_loadu_ps(matrix + i * cols);\n      |                                    ~~~~~~~^~~~~~~~~~\n      |                                           |\n      |                                           const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp841ebjdn.cpp:48:72: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   48 |         __m256 comp = _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + i));\n      |                                                             ~~~~~~~~~~~^~~\n      |                                                                        |\n      |                                                                        const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp841ebjdn.cpp:48:23: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   48 |         __m256 comp = _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + i));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm256_cmp_ps\n[REDACTED]/tmp841ebjdn.cpp:50:14: error: invalid operands to binary | (have \u2018__m256i\u2019 and \u2018__m256\u2019)\n   50 |         mask |= comp;\n      |         ~~~~~^~~~~~~\n[REDACTED]/tmp841ebjdn.cpp:50:14: note:   in evaluation of \u2018operator|=(__m256i, __m256)\u2019\n[REDACTED]/tmp841ebjdn.cpp:51:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   51 |         sum = _mm256_add_ps(sum, norm);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp841ebjdn.cpp:63:26: error: cannot convert \u2018bool*\u2019 to \u2018float*\u2019\n   63 |     _mm_storeu_ps(result + rows, sum);\n      |                   ~~~~~~~^~~~~~\n      |                          |\n      |                          bool*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp841ebjdn.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_39_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1fkw5omg.cpp: In function \u2018void matrix_row_norm_compare_simd(const double*, const double*, size_t, size_t, bool*)\u2019:\n[REDACTED]/tmp1fkw5omg.cpp:37:45: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   37 |         __m256 row = _mm256_loadu_ps(matrix + i * cols);\n      |                                      ~~~~~~~^~~~~~~~~~\n      |                                             |\n      |                                             const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp1fkw5omg.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp1fkw5omg.cpp:41:111: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   41 |             threshold_mask = _mm256_or_si256(threshold_mask, _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + j)));\n      |                                                                                                    ~~~~~~~~~~~^~~\n      |                                                                                                               |\n      |                                                                                                               const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp1fkw5omg.cpp:41:62: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   41 |             threshold_mask = _mm256_or_si256(threshold_mask, _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + j)));\n      |                                                              ^~~~~~~~~~~~~~~\n      |                                                              _mm256_cmp_ps\n"}
{"task_id": "SimdBench_39_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi6it48kt.cpp: In function \u2018void matrix_row_norm_compare_simd(const double*, const double*, size_t, size_t, bool*)\u2019:\n[REDACTED]/tmpi6it48kt.cpp:47:24: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   47 |     double total_sum = _mm256_reduce_add_pd(sum, 0.0);\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_39_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpad1n9dnh.cpp: In function \u2018void matrix_row_norm_compare_simd(const double*, const double*, size_t, size_t, bool*)\u2019:\n[REDACTED]/tmpad1n9dnh.cpp:34:45: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   34 |         __m256 row = _mm256_loadu_ps(matrix + i * cols);\n      |                                      ~~~~~~~^~~~~~~~~~\n      |                                             |\n      |                                             const double*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpad1n9dnh.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpad1n9dnh.cpp:38:111: error: cannot convert \u2018const double*\u2019 to \u2018const float*\u2019\n   38 |             threshold_mask = _mm256_or_si256(threshold_mask, _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + j)));\n      |                                                                                                    ~~~~~~~~~~~^~~\n      |                                                                                                               |\n      |                                                                                                               const double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpad1n9dnh.cpp:38:62: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   38 |             threshold_mask = _mm256_or_si256(threshold_mask, _mm256_cmpgt_ps(norm, _mm256_loadu_ps(thresholds + j)));\n      |                                                              ^~~~~~~~~~~~~~~\n      |                                                              _mm256_cmp_ps\n"}
{"task_id": "SimdBench_40_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_40_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_40_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_40_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_40_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_41_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi54fmo0r.cpp: In function \u2018int64_t squarediff_simd(const int8_t*, const int8_t*, size_t)\u2019:\n[REDACTED]/tmpi54fmo0r.cpp:47:5: error: \u2018_mm256_storeu_si128\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si128\u2019?\n   47 |     _mm256_storeu_si128((__m128i*)&result, diff);\n      |     ^~~~~~~~~~~~~~~~~~~\n      |     _mm_storeu_si128\n"}
{"task_id": "SimdBench_41_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8524veov.cpp: In function \u2018int64_t squarediff_simd(const int8_t*, const int8_t*, size_t)\u2019:\n[REDACTED]/tmp8524veov.cpp:39:30: error: \u2018_mm256_mul_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi8\u2019?\n   39 |         __m256i squareDiff = _mm256_mul_epi8(diff, diff);\n      |                              ^~~~~~~~~~~~~~~\n      |                              _mm256_sub_epi8\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8524veov.cpp:16:\n[REDACTED]/tmp8524veov.cpp:41:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   41 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 0));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:42:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   42 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 1));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:43:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   43 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 2));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:44:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   44 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 3));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:46:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   46 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 4));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:47:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   47 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 5));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:48:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   48 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 6));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:49:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   49 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 7));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp8524veov.cpp:64:25: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   64 |     int64_t totalSumA = _mm256_reduce_add_epi32(sumA, _mm256_set1_epi32(0));\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~\n      |                         _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_41_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpsnsnxry2.cpp: In function \u2018int64_t squarediff_simd(const int8_t*, const int8_t*, size_t)\u2019:\n[REDACTED]/tmpsnsnxry2.cpp:59:5: error: \u2018_mm256_storeu_si128\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si128\u2019?\n   59 |     _mm256_storeu_si128((__m128i *)&result, diff);\n      |     ^~~~~~~~~~~~~~~~~~~\n      |     _mm_storeu_si128\n"}
{"task_id": "SimdBench_41_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp3beb_t1a.cpp:16:\n[REDACTED]/tmp3beb_t1a.cpp: In function \u2018int64_t squarediff_simd(const int8_t*, const int8_t*, size_t)\u2019:\n[REDACTED]/tmp3beb_t1a.cpp:41:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   41 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 0));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:42:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   42 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 1));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:43:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   43 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 2));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:44:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   44 |         sumA = _mm256_add_epi32(sumA, _mm256_extract_epi32(squareDiff, 3));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:46:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   46 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 4));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:47:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   47 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 5));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:48:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   48 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 6));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:49:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   49 |         sumB = _mm256_add_epi32(sumB, _mm256_extract_epi32(squareDiff, 7));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp3beb_t1a.cpp:57:22: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   57 |     int64_t result = _mm256_reduce_add_epi32(sumA, 0LL) - _mm256_reduce_add_epi32(sumB, 0LL);\n      |                      ^~~~~~~~~~~~~~~~~~~~~~~\n      |                      _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_41_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpii2ebwkr.cpp: In function \u2018int64_t squarediff_simd(const int8_t*, const int8_t*, size_t)\u2019:\n[REDACTED]/tmpii2ebwkr.cpp:47:52: error: \u2018_MM_REDUCE_ADD_SAT\u2019 was not declared in this scope\n   47 |     int64_t sumASq = _mm256_reduce_add_epi32(sumA, _MM_REDUCE_ADD_SAT);\n      |                                                    ^~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpii2ebwkr.cpp:47:22: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   47 |     int64_t sumASq = _mm256_reduce_add_epi32(sumA, _MM_REDUCE_ADD_SAT);\n      |                      ^~~~~~~~~~~~~~~~~~~~~~~\n      |                      _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_42_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp55vkh4zc.cpp: In function \u2018void tensor_bit_clear_simd(const uint64_t*, const uint64_t*, uint64_t*, size_t)\u2019:\n[REDACTED]/tmp55vkh4zc.cpp:33:24: error: \u2018_mm256_set1_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   33 |         __m256i mask = _mm256_set1_epi64u(~avx_B[i]);\n      |                        ^~~~~~~~~~~~~~~~~~\n      |                        _mm256_set1_epi64x\n"}
{"task_id": "SimdBench_42_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpf09y9a3e.cpp: In function \u2018void tensor_bit_clear_simd(const uint64_t*, const uint64_t*, uint64_t*, size_t)\u2019:\n[REDACTED]/tmpf09y9a3e.cpp:30:24: error: \u2018_mm256_set1_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   30 |         __m256i mask = _mm256_set1_epi64u(~avx_B[i]);\n      |                        ^~~~~~~~~~~~~~~~~~\n      |                        _mm256_set1_epi64x\n"}
{"task_id": "SimdBench_42_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_42_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw_6q6089.cpp: In function \u2018void tensor_bit_clear_simd(const uint64_t*, const uint64_t*, uint64_t*, size_t)\u2019:\n[REDACTED]/tmpw_6q6089.cpp:33:24: error: \u2018_mm256_set1_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   33 |         __m256i mask = _mm256_set1_epi64(0xFFFFFFFFFFFFFFFF); // Create a mask with all bits set to 1\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm256_set1_epi64x\n[REDACTED]/tmpw_6q6089.cpp:41:9: error: invalid type argument of unary \u2018*\u2019 (have \u2018__m256i\u2019)\n   41 |         *avx_C[i] &= ~(*avx_B[i]); // Perform bitwise AND between the last element of B and the corresponding element of C\n      |         ^~~~~~~~~\n[REDACTED]/tmpw_6q6089.cpp:41:24: error: invalid type argument of unary \u2018*\u2019 (have \u2018__m256i\u2019)\n   41 |         *avx_C[i] &= ~(*avx_B[i]); // Perform bitwise AND between the last element of B and the corresponding element of C\n      |                        ^~~~~~~~~\n"}
{"task_id": "SimdBench_42_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp4tyoletp.cpp: In function \u2018void tensor_bit_clear_simd(const uint64_t*, const uint64_t*, uint64_t*, size_t)\u2019:\n[REDACTED]/tmp4tyoletp.cpp:30:24: error: \u2018_mm256_set1_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set1_epi64x\u2019?\n   30 |         __m256i mask = _mm256_set1_epi64u(~avx_B[i]);\n      |                        ^~~~~~~~~~~~~~~~~~\n      |                        _mm256_set1_epi64x\n"}
{"task_id": "SimdBench_43_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpf6utwuw2.cpp: In function \u2018void tensor_three_valued_logic_simd(const int8_t*, const int8_t*, int8_t*, size_t)\u2019:\n[REDACTED]/tmpf6utwuw2.cpp:34:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask_pos = _mm256_set_epi32(0x7F, 0x7F, 0x7F, 0x7F); // Mask for positive values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpf6utwuw2.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpf6utwuw2.cpp:35:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask_neg = _mm256_set_epi32(0xFF, 0xFF, 0xFF, 0xFF); // Mask for negative values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_43_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplou6e64u.cpp: In function \u2018void tensor_three_valued_logic_simd(const int8_t*, const int8_t*, int8_t*, size_t)\u2019:\n[REDACTED]/tmplou6e64u.cpp:34:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask_pos = _mm256_set_epi32(0x7F, 0x7F, 0x7F, 0x7F); // Mask for positive values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmplou6e64u.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmplou6e64u.cpp:35:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask_neg = _mm256_set_epi32(0xFF, 0xFF, 0xFF, 0xFF); // Mask for negative values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_43_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2iioocnn.cpp: In function \u2018void tensor_three_valued_logic_simd(const int8_t*, const int8_t*, int8_t*, size_t)\u2019:\n[REDACTED]/tmp2iioocnn.cpp:34:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask_pos = _mm256_set_epi32(0x7F, 0x7F, 0x7F, 0x7F); // Mask for positive values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2iioocnn.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp2iioocnn.cpp:35:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask_neg = _mm256_set_epi32(0xFF, 0xFF, 0xFF, 0xFF); // Mask for negative values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_43_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpaqxj7igu.cpp: In function \u2018void tensor_three_valued_logic_simd(const int8_t*, const int8_t*, int8_t*, size_t)\u2019:\n[REDACTED]/tmpaqxj7igu.cpp:37:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |     __m256i mask_pos = _mm256_set_epi32(0x7F, 0x7F, 0x7F, 0x7F); // Mask for positive values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpaqxj7igu.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpaqxj7igu.cpp:38:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     __m256i mask_neg = _mm256_set_epi32(0xFF, 0xFF, 0xFF, 0xFF); // Mask for negative values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_43_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpngj60kc0.cpp: In function \u2018void tensor_three_valued_logic_simd(const int8_t*, const int8_t*, int8_t*, size_t)\u2019:\n[REDACTED]/tmpngj60kc0.cpp:37:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |     __m256i mask_pos = _mm256_set_epi32(0x7F, 0x7F, 0x7F, 0x7F); // Mask for positive values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpngj60kc0.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpngj60kc0.cpp:38:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     __m256i mask_neg = _mm256_set_epi32(0xFF, 0xFF, 0xFF, 0xFF); // Mask for negative values\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_44_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_44_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_44_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_44_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_44_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_45_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwaf_kvpz.cpp: In function \u2018void tensor_multi_select_simd(const float*, const float*, const float*, const float*, const bool*, const bool*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpwaf_kvpz.cpp:34:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask1 = _mm256_set_epi32(0, 0, 0, 1); // Mask for cond1\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpwaf_kvpz.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpwaf_kvpz.cpp:35:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask2 = _mm256_set_epi32(0, 0, 1, 0); // Mask for cond2\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpwaf_kvpz.cpp:45:102: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   45 |                 __m256 mask1_i = _mm256_and_si256(mask1, _mm256_cmpeq_epi32(_mm256_loadu_si256(cond1 + i), _mm256_set_epi32(1)));\n      |                                                                                                ~~~~~~^~~\n      |                                                                                                      |\n      |                                                                                                      const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpwaf_kvpz.cpp:45:124: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   45 |                 __m256 mask1_i = _mm256_and_si256(mask1, _mm256_cmpeq_epi32(_mm256_loadu_si256(cond1 + i), _mm256_set_epi32(1)));\n      |                                                                                                            ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpwaf_kvpz.cpp:46:102: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   46 |                 __m256 mask2_i = _mm256_and_si256(mask2, _mm256_cmpeq_epi32(_mm256_loadu_si256(cond2 + i), _mm256_set_epi32(1)));\n      |                                                                                                ~~~~~~^~~\n      |                                                                                                      |\n      |                                                                                                      const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpwaf_kvpz.cpp:46:124: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   46 |                 __m256 mask2_i = _mm256_and_si256(mask2, _mm256_cmpeq_epi32(_mm256_loadu_si256(cond2 + i), _mm256_set_epi32(1)));\n      |                                                                                                            ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpwaf_kvpz.cpp:50:55: error: wrong type argument to bit-complement\n   50 |                 result = _mm256_blendv_ps(result, d, ~mask1_i & ~mask2_i);\n      |                                                       ^~~~~~~\n[REDACTED]/tmpwaf_kvpz.cpp:50:66: error: wrong type argument to bit-complement\n   50 |                 result = _mm256_blendv_ps(result, d, ~mask1_i & ~mask2_i);\n      |                                                                  ^~~~~~~\n"}
{"task_id": "SimdBench_45_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpe8hnt9l9.cpp: In function \u2018void tensor_multi_select_simd(const float*, const float*, const float*, const float*, const bool*, const bool*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpe8hnt9l9.cpp:45:76: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   45 |                 __m256 mask1_i = _mm256_and_si256(_mm256_loadu_si256(cond1 + i), _mm256_loadu_si256(cond2 + i));\n      |                                                                      ~~~~~~^~~\n      |                                                                            |\n      |                                                                            const bool*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpe8hnt9l9.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpe8hnt9l9.cpp:45:107: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   45 |                 __m256 mask1_i = _mm256_and_si256(_mm256_loadu_si256(cond1 + i), _mm256_loadu_si256(cond2 + i));\n      |                                                                                                     ~~~~~~^~~\n      |                                                                                                           |\n      |                                                                                                           const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpe8hnt9l9.cpp:46:54: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   46 |                 __m256 mask2_i = _mm256_andnot_si256(mask1_i, _mm256_set1_epi32(1));\n      |                                                      ^~~~~~~\n      |                                                      |\n      |                                                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:186:30: note:   initializing argument 1 of \u2018__m256i _mm256_andnot_si256(__m256i, __m256i)\u2019\n  186 | _mm256_andnot_si256 (__m256i __A, __m256i __B)\n      |                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_45_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpa6tuu9xy.cpp: In function \u2018void tensor_multi_select_simd(const float*, const float*, const float*, const float*, const bool*, const bool*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpa6tuu9xy.cpp:34:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask1 = _mm256_set_epi32(0, 1, 0, 1); // Create a mask for cond1\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpa6tuu9xy.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpa6tuu9xy.cpp:35:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask2 = _mm256_set_epi32(0, 0, 1, 1); // Create a mask for cond2\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpa6tuu9xy.cpp:45:83: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   45 |                 __m256 mask1_i = _mm256_and_si256(mask1, _mm256_loadu_si256(cond1 + i));\n      |                                                                             ~~~~~~^~~\n      |                                                                                   |\n      |                                                                                   const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpa6tuu9xy.cpp:46:83: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   46 |                 __m256 mask2_i = _mm256_and_si256(mask2, _mm256_loadu_si256(cond2 + i));\n      |                                                                             ~~~~~~^~~\n      |                                                                                   |\n      |                                                                                   const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpa6tuu9xy.cpp:50:55: error: wrong type argument to bit-complement\n   50 |                 result = _mm256_blendv_ps(result, d, ~mask1_i & ~mask2_i);\n      |                                                       ^~~~~~~\n[REDACTED]/tmpa6tuu9xy.cpp:50:66: error: wrong type argument to bit-complement\n   50 |                 result = _mm256_blendv_ps(result, d, ~mask1_i & ~mask2_i);\n      |                                                                  ^~~~~~~\n"}
{"task_id": "SimdBench_45_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmps8b92o7q.cpp: In function \u2018void tensor_multi_select_simd(const float*, const float*, const float*, const float*, const bool*, const bool*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmps8b92o7q.cpp:45:75: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   45 |                 __m256 mask_a = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(1)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(1)));\n      |                                                                     ~~~~~~^~~~~~~\n      |                                                                           |\n      |                                                                           const bool*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmps8b92o7q.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:45:132: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   45 |                 __m256 mask_a = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(1)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(1)));\n      |                                                                                                                              ~~~~~~^~~~~~~\n      |                                                                                                                                    |\n      |                                                                                                                                    const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:46:75: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   46 |                 __m256 mask_b = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(1)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(0)));\n      |                                                                     ~~~~~~^~~~~~~\n      |                                                                           |\n      |                                                                           const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:46:132: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   46 |                 __m256 mask_b = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(1)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(0)));\n      |                                                                                                                              ~~~~~~^~~~~~~\n      |                                                                                                                                    |\n      |                                                                                                                                    const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:47:75: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   47 |                 __m256 mask_c = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(0)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(1)));\n      |                                                                     ~~~~~~^~~~~~~\n      |                                                                           |\n      |                                                                           const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:47:132: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   47 |                 __m256 mask_c = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(0)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(1)));\n      |                                                                                                                              ~~~~~~^~~~~~~\n      |                                                                                                                                    |\n      |                                                                                                                                    const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:48:75: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   48 |                 __m256 mask_d = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(0)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(0)));\n      |                                                                     ~~~~~~^~~~~~~\n      |                                                                           |\n      |                                                                           const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmps8b92o7q.cpp:48:132: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   48 |                 __m256 mask_d = _mm256_and_si256(_mm256_cmpeq_epi32(cond1 + i * 4, _mm256_set1_epi32(0)), _mm256_cmpeq_epi32(cond2 + i * 4, _mm256_set1_epi32(0)));\n      |                                                                                                                              ~~~~~~^~~~~~~\n      |                                                                                                                                    |\n      |                                                                                                                                    const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:245:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpeq_epi32(__m256i, __m256i)\u2019\n  245 | _mm256_cmpeq_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_45_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpu35to4jh.cpp: In function \u2018void tensor_multi_select_simd(const float*, const float*, const float*, const float*, const bool*, const bool*, float*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpu35to4jh.cpp:34:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask1 = _mm256_set_epi32(0, 1, 0, 1); // Create a mask for cond1\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpu35to4jh.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpu35to4jh.cpp:35:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask2 = _mm256_set_epi32(0, 0, 1, 1); // Create a mask for cond2\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpu35to4jh.cpp:45:83: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   45 |                 __m256 mask1_i = _mm256_and_si256(mask1, _mm256_loadu_si256(cond1 + i));\n      |                                                                             ~~~~~~^~~\n      |                                                                                   |\n      |                                                                                   const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpu35to4jh.cpp:46:83: error: cannot convert \u2018const bool*\u2019 to \u2018const __m256i_u*\u2019\n   46 |                 __m256 mask2_i = _mm256_and_si256(mask2, _mm256_loadu_si256(cond2 + i));\n      |                                                                             ~~~~~~^~~\n      |                                                                                   |\n      |                                                                                   const bool*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpu35to4jh.cpp:50:55: error: wrong type argument to bit-complement\n   50 |                 result = _mm256_blendv_ps(result, d, ~mask1_i & ~mask2_i);\n      |                                                       ^~~~~~~\n[REDACTED]/tmpu35to4jh.cpp:50:66: error: wrong type argument to bit-complement\n   50 |                 result = _mm256_blendv_ps(result, d, ~mask1_i & ~mask2_i);\n      |                                                                  ^~~~~~~\n"}
{"task_id": "SimdBench_46_AVX", "passed": false, "result": "runtime failed: Fatal glibc error: malloc.c:2599 (sysmalloc): assertion failed: (old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\n"}
{"task_id": "SimdBench_46_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpnh99737f.cpp: In function \u2018void tensor_bit_count_simd(const uint32_t*, uint8_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpnh99737f.cpp:33:45: warning: division by zero [-Wdiv-by-zero]\n   33 |     const int num_vecs = dim1 * dim2 * dim3 / vec_size;\n      |                          ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n[REDACTED]/tmpnh99737f.cpp:43:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   43 |         _mm_storeu_si256(&vec_out[i], sum);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_46_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpykbycsjx.cpp: In function \u2018void tensor_bit_count_simd(const uint32_t*, uint8_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpykbycsjx.cpp:33:45: warning: division by zero [-Wdiv-by-zero]\n   33 |     const int num_vecs = dim1 * dim2 * dim3 / vec_size;\n      |                          ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n[REDACTED]/tmpykbycsjx.cpp:43:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   43 |         _mm_storeu_si256(&vec_out[i], sum);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_46_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpnfka05e7.cpp: In function \u2018void tensor_bit_count_simd(const uint32_t*, uint8_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmpnfka05e7.cpp:33:45: warning: division by zero [-Wdiv-by-zero]\n   33 |     const int num_vecs = dim1 * dim2 * dim3 / vec_size;\n      |                          ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n[REDACTED]/tmpnfka05e7.cpp:35:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpnfka05e7.cpp:38:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |         __m256i vec_a = _mm_loadu_si256(reinterpret_cast<const __m256i*>(A + i * vec_size));\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmpnfka05e7.cpp:39:40: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i vec_out = _mm_sad_epu8(_mm_and_si256(vec_a, mask), _mm_setzero_si256());\n      |                                        ^~~~~~~~~~~~~\n      |                                        _mm_and_si64\n[REDACTED]/tmpnfka05e7.cpp:39:68: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   39 |         __m256i vec_out = _mm_sad_epu8(_mm_and_si256(vec_a, mask), _mm_setzero_si256());\n      |                                                                    ^~~~~~~~~~~~~~~~~\n      |                                                                    _mm_setzero_si64\n[REDACTED]/tmpnfka05e7.cpp:40:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   40 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(out + i * vec_size), vec_out);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_46_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6u15rxat.cpp: In function \u2018void tensor_bit_count_simd(const uint32_t*, uint8_t*, size_t, size_t, size_t)\u2019:\n[REDACTED]/tmp6u15rxat.cpp:33:62: warning: division by zero [-Wdiv-by-zero]\n   33 |     const int num_vecs = (dim1 * dim2 * dim3 + vec_size - 1) / vec_size;\n      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n[REDACTED]/tmp6u15rxat.cpp:35:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp6u15rxat.cpp:38:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |         __m256i vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(A + i * vec_size));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp6u15rxat.cpp:39:40: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i count = _mm_popcnt_u32(_mm_and_si256(vec, mask));\n      |                                        ^~~~~~~~~~~~~\n      |                                        _mm_and_si64\n[REDACTED]/tmp6u15rxat.cpp:40:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   40 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(out + i), count);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_47_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1dldd8t_.cpp: In function \u2018void matrix_conditional_abs_simd(const int*, int*, size_t, size_t)\u2019:\n[REDACTED]/tmp1dldd8t_.cpp:30:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   30 |     __m256i mask = _mm_set_epi32(0, 0, 0, -1); // Mask to set negative values to 0\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp1dldd8t_.cpp:33:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         __m256i a = _mm_loadu_si256((__m256i*)(A + i));\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmp1dldd8t_.cpp:37:70: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i is_divisible_by_3 = _mm_cmpeq_epi32(a, _mm_mul_epi32(a, _mm_set_epi32(3, 0, 0, 0)));\n      |                                                                      ^\n      |                                                                      |\n      |                                                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp1dldd8t_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp1dldd8t_.cpp:40:46: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   40 |         __m256i result = _mm_blendv_epi32(b, _mm_andnot_si256(is_divisible_by_3, a), is_divisible_by_3);\n      |                                              ^~~~~~~~~~~~~~~~\n      |                                              _mm_andnot_si64\n[REDACTED]/tmp1dldd8t_.cpp:40:26: error: \u2018_mm_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_blend_epi32\u2019?\n   40 |         __m256i result = _mm_blendv_epi32(b, _mm_andnot_si256(is_divisible_by_3, a), is_divisible_by_3);\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm_blend_epi32\n[REDACTED]/tmp1dldd8t_.cpp:42:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   42 |         _mm_storeu_si256((__m256i*)(B + i), result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_47_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdsu9hkdy.cpp: In function \u2018void matrix_conditional_abs_simd(const int*, int*, size_t, size_t)\u2019:\n[REDACTED]/tmpdsu9hkdy.cpp:30:39: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   30 |     const __m256i mask = _mm_set_epi32(0, 1, 0, 1); // Mask to check divisibility by 3\n      |                          ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmpdsu9hkdy.cpp:33:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         __m256i a = _mm_loadu_si256((__m256i*)&A[i]);\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmpdsu9hkdy.cpp:36:25: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   36 |         __m256i abs_a = _mm_and_si256(a, mask); // Check if divisible by 3\n      |                         ^~~~~~~~~~~~~\n      |                         _mm_and_si64\n[REDACTED]/tmpdsu9hkdy.cpp:37:59: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i abs_b = _mm_or_si256(abs_a, _mm_sub_epi32(b, abs_a)); // Set to absolute value if divisible by 3\n      |                                                           ^\n      |                                                           |\n      |                                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpdsu9hkdy.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpdsu9hkdy.cpp:37:25: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   37 |         __m256i abs_b = _mm_or_si256(abs_a, _mm_sub_epi32(b, abs_a)); // Set to absolute value if divisible by 3\n      |                         ^~~~~~~~~~~~\n      |                         _mm_or_si64\n[REDACTED]/tmpdsu9hkdy.cpp:39:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   39 |         _mm_storeu_si256((__m256i*)&B[i], abs_b);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_47_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp80vtxj07.cpp: In function \u2018void matrix_conditional_abs_simd(const int*, int*, size_t, size_t)\u2019:\n[REDACTED]/tmp80vtxj07.cpp:30:39: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   30 |     const __m256i mask = _mm_set_epi32(0, 1, 0, 1); // Mask to select elements divisible by 3\n      |                          ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmp80vtxj07.cpp:33:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         __m256i a = _mm_loadu_si256((__m256i*)&A[i]);\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmp80vtxj07.cpp:36:25: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   36 |         __m256i abs_a = _mm_and_si256(a, mask); // Select elements divisible by 3\n      |                         ^~~~~~~~~~~~~\n      |                         _mm_and_si64\n[REDACTED]/tmp80vtxj07.cpp:37:38: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   37 |         __m256i abs_b = _mm_or_si256(_mm_andnot_si256(mask, a), b); // Set elements not divisible by 3 to their original values\n      |                                      ^~~~~~~~~~~~~~~~\n      |                                      _mm_andnot_si64\n[REDACTED]/tmp80vtxj07.cpp:37:25: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   37 |         __m256i abs_b = _mm_or_si256(_mm_andnot_si256(mask, a), b); // Set elements not divisible by 3 to their original values\n      |                         ^~~~~~~~~~~~\n      |                         _mm_or_si64\n[REDACTED]/tmp80vtxj07.cpp:39:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   39 |         _mm_storeu_si256((__m256i*)&B[i], abs_b);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_47_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp417rcer3.cpp: In function \u2018void matrix_conditional_abs_simd(const int*, int*, size_t, size_t)\u2019:\n[REDACTED]/tmp417rcer3.cpp:27:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i mask = _mm_set_epi32(0, 1, 2, 3); // Mask to select elements divisible by 3\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp417rcer3.cpp:28:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i abs_mask = _mm_set_epi32(0, 1, 2, 3); // Mask to select elements that are not divisible by 3\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp417rcer3.cpp:31:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i a = _mm_loadu_si256((__m256i*)(A + i));\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmp417rcer3.cpp:35:28: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   35 |         __m256i div_by_3 = _mm_and_si256(a, mask);\n      |                            ^~~~~~~~~~~~~\n      |                            _mm_and_si64\n[REDACTED]/tmp417rcer3.cpp:38:32: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   38 |         __m256i not_div_by_3 = _mm_andnot_si256(div_by_3, mask);\n      |                                ^~~~~~~~~~~~~~~~\n      |                                _mm_andnot_si64\n[REDACTED]/tmp417rcer3.cpp:41:83: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   41 |         __m256i abs_result = _mm_or_si256(_mm_and_si256(div_by_3, _mm_cvtepi32_ps(_mm_setzero_si256())), _mm_andnot_si256(not_div_by_3, b));\n      |                                                                                   ^~~~~~~~~~~~~~~~~\n      |                                                                                   _mm_setzero_si64\n[REDACTED]/tmp417rcer3.cpp:41:30: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   41 |         __m256i abs_result = _mm_or_si256(_mm_and_si256(div_by_3, _mm_cvtepi32_ps(_mm_setzero_si256())), _mm_andnot_si256(not_div_by_3, b));\n      |                              ^~~~~~~~~~~~\n      |                              _mm_or_si64\n[REDACTED]/tmp417rcer3.cpp:44:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   44 |         _mm_storeu_si256((__m256i*)(B + i), abs_result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_47_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo_e78eyp.cpp: In function \u2018void matrix_conditional_abs_simd(const int*, int*, size_t, size_t)\u2019:\n[REDACTED]/tmpo_e78eyp.cpp:27:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   27 |     __m256i mask = _mm_set_epi32(0, 1, 0, 1); // Mask to select elements divisible by 3\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpo_e78eyp.cpp:28:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i abs_mask = _mm_set_epi32(0, 1, 0, 1); // Mask to select elements that are not divisible by 3\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpo_e78eyp.cpp:31:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |         __m256i a = _mm_loadu_si256((__m256i*)(A + i));\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmpo_e78eyp.cpp:34:76: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i div_by_3 = _mm_cmpeq_epi32(a, _mm_mul_epi32(_mm_slli_epi32(a, 2), mask)); // Check if divisible by 3\n      |                                                                            ^\n      |                                                                            |\n      |                                                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpo_e78eyp.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1190:25: note:   initializing argument 1 of \u2018__m128i _mm_slli_epi32(__m128i, int)\u2019\n 1190 | _mm_slli_epi32 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpo_e78eyp.cpp:35:59: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   35 |         __m256i not_div_by_3 = _mm_cmpneq_epi32(div_by_3, _mm_setzero_si256()); // Check if not divisible by 3\n      |                                                           ^~~~~~~~~~~~~~~~~\n      |                                                           _mm_setzero_si64\n[REDACTED]/tmpo_e78eyp.cpp:35:32: error: \u2018_mm_cmpneq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_cmpeq_epi32\u2019?\n   35 |         __m256i not_div_by_3 = _mm_cmpneq_epi32(div_by_3, _mm_setzero_si256()); // Check if not divisible by 3\n      |                                ^~~~~~~~~~~~~~~~\n      |                                _mm_cmpeq_epi32\n[REDACTED]/tmpo_e78eyp.cpp:37:25: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   37 |         __m256i abs_a = _mm_and_si256(div_by_3, _mm_sub_epi32(_mm_setzero_si256(), a)); // Absolute value for divisible by 3\n      |                         ^~~~~~~~~~~~~\n      |                         _mm_and_si64\n[REDACTED]/tmpo_e78eyp.cpp:38:25: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   38 |         __m256i abs_b = _mm_andnot_si256(not_div_by_3, b); // Absolute value for not divisible by 3\n      |                         ^~~~~~~~~~~~~~~~\n      |                         _mm_andnot_si64\n[REDACTED]/tmpo_e78eyp.cpp:40:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   40 |         _mm_storeu_si256((__m256i*)(B + i), abs_a);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_48_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqroq60l5.cpp: In function \u2018void matrix_conditional_bit_rotate_simd(const uint32_t*, uint32_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpqroq60l5.cpp:31:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set_epi32(0xF0, 0xF0, 0xF0, 0xF0); // Mask to check if the low 4 bits are all 1\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpqroq60l5.cpp:32:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i rotate_mask = _mm_set_epi32(0xFF << rotate_bits, 0xFF << rotate_bits, 0xFF << rotate_bits, 0xFF << rotate_bits); // Rotate mask\n      |                           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmpqroq60l5.cpp:35:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   35 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[i]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpqroq60l5.cpp:38:30: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   38 |         __m256i low_4_bits = _mm_and_si256(src_vec, mask); // Extract the low 4 bits\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_and_si64\n[REDACTED]/tmpqroq60l5.cpp:39:67: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         __m256i rotated_low_4_bits = _mm_and_si256(_mm_srli_epi32(low_4_bits, rotate_bits), rotate_mask); // Rotate the low 4 bits\n      |                                                                   ^~~~~~~~~~\n      |                                                                   |\n      |                                                                   __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpqroq60l5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1255:25: note:   initializing argument 1 of \u2018__m128i _mm_srli_epi32(__m128i, int)\u2019\n 1255 | _mm_srli_epi32 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpqroq60l5.cpp:40:38: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   40 |         __m256i negated_low_4_bits = _mm_xor_si256(low_4_bits, rotate_mask); // Negate the low 4 bits\n      |                                      ^~~~~~~~~~~~~\n      |                                      _mm_xor_si64\n[REDACTED]/tmpqroq60l5.cpp:42:26: error: \u2018_mm_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_blend_epi32\u2019?\n   42 |         __m256i result = _mm_blendv_epi32(rotated_low_4_bits, negated_low_4_bits, low_4_bits); // Blend the results based on the condition\n      |                          ^~~~~~~~~~~~~~~~\n      |                          _mm_blend_epi32\n[REDACTED]/tmpqroq60l5.cpp:44:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   44 |         _mm_storeu_si256((__m256i*)(&dst[i]), result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_48_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpcxxcq53r.cpp: In function \u2018void matrix_conditional_bit_rotate_simd(const uint32_t*, uint32_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpcxxcq53r.cpp:31:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set_epi32(0xF0F0F0F0, 0xF0F0F0F0, 0xF0F0F0F0, 0xF0F0F0F0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpcxxcq53r.cpp:32:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i rotate_mask = _mm_set_epi32(0x000000FF, 0x000000FF, 0x000000FF, 0x000000FF);\n      |                           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmpcxxcq53r.cpp:35:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   35 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[i]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpcxxcq53r.cpp:39:30: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i low_4_bits = _mm_and_si256(src_vec, mask);\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_and_si64\n[REDACTED]/tmpcxxcq53r.cpp:42:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         __m256i compare_result = _mm_cmpeq_epi32(low_4_bits, mask);\n      |                                                  ^~~~~~~~~~\n      |                                                  |\n      |                                                  __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpcxxcq53r.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpcxxcq53r.cpp:45:57: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   45 |         __m256i rotated_dst = _mm_blendv_epi32(dst_vec, _mm_xor_si256(src_vec, rotate_mask), compare_result);\n      |                                                         ^~~~~~~~~~~~~\n      |                                                         _mm_xor_si64\n[REDACTED]/tmpcxxcq53r.cpp:45:31: error: \u2018_mm_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_blend_epi32\u2019?\n   45 |         __m256i rotated_dst = _mm_blendv_epi32(dst_vec, _mm_xor_si256(src_vec, rotate_mask), compare_result);\n      |                               ^~~~~~~~~~~~~~~~\n      |                               _mm_blend_epi32\n[REDACTED]/tmpcxxcq53r.cpp:48:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   48 |         _mm_storeu_si256((__m256i*)(&dst[i]), rotated_dst);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_48_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprjd6bxts.cpp: In function \u2018void matrix_conditional_bit_rotate_simd(const uint32_t*, uint32_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmprjd6bxts.cpp:31:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set_epi32(0xF0, 0xF0, 0xF0, 0xF0); // Mask to check if the low 4 bits are all 1\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmprjd6bxts.cpp:32:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i rotate_mask = _mm_set_epi32(0xFF << rotate_bits, 0xFF << rotate_bits, 0xFF << rotate_bits, 0xFF << rotate_bits); // Rotate mask\n      |                           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmprjd6bxts.cpp:35:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   35 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[i]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmprjd6bxts.cpp:38:30: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   38 |         __m256i low_4_bits = _mm_and_si256(src_vec, mask); // Check if the low 4 bits are all 1\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_and_si64\n[REDACTED]/tmprjd6bxts.cpp:41:38: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   41 |         __m256i negated_low_4_bits = _mm_xor_si256(low_4_bits, rotate_mask); // Negate the low 4 bits\n      |                                      ^~~~~~~~~~~~~\n      |                                      _mm_xor_si64\n[REDACTED]/tmprjd6bxts.cpp:43:31: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   43 |         __m256i new_dst_vec = _mm_or_si256(dst_vec, rotated_low_4_bits); // Set the rotated low 4 bits\n      |                               ^~~~~~~~~~~~\n      |                               _mm_or_si64\n[REDACTED]/tmprjd6bxts.cpp:46:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   46 |         _mm_storeu_si256((__m256i*)(&dst[i]), new_dst_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_48_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvaiue52i.cpp: In function \u2018void matrix_conditional_bit_rotate_simd(const uint32_t*, uint32_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpvaiue52i.cpp:31:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set_epi32(0xF, 0xF, 0xF, 0xF); // Mask to check if low 4 bits are all 1\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpvaiue52i.cpp:32:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i rotate_mask = _mm_set_epi32(0xFF << rotate_bits, 0xFF << rotate_bits, 0xFF << rotate_bits, 0xFF << rotate_bits); // Rotate mask\n      |                           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmpvaiue52i.cpp:35:29: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   35 |         __m256i src_chunk = _mm_loadu_si256((__m256i*)(&src[i]));\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm_loadu_si16\n[REDACTED]/tmpvaiue52i.cpp:38:30: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   38 |         __m256i low_4_bits = _mm_and_si256(src_chunk, mask); // Check if low 4 bits are all 1\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_and_si64\n[REDACTED]/tmpvaiue52i.cpp:39:47: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   39 |         __m256i rotated_chunk = _mm_xor_si256(_mm_andnot_si256(low_4_bits, rotate_mask), src_chunk); // Rotate or negate based on condition\n      |                                               ^~~~~~~~~~~~~~~~\n      |                                               _mm_andnot_si64\n[REDACTED]/tmpvaiue52i.cpp:39:33: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   39 |         __m256i rotated_chunk = _mm_xor_si256(_mm_andnot_si256(low_4_bits, rotate_mask), src_chunk); // Rotate or negate based on condition\n      |                                 ^~~~~~~~~~~~~\n      |                                 _mm_xor_si64\n[REDACTED]/tmpvaiue52i.cpp:41:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   41 |         _mm_storeu_si256((__m256i*)(&dst[i]), rotated_chunk);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_48_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdgjosicj.cpp: In function \u2018void matrix_conditional_bit_rotate_simd(const uint32_t*, uint32_t*, uint8_t, size_t)\u2019:\n[REDACTED]/tmpdgjosicj.cpp:31:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set_epi32(0xF0F0F0F0, 0xF0F0F0F0, 0xF0F0F0F0, 0xF0F0F0F0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpdgjosicj.cpp:32:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i rotate_mask = _mm_set_epi32((uint32_t)(rotate_bits & 0xF), (uint32_t)((rotate_bits >> 4) & 0xF), (uint32_t)((rotate_bits >> 8) & 0xF), (uint32_t)((rotate_bits >> 12) & 0xF));\n      |                           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmpdgjosicj.cpp:33:41: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i rotate_shift = _mm_set_epi32(0, 0, 0, 0);\n      |                            ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                         |\n      |                                         __m128i\n[REDACTED]/tmpdgjosicj.cpp:36:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[i * 4]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpdgjosicj.cpp:39:32: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i mask_and_src = _mm_and_si256(src_vec, mask);\n      |                                ^~~~~~~~~~~~~\n      |                                _mm_and_si64\n[REDACTED]/tmpdgjosicj.cpp:40:36: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   40 |         __m256i mask_and_not_src = _mm_andnot_si256(mask, src_vec);\n      |                                    ^~~~~~~~~~~~~~~~\n      |                                    _mm_andnot_si64\n[REDACTED]/tmpdgjosicj.cpp:41:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         __m256i rotated_src = _mm_shuffle_epi8(mask_and_src, rotate_mask);\n      |                                                ^~~~~~~~~~~~\n      |                                                |\n      |                                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37,\n                 from [REDACTED]/tmpdgjosicj.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpdgjosicj.cpp:42:31: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   42 |         __m256i negated_src = _mm_xor_si256(rotated_src, mask_and_not_src);\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_xor_si64\n[REDACTED]/tmpdgjosicj.cpp:44:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |         __m256i rotated_dst = _mm_shuffle_epi8(dst_vec, rotate_mask);\n      |                                                ^~~~~~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpdgjosicj.cpp:47:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   47 |         _mm_storeu_si256((__m256i*)(&dst[i * 4]), negated_dst);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmpdgjosicj.cpp:51:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   51 |         __m256i src_vec = _mm_loadu_si256((__m256i*)(&src[length - 4]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpdgjosicj.cpp:54:32: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   54 |         __m256i mask_and_src = _mm_and_si256(src_vec, mask);\n      |                                ^~~~~~~~~~~~~\n      |                                _mm_and_si64\n[REDACTED]/tmpdgjosicj.cpp:55:36: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   55 |         __m256i mask_and_not_src = _mm_andnot_si256(mask, src_vec);\n      |                                    ^~~~~~~~~~~~~~~~\n      |                                    _mm_andnot_si64\n[REDACTED]/tmpdgjosicj.cpp:56:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   56 |         __m256i rotated_src = _mm_shuffle_epi8(mask_and_src, rotate_mask);\n      |                                                ^~~~~~~~~~~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpdgjosicj.cpp:57:31: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   57 |         __m256i negated_src = _mm_xor_si256(rotated_src, mask_and_not_src);\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_xor_si64\n[REDACTED]/tmpdgjosicj.cpp:59:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   59 |         __m256i rotated_dst = _mm_shuffle_epi8(dst_vec, rotate_mask);\n      |                                                ^~~~~~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpdgjosicj.cpp:62:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   62 |         _mm_storeu_si256((__m256i*)(&dst[length - 4]), negated_dst);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_49_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgd4hmudb.cpp: In function \u2018void tensor_ternary_compare_simd(const float*, const float*, int8_t*, float, size_t)\u2019:\n[REDACTED]/tmpgd4hmudb.cpp:32:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 epsilon_vec = _mm_set_ps(epsilon, epsilon, epsilon, epsilon);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpgd4hmudb.cpp:33:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |     __m256 zero_vec = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpgd4hmudb.cpp:36:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   36 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpgd4hmudb.cpp:37:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 b_vec = _mm_loadu_ps(&B[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpgd4hmudb.cpp:39:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 diff_vec = _mm_sub_ps(a_vec, b_vec);\n      |                                      ^~~~~\n      |                                      |\n      |                                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpgd4hmudb.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpgd4hmudb.cpp:40:31: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   40 |         __m256 abs_diff_vec = _mm_abs_ps(diff_vec);\n      |                               ^~~~~~~~~~\n      |                               _mm_abs_ph\n[REDACTED]/tmpgd4hmudb.cpp:42:45: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 condition_vec = _mm_cmpgt_ps(abs_diff_vec, epsilon_vec);\n      |                                             ^~~~~~~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpgd4hmudb.cpp:43:49: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         __m256 neg_condition_vec = _mm_cmplt_ps(abs_diff_vec, -epsilon_vec);\n      |                                                 ^~~~~~~~~~~~\n      |                                                 |\n      |                                                 __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpgd4hmudb.cpp:45:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         __m256 result_vec = _mm_or_ps(condition_vec, neg_condition_vec);\n      |                                       ^~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpgd4hmudb.cpp:46:45: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   46 |         __m256 zero_result_vec = _mm_and_ps(result_vec, zero_vec);\n      |                                             ^~~~~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpgd4hmudb.cpp:48:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   48 |         _mm_storeu_ps(&out[i], zero_result_vec);\n      |                       ^~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_49_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7wkj1c73.cpp: In function \u2018void tensor_ternary_compare_simd(const float*, const float*, int8_t*, float, size_t)\u2019:\n[REDACTED]/tmp7wkj1c73.cpp:32:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 epsilon_vec = _mm_set_ps1(epsilon);\n      |                          ~~~~~~~~~~~^~~~~~~~~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmp7wkj1c73.cpp:33:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |     __m256 zero_vec = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmp7wkj1c73.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |     __m256 one_vec = _mm_set1_ps(1.0f);\n      |                      ~~~~~~~~~~~^~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp7wkj1c73.cpp:37:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmp7wkj1c73.cpp:38:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   38 |         __m256 b_vec = _mm_loadu_ps(&B[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmp7wkj1c73.cpp:40:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         __m256 diff_vec = _mm_sub_ps(a_vec, b_vec);\n      |                                      ^~~~~\n      |                                      |\n      |                                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp7wkj1c73.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:41:31: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   41 |         __m256 abs_diff_vec = _mm_abs_ps(diff_vec);\n      |                               ^~~~~~~~~~\n      |                               _mm_abs_ph\n[REDACTED]/tmp7wkj1c73.cpp:43:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         __m256 mask_pos = _mm_cmpgt_ps(abs_diff_vec, epsilon_vec);\n      |                                        ^~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:44:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         __m256 mask_neg = _mm_cmplt_ps(abs_diff_vec, epsilon_vec);\n      |                                        ^~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:45:41: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         __m256 mask_zero = _mm_cmpeq_ps(abs_diff_vec, zero_vec);\n      |                                         ^~~~~~~~~~~~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:366:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpeq_ps(__m128, __m128)\u2019\n  366 | _mm_cmpeq_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:47:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   47 |         __m256 result_pos = _mm_and_ps(mask_pos, one_vec);\n      |                                        ^~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:48:50: error: \u2018negative_vec\u2019 was not declared in this scope\n   48 |         __m256 result_neg = _mm_and_ps(mask_neg, negative_vec);\n      |                                                  ^~~~~~~~~~~~\n[REDACTED]/tmp7wkj1c73.cpp:49:44: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   49 |         __m256 result_zero = _mm_andnot_ps(mask_zero, zero_vec);\n      |                                            ^~~~~~~~~\n      |                                            |\n      |                                            __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:252:23: note:   initializing argument 1 of \u2018__m128 _mm_andnot_ps(__m128, __m128)\u2019\n  252 | _mm_andnot_ps (__m128 __A, __m128 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:51:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   51 |         _mm_storeu_ps(&out[i], result_pos);\n      |                       ^~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:52:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   52 |         _mm_storeu_ps(&out[i + 4], result_neg);\n      |                       ^~~~~~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp7wkj1c73.cpp:53:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   53 |         _mm_storeu_ps(&out[i + 8], result_zero);\n      |                       ^~~~~~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_49_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxk9oakcb.cpp: In function \u2018void tensor_ternary_compare_simd(const float*, const float*, int8_t*, float, size_t)\u2019:\n[REDACTED]/tmpxk9oakcb.cpp:29:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 epsilon_vec = _mm_set1_ps(epsilon);\n      |                          ~~~~~~~~~~~^~~~~~~~~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpxk9oakcb.cpp:30:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   30 |     __m256 zero_vec = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpxk9oakcb.cpp:33:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpxk9oakcb.cpp:34:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 b_vec = _mm_loadu_ps(&B[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpxk9oakcb.cpp:36:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   36 |         __m256 diff_vec = _mm_sub_ps(a_vec, b_vec);\n      |                                      ^~~~~\n      |                                      |\n      |                                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpxk9oakcb.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:37:31: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   37 |         __m256 abs_diff_vec = _mm_abs_ps(diff_vec);\n      |                               ^~~~~~~~~~\n      |                               _mm_abs_ph\n[REDACTED]/tmpxk9oakcb.cpp:39:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 mask_pos = _mm_cmpgt_ps(abs_diff_vec, epsilon_vec);\n      |                                        ^~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:40:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         __m256 mask_neg = _mm_cmplt_ps(abs_diff_vec, -epsilon_vec);\n      |                                        ^~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:42:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 result_pos = _mm_and_ps(mask_pos, _mm_set1_ps(1));\n      |                                        ^~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:43:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         __m256 result_neg = _mm_and_ps(mask_neg, _mm_set1_ps(-1));\n      |                                        ^~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:45:54: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         __m256 result_zero = _mm_andnot_ps(_mm_or_ps(mask_pos, mask_neg), zero_vec);\n      |                                                      ^~~~~~~~\n      |                                                      |\n      |                                                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:47:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   47 |         _mm_storeu_ps(&out[i], result_pos);\n      |                       ^~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:48:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   48 |         _mm_storeu_ps(&out[i + 4], result_neg);\n      |                       ^~~~~~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpxk9oakcb.cpp:49:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   49 |         _mm_storeu_ps(&out[i + 8], result_zero);\n      |                       ^~~~~~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_49_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpyf7ay19x.cpp: In function \u2018void tensor_ternary_compare_simd(const float*, const float*, int8_t*, float, size_t)\u2019:\n[REDACTED]/tmpyf7ay19x.cpp:29:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   29 |     __m256 epsilon_vec = _mm_set1_ps(epsilon);\n      |                          ~~~~~~~~~~~^~~~~~~~~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpyf7ay19x.cpp:30:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   30 |     __m256 zero_vec = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmpyf7ay19x.cpp:33:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpyf7ay19x.cpp:34:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |         __m256 b_vec = _mm_loadu_ps(&B[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpyf7ay19x.cpp:36:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   36 |         __m256 diff_vec = _mm_sub_ps(a_vec, b_vec);\n      |                                      ^~~~~\n      |                                      |\n      |                                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpyf7ay19x.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpyf7ay19x.cpp:37:31: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   37 |         __m256 abs_diff_vec = _mm_abs_ps(diff_vec);\n      |                               ^~~~~~~~~~\n      |                               _mm_abs_ph\n[REDACTED]/tmpyf7ay19x.cpp:39:45: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 condition_vec = _mm_cmpgt_ps(abs_diff_vec, epsilon_vec);\n      |                                             ^~~~~~~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpyf7ay19x.cpp:40:49: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         __m256 neg_condition_vec = _mm_cmplt_ps(abs_diff_vec, -epsilon_vec);\n      |                                                 ^~~~~~~~~~~~\n      |                                                 |\n      |                                                 __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpyf7ay19x.cpp:42:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 result_vec = _mm_or_ps(condition_vec, neg_condition_vec);\n      |                                       ^~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpyf7ay19x.cpp:43:45: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         __m256 zero_result_vec = _mm_and_ps(result_vec, zero_vec);\n      |                                             ^~~~~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpyf7ay19x.cpp:45:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   45 |         _mm_storeu_ps(&out[i], zero_result_vec);\n      |                       ^~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_49_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptycj5vhm.cpp: In function \u2018void tensor_ternary_compare_simd(const float*, const float*, int8_t*, float, size_t)\u2019:\n[REDACTED]/tmptycj5vhm.cpp:32:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 epsilon_vec = _mm_set_ps1(epsilon);\n      |                          ~~~~~~~~~~~^~~~~~~~~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmptycj5vhm.cpp:33:37: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |     __m256 zero_vec = _mm_setzero_ps();\n      |                       ~~~~~~~~~~~~~~^~\n      |                                     |\n      |                                     __m128\n[REDACTED]/tmptycj5vhm.cpp:34:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |     __m256 one_vec = _mm_set1_ps(1.0f);\n      |                      ~~~~~~~~~~~^~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmptycj5vhm.cpp:37:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmptycj5vhm.cpp:38:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   38 |         __m256 b_vec = _mm_loadu_ps(&B[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmptycj5vhm.cpp:40:38: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         __m256 diff_vec = _mm_sub_ps(a_vec, b_vec);\n      |                                      ^~~~~\n      |                                      |\n      |                                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmptycj5vhm.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmptycj5vhm.cpp:41:31: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   41 |         __m256 abs_diff_vec = _mm_abs_ps(diff_vec);\n      |                               ^~~~~~~~~~\n      |                               _mm_abs_ph\n[REDACTED]/tmptycj5vhm.cpp:43:45: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         __m256 condition_vec = _mm_cmpgt_ps(abs_diff_vec, epsilon_vec);\n      |                                             ^~~~~~~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmptycj5vhm.cpp:44:49: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         __m256 neg_condition_vec = _mm_cmplt_ps(abs_diff_vec, epsilon_vec);\n      |                                                 ^~~~~~~~~~~~\n      |                                                 |\n      |                                                 __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmptycj5vhm.cpp:46:50: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   46 |         __m256 result_vec = _mm_or_ps(_mm_and_ps(condition_vec, one_vec),\n      |                                                  ^~~~~~~~~~~~~\n      |                                                  |\n      |                                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmptycj5vhm.cpp:47:51: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   47 |                                        _mm_and_ps(neg_condition_vec, zero_vec));\n      |                                                   ^~~~~~~~~~~~~~~~~\n      |                                                   |\n      |                                                   __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmptycj5vhm.cpp:49:23: error: cannot convert \u2018int8_t*\u2019 {aka \u2018signed char*\u2019} to \u2018float*\u2019\n   49 |         _mm_storeu_ps(&out[i], result_vec);\n      |                       ^~~~~~~\n      |                       |\n      |                       int8_t* {aka signed char*}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:23: note:   initializing argument 1 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_50_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo4u7zmy8.cpp: In function \u2018void float_to_int_saturate_simd(const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpo4u7zmy8.cpp:31:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i max_val = _mm_set1_epi32(INT32_MAX);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpo4u7zmy8.cpp:32:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i min_val = _mm_set1_epi32(INT32_MIN);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpo4u7zmy8.cpp:35:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   35 |         __m256f val = _mm_loadu_ps(A + i);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpo4u7zmy8.cpp:36:43: error: \u2018val\u2019 was not declared in this scope\n   36 |         __m256i int_val = _mm_cvtps_epi32(val);\n      |                                           ^~~\n[REDACTED]/tmpo4u7zmy8.cpp:39:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         int_val = _mm_max_epi32(int_val, min_val);\n      |                                 ^~~~~~~\n      |                                 |\n      |                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpo4u7zmy8.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:306:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi32(__m128i, __m128i)\u2019\n  306 | _mm_max_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpo4u7zmy8.cpp:40:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         int_val = _mm_min_epi32(int_val, max_val);\n      |                                 ^~~~~~~\n      |                                 |\n      |                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:300:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi32(__m128i, __m128i)\u2019\n  300 | _mm_min_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpo4u7zmy8.cpp:42:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         _mm_storeu_si32(B + i, int_val);\n      |                                ^~~~~~~\n      |                                |\n      |                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpo4u7zmy8.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_50_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpc3w_op9b.cpp: In function \u2018void float_to_int_saturate_simd(const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpc3w_op9b.cpp:28:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i max_val = _mm_set1_epi32(INT32_MAX);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpc3w_op9b.cpp:29:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i min_val = _mm_set1_epi32(INT32_MIN);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpc3w_op9b.cpp:32:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   32 |         __m256f f = _mm_loadu_ps(A + i);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpc3w_op9b.cpp:33:39: error: \u2018f\u2019 was not declared in this scope\n   33 |         __m256i i32 = _mm_cvtps_epi32(f);\n      |                                       ^\n[REDACTED]/tmpc3w_op9b.cpp:36:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         i32 = _mm_min_epi32(i32, max_val);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpc3w_op9b.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:300:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi32(__m128i, __m128i)\u2019\n  300 | _mm_min_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpc3w_op9b.cpp:37:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         i32 = _mm_max_epi32(i32, min_val);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:306:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi32(__m128i, __m128i)\u2019\n  306 | _mm_max_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpc3w_op9b.cpp:39:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         _mm_storeu_si32(B + i, i32);\n      |                                ^~~\n      |                                |\n      |                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpc3w_op9b.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_50_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppj2se0z7.cpp: In function \u2018void float_to_int_saturate_simd(const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmppj2se0z7.cpp:31:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i max_val = _mm_set1_epi32(INT32_MAX);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmppj2se0z7.cpp:32:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i min_val = _mm_set1_epi32(INT32_MIN);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmppj2se0z7.cpp:35:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   35 |         __m256f f = _mm_loadu_ps(A + i);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmppj2se0z7.cpp:36:39: error: \u2018f\u2019 was not declared in this scope\n   36 |         __m256i i32 = _mm_cvtps_epi32(f);\n      |                                       ^\n[REDACTED]/tmppj2se0z7.cpp:39:43: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         i32 = _mm_min_epi32(_mm_max_epi32(i32, min_val), max_val);\n      |                                           ^~~\n      |                                           |\n      |                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmppj2se0z7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:306:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi32(__m128i, __m128i)\u2019\n  306 | _mm_max_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmppj2se0z7.cpp:41:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         _mm_storeu_si32(B + i, i32);\n      |                                ^~~\n      |                                |\n      |                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmppj2se0z7.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_50_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp4qbucuia.cpp: In function \u2018void float_to_int_saturate_simd(const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmp4qbucuia.cpp:31:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i max_val = _mm_set1_epi32(INT32_MAX);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp4qbucuia.cpp:32:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i min_val = _mm_set1_epi32(INT32_MIN);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp4qbucuia.cpp:35:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   35 |         __m256f f = _mm_loadu_ps(A + i);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmp4qbucuia.cpp:36:39: error: \u2018f\u2019 was not declared in this scope\n   36 |         __m256i i32 = _mm_cvtps_epi32(f);\n      |                                       ^\n[REDACTED]/tmp4qbucuia.cpp:39:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         i32 = _mm_min_epi32(i32, max_val);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp4qbucuia.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:300:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi32(__m128i, __m128i)\u2019\n  300 | _mm_min_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp4qbucuia.cpp:40:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         i32 = _mm_max_epi32(i32, min_val);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:306:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epi32(__m128i, __m128i)\u2019\n  306 | _mm_max_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp4qbucuia.cpp:42:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         _mm_storeu_si32(B + i, i32);\n      |                                ^~~\n      |                                |\n      |                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp4qbucuia.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_50_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwboax8_9.cpp: In function \u2018void float_to_int_saturate_simd(const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpwboax8_9.cpp:28:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   28 |     __m256i max_val = _mm_set1_epi32(INT32_MAX);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpwboax8_9.cpp:29:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i min_val = _mm_set1_epi32(INT32_MIN);\n      |                       ~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpwboax8_9.cpp:32:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   32 |         __m256f val = _mm_loadu_ps(&A[i]);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpwboax8_9.cpp:33:43: error: \u2018val\u2019 was not declared in this scope\n   33 |         __m256i int_val = _mm_cvtps_epi32(val);\n      |                                           ^~~\n[REDACTED]/tmpwboax8_9.cpp:36:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         int_val = _mm_min_epu32(int_val, max_val);\n      |                                 ^~~~~~~\n      |                                 |\n      |                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpwboax8_9.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:312:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epu32(__m128i, __m128i)\u2019\n  312 | _mm_min_epu32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwboax8_9.cpp:37:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         int_val = _mm_max_epu32(int_val, min_val);\n      |                                 ^~~~~~~\n      |                                 |\n      |                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:318:24: note:   initializing argument 1 of \u2018__m128i _mm_max_epu32(__m128i, __m128i)\u2019\n  318 | _mm_max_epu32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwboax8_9.cpp:39:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         _mm_storeu_si32(&B[i], int_val);\n      |                                ^~~~~~~\n      |                                |\n      |                                __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpwboax8_9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_51_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpn74rgvhe.cpp: In function \u2018void int_to_float_scaled_simd(const int32_t*, int8_t, float*, size_t)\u2019:\n[REDACTED]/tmpn74rgvhe.cpp:30:16: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         temp = _mm_loadu_si256((__m256i*)(&A[i]));\n      |                ^~~~~~~~~~~~~~~\n      |                _mm_loadu_si16\n[REDACTED]/tmpn74rgvhe.cpp:33:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   33 |         scaled_values = _mm_mul_ps(temp, _mm_set1_ps(scale));\n      |                                    ^~~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpn74rgvhe.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpn74rgvhe.cpp:36:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   36 |         _mm_storeu_si256((__m256i*)(&B[i]), scaled_values);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_51_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpis06b8ru.cpp: In function \u2018void int_to_float_scaled_simd(const int32_t*, int8_t, float*, size_t)\u2019:\n[REDACTED]/tmpis06b8ru.cpp:25:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   25 |     __m256i scale_vec = _mm_set1_epi8(scale); // Create a vector containing the scale factor\n      |                         ~~~~~~~~~~~~~^~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpis06b8ru.cpp:30:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         __m256i vec_A = _mm_loadu_si256(ptr_A + i); // Load 8 int32_t values from A into a vector\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmpis06b8ru.cpp:31:56: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   31 |         __m256 vec_result = _mm_mul_ps(_mm_cvtepi32_ps(vec_A), scale_vec); // Convert int32_t to float and scale\n      |                                                        ^~~~~\n      |                                                        |\n      |                                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpis06b8ru.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:812:26: note:   initializing argument 1 of \u2018__m128 _mm_cvtepi32_ps(__m128i)\u2019\n  812 | _mm_cvtepi32_ps (__m128i __A)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpis06b8ru.cpp:32:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   32 |         _mm_storeu_si256(ptr_B + i, vec_result); // Store the result back to B\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_51_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpb86m44fi.cpp: In function \u2018void int_to_float_scaled_simd(const int32_t*, int8_t, float*, size_t)\u2019:\n[REDACTED]/tmpb86m44fi.cpp:29:51: error: cannot convert \u2018const __m256i\u2019 to \u2018__m256\u2019\n   29 |         const __m256 scaled_a_vec = _mm256_mul_ps(a_vec, scale_vec); // Multiply each element by the scale factor\n      |                                                   ^~~~~\n      |                                                   |\n      |                                                   const __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpb86m44fi.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_51_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvn4buwd2.cpp: In function \u2018void int_to_float_scaled_simd(const int32_t*, int8_t, float*, size_t)\u2019:\n[REDACTED]/tmpvn4buwd2.cpp:25:44: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   25 |     const __m256i scale_vec = _mm_set1_epi8(scale); // Create a vector containing the scale factor\n      |                               ~~~~~~~~~~~~~^~~~~~~\n      |                                            |\n      |                                            __m128i\n[REDACTED]/tmpvn4buwd2.cpp:28:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   28 |         __m256i a_vec = _mm_loadu_si256((__m256i*)(&A[i])); // Load 4 int32_t values from A into a vector\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmpvn4buwd2.cpp:29:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   29 |         __m256f b_vec = _mm_mul_ps(_mm_cvtepi32_ps(a_vec), scale_vec); // Convert int32_t values to float and scale\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpvn4buwd2.cpp:30:38: error: \u2018b_vec\u2019 was not declared in this scope; did you mean \u2018a_vec\u2019?\n   30 |         _mm_storeu_ps((float*)&B[i], b_vec); // Store the scaled float values back to B\n      |                                      ^~~~~\n      |                                      a_vec\n"}
{"task_id": "SimdBench_51_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkcbsxaei.cpp: In function \u2018void int_to_float_scaled_simd(const int32_t*, int8_t, float*, size_t)\u2019:\n[REDACTED]/tmpkcbsxaei.cpp:33:16: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         temp = _mm_loadu_si256((__m256i*)(&A[i]));\n      |                ^~~~~~~~~~~~~~~\n      |                _mm_loadu_si16\n[REDACTED]/tmpkcbsxaei.cpp:36:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   36 |         scaled_values = _mm_mul_ps(temp, _mm_set1_ps(scale));\n      |                                    ^~~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpkcbsxaei.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:202:20: note:   initializing argument 1 of \u2018__m128 _mm_mul_ps(__m128, __m128)\u2019\n  202 | _mm_mul_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpkcbsxaei.cpp:39:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   39 |         _mm_storeu_si256((__m256i*)(&B[i]), scaled_values);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_52_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzs_b2vzg.cpp: In function \u2018void float_div_round_simd(const float*, const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpzs_b2vzg.cpp:36:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   36 |         a = _mm_loadu_ps(A + i);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpzs_b2vzg.cpp:37:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   37 |         b = _mm_loadu_ps(B + i);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpzs_b2vzg.cpp:40:24: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         c = _mm_div_ps(a, b);\n      |                        ^\n      |                        |\n      |                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpzs_b2vzg.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpzs_b2vzg.cpp:41:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         temp = _mm_cvtps_epi32(c); // Convert to integer\n      |                                ^\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:854:25: note:   initializing argument 1 of \u2018__m128i _mm_cvtps_epi32(__m128)\u2019\n  854 | _mm_cvtps_epi32 (__m128 __A)\n      |                  ~~~~~~~^~~\n"}
{"task_id": "SimdBench_52_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1sf64609.cpp: In function \u2018void float_div_round_simd(const float*, const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmp1sf64609.cpp:35:9: error: \u2018_mm256_storeu_si128\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si128\u2019?\n   35 |         _mm256_storeu_si128((__m128i*)C, c); // Store the result\n      |         ^~~~~~~~~~~~~~~~~~~\n      |         _mm_storeu_si128\n[REDACTED]/tmp1sf64609.cpp:36:13: error: \u2018_mm256_adds_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_add_ps\u2019?\n   36 |         a = _mm256_adds_ps(a, b); // Add B to A\n      |             ^~~~~~~~~~~~~~\n      |             _mm256_add_ps\n[REDACTED]/tmp1sf64609.cpp:43:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   43 |         a = _mm_loadu_ps(A + size - 8);\n      |             ~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmp1sf64609.cpp:44:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   44 |         b = _mm_loadu_ps(B + size - 8);\n      |             ~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmp1sf64609.cpp:47:52: error: cannot convert \u2018__m256\u2019 to \u2018__m128i\u2019\n   47 |         _mm_storeu_si128((__m128i*)(C + size - 8), c); // Store the result\n      |                                                    ^\n      |                                                    |\n      |                                                    __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp1sf64609.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_52_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2s5h308q.cpp: In function \u2018void float_div_round_simd(const float*, const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmp2s5h308q.cpp:36:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   36 |         a = _mm_loadu_ps(&A[i]);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmp2s5h308q.cpp:37:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   37 |         b = _mm_loadu_ps(&B[i]);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmp2s5h308q.cpp:40:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         c = _mm_cvtps_epi32(_mm_div_ss(a, b));\n      |                                        ^\n      |                                        |\n      |                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2s5h308q.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:152:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ss(__m128, __m128)\u2019\n  152 | _mm_div_ss (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp2s5h308q.cpp:43:32: error: cannot convert \u2018__m256\u2019 to \u2018__m128i\u2019\n   43 |         _mm_storeu_si32(&C[i], c);\n      |                                ^\n      |                                |\n      |                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_52_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpny7pj8r5.cpp: In function \u2018void float_div_round_simd(const float*, const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpny7pj8r5.cpp:36:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   36 |         a = _mm_loadu_ps(&A[i]);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpny7pj8r5.cpp:37:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   37 |         b = _mm_loadu_ps(&B[i]);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpny7pj8r5.cpp:40:24: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         c = _mm_div_ps(a, b);\n      |                        ^\n      |                        |\n      |                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpny7pj8r5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpny7pj8r5.cpp:41:48: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         mask = _mm_cmpgt_epi32(_mm_cvtps_epi32(c), _mm_set1_epi32(0xFFFFFFFF));\n      |                                                ^\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:854:25: note:   initializing argument 1 of \u2018__m128i _mm_cvtps_epi32(__m128)\u2019\n  854 | _mm_cvtps_epi32 (__m128 __A)\n      |                  ~~~~~~~^~~\n[REDACTED]/tmpny7pj8r5.cpp:42:27: error: cannot convert \u2018__m256\u2019 to \u2018__m128i\u2019\n   42 |         c = _mm_sub_epi32(c, mask);\n      |                           ^\n      |                           |\n      |                           __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpny7pj8r5.cpp:45:32: error: \u2018_mm_cvtsi32_ps\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi32_ss\u2019?\n   45 |         _mm_storeu_si32(&C[i], _mm_cvtsi32_ps(c));\n      |                                ^~~~~~~~~~~~~~\n      |                                _mm_cvtsi32_ss\n"}
{"task_id": "SimdBench_52_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdl1i9ip0.cpp: In function \u2018void float_div_round_simd(const float*, const float*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpdl1i9ip0.cpp:36:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   36 |         a = _mm_loadu_ps(A + i);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpdl1i9ip0.cpp:37:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   37 |         b = _mm_loadu_ps(B + i);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpdl1i9ip0.cpp:40:24: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         c = _mm_div_ps(a, b);\n      |                        ^\n      |                        |\n      |                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpdl1i9ip0.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpdl1i9ip0.cpp:41:48: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         mask = _mm_cmpgt_epi32(_mm_cvtps_epi32(c), _mm_set1_epi32(0xFFFFFFFF));\n      |                                                ^\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:854:25: note:   initializing argument 1 of \u2018__m128i _mm_cvtps_epi32(__m128)\u2019\n  854 | _mm_cvtps_epi32 (__m128 __A)\n      |                  ~~~~~~~^~~\n[REDACTED]/tmpdl1i9ip0.cpp:42:27: error: cannot convert \u2018__m256\u2019 to \u2018__m128i\u2019\n   42 |         c = _mm_sub_epi32(c, mask);\n      |                           ^\n      |                           |\n      |                           __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpdl1i9ip0.cpp:45:32: error: \u2018_mm_cvtsi32_ps\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi32_ss\u2019?\n   45 |         _mm_storeu_si32(C + i, _mm_cvtsi32_ps(c));\n      |                                ^~~~~~~~~~~~~~\n      |                                _mm_cvtsi32_ss\n"}
{"task_id": "SimdBench_53_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmuuo_sm9.cpp: In function \u2018void double_to_float_saturate_simd(const double*, float*, size_t)\u2019:\n[REDACTED]/tmpmuuo_sm9.cpp:31:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   31 |     __m256d max_val = _mm_set1_pd(FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpmuuo_sm9.cpp:32:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   32 |     __m256d min_val = _mm_set1_pd(-FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpmuuo_sm9.cpp:35:33: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   35 |         __m256d a = _mm_loadu_pd(A + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128d\n[REDACTED]/tmpmuuo_sm9.cpp:36:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256d\u2019 in initialization\n   36 |         __m256d b = _mm_loadu_ps(B + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpmuuo_sm9.cpp:39:49: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   39 |         __m256d greater_than_max = _mm_cmpgt_pd(a, max_val);\n      |                                                 ^\n      |                                                 |\n      |                                                 __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpmuuo_sm9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpmuuo_sm9.cpp:41:45: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   41 |         __m256d saturated_a = _mm_andnot_pd(greater_than_max, a);\n      |                                             ^~~~~~~~~~~~~~~~\n      |                                             |\n      |                                             __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:341:24: note:   initializing argument 1 of \u2018__m128d _mm_andnot_pd(__m128d, __m128d)\u2019\n  341 | _mm_andnot_pd (__m128d __A, __m128d __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpmuuo_sm9.cpp:44:46: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   44 |         __m256d less_than_min = _mm_cmplt_pd(a, min_val);\n      |                                              ^\n      |                                              |\n      |                                              __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:365:23: note:   initializing argument 1 of \u2018__m128d _mm_cmplt_pd(__m128d, __m128d)\u2019\n  365 | _mm_cmplt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpmuuo_sm9.cpp:46:45: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   46 |         __m256d saturated_b = _mm_andnot_pd(less_than_min, b);\n      |                                             ^~~~~~~~~~~~~\n      |                                             |\n      |                                             __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:341:24: note:   initializing argument 1 of \u2018__m128d _mm_andnot_pd(__m128d, __m128d)\u2019\n  341 | _mm_andnot_pd (__m128d __A, __m128d __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpmuuo_sm9.cpp:49:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   49 |         __m256f f_a = _mm_cvtpd_ps(saturated_a);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpmuuo_sm9.cpp:50:16: error: expected \u2018;\u2019 before \u2018f_b\u2019\n   50 |         __m256f f_b = _mm_cvtpd_ps(saturated_b);\n      |                ^~~~\n      |                ;\n[REDACTED]/tmpmuuo_sm9.cpp:53:30: error: \u2018f_a\u2019 was not declared in this scope; did you mean \u2018fma\u2019?\n   53 |         _mm_storeu_ps(B + i, f_a);\n      |                              ^~~\n      |                              fma\n[REDACTED]/tmpmuuo_sm9.cpp:54:34: error: \u2018f_b\u2019 was not declared in this scope\n   54 |         _mm_storeu_ps(B + i + 4, f_b);\n      |                                  ^~~\n"}
{"task_id": "SimdBench_53_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkt4i8bse.cpp: In function \u2018void double_to_float_saturate_simd(const double*, float*, size_t)\u2019:\n[REDACTED]/tmpkt4i8bse.cpp:31:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   31 |     __m256d max_val = _mm_set1_pd(FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpkt4i8bse.cpp:32:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   32 |     __m256d min_val = _mm_set1_pd(-FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpkt4i8bse.cpp:35:33: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   35 |         __m256d a = _mm_loadu_pd(A + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128d\n[REDACTED]/tmpkt4i8bse.cpp:36:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256d\u2019 in initialization\n   36 |         __m256d b = _mm_loadu_ps(B + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpkt4i8bse.cpp:39:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   39 |         __m256f saturated_b = _mm_cvtph_ps(_mm_cvtpd_ps(a), _mm_setzero_si128());\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpkt4i8bse.cpp:40:9: error: \u2018saturated_b\u2019 was not declared in this scope\n   40 |         saturated_b = _mm_min_ps(saturated_b, max_val);\n      |         ^~~~~~~~~~~\n"}
{"task_id": "SimdBench_53_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqq83m_4i.cpp: In function \u2018void double_to_float_saturate_simd(const double*, float*, size_t)\u2019:\n[REDACTED]/tmpqq83m_4i.cpp:28:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   28 |     __m256d max_val = _mm_set1_pd(FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpqq83m_4i.cpp:29:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   29 |     __m256d min_val = _mm_set1_pd(-FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpqq83m_4i.cpp:32:33: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   32 |         __m256d a = _mm_loadu_pd(A + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128d\n[REDACTED]/tmpqq83m_4i.cpp:33:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256d\u2019 in initialization\n   33 |         __m256d b = _mm_loadu_ps(B + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpqq83m_4i.cpp:36:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   36 |         __m256f f_a = _mm_cvtpd_ps(a);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpqq83m_4i.cpp:39:16: error: expected \u2018;\u2019 before \u2018saturated_f_a\u2019\n   39 |         __m256f saturated_f_a = _mm_max_ps(_mm_min_ps(f_a, max_val), min_val);\n      |                ^~~~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmpqq83m_4i.cpp:42:30: error: \u2018saturated_f_a\u2019 was not declared in this scope\n   42 |         _mm_storeu_ps(B + i, saturated_f_a);\n      |                              ^~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_53_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp4nr1z9w7.cpp: In function \u2018void double_to_float_saturate_simd(const double*, float*, size_t)\u2019:\n[REDACTED]/tmp4nr1z9w7.cpp:31:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   31 |     __m256d max_val = _mm_set1_pd(FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmp4nr1z9w7.cpp:32:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   32 |     __m256d min_val = _mm_set1_pd(-FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmp4nr1z9w7.cpp:35:33: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   35 |         __m256d a = _mm_loadu_pd(A + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128d\n[REDACTED]/tmp4nr1z9w7.cpp:36:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256d\u2019 in initialization\n   36 |         __m256d b = _mm_loadu_ps(B + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmp4nr1z9w7.cpp:39:49: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   39 |         __m256d greater_than_max = _mm_cmpgt_pd(a, max_val);\n      |                                                 ^\n      |                                                 |\n      |                                                 __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp4nr1z9w7.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmp4nr1z9w7.cpp:41:46: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   41 |         __m256d less_than_min = _mm_cmplt_pd(a, min_val);\n      |                                              ^\n      |                                              |\n      |                                              __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:365:23: note:   initializing argument 1 of \u2018__m128d _mm_cmplt_pd(__m128d, __m128d)\u2019\n  365 | _mm_cmplt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmp4nr1z9w7.cpp:44:45: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   44 |         __m256d saturated_a = _mm_blendv_pd(a, max_val, greater_than_max);\n      |                                             ^\n      |                                             |\n      |                                             __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp4nr1z9w7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:229:24: note:   initializing argument 1 of \u2018__m128d _mm_blendv_pd(__m128d, __m128d, __m128d)\u2019\n  229 | _mm_blendv_pd (__m128d __X, __m128d __Y, __m128d __M)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp4nr1z9w7.cpp:45:37: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   45 |         saturated_a = _mm_blendv_pd(saturated_a, min_val, less_than_min);\n      |                                     ^~~~~~~~~~~\n      |                                     |\n      |                                     __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:229:24: note:   initializing argument 1 of \u2018__m128d _mm_blendv_pd(__m128d, __m128d, __m128d)\u2019\n  229 | _mm_blendv_pd (__m128d __X, __m128d __Y, __m128d __M)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp4nr1z9w7.cpp:48:33: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   48 |         __m256 f = _mm_cvtpd_ps(saturated_a);\n      |                                 ^~~~~~~~~~~\n      |                                 |\n      |                                 __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:830:23: note:   initializing argument 1 of \u2018__m128 _mm_cvtpd_ps(__m128d)\u2019\n  830 | _mm_cvtpd_ps (__m128d __A)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmp4nr1z9w7.cpp:51:30: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   51 |         _mm_storeu_ps(B + i, f);\n      |                              ^\n      |                              |\n      |                              __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_53_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpc3yctj37.cpp: In function \u2018void double_to_float_saturate_simd(const double*, float*, size_t)\u2019:\n[REDACTED]/tmpc3yctj37.cpp:28:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   28 |     __m256d max_val = _mm_set1_pd(FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpc3yctj37.cpp:29:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   29 |     __m256d min_val = _mm_set1_pd(-FLT_MAX);\n      |                       ~~~~~~~~~~~^~~~~~~~~~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpc3yctj37.cpp:32:33: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   32 |         __m256d a = _mm_loadu_pd(A + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128d\n[REDACTED]/tmpc3yctj37.cpp:33:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256d\u2019 in initialization\n   33 |         __m256d b = _mm_loadu_ps(B + i);\n      |                     ~~~~~~~~~~~~^~~~~~~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpc3yctj37.cpp:36:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   36 |         __m256f f = _mm_cvtpd_ps(a);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpc3yctj37.cpp:39:16: error: expected \u2018;\u2019 before \u2018saturated_f\u2019\n   39 |         __m256f saturated_f = _mm_min_ps(_mm_max_ps(f, min_val), max_val);\n      |                ^~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmpc3yctj37.cpp:42:30: error: \u2018saturated_f\u2019 was not declared in this scope\n   42 |         _mm_storeu_ps(B + i, saturated_f);\n      |                              ^~~~~~~~~~~\n"}
{"task_id": "SimdBench_54_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqce99rnf.cpp: In function \u2018void int16_to_int32_simd(const int16_t*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpqce99rnf.cpp:30:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   30 |         __m256i vec_B = _mm256_cvtepu16_epi32(vec_A);\n      |                                               ^~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpqce99rnf.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:503:32: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepu16_epi32(__m128i)\u2019\n  503 | _mm256_cvtepu16_epi32 (__m128i __X)\n      |                        ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_54_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxbksh758.cpp: In function \u2018void int16_to_int32_simd(const int16_t*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpxbksh758.cpp:30:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   30 |         __m256i vec_B = _mm256_cvtepi16_epi32(vec_A);\n      |                                               ^~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpxbksh758.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:461:32: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepi16_epi32(__m128i)\u2019\n  461 | _mm256_cvtepi16_epi32 (__m128i __X)\n      |                        ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_54_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpux0tfpat.cpp: In function \u2018void int16_to_int32_simd(const int16_t*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpux0tfpat.cpp:33:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   33 |         __m256i vec_B = _mm256_cvtepu16_epi32(vec_A);\n      |                                               ^~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpux0tfpat.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:503:32: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepu16_epi32(__m128i)\u2019\n  503 | _mm256_cvtepu16_epi32 (__m128i __X)\n      |                        ~~~~~~~~^~~\n[REDACTED]/tmpux0tfpat.cpp:39:35: error: cannot convert a vector of type \u2018__m256i\u2019 to type \u2018int32_t\u2019 {aka \u2018int\u2019} which has different size\n   39 |         *avx_B++ = (int32_t)*avx_A++;\n      |                                   ^~\n"}
{"task_id": "SimdBench_54_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzd6t10nv.cpp: In function \u2018void int16_to_int32_simd(const int16_t*, int32_t*, size_t)\u2019:\n[REDACTED]/tmpzd6t10nv.cpp:30:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   30 |         __m256i vec_B = _mm256_cvtepu16_epi32(vec_A);\n      |                                               ^~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpzd6t10nv.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:503:32: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepu16_epi32(__m128i)\u2019\n  503 | _mm256_cvtepu16_epi32 (__m128i __X)\n      |                        ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_54_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplaa9_jgc.cpp: In function \u2018void int16_to_int32_simd(const int16_t*, int32_t*, size_t)\u2019:\n[REDACTED]/tmplaa9_jgc.cpp:30:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   30 |         __m256i vec_B = _mm256_cvtepi16_epi32(vec_A);\n      |                                               ^~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmplaa9_jgc.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:461:32: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepi16_epi32(__m128i)\u2019\n  461 | _mm256_cvtepi16_epi32 (__m128i __X)\n      |                        ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_55_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpffpwj0rt.cpp: In function \u2018void conditional_normalize_simd(const float*, const int32_t*, float*, size_t, float, float)\u2019:\n[REDACTED]/tmpffpwj0rt.cpp:31:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   31 |     __m256 min_val_vec = _mm_set_ps(min_val, min_val, min_val, min_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpffpwj0rt.cpp:32:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 max_val_vec = _mm_set_ps(max_val, max_val, max_val, max_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpffpwj0rt.cpp:35:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpffpwj0rt.cpp:36:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256\u2019 in initialization\n   36 |         __m256 c_vec = _mm_loadu_si32(&control[i]);\n      |                        ~~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpffpwj0rt.cpp:38:46: error: \u2018_mm_setzero_si32\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   38 |         __m256 mask = _mm_cmpgt_epi32(c_vec, _mm_setzero_si32());\n      |                                              ^~~~~~~~~~~~~~~~\n      |                                              _mm_setzero_si64\n[REDACTED]/tmpffpwj0rt.cpp:39:66: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 normalized_a_vec = _mm_andnot_ps(mask, _mm_sub_ps(a_vec, min_val_vec));\n      |                                                                  ^~~~~\n      |                                                                  |\n      |                                                                  __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpffpwj0rt.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpffpwj0rt.cpp:40:125: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         normalized_a_vec = _mm_or_ps(normalized_a_vec, _mm_max_ps(_mm_setzero_ps(), _mm_min_ps(normalized_a_vec, _mm_sub_ps(max_val_vec, a_vec))));\n      |                                                                                                                             ^~~~~~~~~~~\n      |                                                                                                                             |\n      |                                                                                                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpffpwj0rt.cpp:42:30: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         _mm_storeu_ps(&B[i], normalized_a_vec);\n      |                              ^~~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_55_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpu0urhvog.cpp: In function \u2018void conditional_normalize_simd(const float*, const int32_t*, float*, size_t, float, float)\u2019:\n[REDACTED]/tmpu0urhvog.cpp:31:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   31 |     __m256 min_val_vec = _mm_set_ps(min_val, min_val, min_val, min_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpu0urhvog.cpp:32:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 max_val_vec = _mm_set_ps(max_val, max_val, max_val, max_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpu0urhvog.cpp:35:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpu0urhvog.cpp:36:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |         __m256 c_vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&control[i]));\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmpu0urhvog.cpp:38:46: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   38 |         __m256 mask = _mm_cmpgt_epi32(c_vec, _mm_setzero_si256());\n      |                                              ^~~~~~~~~~~~~~~~~\n      |                                              _mm_setzero_si64\n[REDACTED]/tmpu0urhvog.cpp:39:27: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   39 |         __m256 neg_mask = _mm_andnot_si256(mask, _mm_setzero_si256());\n      |                           ^~~~~~~~~~~~~~~~\n      |                           _mm_andnot_si64\n[REDACTED]/tmpu0urhvog.cpp:41:42: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         __m256 min_diff_vec = _mm_sub_ps(a_vec, min_val_vec);\n      |                                          ^~~~~\n      |                                          |\n      |                                          __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpu0urhvog.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:42:42: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 max_diff_vec = _mm_sub_ps(a_vec, max_val_vec);\n      |                                          ^~~~~\n      |                                          |\n      |                                          __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:44:47: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         __m256 norm_min_diff_vec = _mm_div_ps(min_diff_vec, max_diff_vec);\n      |                                               ^~~~~~~~~~~~\n      |                                               |\n      |                                               __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:45:47: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         __m256 norm_max_diff_vec = _mm_div_ps(max_diff_vec, min_diff_vec);\n      |                                               ^~~~~~~~~~~~\n      |                                               |\n      |                                               __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:47:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   47 |         __m256 norm_a_vec = _mm_or_ps(norm_min_diff_vec, norm_max_diff_vec);\n      |                                       ^~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:49:41: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   49 |         __m256 zero_mask = _mm_cmplt_ps(norm_a_vec, _mm_setzero_ps());\n      |                                         ^~~~~~~~~~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:50:52: error: \u2018_mm_setone_ps\u2019 was not declared in this scope; did you mean \u2018_mm_store_ps\u2019?\n   50 |         __m256 one_mask = _mm_cmpgt_ps(norm_a_vec, _mm_setone_ps());\n      |                                                    ^~~~~~~~~~~~~\n      |                                                    _mm_store_ps\n[REDACTED]/tmpu0urhvog.cpp:53:33: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   53 |         __m256 one_norm_a_vec = _mm_and_si256(one_mask, norm_a_vec);\n      |                                 ^~~~~~~~~~~~~\n      |                                 _mm_and_si64\n[REDACTED]/tmpu0urhvog.cpp:58:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   58 |         __m256 result_vec = _mm_or_ps(zero_result_vec, one_result_vec);\n      |                                       ^~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpu0urhvog.cpp:62:30: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   62 |         _mm_storeu_ps(&B[i], neg_result_vec);\n      |                              ^~~~~~~~~~~~~~\n      |                              |\n      |                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_55_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpcg9cc1gv.cpp: In function \u2018void conditional_normalize_simd(const float*, const int32_t*, float*, size_t, float, float)\u2019:\n[REDACTED]/tmpcg9cc1gv.cpp:31:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   31 |     __m256 min_val_vec = _mm_set_ps(min_val, min_val, min_val, min_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpcg9cc1gv.cpp:32:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   32 |     __m256 max_val_vec = _mm_set_ps(max_val, max_val, max_val, max_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpcg9cc1gv.cpp:35:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpcg9cc1gv.cpp:36:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256\u2019 in initialization\n   36 |         __m256 c_vec = _mm_loadu_si32(&control[i]);\n      |                        ~~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpcg9cc1gv.cpp:38:46: error: \u2018_mm_setzero_si32\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   38 |         __m256 mask = _mm_cmpgt_epi32(c_vec, _mm_setzero_si32());\n      |                                              ^~~~~~~~~~~~~~~~\n      |                                              _mm_setzero_si64\n[REDACTED]/tmpcg9cc1gv.cpp:39:66: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   39 |         __m256 normalized_a_vec = _mm_andnot_ps(mask, _mm_sub_ps(a_vec, min_val_vec));\n      |                                                                  ^~~~~\n      |                                                                  |\n      |                                                                  __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpcg9cc1gv.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpcg9cc1gv.cpp:40:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   40 |         normalized_a_vec = _mm_div_ps(normalized_a_vec, max_val_vec);\n      |                                       ^~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpcg9cc1gv.cpp:42:30: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         _mm_storeu_ps(&B[i], normalized_a_vec);\n      |                              ^~~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_55_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpakxi_rfh.cpp: In function \u2018void conditional_normalize_simd(const float*, const int32_t*, float*, size_t, float, float)\u2019:\n[REDACTED]/tmpakxi_rfh.cpp:34:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |     __m256 min_val_vec = _mm_set_ps(min_val, min_val, min_val, min_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpakxi_rfh.cpp:35:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |     __m256 max_val_vec = _mm_set_ps(max_val, max_val, max_val, max_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpakxi_rfh.cpp:38:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   38 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpakxi_rfh.cpp:39:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256\u2019 in initialization\n   39 |         __m256 c_vec = _mm_loadu_si32(&control[i]);\n      |                        ~~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpakxi_rfh.cpp:41:46: error: \u2018_mm_setzero_si32\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   41 |         __m256 mask = _mm_cmpgt_epi32(c_vec, _mm_setzero_si32());\n      |                                              ^~~~~~~~~~~~~~~~\n      |                                              _mm_setzero_si64\n[REDACTED]/tmpakxi_rfh.cpp:42:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 norm_a_vec = _mm_sub_ps(a_vec, min_val_vec);\n      |                                        ^~~~~\n      |                                        |\n      |                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpakxi_rfh.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpakxi_rfh.cpp:43:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         __m256 div_a_vec = _mm_sub_ps(max_val_vec, min_val_vec);\n      |                                       ^~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpakxi_rfh.cpp:44:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         __m256 result_vec = _mm_div_ps(norm_a_vec, div_a_vec);\n      |                                        ^~~~~~~~~~\n      |                                        |\n      |                                        __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpakxi_rfh.cpp:46:41: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   46 |         __m256 zero_mask = _mm_cmplt_ps(result_vec, _mm_setzero_ps());\n      |                                         ^~~~~~~~~~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:372:22: note:   initializing argument 1 of \u2018__m128 _mm_cmplt_ps(__m128, __m128)\u2019\n  372 | _mm_cmplt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpakxi_rfh.cpp:47:52: error: \u2018_mm_setone_ps\u2019 was not declared in this scope; did you mean \u2018_mm_store_ps\u2019?\n   47 |         __m256 one_mask = _mm_cmpgt_ps(result_vec, _mm_setone_ps());\n      |                                                    ^~~~~~~~~~~~~\n      |                                                    _mm_store_ps\n[REDACTED]/tmpakxi_rfh.cpp:49:43: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   49 |         result_vec = _mm_or_ps(_mm_and_ps(zero_mask, _mm_setzero_ps()), _mm_and_ps(one_mask, _mm_setone_ps()));\n      |                                           ^~~~~~~~~\n      |                                           |\n      |                                           __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpakxi_rfh.cpp:50:58: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   50 |         result_vec = _mm_or_ps(result_vec, _mm_andnot_ps(mask, result_vec));\n      |                                                          ^~~~\n      |                                                          |\n      |                                                          __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:252:23: note:   initializing argument 1 of \u2018__m128 _mm_andnot_ps(__m128, __m128)\u2019\n  252 | _mm_andnot_ps (__m128 __A, __m128 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpakxi_rfh.cpp:52:30: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   52 |         _mm_storeu_ps(&B[i], result_vec);\n      |                              ^~~~~~~~~~\n      |                              |\n      |                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_55_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpg9h0ino5.cpp: In function \u2018void conditional_normalize_simd(const float*, const int32_t*, float*, size_t, float, float)\u2019:\n[REDACTED]/tmpg9h0ino5.cpp:34:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   34 |     __m256 min_val_vec = _mm_set_ps(min_val, min_val, min_val, min_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpg9h0ino5.cpp:35:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |     __m256 max_val_vec = _mm_set_ps(max_val, max_val, max_val, max_val);\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpg9h0ino5.cpp:38:36: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   38 |         __m256 a_vec = _mm_loadu_ps(&A[i]);\n      |                        ~~~~~~~~~~~~^~~~~~~\n      |                                    |\n      |                                    __m128\n[REDACTED]/tmpg9h0ino5.cpp:39:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256\u2019 in initialization\n   39 |         __m256 c_vec = _mm_loadu_si32(&control[i]);\n      |                        ~~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpg9h0ino5.cpp:41:46: error: \u2018_mm_setzero_si32\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   41 |         __m256 mask = _mm_cmpgt_epi32(c_vec, _mm_setzero_si32());\n      |                                              ^~~~~~~~~~~~~~~~\n      |                                              _mm_setzero_si64\n[REDACTED]/tmpg9h0ino5.cpp:42:66: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 normalized_a_vec = _mm_andnot_ps(mask, _mm_sub_ps(a_vec, min_val_vec));\n      |                                                                  ^~~~~\n      |                                                                  |\n      |                                                                  __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpg9h0ino5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpg9h0ino5.cpp:43:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         normalized_a_vec = _mm_div_ps(normalized_a_vec, max_val_vec);\n      |                                       ^~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:208:20: note:   initializing argument 1 of \u2018__m128 _mm_div_ps(__m128, __m128)\u2019\n  208 | _mm_div_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpg9h0ino5.cpp:45:30: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         _mm_storeu_ps(&B[i], normalized_a_vec);\n      |                              ^~~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_56_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbyesyk0i.cpp: In function \u2018void int_to_float_sqrt_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmpbyesyk0i.cpp:30:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |     __m256i v_A = _mm_loadu_si256((__m256i*)A);\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n[REDACTED]/tmpbyesyk0i.cpp:31:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   31 |     __m256i v_high_16bits = _mm_srli_epi16(v_A, 16); // Extract high 16 bits\n      |                                            ^~~\n      |                                            |\n      |                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpbyesyk0i.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1249:25: note:   initializing argument 1 of \u2018__m128i _mm_srli_epi16(__m128i, int)\u2019\n 1249 | _mm_srli_epi16 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpbyesyk0i.cpp:32:36: error: \u2018_mm_castsi256_ps\u2019 was not declared in this scope; did you mean \u2018_mm_castsi128_ps\u2019?\n   32 |     __m256 v_float = _mm_cvtusi2ss(_mm_castsi256_ps(v_high_16bits)); // Convert to float\n      |                                    ^~~~~~~~~~~~~~~~\n      |                                    _mm_castsi128_ps\n[REDACTED]/tmpbyesyk0i.cpp:32:22: error: \u2018_mm_cvtusi2ss\u2019 was not declared in this scope; did you mean \u2018_mm_cvt_si2ss\u2019?\n   32 |     __m256 v_float = _mm_cvtusi2ss(_mm_castsi256_ps(v_high_16bits)); // Convert to float\n      |                      ^~~~~~~~~~~~~\n      |                      _mm_cvt_si2ss\n[REDACTED]/tmpbyesyk0i.cpp:33:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   33 |     __m256 v_sqrt = _mm_sqrt_ss(v_float); // Take square root\n      |                                 ^~~~~~~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:158:21: note:   initializing argument 1 of \u2018__m128 _mm_sqrt_ss(__m128)\u2019\n  158 | _mm_sqrt_ss (__m128 __A)\n      |              ~~~~~~~^~~\n[REDACTED]/tmpbyesyk0i.cpp:34:22: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   34 |     _mm_storeu_ps(B, v_sqrt); // Store result\n      |                      ^~~~~~\n      |                      |\n      |                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_56_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgmpu22wn.cpp: In function \u2018void int_to_float_sqrt_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmpgmpu22wn.cpp:30:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |     __m256i v_A = _mm_loadu_si256((__m256i*)A);\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n[REDACTED]/tmpgmpu22wn.cpp:31:32: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   31 |     __m256 v_B = _mm_setzero_ps();\n      |                  ~~~~~~~~~~~~~~^~\n      |                                |\n      |                                __m128\n[REDACTED]/tmpgmpu22wn.cpp:34:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |     __m256 v_high_bits = _mm_srlv_epi16(v_A, _mm_set1_epi16(0xFFFF));\n      |                                         ^~~\n      |                                         |\n      |                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:67,\n                 from [REDACTED]/tmpgmpu22wn.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlbwintrin.h:4238:25: note:   initializing argument 1 of \u2018__m128i _mm_srlv_epi16(__m128i, __m128i)\u2019\n 4238 | _mm_srlv_epi16 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpgmpu22wn.cpp:35:35: error: cannot convert \u2018__m256\u2019 to \u2018__m128i\u2019\n   35 |     v_high_bits = _mm_cvtepi32_ps(v_high_bits);\n      |                                   ^~~~~~~~~~~\n      |                                   |\n      |                                   __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpgmpu22wn.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:812:26: note:   initializing argument 1 of \u2018__m128 _mm_cvtepi32_ps(__m128i)\u2019\n  812 | _mm_cvtepi32_ps (__m128i __A)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpgmpu22wn.cpp:38:23: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |     v_B = _mm_sqrt_ps(v_high_bits);\n      |                       ^~~~~~~~~~~\n      |                       |\n      |                       __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:214:21: note:   initializing argument 1 of \u2018__m128 _mm_sqrt_ps(__m128)\u2019\n  214 | _mm_sqrt_ps (__m128 __A)\n      |              ~~~~~~~^~~\n[REDACTED]/tmpgmpu22wn.cpp:41:22: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |     _mm_storeu_ps(B, v_B);\n      |                      ^~~\n      |                      |\n      |                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_56_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdk427a6m.cpp: In function \u2018void int_to_float_sqrt_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmpdk427a6m.cpp:30:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |     __m256i v_A = _mm_loadu_si256((__m256i*)A);\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n[REDACTED]/tmpdk427a6m.cpp:31:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   31 |     __m256i v_high_bits = _mm_srli_epi16(v_A, 16);\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpdk427a6m.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1249:25: note:   initializing argument 1 of \u2018__m128i _mm_srli_epi16(__m128i, int)\u2019\n 1249 | _mm_srli_epi16 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpdk427a6m.cpp:32:53: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   32 |     __m256 v_float = _mm_cvtusi2ss(_mm_packus_epi16(v_high_bits, v_high_bits));\n      |                                                     ^~~~~~~~~~~\n      |                                                     |\n      |                                                     __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1004:27: note:   initializing argument 1 of \u2018__m128i _mm_packus_epi16(__m128i, __m128i)\u2019\n 1004 | _mm_packus_epi16 (__m128i __A, __m128i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpdk427a6m.cpp:32:22: error: \u2018_mm_cvtusi2ss\u2019 was not declared in this scope; did you mean \u2018_mm_cvt_si2ss\u2019?\n   32 |     __m256 v_float = _mm_cvtusi2ss(_mm_packus_epi16(v_high_bits, v_high_bits));\n      |                      ^~~~~~~~~~~~~\n      |                      _mm_cvt_si2ss\n[REDACTED]/tmpdk427a6m.cpp:33:33: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   33 |     __m256 v_sqrt = _mm_sqrt_ps(v_float);\n      |                                 ^~~~~~~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:214:21: note:   initializing argument 1 of \u2018__m128 _mm_sqrt_ps(__m128)\u2019\n  214 | _mm_sqrt_ps (__m128 __A)\n      |              ~~~~~~~^~~\n[REDACTED]/tmpdk427a6m.cpp:34:22: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   34 |     _mm_storeu_ps(B, v_sqrt);\n      |                      ^~~~~~\n      |                      |\n      |                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_56_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_56_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp429xr920.cpp: In function \u2018void int_to_float_sqrt_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmp429xr920.cpp:30:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |     __m256i v_A = _mm_loadu_si256((__m256i*)A);\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n[REDACTED]/tmp429xr920.cpp:31:32: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   31 |     __m256 v_B = _mm_setzero_ps();\n      |                  ~~~~~~~~~~~~~~^~\n      |                                |\n      |                                __m128\n[REDACTED]/tmp429xr920.cpp:34:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |     __m256i v_high_bits = _mm_srli_epi16(v_A, 16);\n      |                                          ^~~\n      |                                          |\n      |                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp429xr920.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1249:25: note:   initializing argument 1 of \u2018__m128i _mm_srli_epi16(__m128i, int)\u2019\n 1249 | _mm_srli_epi16 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp429xr920.cpp:35:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |     __m256 v_floats = _mm_cvtepi32_ps(v_high_bits);\n      |                                       ^~~~~~~~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:812:26: note:   initializing argument 1 of \u2018__m128 _mm_cvtepi32_ps(__m128i)\u2019\n  812 | _mm_cvtepi32_ps (__m128i __A)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmp429xr920.cpp:38:28: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |     v_floats = _mm_sqrt_ps(v_floats);\n      |                            ^~~~~~~~\n      |                            |\n      |                            __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:214:21: note:   initializing argument 1 of \u2018__m128 _mm_sqrt_ps(__m128)\u2019\n  214 | _mm_sqrt_ps (__m128 __A)\n      |              ~~~~~~~^~~\n[REDACTED]/tmp429xr920.cpp:41:22: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |     _mm_storeu_ps(B, v_floats);\n      |                      ^~~~~~~~\n      |                      |\n      |                      __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_57_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_57_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbvc6obi8.cpp: In function \u2018void int_bits_to_float_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmpbvc6obi8.cpp:36:26: error: cannot convert \u2018__m128*\u2019 to \u2018float*\u2019\n   36 |         _mm256_storeu_ps((__m128*)(&B[i]), vB); // Store the result back to B\n      |                          ^~~~~~~~~~~~~~~~\n      |                          |\n      |                          __m128*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbvc6obi8.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_57_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpaa2jqwl_.cpp: In function \u2018void int_bits_to_float_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmpaa2jqwl_.cpp:28:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   28 |     __m256 vF = _mm256_cvtph_ps(vA); // Convert each uint32_t to a float\n      |                                 ^~\n      |                                 |\n      |                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:111,\n                 from [REDACTED]/tmpaa2jqwl_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/f16cintrin.h:52:26: note:   initializing argument 1 of \u2018__m256 _mm256_cvtph_ps(__m128i)\u2019\n   52 | _mm256_cvtph_ps (__m128i __A)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_57_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpokxw1xnj.cpp: In function \u2018void int_bits_to_float_simd(const uint32_t*, float*, size_t)\u2019:\n[REDACTED]/tmpokxw1xnj.cpp:34:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         vB = _mm256_cvtph_ps(vA, vB);\n      |                              ^~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:111,\n                 from [REDACTED]/tmpokxw1xnj.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/f16cintrin.h:52:26: note:   initializing argument 1 of \u2018__m256 _mm256_cvtph_ps(__m128i)\u2019\n   52 | _mm256_cvtph_ps (__m128i __A)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpokxw1xnj.cpp:40:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m128\u2019 in initialization\n   40 |         __m128 vA = _mm_loadu_si128((__m128i*)A);\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmpokxw1xnj.cpp:41:21: error: \u2018_mm256_castps_ps128\u2019 was not declared in this scope; did you mean \u2018_mm256_castps256_ps128\u2019?\n   41 |         __m128 vB = _mm256_castps_ps128(vB);\n      |                     ^~~~~~~~~~~~~~~~~~~\n      |                     _mm256_castps256_ps128\n[REDACTED]/tmpokxw1xnj.cpp:44:31: error: cannot convert \u2018__m128\u2019 to \u2018__m128i\u2019\n   44 |             vB = _mm_cvtph_ps(vA, vB);\n      |                               ^~\n      |                               |\n      |                               __m128\n/usr/lib/gcc/x86_64-linux-gnu/13/include/f16cintrin.h:46:23: note:   initializing argument 1 of \u2018__m128 _mm_cvtph_ps(__m128i)\u2019\n   46 | _mm_cvtph_ps (__m128i __A)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpokxw1xnj.cpp:45:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m128\u2019 in assignment\n   45 |             vA = _mm_loadu_si128((__m128i*)(A + 4));\n      |                  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpokxw1xnj.cpp:50:13: error: \u2018__m8\u2019 was not declared in this scope\n   50 |             __m8 vA = _mm_loadu_si8(A);\n      |             ^~~~\n[REDACTED]/tmpokxw1xnj.cpp:51:17: error: expected \u2018;\u2019 before \u2018vB\u2019\n   51 |             __m8 vB = _mm256_castps_ps8(vB);\n      |                 ^~~\n      |                 ;\n[REDACTED]/tmpokxw1xnj.cpp:54:35: error: cannot convert \u2018__m128\u2019 to \u2018__m128i\u2019\n   54 |                 vB = _mm_cvtph_ps(vA, vB);\n      |                                   ^~\n      |                                   |\n      |                                   __m128\n/usr/lib/gcc/x86_64-linux-gnu/13/include/f16cintrin.h:46:23: note:   initializing argument 1 of \u2018__m128 _mm_cvtph_ps(__m128i)\u2019\n   46 | _mm_cvtph_ps (__m128i __A)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpokxw1xnj.cpp:55:22: error: \u2018_mm_loadu_si8\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si64\u2019?\n   55 |                 vA = _mm_loadu_si8((const char*)(A + 2));\n      |                      ^~~~~~~~~~~~~\n      |                      _mm_loadu_si64\n[REDACTED]/tmpokxw1xnj.cpp:60:35: error: \u2018_mm_loadu_si8\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si64\u2019?\n   60 |                 vB = _mm_cvtph_ps(_mm_loadu_si8((const char*)(A)), vB);\n      |                                   ^~~~~~~~~~~~~\n      |                                   _mm_loadu_si64\n[REDACTED]/tmpokxw1xnj.cpp:65:22: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   65 |     _mm_storeu_ps(B, vB);\n      |                      ^~\n      |                      |\n      |                      __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpokxw1xnj.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:987:35: note:   initializing argument 2 of \u2018void _mm_storeu_ps(float*, __m128)\u2019\n  987 | _mm_storeu_ps (float *__P, __m128 __A)\n      |                            ~~~~~~~^~~\n"}
{"task_id": "SimdBench_57_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_58_AVX", "passed": false, "result": "runtime failed: malloc(): corrupted top size\n"}
{"task_id": "SimdBench_58_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpfyn0__yu.cpp: In function \u2018void conditional_diff_simd(const int32_t*, const bool*, float*, size_t)\u2019:\n[REDACTED]/tmpfyn0__yu.cpp:38:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   38 |             result = _mm256_and_ps(result, _mm256_castsi256_ps(mask));\n      |                                    ^~~~~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpfyn0__yu.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:172:23: note:   initializing argument 1 of \u2018__m256 _mm256_and_ps(__m256, __m256)\u2019\n  172 | _mm256_and_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_58_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpu0iiycwq.cpp: In function \u2018void conditional_diff_simd(const int32_t*, const bool*, float*, size_t)\u2019:\n[REDACTED]/tmpu0iiycwq.cpp:35:57: error: cannot convert \u2018const bool*\u2019 to \u2018__m256i\u2019\n   35 |         __m256i diff_mask = _mm256_and_si256(mask, cond + i);\n      |                                                    ~~~~~^~~\n      |                                                         |\n      |                                                         const bool*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpu0iiycwq.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:179:40: note:   initializing argument 2 of \u2018__m256i _mm256_and_si256(__m256i, __m256i)\u2019\n  179 | _mm256_and_si256 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpu0iiycwq.cpp:38:28: error: \u2018_mm256_cmpneq_ps\u2019 was not declared in this scope; did you mean \u2018_mm_cmpneq_ps\u2019?\n   38 |         __m256 zero_mask = _mm256_cmpneq_ps(diff_float, _mm256_setzero_ps());\n      |                            ^~~~~~~~~~~~~~~~\n      |                            _mm_cmpneq_ps\n[REDACTED]/tmpu0iiycwq.cpp:40:51: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   40 |         _mm256_storeu_si256((__m256i*)(diff + i), result);\n      |                                                   ^~~~~~\n      |                                                   |\n      |                                                   __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_58_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2zsemye6.cpp: In function \u2018void conditional_diff_simd(const int32_t*, const bool*, float*, size_t)\u2019:\n[REDACTED]/tmp2zsemye6.cpp:38:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   38 |             result = _mm256_and_ps(result, _mm256_castsi256_ps(mask));\n      |                                    ^~~~~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2zsemye6.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:172:23: note:   initializing argument 1 of \u2018__m256 _mm256_and_ps(__m256, __m256)\u2019\n  172 | _mm256_and_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_58_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp91qrgprj.cpp: In function \u2018void conditional_diff_simd(const int32_t*, const bool*, float*, size_t)\u2019:\n[REDACTED]/tmp91qrgprj.cpp:36:39: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   36 |         __m256i result = _mm256_sub_ps(_mm256_castsi256_ps(diff_mask), _mm256_castsi256_ps(prev));\n      |                          ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n[REDACTED]/tmp91qrgprj.cpp:39:39: error: too many arguments to function \u2018__m256 _mm256_setzero_ps()\u2019\n   39 |             result = _mm256_setzero_ps(result);\n      |                      ~~~~~~~~~~~~~~~~~^~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp91qrgprj.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1244:1: note: declared here\n 1244 | _mm256_setzero_ps (void)\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp91qrgprj.cpp:39:39: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in assignment\n   39 |             result = _mm256_setzero_ps(result);\n      |                      ~~~~~~~~~~~~~~~~~^~~~~~~~\n      |                                       |\n      |                                       __m256\n"}
{"task_id": "SimdBench_59_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_59_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_59_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp55e8hjn3.cpp:26:1: error: stray \u2018`\u2019 in program\n   26 | ```c\n      | ^\n[REDACTED]/tmp55e8hjn3.cpp:26:2: error: stray \u2018`\u2019 in program\n   26 | ```c\n      |  ^\n[REDACTED]/tmp55e8hjn3.cpp:26:3: error: stray \u2018`\u2019 in program\n   26 | ```c\n      |   ^\n[REDACTED]/tmp55e8hjn3.cpp:26:4: error: \u2018c\u2019 does not name a type\n   26 | ```c\n      |    ^\n"}
{"task_id": "SimdBench_59_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_59_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_60_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3x8vcnui.cpp: In function \u2018double indexed_sum_simd(const double*, const int16_t*, size_t)\u2019:\n[REDACTED]/tmp3x8vcnui.cpp:36:26: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   36 |         sum = _mm_add_sd(sum, _mm_load_sd(&vec[index[i]]));\n      |                          ^~~\n      |                          |\n      |                          __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp3x8vcnui.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:255:21: note:   initializing argument 1 of \u2018__m128d _mm_add_sd(__m128d, __m128d)\u2019\n  255 | _mm_add_sd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:69,\n                 from [REDACTED]/tmp3x8vcnui.cpp:16:\n[REDACTED]/tmp3x8vcnui.cpp:38:12: error: cannot convert \u2018__vector(2) double\u2019 to \u2018double\u2019 in return\n   38 |     return _mm256_extractf64x2_pd(sum, 0);\n      |            ^~~~~~~~~~~~~~~~~~~~~~\n      |            |\n      |            __vector(2) double\n"}
{"task_id": "SimdBench_60_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo5lfr9r8.cpp: In function \u2018double indexed_sum_simd(const double*, const int16_t*, size_t)\u2019:\n[REDACTED]/tmpo5lfr9r8.cpp:31:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m256d\u2019 in initialization\n   31 |         __m256d idx = _mm256_loadu_si256((__m256i*)(&index[i]));\n      |                       ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                                         |\n      |                                         __m256i\n[REDACTED]/tmpo5lfr9r8.cpp:32:54: error: invalid types \u2018const double*[double]\u2019 for array subscript\n   32 |         __m256d val = _mm256_loadu_pd((__m256d*)(&vec[idx[0]]));\n      |                                                      ^\n[REDACTED]/tmpo5lfr9r8.cpp:34:69: error: invalid types \u2018const double*[double]\u2019 for array subscript\n   34 |             val = _mm256_add_pd(val, _mm256_loadu_pd((__m256d*)(&vec[idx[1]])));\n      |                                                                     ^\n[REDACTED]/tmpo5lfr9r8.cpp:37:69: error: invalid types \u2018const double*[double]\u2019 for array subscript\n   37 |             val = _mm256_add_pd(val, _mm256_loadu_pd((__m256d*)(&vec[idx[2]])));\n      |                                                                     ^\n[REDACTED]/tmpo5lfr9r8.cpp:40:69: error: invalid types \u2018const double*[double]\u2019 for array subscript\n   40 |             val = _mm256_add_pd(val, _mm256_loadu_pd((__m256d*)(&vec[idx[3]])));\n      |                                                                     ^\n[REDACTED]/tmpo5lfr9r8.cpp:44:21: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   44 |     double result = _mm256_reduce_add_pd(sum);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_60_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_60_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp0jm7gr73.cpp: In function \u2018double indexed_sum_simd(const double*, const int16_t*, size_t)\u2019:\n[REDACTED]/tmp0jm7gr73.cpp:35:50: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019\n   35 |         __m256i mask_idx = _mm256_and_si256(idx, mask);\n      |                                                  ^~~~\n      |                                                  |\n      |                                                  __m128i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmp0jm7gr73.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:179:40: note:   initializing argument 2 of \u2018__m256i _mm256_and_si256(__m256i, __m256i)\u2019\n  179 | _mm256_and_si256 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp0jm7gr73.cpp:36:49: error: cannot convert \u2018__m256d\u2019 to \u2018const double*\u2019\n   36 |         __m256d selected_v = _mm256_maskload_pd(v, mask_idx);\n      |                                                 ^\n      |                                                 |\n      |                                                 __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:952:35: note:   initializing argument 1 of \u2018__m256d _mm256_maskload_pd(const double*, __m256i)\u2019\n  952 | _mm256_maskload_pd (double const *__P, __m256i __M)\n      |                     ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp0jm7gr73.cpp:41:26: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   41 |         sum = _mm_add_pd(sum, _mm_loadu_pd(&vec[index[i]]));\n      |                          ^~~\n      |                          |\n      |                          __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp0jm7gr73.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:249:21: note:   initializing argument 1 of \u2018__m128d _mm_add_pd(__m128d, __m128d)\u2019\n  249 | _mm_add_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmp0jm7gr73.cpp:44:12: error: \u2018_mm256_extractf64x4_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf64x2_pd\u2019?\n   44 |     return _mm256_extractf64x4_pd(sum, 0);\n      |            ^~~~~~~~~~~~~~~~~~~~~~\n      |            _mm256_extractf64x2_pd\n"}
{"task_id": "SimdBench_60_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpojn2qrji.cpp: In function \u2018double indexed_sum_simd(const double*, const int16_t*, size_t)\u2019:\n[REDACTED]/tmpojn2qrji.cpp:47:17: error: redeclaration of \u2018__m256d i\u2019\n   47 |         __m256d i = _mm256_loadu_pd(&vec[index[i + 13]]);\n      |                 ^\n[REDACTED]/tmpojn2qrji.cpp:33:17: note: \u2018size_t i\u2019 previously declared here\n   33 |     for (size_t i = 0; i < length; i += 32) {\n      |                 ^\n[REDACTED]/tmpojn2qrji.cpp:47:47: error: invalid types \u2018const int16_t* {aka const short int*}[__m256d]\u2019 for array subscript\n   47 |         __m256d i = _mm256_loadu_pd(&vec[index[i + 13]]);\n      |                                               ^\n[REDACTED]/tmpojn2qrji.cpp:48:47: error: invalid types \u2018const int16_t* {aka const short int*}[__m256d]\u2019 for array subscript\n   48 |         __m256d j = _mm256_loadu_pd(&vec[index[i + 14]]);\n      |                                               ^\n[REDACTED]/tmpojn2qrji.cpp:49:47: error: invalid types \u2018const int16_t* {aka const short int*}[__m256d]\u2019 for array subscript\n   49 |         __m256d k = _mm256_loadu_pd(&vec[index[i + 15]]);\n      |                                               ^\n[REDACTED]/tmpojn2qrji.cpp:50:47: error: too few arguments to function \u2018__m256d _mm256_add_pd(__m256d, __m256d)\u2019\n   50 |         sum = _mm256_add_pd(sum, _mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(v, w), x), y), z), a));\n      |                                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpojn2qrji.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:141:1: note: declared here\n  141 | _mm256_add_pd (__m256d __A, __m256d __B)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmpojn2qrji.cpp:51:47: error: too few arguments to function \u2018__m256d _mm256_add_pd(__m256d, __m256d)\u2019\n   51 |         sum = _mm256_add_pd(sum, _mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(b, c), d), e), f), g)));\n      |                                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:141:1: note: declared here\n  141 | _mm256_add_pd (__m256d __A, __m256d __B)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmpojn2qrji.cpp:52:133: error: \u2018l\u2019 was not declared in this scope\n   52 |         sum = _mm256_add_pd(sum, _mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(_mm256_add_pd(h, i), j), k), l))));\n      |                                                                                                                                     ^\n[REDACTED]/tmpojn2qrji.cpp:54:12: error: \u2018i\u2019 was not declared in this scope\n   54 |     for (; i < length; ++i) {\n      |            ^\n"}
{"task_id": "SimdBench_61_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_61_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzqxoaid3.cpp: In function \u2018void simple_conv2d_simd(const double*, const double*, double*, size_t, size_t)\u2019:\n[REDACTED]/tmpzqxoaid3.cpp:58:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   58 |             __m256 mul_result = _mm256_mul_ps(input_row, input_next_row);\n      |                                               ^~~~~~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpzqxoaid3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpzqxoaid3.cpp:61:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   61 |             output_col = _mm256_add_ps(output_col, mul_result);\n      |                                        ^~~~~~~~~~\n      |                                        |\n      |                                        __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_61_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpst_2hmv3.cpp: In function \u2018void simple_conv2d_simd(const double*, const double*, double*, size_t, size_t)\u2019:\n[REDACTED]/tmpst_2hmv3.cpp:59:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   59 |         __m256 conv_result = _mm256_mul_ps(input_vec, kernel_vec);\n      |                                            ^~~~~~~~~\n      |                                            |\n      |                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpst_2hmv3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpst_2hmv3.cpp:62:53: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   62 |         _mm256_storeu_si256((__m256i*)(output + i), conv_result);\n      |                                                     ^~~~~~~~~~~\n      |                                                     |\n      |                                                     __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_61_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpawmvw9rt.cpp: In function \u2018void simple_conv2d_simd(const double*, const double*, double*, size_t, size_t)\u2019:\n[REDACTED]/tmpawmvw9rt.cpp:54:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   54 |     __m256 sum = _mm256_hadd_epi32(product, product);\n      |                  ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                   |\n      |                                   __m256i\n[REDACTED]/tmpawmvw9rt.cpp:57:43: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   57 |     _mm256_storeu_si256((__m256i*)output, sum);\n      |                                           ^~~\n      |                                           |\n      |                                           __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpawmvw9rt.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n[REDACTED]/tmpawmvw9rt.cpp:64:20: error: \u2018input_end\u2019 was not declared in this scope; did you mean \u2018input_row\u2019?\n   64 |     while (input < input_end && kernel < kernel_end) {\n      |                    ^~~~~~~~~\n      |                    input_row\n[REDACTED]/tmpawmvw9rt.cpp:64:42: error: \u2018kernel_end\u2019 was not declared in this scope; did you mean \u2018kernel_row\u2019?\n   64 |     while (input < input_end && kernel < kernel_end) {\n      |                                          ^~~~~~~~~~\n      |                                          kernel_row\n[REDACTED]/tmpawmvw9rt.cpp:75:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in assignment\n   75 |         sum = _mm256_hadd_epi32(product, product);\n      |               ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __m256i\n[REDACTED]/tmpawmvw9rt.cpp:78:47: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   78 |         _mm256_storeu_si256((__m256i*)output, sum);\n      |                                               ^~~\n      |                                               |\n      |                                               __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:46: note:   initializing argument 2 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                                      ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_61_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_62_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqmigru54.cpp: In function \u2018bool has_close_elements_simd(const std::vector<double>&, double)\u2019:\n[REDACTED]/tmpqmigru54.cpp:35:39: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   35 |     __m256d threshold_vec = _mm_set_pd(threshold);\n      |                             ~~~~~~~~~~^~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpqmigru54.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmpqmigru54.cpp:38:32: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   38 |     __m256d vec1 = _mm_loadu_pd(numbers.data());\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n      |                                |\n      |                                __m128d\n[REDACTED]/tmpqmigru54.cpp:41:31: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   41 |     __m256d diff = _mm_sub_pd(vec1, threshold_vec);\n      |                               ^~~~\n      |                               |\n      |                               __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:261:21: note:   initializing argument 1 of \u2018__m128d _mm_sub_pd(__m128d, __m128d)\u2019\n  261 | _mm_sub_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpqmigru54.cpp:42:33: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   42 |     __m256d mask = _mm_cmpgt_pd(diff, _mm_setzero_pd());\n      |                                 ^~~~\n      |                                 |\n      |                                 __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpqmigru54.cpp:43:38: error: cannot convert \u2018__m256d\u2019 to \u2018__m128\u2019\n   43 |     __m256d result = _mm_movemask_ps(mask);\n      |                                      ^~~~\n      |                                      |\n      |                                      __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpqmigru54.cpp:16:\n[REDACTED]/tmpqmigru54.cpp:46:30: error: cannot convert \u2018__m256d\u2019 to \u2018__m128i\u2019\n   46 |     return _mm_test_all_ones(result);\n      |                              ^\n      |                              |\n      |                              __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_62_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpk4tnf42v.cpp: In function \u2018bool has_close_elements_simd(const std::vector<double>&, double)\u2019:\n[REDACTED]/tmpk4tnf42v.cpp:35:39: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   35 |     __m256d threshold_vec = _mm_set_pd(threshold);\n      |                             ~~~~~~~~~~^~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpk4tnf42v.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmpk4tnf42v.cpp:38:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   38 |         __m256d vec1 = _mm_loadu_pd(numbers.data() + i);\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpk4tnf42v.cpp:39:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   39 |         __m256d vec2 = _mm_loadu_pd(numbers.data() + i + 4);\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpk4tnf42v.cpp:41:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   41 |         __m256d diff = _mm_sub_pd(vec1, vec2);\n      |                                   ^~~~\n      |                                   |\n      |                                   __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:261:21: note:   initializing argument 1 of \u2018__m128d _mm_sub_pd(__m128d, __m128d)\u2019\n  261 | _mm_sub_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpk4tnf42v.cpp:42:28: error: \u2018_mm_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   42 |         __m256d abs_diff = _mm_abs_pd(diff);\n      |                            ^~~~~~~~~~\n      |                            _mm_abs_ph\n[REDACTED]/tmpk4tnf42v.cpp:44:37: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   44 |         __m256d mask = _mm_cmpgt_pd(abs_diff, threshold_vec);\n      |                                     ^~~~~~~~\n      |                                     |\n      |                                     __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpk4tnf42v.cpp:45:42: error: cannot convert \u2018__m256d\u2019 to \u2018__m128\u2019\n   45 |         __m256d result = _mm_movemask_ps(mask);\n      |                                          ^~~~\n      |                                          |\n      |                                          __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpk4tnf42v.cpp:16:\n[REDACTED]/tmpk4tnf42v.cpp:47:31: error: cannot convert \u2018__m256d\u2019 to \u2018__m128i\u2019\n   47 |         if (_mm_test_all_ones(result)) {\n      |                               ^\n      |                               |\n      |                               __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_62_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbm7x20ng.cpp: In function \u2018bool has_close_elements_simd(const std::vector<double>&, double)\u2019:\n[REDACTED]/tmpbm7x20ng.cpp:35:39: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   35 |     __m256d threshold_vec = _mm_set_pd(threshold);\n      |                             ~~~~~~~~~~^~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpbm7x20ng.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmpbm7x20ng.cpp:38:34: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   38 |     __m256d mask = _mm_setzero_pd();\n      |                    ~~~~~~~~~~~~~~^~\n      |                                  |\n      |                                  __m128d\n[REDACTED]/tmpbm7x20ng.cpp:41:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   41 |         __m256d vec1 = _mm_loadu_pd(numbers.data() + i);\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpbm7x20ng.cpp:42:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   42 |         __m256d vec2 = _mm_loadu_pd(numbers.data() + i + 4);\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpbm7x20ng.cpp:45:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   45 |         __m256d diff = _mm_sub_pd(vec1, vec2);\n      |                                   ^~~~\n      |                                   |\n      |                                   __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:261:21: note:   initializing argument 1 of \u2018__m128d _mm_sub_pd(__m128d, __m128d)\u2019\n  261 | _mm_sub_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpbm7x20ng.cpp:48:28: error: \u2018_mm_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   48 |         __m256d abs_diff = _mm_abs_pd(diff);\n      |                            ^~~~~~~~~~\n      |                            _mm_abs_ph\n[REDACTED]/tmpbm7x20ng.cpp:49:43: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   49 |         __m256d cmp_result = _mm_cmpgt_pd(abs_diff, threshold_vec);\n      |                                           ^~~~~~~~\n      |                                           |\n      |                                           __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:377:23: note:   initializing argument 1 of \u2018__m128d _mm_cmpgt_pd(__m128d, __m128d)\u2019\n  377 | _mm_cmpgt_pd (__m128d __A, __m128d __B)\n      |               ~~~~~~~~^~~\n[REDACTED]/tmpbm7x20ng.cpp:52:26: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   52 |         mask = _mm_or_pd(mask, cmp_result);\n      |                          ^~~~\n      |                          |\n      |                          __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:347:20: note:   initializing argument 1 of \u2018__m128d _mm_or_pd(__m128d, __m128d)\u2019\n  347 | _mm_or_pd (__m128d __A, __m128d __B)\n      |            ~~~~~~~~^~~\n[REDACTED]/tmpbm7x20ng.cpp:56:28: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   56 |     return _mm_movemask_pd(mask) != 0;\n      |                            ^~~~\n      |                            |\n      |                            __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:986:26: note:   initializing argument 1 of \u2018int _mm_movemask_pd(__m128d)\u2019\n  986 | _mm_movemask_pd (__m128d __A)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_62_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo_iu9__j.cpp: In function \u2018bool has_close_elements_simd(const std::vector<double>&, double)\u2019:\n[REDACTED]/tmpo_iu9__j.cpp:35:39: error: too few arguments to function \u2018__m128d _mm_set_pd(double, double)\u2019\n   35 |     __m256d threshold_vec = _mm_set_pd(threshold);\n      |                             ~~~~~~~~~~^~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpo_iu9__j.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:86:1: note: declared here\n   86 | _mm_set_pd (double __W, double __X)\n      | ^~~~~~~~~~\n[REDACTED]/tmpo_iu9__j.cpp:38:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   38 |         __m256d vec1 = _mm_loadu_pd(numbers.data() + i);\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpo_iu9__j.cpp:39:36: error: cannot convert \u2018__m128d\u2019 to \u2018__m256d\u2019 in initialization\n   39 |         __m256d vec2 = _mm_loadu_pd(numbers.data() + i + 4);\n      |                        ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m128d\n[REDACTED]/tmpo_iu9__j.cpp:41:35: error: cannot convert \u2018__m256d\u2019 to \u2018__m128d\u2019\n   41 |         __m256d diff = _mm_sub_pd(vec1, vec2);\n      |                                   ^~~~\n      |                                   |\n      |                                   __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:261:21: note:   initializing argument 1 of \u2018__m128d _mm_sub_pd(__m128d, __m128d)\u2019\n  261 | _mm_sub_pd (__m128d __A, __m128d __B)\n      |             ~~~~~~~~^~~\n[REDACTED]/tmpo_iu9__j.cpp:42:28: error: \u2018_mm_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   42 |         __m256d abs_diff = _mm_abs_pd(diff);\n      |                            ^~~~~~~~~~\n      |                            _mm_abs_ph\n[REDACTED]/tmpo_iu9__j.cpp:44:24: error: \u2018_mm_cmpne_pd\u2019 was not declared in this scope; did you mean \u2018_mm_cmpnle_pd\u2019?\n   44 |         __m256d mask = _mm_cmpne_pd(abs_diff, threshold_vec, _CMP_LT_OQ);\n      |                        ^~~~~~~~~~~~\n      |                        _mm_cmpnle_pd\n[REDACTED]/tmpo_iu9__j.cpp:45:42: error: cannot convert \u2018__m256d\u2019 to \u2018__m128\u2019\n   45 |         __m256d result = _mm_movemask_ps(mask);\n      |                                          ^~~~\n      |                                          |\n      |                                          __m256d\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpo_iu9__j.cpp:16:\n[REDACTED]/tmpo_iu9__j.cpp:47:31: error: cannot convert \u2018__m256d\u2019 to \u2018__m128i\u2019\n   47 |         if (_mm_test_all_ones(result)) {\n      |                               ^\n      |                               |\n      |                               __m256d\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_62_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpfm4ejgxx.cpp: In function \u2018bool has_close_elements_simd(const std::vector<double>&, double)\u2019:\n[REDACTED]/tmpfm4ejgxx.cpp:35:39: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   35 |     __m256 threshold_vec = _mm_set1_ps(threshold);\n      |                            ~~~~~~~~~~~^~~~~~~~~~~\n      |                                       |\n      |                                       __m128\n[REDACTED]/tmpfm4ejgxx.cpp:38:36: error: cannot convert \u2018const __gnu_cxx::__alloc_traits<std::allocator<double>, double>::value_type*\u2019 {aka \u2018const double*\u2019} to \u2018const float*\u2019\n   38 |         __m256 vec1 = _mm_loadu_ps(&numbers[i]);\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpfm4ejgxx.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpfm4ejgxx.cpp:39:36: error: cannot convert \u2018const __gnu_cxx::__alloc_traits<std::allocator<double>, double>::value_type*\u2019 {aka \u2018const double*\u2019} to \u2018const float*\u2019\n   39 |         __m256 vec2 = _mm_loadu_ps(&numbers[i + 4]);\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:938:28: note:   initializing argument 1 of \u2018__m128 _mm_loadu_ps(const float*)\u2019\n  938 | _mm_loadu_ps (float const *__P)\n      |               ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpfm4ejgxx.cpp:41:34: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   41 |         __m256 diff = _mm_sub_ps(vec1, vec2);\n      |                                  ^~~~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:196:20: note:   initializing argument 1 of \u2018__m128 _mm_sub_ps(__m128, __m128)\u2019\n  196 | _mm_sub_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpfm4ejgxx.cpp:42:27: error: \u2018_mm_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm_abs_ph\u2019?\n   42 |         __m256 abs_diff = _mm_abs_ps(diff);\n      |                           ^~~~~~~~~~\n      |                           _mm_abs_ph\n[REDACTED]/tmpfm4ejgxx.cpp:44:50: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         __m256 close_to_threshold = _mm_cmpgt_ps(abs_diff, threshold_vec);\n      |                                                  ^~~~~~~~\n      |                                                  |\n      |                                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpfm4ejgxx.cpp:45:39: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   45 |         __m256 all_close = _mm_and_ps(close_to_threshold, close_to_threshold);\n      |                                       ^~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpfm4ejgxx.cpp:47:28: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   47 |         if(_mm_movemask_ps(all_close) != 0){\n      |                            ^~~~~~~~~\n      |                            |\n      |                            __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\n"}
{"task_id": "SimdBench_63_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_63_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_63_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzfhxfg24.cpp: In function \u2018bool below_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpzfhxfg24.cpp:45:42: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   45 |     __m256i result = _mm256_movemask_epi8(mask);\n      |                      ~~~~~~~~~~~~~~~~~~~~^~~~~~\n      |                                          |\n      |                                          int\n[REDACTED]/tmpzfhxfg24.cpp:48:27: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   48 |     return _mm_popcnt_u32(result) != 0;\n      |                           ^~~~~~\n      |                           |\n      |                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/x86gprintrin.h:73,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:27,\n                 from [REDACTED]/tmpzfhxfg24.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/popcntintrin.h:35:30: note:   initializing argument 1 of \u2018int _mm_popcnt_u32(unsigned int)\u2019\n   35 | _mm_popcnt_u32 (unsigned int __X)\n      |                 ~~~~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_63_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7pjcuwep.cpp: In function \u2018bool below_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp7pjcuwep.cpp:38:18: error: \u2018_mm256_movemask_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_movemask_epi8\u2019?\n   38 |     int result = _mm256_movemask_epi32(_mm256_cmpgt_epi32(sum, _mm256_setzero_si256()));\n      |                  ^~~~~~~~~~~~~~~~~~~~~\n      |                  _mm256_movemask_epi8\n"}
{"task_id": "SimdBench_63_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8yclnwed.cpp:16:\n[REDACTED]/tmp8yclnwed.cpp: In function \u2018bool below_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp8yclnwed.cpp:41:34: error: cannot convert a value of type \u2018__m128i\u2019 to vector type \u2018__m256i\u2019 which has different size\n   41 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 0));\n      |                                  ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8yclnwed.cpp:41:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 0));\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp8yclnwed.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp8yclnwed.cpp:42:34: error: cannot convert a value of type \u2018__m128i\u2019 to vector type \u2018__m256i\u2019 which has different size\n   42 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 1));\n      |                                  ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8yclnwed.cpp:42:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 1));\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp8yclnwed.cpp:43:34: error: cannot convert a value of type \u2018__m128i\u2019 to vector type \u2018__m256i\u2019 which has different size\n   43 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 2));\n      |                                  ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8yclnwed.cpp:43:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 2));\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp8yclnwed.cpp:44:34: error: cannot convert a value of type \u2018__m128i\u2019 to vector type \u2018__m256i\u2019 which has different size\n   44 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 3));\n      |                                  ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8yclnwed.cpp:44:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |         sum = _mm_add_epi32(sum, _mm256_extract_epi32(last_sum, 3));\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp8yclnwed.cpp:46:51: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   46 |     return _mm_movemask_epi8(_mm_cmpgt_epi32(sum, _mm_setzero_si256())) != 0;\n      |                                                   ^~~~~~~~~~~~~~~~~\n      |                                                   _mm_setzero_si64\n"}
{"task_id": "SimdBench_64_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpn4su4x73.cpp: In function \u2018double mean_absolute_deviation_simd(std::vector<double>)\u2019:\n[REDACTED]/tmpn4su4x73.cpp:33:35: error: cannot convert \u2018__m256d\u2019 to \u2018double\u2019 in initialization\n   33 |     double sum = _mm256_setzero_pd();\n      |                  ~~~~~~~~~~~~~~~~~^~\n      |                                   |\n      |                                   __m256d\n[REDACTED]/tmpn4su4x73.cpp:34:36: error: cannot convert \u2018__m256d\u2019 to \u2018double\u2019 in initialization\n   34 |     double mean = _mm256_setzero_pd();\n      |                   ~~~~~~~~~~~~~~~~~^~\n      |                                    |\n      |                                    __m256d\n[REDACTED]/tmpn4su4x73.cpp:37:33: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |     __m256i i = _mm256_set_epi32(0, 1, 2, 3);\n      |                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpn4su4x73.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpn4su4x73.cpp:38:33: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     for (; i != _mm256_set_epi32(num_elements / 4, num_elements / 4 + 1, num_elements / 4 + 2, num_elements / 4 + 3); ++i) {\n      |                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpn4su4x73.cpp:39:44: error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<double>\u2019 and \u2018__m256i\u2019)\n   39 |         __m256 v = _mm256_loadu_ps(&numbers[i]);\n      |                                            ^\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmpn4su4x73.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:1126:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](size_type) [with _Tp = double; _Alloc = std::allocator<double>; reference = double&; size_type = long unsigned int]\u2019\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1126:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<double>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/usr/include/c++/13/bits/stl_vector.h:1145:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](size_type) const [with _Tp = double; _Alloc = std::allocator<double>; const_reference = const double&; size_type = long unsigned int]\u2019\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1145:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<double>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n[REDACTED]/tmpn4su4x73.cpp:40:30: error: cannot convert \u2018double\u2019 to \u2018__m256d\u2019\n   40 |         sum += _mm256_add_pd(sum, v);\n      |                              ^~~\n      |                              |\n      |                              double\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:141:24: note:   initializing argument 1 of \u2018__m256d _mm256_add_pd(__m256d, __m256d)\u2019\n  141 | _mm256_add_pd (__m256d __A, __m256d __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpn4su4x73.cpp:46:36: error: cannot convert \u2018__gnu_cxx::__alloc_traits<std::allocator<double>, double>::value_type*\u2019 {aka \u2018double*\u2019} to \u2018const float*\u2019\n   46 |         __m256 v = _mm256_loadu_ps(&numbers[num_elements - remaining_elements]);\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpn4su4x73.cpp:47:30: error: cannot convert \u2018double\u2019 to \u2018__m256d\u2019\n   47 |         sum += _mm256_add_pd(sum, v);\n      |                              ^~~\n      |                              |\n      |                              double\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:141:24: note:   initializing argument 1 of \u2018__m256d _mm256_add_pd(__m256d, __m256d)\u2019\n  141 | _mm256_add_pd (__m256d __A, __m256d __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpn4su4x73.cpp:51:26: error: cannot convert \u2018double\u2019 to \u2018__m256d\u2019\n   51 |     mean = _mm256_div_pd(sum, _mm256_set1_pd(static_cast<double>(num_elements)));\n      |                          ^~~\n      |                          |\n      |                          double\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:235:24: note:   initializing argument 1 of \u2018__m256d _mm256_div_pd(__m256d, __m256d)\u2019\n  235 | _mm256_div_pd (__m256d __A, __m256d __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpn4su4x73.cpp:54:54: error: cannot convert \u2018double*\u2019 to \u2018__m256d\u2019\n   54 |     __m256 squared_diffs = _mm256_sub_pd(numbers.data(), mean);\n      |                                          ~~~~~~~~~~~~^~\n      |                                                      |\n      |                                                      double*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:360:24: note:   initializing argument 1 of \u2018__m256d _mm256_sub_pd(__m256d, __m256d)\u2019\n  360 | _mm256_sub_pd (__m256d __A, __m256d __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpn4su4x73.cpp:57:11: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   57 |     sum = _mm256_reduce_add_pd(squared_diffs);\n      |           ^~~~~~~~~~~~~~~~~~~~\n      |           _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_64_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmps_26pil2.cpp: In function \u2018double mean_absolute_deviation_simd(std::vector<double>)\u2019:\n[REDACTED]/tmps_26pil2.cpp:46:24: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   46 |     double total_sum = _mm256_reduce_add_pd(sum);\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n[REDACTED]/tmps_26pil2.cpp:49:43: error: \u2018current_number\u2019 was not declared in this scope\n   49 |     __m256d squared_diffs = _mm256_sub_pd(current_number, mean);\n      |                                           ^~~~~~~~~~~~~~\n[REDACTED]/tmps_26pil2.cpp:52:27: error: no matching function for call to \u2018sqrt(__m256d)\u2019\n   52 |     double mad = std::sqrt(squared_diffs_sum / num_elements);\n      |                  ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from [REDACTED]/tmps_26pil2.cpp:11:\n/usr/include/c++/13/cmath:450:5: note: candidate: \u2018template<class _Tp> constexpr typename __gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, double>::__type std::sqrt(_Tp)\u2019\n  450 |     sqrt(_Tp __x)\n      |     ^~~~\n/usr/include/c++/13/cmath:450:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/cmath: In substitution of \u2018template<class _Tp> constexpr typename __gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, double>::__type std::sqrt(_Tp) [with _Tp = __vector(4) double]\u2019:\n[REDACTED]/tmps_26pil2.cpp:52:27:   required from here\n/usr/include/c++/13/cmath:450:5: error: no type named \u2018__type\u2019 in \u2018struct __gnu_cxx::__enable_if<false, double>\u2019\nIn file included from /usr/include/features.h:502,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h:39,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h:679,\n                 from /usr/include/c++/13/bits/requires_hosted.h:31,\n                 from /usr/include/c++/13/iostream:38,\n                 from [REDACTED]/tmps_26pil2.cpp:1:\n/usr/include/x86_64-linux-gnu/bits/mathcalls.h:143:1: note: candidate: \u2018double sqrt(double)\u2019\n  143 | __MATHCALL (sqrt,, (_Mdouble_ __x));\n      | ^~~~~~~~~~\nIn file included from /usr/include/c++/13/cmath:47:\n/usr/include/x86_64-linux-gnu/bits/mathcalls.h:143:1: note:   no known conversion for argument 1 from \u2018__m256d\u2019 to \u2018double\u2019\n  143 | __MATHCALL (sqrt,, (_Mdouble_ __x));\n      | ^\n/usr/include/c++/13/cmath:438:3: note: candidate: \u2018constexpr float std::sqrt(float)\u2019\n  438 |   sqrt(float __x)\n      |   ^~~~\n/usr/include/c++/13/cmath:438:14: note:   no known conversion for argument 1 from \u2018__m256d\u2019 to \u2018float\u2019\n  438 |   sqrt(float __x)\n      |        ~~~~~~^~~\n/usr/include/c++/13/cmath:442:3: note: candidate: \u2018constexpr long double std::sqrt(long double)\u2019\n  442 |   sqrt(long double __x)\n      |   ^~~~\n/usr/include/c++/13/cmath:442:20: note:   no known conversion for argument 1 from \u2018__m256d\u2019 to \u2018long double\u2019\n  442 |   sqrt(long double __x)\n      |        ~~~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_64_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpu338xeli.cpp: In function \u2018double mean_absolute_deviation_simd(std::vector<double>)\u2019:\n[REDACTED]/tmpu338xeli.cpp:46:24: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   46 |     double total_sum = _mm256_reduce_add_ps(sum);\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n[REDACTED]/tmpu338xeli.cpp:51:19: error: \u2018_mm256_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   51 |     __m256d mad = _mm256_abs_pd(diff);\n      |                   ^~~~~~~~~~~~~\n      |                   _mm256_abs_ph\n"}
{"task_id": "SimdBench_64_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpznd64641.cpp: In function \u2018double mean_absolute_deviation_simd(std::vector<double>)\u2019:\n[REDACTED]/tmpznd64641.cpp:52:28: error: \u2018_mm256_abs_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   52 |         __m256d abs_diff = _mm256_abs_pd(diff);\n      |                            ^~~~~~~~~~~~~\n      |                            _mm256_abs_ph\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:69,\n                 from [REDACTED]/tmpznd64641.cpp:16:\n[REDACTED]/tmpznd64641.cpp:65:15: error: cannot convert \u2018__vector(2) double\u2019 to \u2018__m256d\u2019 in assignment\n   65 |     mad_sum = _mm256_extractf64x2_pd(mad_sum, 0);\n      |               ^~~~~~~~~~~~~~~~~~~~~~\n      |               |\n      |               __vector(2) double\n[REDACTED]/tmpznd64641.cpp:67:12: error: cannot convert \u2018__m256d\u2019 to \u2018double\u2019 in return\n   67 |     return mad_sum;\n      |            ^~~~~~~\n      |            |\n      |            __m256d\n"}
{"task_id": "SimdBench_64_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3l1epm8p.cpp: In function \u2018double mean_absolute_deviation_simd(std::vector<double>)\u2019:\n[REDACTED]/tmp3l1epm8p.cpp:41:24: error: \u2018_mm256_reduce_add_pd\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   41 |     double total_sum = _mm256_reduce_add_pd(sum);\n      |                        ^~~~~~~~~~~~~~~~~~~~\n      |                        _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_65_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpty8gft82.cpp:35:1: error: stray \u2018`\u2019 in program\n   35 | ```cpp\n      | ^\n[REDACTED]/tmpty8gft82.cpp:35:2: error: stray \u2018`\u2019 in program\n   35 | ```cpp\n      |  ^\n[REDACTED]/tmpty8gft82.cpp:35:3: error: stray \u2018`\u2019 in program\n   35 | ```cpp\n      |   ^\n[REDACTED]/tmpty8gft82.cpp:50: warning: missing terminating ' character\n   50 |         __m256i result_vec = _mm_shuffle_epi32(combined, combined, 0b0000'0000'0000'00'0000'00'0000'00'0000'00'00000'0000'00'0000'0000'0000'00'0000'00'0000'0000'00'0000'00'0000'00'0000'0000'0000'0000'0000'0000'00'0000'00'0000'00'0000'00'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'00'0000'00'0000'00'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'00'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'00'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'\n      | \n[REDACTED]/tmpty8gft82.cpp:83:2: error: unterminated argument list invoking macro \"_mm_shuffle_epi32\"\n   83 | }\n      |  ^\n[REDACTED]/tmpty8gft82.cpp:35:4: error: \u2018cpp\u2019 does not name a type\n   35 | ```cpp\n      |    ^~~\n"}
{"task_id": "SimdBench_65_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7ztpsz1b.cpp: In function \u2018std::vector<int> intersperse_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmp7ztpsz1b.cpp:42:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i del = _mm_set_epi32(delimeter, delimeter, delimeter, delimeter);\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmp7ztpsz1b.cpp:45:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   45 |         __m256i vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&numbers[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp7ztpsz1b.cpp:46:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   46 |         __m256i result_vec = _mm_add_epi32(vec, del);\n      |                                            ^~~\n      |                                            |\n      |                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp7ztpsz1b.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp7ztpsz1b.cpp:47:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   47 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(&result), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmp7ztpsz1b.cpp:53:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   53 |         __m256i vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&numbers[numbers.size() - remaining_elements]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp7ztpsz1b.cpp:54:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   54 |         __m256i result_vec = _mm_add_epi32(vec, del);\n      |                                            ^~~\n      |                                            |\n      |                                            __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp7ztpsz1b.cpp:55:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   55 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(&result), result_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_65_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxrp3cmls.cpp: In function \u2018std::vector<int> intersperse_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpxrp3cmls.cpp:54:68: error: cannot convert \u2018__m256i\u2019 to \u2018long long int\u2019 in assignment\n   54 |         vec_ptr[word_index >> 3][word_index & 7] = _mm256_set_epi32(\n      |                                                    ~~~~~~~~~~~~~~~~^\n      |                                                                    |\n      |                                                                    __m256i\n   55 |             numbers[i], numbers[i], numbers[i], numbers[i],\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~         \n   56 |             numbers[i], numbers[i], numbers[i], numbers[i]\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          \n   57 |         );\n      |         ~                                                           \nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpxrp3cmls.cpp:16:\n[REDACTED]/tmpxrp3cmls.cpp:65:30: error: cannot convert a value of type \u2018long long int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   65 |             result.push_back(_mm256_extract_epi32(vec_ptr[i][j], 0));\n      |                              ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_65_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp323jrbhi.cpp: In function \u2018std::vector<int> intersperse_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmp323jrbhi.cpp:43:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   43 |     __m256i del = _mm_set_epi32(delimeter, delimeter, delimeter, delimeter);\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmp323jrbhi.cpp:50:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   50 |         _mm_storeu_si256(ptr, *next_ptr);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_65_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_37q1gvm.cpp: In function \u2018std::vector<int> intersperse_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmp_37q1gvm.cpp:42:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i del = _mm_set_epi32(delimeter, delimeter, delimeter, delimeter);\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmp_37q1gvm.cpp:43:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   43 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp_37q1gvm.cpp:46:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   46 |         __m256i vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&numbers[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp_37q1gvm.cpp:47:30: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   47 |         __m256i masked_vec = _mm_and_si256(vec, mask);\n      |                              ^~~~~~~~~~~~~\n      |                              _mm_and_si64\n[REDACTED]/tmp_37q1gvm.cpp:48:46: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |         __m256i shifted_vec = _mm_slli_epi32(masked_vec, 2);\n      |                                              ^~~~~~~~~~\n      |                                              |\n      |                                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_37q1gvm.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1190:25: note:   initializing argument 1 of \u2018__m128i _mm_slli_epi32(__m128i, int)\u2019\n 1190 | _mm_slli_epi32 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp_37q1gvm.cpp:49:32: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   49 |         __m256i combined_vec = _mm_or_si256(shifted_vec, vec);\n      |                                ^~~~~~~~~~~~\n      |                                _mm_or_si64\n[REDACTED]/tmp_37q1gvm.cpp:50:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   50 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(&result), combined_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_66_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpynz7an09.cpp: In function \u2018std::vector<long int> sum_product_simd(std::vector<short int>)\u2019:\n[REDACTED]/tmpynz7an09.cpp:40:27: error: \u2018_mm256_setone_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_store_si256\u2019?\n   40 |     __m256i vec_product = _mm256_setone_si256();\n      |                           ^~~~~~~~~~~~~~~~~~~\n      |                           _mm256_store_si256\n[REDACTED]/tmpynz7an09.cpp:55:27: error: \u2018_mm256_extractf128_si128\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf128_si256\u2019?\n   55 |     __m128i reduced_sum = _mm256_extractf128_si128(vec_sum, 0);\n      |                           ^~~~~~~~~~~~~~~~~~~~~~~~\n      |                           _mm256_extractf128_si256\n"}
{"task_id": "SimdBench_66_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpaikvs_so.cpp: In function \u2018std::vector<long int> sum_product_simd(std::vector<short int>)\u2019:\n[REDACTED]/tmpaikvs_so.cpp:40:27: error: \u2018_mm256_setone_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_store_si256\u2019?\n   40 |     __m256i vec_product = _mm256_setone_si256();\n      |                           ^~~~~~~~~~~~~~~~~~~\n      |                           _mm256_store_si256\n[REDACTED]/tmpaikvs_so.cpp:54:11: error: \u2018_mm256_reduce_add_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   54 |     sum = _mm256_reduce_add_epi16(vec_sum);\n      |           ^~~~~~~~~~~~~~~~~~~~~~~\n      |           _mm256_reduce_add_ph\n[REDACTED]/tmpaikvs_so.cpp:55:15: error: \u2018_mm256_reduce_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   55 |     product = _mm256_reduce_and_si256(vec_product);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~\n      |               _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_66_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprrdu4mxc.cpp: In function \u2018std::vector<long int> sum_product_simd(std::vector<short int>)\u2019:\n[REDACTED]/tmprrdu4mxc.cpp:40:27: error: \u2018_mm256_setone_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_store_si256\u2019?\n   40 |     __m256i vec_product = _mm256_setone_si256();\n      |                           ^~~~~~~~~~~~~~~~~~~\n      |                           _mm256_store_si256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmprrdu4mxc.cpp:16:\n[REDACTED]/tmprrdu4mxc.cpp:57:12: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   57 |     sum += _mm256_extract_epi16(_mm256_extract_epi16(vec_sum, 0), 0);\n      |            ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:58:12: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   58 |     sum += _mm256_extract_epi16(_mm256_extract_epi16(vec_sum, 1), 0);\n      |            ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:59:12: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   59 |     sum += _mm256_extract_epi16(_mm256_extract_epi16(vec_sum, 2), 0);\n      |            ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:60:12: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   60 |     sum += _mm256_extract_epi16(_mm256_extract_epi16(vec_sum, 3), 0);\n      |            ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:62:16: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   62 |     product += _mm256_extract_epi16(_mm256_extract_epi16(vec_product, 0), 0);\n      |                ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:63:16: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   63 |     product += _mm256_extract_epi16(_mm256_extract_epi16(vec_product, 1), 0);\n      |                ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:64:16: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   64 |     product += _mm256_extract_epi16(_mm256_extract_epi16(vec_product, 2), 0);\n      |                ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmprrdu4mxc.cpp:65:16: error: cannot convert a value of type \u2018int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   65 |     product += _mm256_extract_epi16(_mm256_extract_epi16(vec_product, 3), 0);\n      |                ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_66_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp02p_ku5c.cpp: In function \u2018std::vector<long int> sum_product_simd(std::vector<short int>)\u2019:\n[REDACTED]/tmp02p_ku5c.cpp:40:27: error: \u2018_mm256_setone_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_store_si256\u2019?\n   40 |     __m256i vec_product = _mm256_setone_si256();\n      |                           ^~~~~~~~~~~~~~~~~~~\n      |                           _mm256_store_si256\n[REDACTED]/tmp02p_ku5c.cpp:54:11: error: \u2018_mm256_reduce_add_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   54 |     sum = _mm256_reduce_add_epi16(vec_sum);\n      |           ^~~~~~~~~~~~~~~~~~~~~~~\n      |           _mm256_reduce_add_ph\n[REDACTED]/tmp02p_ku5c.cpp:55:15: error: \u2018_mm256_reduce_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   55 |     product = _mm256_reduce_and_si256(vec_product);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~\n      |               _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_66_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp62ql6y6m.cpp: In function \u2018std::vector<long int> sum_product_simd(std::vector<short int>)\u2019:\n[REDACTED]/tmp62ql6y6m.cpp:37:20: error: \u2018_mm256_setone_si256\u2019 was not declared in this scope; did you mean \u2018_mm256_store_si256\u2019?\n   37 |     __m256i prod = _mm256_setone_si256();\n      |                    ^~~~~~~~~~~~~~~~~~~\n      |                    _mm256_store_si256\n"}
{"task_id": "SimdBench_67_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9l42iavv.cpp: In function \u2018std::vector<int> rolling_max_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp9l42iavv.cpp:53:16: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   53 |         max1 = _mm256_blendv_epi32(max1, max1_current, max1_current);\n      |                ^~~~~~~~~~~~~~~~~~~\n      |                _mm256_blend_epi32\n[REDACTED]/tmp9l42iavv.cpp:63:16: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   63 |         max1 = _mm256_blendv_epi32(max1, max1_last, max1_last);\n      |                ^~~~~~~~~~~~~~~~~~~\n      |                _mm256_blend_epi32\n"}
{"task_id": "SimdBench_67_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvzgc4r3f.cpp: In function \u2018std::vector<int> rolling_max_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpvzgc4r3f.cpp:47:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   47 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(&result[i]), max_vector);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_67_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzv1fonp5.cpp: In function \u2018std::vector<int> rolling_max_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpzv1fonp5.cpp:45:22: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   45 |         max_vector = _mm256_blendv_epi32(max_vector, current_vector, max_current);\n      |                      ^~~~~~~~~~~~~~~~~~~\n      |                      _mm256_blend_epi32\n"}
{"task_id": "SimdBench_67_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_67_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmps4hjkr2e.cpp: In function \u2018std::vector<int> rolling_max_simd(std::vector<int>)\u2019:\n[REDACTED]/tmps4hjkr2e.cpp:43:30: error: could not convert \u2018_mm256_cmpgt_epi32(max, current)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   43 |         if(_mm256_cmpgt_epi32(max, current)){\n      |            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                              |\n      |                              __m256i\n"}
{"task_id": "SimdBench_68_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2hh33349.cpp: In function \u2018std::string string_xor_simd(std::string, std::string)\u2019:\n[REDACTED]/tmp2hh33349.cpp:48:36: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   48 |     __m256i a_vec = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 0,\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n   49 |                                         0, 0, 0, 0, 0, 0, 0, 0);\n      |                                         ~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2hh33349.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp2hh33349.cpp:50:36: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   50 |     __m256i b_vec = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 0,\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n   51 |                                         0, 0, 0, 0, 0, 0, 0, 0);\n      |                                         ~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp2hh33349.cpp:55:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   55 |             a_vec = _mm256_or_si256(a_vec, _mm256_set_epi8(a[i] - '0'));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp2hh33349.cpp:58:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   58 |             b_vec = _mm256_or_si256(b_vec, _mm256_set_epi8(b[i] - '0'));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmp2hh33349.cpp:67:37: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   67 |         result += static_cast<char>(_mm_extract_epi8(a_vec, i) + '0');\n      |                                     ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_68_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2kn_ugbl.cpp: In function \u2018std::string string_xor_simd(std::string, std::string)\u2019:\n[REDACTED]/tmp2kn_ugbl.cpp:58:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   58 |             a_vec = _mm256_or_si256(a_vec, _mm256_set_epi8((int)a[i]));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2kn_ugbl.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp2kn_ugbl.cpp:61:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   61 |             b_vec = _mm256_or_si256(b_vec, _mm256_set_epi8((int)b[i]));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmp2kn_ugbl.cpp:70:37: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   70 |         result += static_cast<char>(_mm_extract_epi8(a_vec, i));\n      |                                     ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_68_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjuj8qdzh.cpp: In function \u2018std::string string_xor_simd(std::string, std::string)\u2019:\n[REDACTED]/tmpjuj8qdzh.cpp:47:36: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   47 |     __m256i a_vec = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 0,\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n   48 |                                       0, 0, 0, 0, 0, 0, 0, 0);\n      |                                       ~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpjuj8qdzh.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpjuj8qdzh.cpp:49:36: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   49 |     __m256i b_vec = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 0,\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n   50 |                                       0, 0, 0, 0, 0, 0, 0, 0);\n      |                                       ~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpjuj8qdzh.cpp:54:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   54 |             a_vec = _mm256_or_si256(a_vec, _mm256_set_epi8((a[i] == '1') ? 1 : 0));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpjuj8qdzh.cpp:57:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   57 |             b_vec = _mm256_or_si256(b_vec, _mm256_set_epi8((b[i] == '1') ? 1 : 0));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_68_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxbnb9maa.cpp: In function \u2018std::string string_xor_simd(std::string, std::string)\u2019:\n[REDACTED]/tmpxbnb9maa.cpp:47:36: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   47 |     __m256i a_vec = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpxbnb9maa.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpxbnb9maa.cpp:48:36: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   48 |     __m256i b_vec = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      |                     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpxbnb9maa.cpp:52:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   52 |             a_vec = _mm256_or_si256(a_vec, _mm256_set_epi8((a[i] - '0') & 1));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpxbnb9maa.cpp:55:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   55 |             b_vec = _mm256_or_si256(b_vec, _mm256_set_epi8((b[i] - '0') & 1));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_68_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbbnqf6hg.cpp: In function \u2018std::string string_xor_simd(std::string, std::string)\u2019:\n[REDACTED]/tmpbbnqf6hg.cpp:58:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   58 |             a_vec = _mm256_or_si256(a_vec, _mm256_set_epi8(a[i] - '0'));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbbnqf6hg.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpbbnqf6hg.cpp:61:59: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   61 |             b_vec = _mm256_or_si256(b_vec, _mm256_set_epi8(b[i] - '0'));\n      |                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpbbnqf6hg.cpp:70:37: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   70 |         result += static_cast<char>(_mm_extract_epi8(a_vec, i) + '0');\n      |                                     ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_69_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptd3x27cs.cpp: In function \u2018std::string longest_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmptd3x27cs.cpp:38:25: error: cannot convert \u2018const std::__cxx11::basic_string<char>\u2019 to \u2018const int\u2019 in initialization\n   38 |     const int max_len = *std::max_element(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                         |\n      |                         const std::__cxx11::basic_string<char>\n   39 |         return a.size() < b.size();\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   40 |     });\n      |     ~~                   \n[REDACTED]/tmptd3x27cs.cpp:42:41: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i max_len_vec = _mm_set1_epi32(max_len);\n      |                           ~~~~~~~~~~~~~~^~~~~~~~~\n      |                                         |\n      |                                         __m128i\n[REDACTED]/tmptd3x27cs.cpp:48:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   48 |         __m256i len_vec = _mm_loadu_si256(vec_ptr);\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmptd3x27cs.cpp:49:43: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   49 |         __m256i cmp_vec = _mm_cmplt_epi32(len_vec, max_len_vec);\n      |                                           ^~~~~~~\n      |                                           |\n      |                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmptd3x27cs.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1369:26: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi32(__m128i, __m128i)\u2019\n 1369 | _mm_cmplt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmptd3x27cs.cpp:50:28: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   50 |         __m256i mask_vec = _mm_andnot_si256(cmp_vec, max_len_vec);\n      |                            ^~~~~~~~~~~~~~~~\n      |                            _mm_andnot_si64\n[REDACTED]/tmptd3x27cs.cpp:51:30: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   51 |         __m256i result_vec = _mm_or_si256(result_vec, mask_vec);\n      |                              ^~~~~~~~~~~~\n      |                              _mm_or_si64\n[REDACTED]/tmptd3x27cs.cpp:57:47: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   57 |         if (_mm_movemask_epi8(_mm_cmpgt_epi32(_mm_loadu_si256((__m256i*)&strings[i]), result_vec)) > 0) {\n      |                                               ^~~~~~~~~~~~~~~\n      |                                               _mm_loadu_si16\n[REDACTED]/tmptd3x27cs.cpp:57:87: error: \u2018result_vec\u2019 was not declared in this scope; did you mean \u2018result_index\u2019?\n   57 |         if (_mm_movemask_epi8(_mm_cmpgt_epi32(_mm_loadu_si256((__m256i*)&strings[i]), result_vec)) > 0) {\n      |                                                                                       ^~~~~~~~~~\n      |                                                                                       result_index\n"}
{"task_id": "SimdBench_69_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgqfsplj5.cpp: In function \u2018std::string longest_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpgqfsplj5.cpp:38:25: error: cannot convert \u2018const std::__cxx11::basic_string<char>\u2019 to \u2018const int\u2019 in initialization\n   38 |     const int max_len = *std::max_element(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                         |\n      |                         const std::__cxx11::basic_string<char>\n   39 |         return a.size() < b.size();\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   40 |     });\n      |     ~~                   \n[REDACTED]/tmpgqfsplj5.cpp:42:41: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i max_len_vec = _mm_set1_epi32(max_len);\n      |                           ~~~~~~~~~~~~~~^~~~~~~~~\n      |                                         |\n      |                                         __m128i\n[REDACTED]/tmpgqfsplj5.cpp:43:36: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   43 |     __m256i mask = _mm_cmplt_epi32(_mm_loadu_si256((__m256i*)strings.data()), max_len_vec);\n      |                                    ^~~~~~~~~~~~~~~\n      |                                    _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpgqfsplj5.cpp:16:\n[REDACTED]/tmpgqfsplj5.cpp:49:39: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   49 |         __m256i len = _mm_cvtepi32_ps(_mm_extract_epi32(str, 3));\n      |                                       ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpgqfsplj5.cpp:51:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   51 |         __m256i cmp = _mm_cmpgt_ps(len, max_len_vec);\n      |                                    ^~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpgqfsplj5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpgqfsplj5.cpp:52:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   52 |         __m256i select = _mm_blendv_ps(cmp, str, result);\n      |                                        ^~~\n      |                                        |\n      |                                        __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:204:23: note:   initializing argument 1 of \u2018__m128 _mm_blendv_ps(__m128, __m128, __m128)\u2019\n  204 | _mm_blendv_ps (__m128 __X, __m128 __Y, __m128 __M)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpgqfsplj5.cpp:54:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   54 |         result = _mm_add_epi32(result, select);\n      |                                ^~~~~~\n      |                                |\n      |                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpgqfsplj5.cpp:57:28: error: \u2018_mm256_reduce_max_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_max_ph\u2019?\n   57 |     __m256i final_result = _mm256_reduce_max_ps(result);\n      |                            ^~~~~~~~~~~~~~~~~~~~\n      |                            _mm256_reduce_max_ph\n[REDACTED]/tmpgqfsplj5.cpp:58:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   58 |     int final_index = _mm_cvtss_si32(final_result);\n      |                                      ^~~~~~~~~~~~\n      |                                      |\n      |                                      __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:515:24: note:   initializing argument 1 of \u2018int _mm_cvtss_si32(__m128)\u2019\n  515 | _mm_cvtss_si32 (__m128 __A)\n      |                 ~~~~~~~^~~\n"}
{"task_id": "SimdBench_69_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpoh8scacc.cpp: In function \u2018std::string longest_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpoh8scacc.cpp:38:25: error: cannot convert \u2018const std::__cxx11::basic_string<char>\u2019 to \u2018const int\u2019 in initialization\n   38 |     const int max_len = *std::max_element(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                         |\n      |                         const std::__cxx11::basic_string<char>\n   39 |         return a.size() < b.size();\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   40 |     });\n      |     ~~                   \n[REDACTED]/tmpoh8scacc.cpp:42:42: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i max_len_mask = _mm_set1_epi32(max_len);\n      |                            ~~~~~~~~~~~~~~^~~~~~~~~\n      |                                          |\n      |                                          __m128i\n[REDACTED]/tmpoh8scacc.cpp:43:27: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   43 |     __m256i max_len_vec = _mm_setzero_si256();\n      |                           ^~~~~~~~~~~~~~~~~\n      |                           _mm_setzero_si64\n[REDACTED]/tmpoh8scacc.cpp:46:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   46 |         __m256i str = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&strings[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpoh8scacc.cpp:16:\n[REDACTED]/tmpoh8scacc.cpp:47:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   47 |         __m256i len = _mm_cvtsi32_si256(_mm_extract_epi32(str, 3));\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpoh8scacc.cpp:47:23: error: \u2018_mm_cvtsi32_si256\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi32_si64\u2019?\n   47 |         __m256i len = _mm_cvtsi32_si256(_mm_extract_epi32(str, 3));\n      |                       ^~~~~~~~~~~~~~~~~\n      |                       _mm_cvtsi32_si64\n[REDACTED]/tmpoh8scacc.cpp:48:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |         __m256i cmp = _mm_cmplt_epi32(len, max_len_mask);\n      |                                       ^~~\n      |                                       |\n      |                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpoh8scacc.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1369:26: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi32(__m128i, __m128i)\u2019\n 1369 | _mm_cmplt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpoh8scacc.cpp:49:24: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   49 |         __m256i mask = _mm_and_si256(cmp, max_len_vec);\n      |                        ^~~~~~~~~~~~~\n      |                        _mm_and_si64\n[REDACTED]/tmpoh8scacc.cpp:50:23: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   50 |         max_len_vec = _mm_or_si256(mask, max_len_vec);\n      |                       ^~~~~~~~~~~~\n      |                       _mm_or_si64\n[REDACTED]/tmpoh8scacc.cpp:55:60: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   55 |         if (_mm_movemask_epi8(_mm_cmpgt_epi32(max_len_vec, _mm_loadu_si256(reinterpret_cast<const __m256i*>(&strings[i])))) {\n      |                                                            ^~~~~~~~~~~~~~~\n      |                                                            _mm_loadu_si16\n[REDACTED]/tmpoh8scacc.cpp:55:124: error: expected \u2018)\u2019 before \u2018{\u2019 token\n   55 |         if (_mm_movemask_epi8(_mm_cmpgt_epi32(max_len_vec, _mm_loadu_si256(reinterpret_cast<const __m256i*>(&strings[i])))) {\n      |            ~                                                                                                               ^~\n      |                                                                                                                            )\n[REDACTED]/tmpoh8scacc.cpp:58:5: error: expected primary-expression before \u2018}\u2019 token\n   58 |     }\n      |     ^\n"}
{"task_id": "SimdBench_69_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqhjee1l9.cpp: In function \u2018std::string longest_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpqhjee1l9.cpp:36:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i max_len = _mm_set1_epi32(0);\n      |                       ~~~~~~~~~~~~~~^~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmpqhjee1l9.cpp:37:39: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i max_index = _mm_set1_epi32(-1);\n      |                         ~~~~~~~~~~~~~~^~~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmpqhjee1l9.cpp:43:41: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   43 |         __m256i index = _mm256_set_epi32(i, i+1, i+2, i+3);\n      |                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqhjee1l9.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqhjee1l9.cpp:46:19: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   46 |         max_len = _mm256_blendv_epi32(max_len, len, cmp);\n      |                   ^~~~~~~~~~~~~~~~~~~\n      |                   _mm256_blend_epi32\n"}
{"task_id": "SimdBench_69_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpq8rwl6gg.cpp: In function \u2018std::string longest_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpq8rwl6gg.cpp:38:25: error: cannot convert \u2018const std::__cxx11::basic_string<char>\u2019 to \u2018const int\u2019 in initialization\n   38 |     const int max_len = *std::max_element(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                         |\n      |                         const std::__cxx11::basic_string<char>\n   39 |         return a.size() < b.size();\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   40 |     });\n      |     ~~                   \n[REDACTED]/tmpq8rwl6gg.cpp:42:41: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i max_len_vec = _mm_set1_epi32(max_len);\n      |                           ~~~~~~~~~~~~~~^~~~~~~~~\n      |                                         |\n      |                                         __m128i\n[REDACTED]/tmpq8rwl6gg.cpp:43:36: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   43 |     __m256i mask = _mm_cmpgt_epi32(_mm_loadu_si256((__m256i*)strings.data()), max_len_vec);\n      |                                    ^~~~~~~~~~~~~~~\n      |                                    _mm_loadu_si16\n[REDACTED]/tmpq8rwl6gg.cpp:45:38: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   45 |     __m256i result = _mm_blendv_epi8(_mm_setzero_si256(), _mm_loadu_si256((__m256i*)strings.data()), mask);\n      |                                      ^~~~~~~~~~~~~~~~~\n      |                                      _mm_setzero_si64\n[REDACTED]/tmpq8rwl6gg.cpp:47:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   47 |     __m256i max_index = _mm_slli_epi32(result, 4);\n      |                                        ^~~~~~\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpq8rwl6gg.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1190:25: note:   initializing argument 1 of \u2018__m128i _mm_slli_epi32(__m128i, int)\u2019\n 1190 | _mm_slli_epi32 (__m128i __A, int __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpq8rwl6gg.cpp:48:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |     __m256i index_mask = _mm_cmpgt_epi32(max_index, _mm_set1_epi32(strings.size()));\n      |                                          ^~~~~~~~~\n      |                                          |\n      |                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1387:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi32(__m128i, __m128i)\u2019\n 1387 | _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpq8rwl6gg.cpp:49:43: error: \u2018_mm_setzero_si32\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   49 |     __m256i final_index = _mm_blendv_epi8(_mm_setzero_si32(), max_index, index_mask);\n      |                                           ^~~~~~~~~~~~~~~~\n      |                                           _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpq8rwl6gg.cpp:16:\n[REDACTED]/tmpq8rwl6gg.cpp:51:42: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   51 |     int max_index_int = static_cast<int>(_mm_extract_epi32(final_index, 0));\n      |                                          ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_70_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_awg8hvt.cpp: In function \u2018uint64_t greatest_common_divisor_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmp_awg8hvt.cpp:44:12: error: \u2018_mm_cvtsi256_si64\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi64x_si64\u2019?\n   44 |     return _mm_cvtsi256_si64(_mm256_and_si256(av, bv));\n      |            ^~~~~~~~~~~~~~~~~\n      |            _mm_cvtsi64x_si64\n"}
{"task_id": "SimdBench_70_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpr56oczmh.cpp: In function \u2018uint64_t greatest_common_divisor_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpr56oczmh.cpp:34:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   34 |     __m256i avx_a = _mm256_set_epi64x(a >> 32, a & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpr56oczmh.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpr56oczmh.cpp:35:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   35 |     __m256i avx_b = _mm256_set_epi64x(b >> 32, b & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpr56oczmh.cpp:38:24: error: \u2018_mm256_gcd\u2019 was not declared in this scope; did you mean \u2018_mm256_or_pd\u2019?\n   38 |     __m256i gcd_high = _mm256_gcd(avx_a, avx_b);\n      |                        ^~~~~~~~~~\n      |                        _mm256_or_pd\n"}
{"task_id": "SimdBench_70_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8y6cj0s3.cpp: In function \u2018uint64_t greatest_common_divisor_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmp8y6cj0s3.cpp:31:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   31 |     __m256i a_vec = _mm256_set_epi64x(a >> 32, a & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8y6cj0s3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8y6cj0s3.cpp:32:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   32 |     __m256i b_vec = _mm256_set_epi64x(b >> 32, b & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_70_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxlp73n4g.cpp: In function \u2018uint64_t greatest_common_divisor_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpxlp73n4g.cpp:44:12: error: \u2018_mm_cvtsi256_si64\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi64x_si64\u2019?\n   44 |     return _mm_cvtsi256_si64(_mm256_and_si256(av, bv));\n      |            ^~~~~~~~~~~~~~~~~\n      |            _mm_cvtsi64x_si64\n"}
{"task_id": "SimdBench_70_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptz9np_9n.cpp: In function \u2018uint64_t greatest_common_divisor_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmptz9np_9n.cpp:34:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   34 |     __m256i a_vec = _mm256_set_epi64x(a >> 32, a & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmptz9np_9n.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmptz9np_9n.cpp:35:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   35 |     __m256i b_vec = _mm256_set_epi64x(b >> 32, b & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmptz9np_9n.cpp:39:41: error: cannot convert \u2018__m256i\u2019 to \u2018long long int\u2019\n   39 |         b_vec = _mm256_set_epi64x(b_vec >> 32, b_vec & 0xFFFFFFFF);\n      |                                   ~~~~~~^~~~~\n      |                                         |\n      |                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:30: note:   initializing argument 1 of \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      |                    ~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_71_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp48ohpgv6.cpp: In function \u2018std::vector<float> find_closest_elements_simd(std::vector<float>)\u2019:\n[REDACTED]/tmp48ohpgv6.cpp:57:28: error: \u2018_mm256_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   57 |         __m256 abs_diff1 = _mm256_abs_ps(diff1);\n      |                            ^~~~~~~~~~~~~\n      |                            _mm256_abs_ph\n[REDACTED]/tmp48ohpgv6.cpp:61:32: error: \u2018_mm256_argmin_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_min_ps\u2019?\n   61 |         __m256 min_index_vec = _mm256_argmin_ps(min_diff_vec);\n      |                                ^~~~~~~~~~~~~~~~\n      |                                _mm256_min_ps\n"}
{"task_id": "SimdBench_71_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpq_5rv0gi.cpp: In function \u2018std::vector<float> find_closest_elements_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpq_5rv0gi.cpp:52:24: error: \u2018_mm256_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   52 |     __m256 abs_diff1 = _mm256_abs_ps(diff1);\n      |                        ^~~~~~~~~~~~~\n      |                        _mm256_abs_ph\n[REDACTED]/tmpq_5rv0gi.cpp:59:21: error: \u2018_mm256_pcmpge_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   59 |     __m256 index1 = _mm256_pcmpge_ps(min_diff1, _mm256_set1_ps(min_diff));\n      |                     ^~~~~~~~~~~~~~~~\n      |                     _mm256_cmp_ps\n[REDACTED]/tmpq_5rv0gi.cpp:70:17: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   70 |     result[0] = _mm256_extractf32_ps(closest1, 0);\n      |                 ^~~~~~~~~~~~~~~~~~~~\n      |                 _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_71_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpls1qarkq.cpp: In function \u2018std::vector<float> find_closest_elements_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpls1qarkq.cpp:43:23: error: \u2018_mm256_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   43 |     __m256 abs_diff = _mm256_abs_ps(diff);\n      |                       ^~~~~~~~~~~~~\n      |                       _mm256_abs_ph\n[REDACTED]/tmpls1qarkq.cpp:44:22: error: \u2018_mm256_argmin_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_min_ps\u2019?\n   44 |     __m256 arg_min = _mm256_argmin_ps(abs_diff);\n      |                      ^~~~~~~~~~~~~~~~\n      |                      _mm256_min_ps\n"}
{"task_id": "SimdBench_71_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpiixrje0m.cpp: In function \u2018std::vector<float> find_closest_elements_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpiixrje0m.cpp:52:29: error: \u2018_mm256_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   52 |         __m256 v_abs_diff = _mm256_abs_ps(v_current_diff);\n      |                             ^~~~~~~~~~~~~\n      |                             _mm256_abs_ph\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpiixrje0m.cpp:16:\n[REDACTED]/tmpiixrje0m.cpp:55:12: error: could not convert \u2018__builtin_ia32_cmpps256(v_min_diff_temp, v_min_diff, 17)\u2019 from \u2018__vector(8) float\u2019 to \u2018bool\u2019\n   55 |         if(_mm256_cmp_ps(v_min_diff_temp, v_min_diff, _CMP_LT_OQ)){\n      |            ^~~~~~~~~~~~~\n      |            |\n      |            __vector(8) float\n"}
{"task_id": "SimdBench_71_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprhx_k_w3.cpp: In function \u2018std::vector<float> find_closest_elements_simd(std::vector<float>)\u2019:\n[REDACTED]/tmprhx_k_w3.cpp:45:29: error: \u2018_mm256_abs_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_abs_ph\u2019?\n   45 |         __m256 v_abs_diff = _mm256_abs_ps(v_diff);\n      |                             ^~~~~~~~~~~~~\n      |                             _mm256_abs_ph\n"}
{"task_id": "SimdBench_72_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqrtpmxxp.cpp: In function \u2018std::vector<float> rescale_to_unit_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpqrtpmxxp.cpp:46:34: error: \u2018_mm256_get_ps_u32\u2019 was not declared in this scope; did you mean \u2018_mm256_set_ps\u2019?\n   46 |     float scale_factor = 1.0f / (_mm256_get_ps_u32(max_val) - _mm256_get_ps_u32(min_val));\n      |                                  ^~~~~~~~~~~~~~~~~\n      |                                  _mm256_set_ps\n[REDACTED]/tmpqrtpmxxp.cpp:52:61: error: too few arguments to function \u2018__m256 _mm256_set_ps(float, float, float, float, float, float, float, float)\u2019\n   52 |         __m256 scaled_val = _mm256_mul_ps(val, _mm256_set_ps(scale_factor, scale_factor, scale_factor, scale_factor));\n      |                                                ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqrtpmxxp.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1265:1: note: declared here\n 1265 | _mm256_set_ps (float __A, float __B, float __C, float __D,\n      | ^~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_72_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpv7ks0iwf.cpp: In function \u2018std::vector<float> rescale_to_unit_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpv7ks0iwf.cpp:51:48: error: cannot convert \u2018__m256\u2019 to \u2018const __m128*\u2019\n   51 |     __m256 broadcast_min = _mm256_broadcast_ps(min_val);\n      |                                                ^~~~~~~\n      |                                                |\n      |                                                __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpv7ks0iwf.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:752:36: note:   initializing argument 1 of \u2018__m256 _mm256_broadcast_ps(const __m128*)\u2019\n  752 | _mm256_broadcast_ps (__m128 const *__X)\n      |                      ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpv7ks0iwf.cpp:52:48: error: cannot convert \u2018__m256\u2019 to \u2018const __m128*\u2019\n   52 |     __m256 broadcast_max = _mm256_broadcast_ps(max_val);\n      |                                                ^~~~~~~\n      |                                                |\n      |                                                __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:752:36: note:   initializing argument 1 of \u2018__m256 _mm256_broadcast_ps(const __m128*)\u2019\n  752 | _mm256_broadcast_ps (__m128 const *__X)\n      |                      ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpv7ks0iwf.cpp:72:45: error: cannot convert \u2018__m256\u2019 to \u2018const __m128*\u2019\n   72 |         broadcast_min = _mm256_broadcast_ps(min_val);\n      |                                             ^~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:752:36: note:   initializing argument 1 of \u2018__m256 _mm256_broadcast_ps(const __m128*)\u2019\n  752 | _mm256_broadcast_ps (__m128 const *__X)\n      |                      ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpv7ks0iwf.cpp:73:45: error: cannot convert \u2018__m256\u2019 to \u2018const __m128*\u2019\n   73 |         broadcast_max = _mm256_broadcast_ps(max_val);\n      |                                             ^~~~~~~\n      |                                             |\n      |                                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:752:36: note:   initializing argument 1 of \u2018__m256 _mm256_broadcast_ps(const __m128*)\u2019\n  752 | _mm256_broadcast_ps (__m128 const *__X)\n      |                      ~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpv7ks0iwf.cpp:75:9: error: \u2018scaled_vec3\u2019 was not declared in this scope; did you mean \u2018scaled_vec2\u2019?\n   75 |         scaled_vec3 = _mm256_div_ps(vec3, broadcast_max);\n      |         ^~~~~~~~~~~\n      |         scaled_vec2\n[REDACTED]/tmpv7ks0iwf.cpp:76:9: error: \u2018scaled_vec4\u2019 was not declared in this scope; did you mean \u2018scaled_vec2\u2019?\n   76 |         scaled_vec4 = _mm256_div_ps(vec4, broadcast_max);\n      |         ^~~~~~~~~~~\n      |         scaled_vec2\n"}
{"task_id": "SimdBench_72_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkftbnb8b.cpp: In function \u2018std::vector<float> rescale_to_unit_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpkftbnb8b.cpp:51:23: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   51 |     float min_val_f = _mm256_extractf32_ps(min_val, 0);\n      |                       ^~~~~~~~~~~~~~~~~~~~\n      |                       _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_72_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppzjfaosf.cpp: In function \u2018std::vector<float> rescale_to_unit_simd(std::vector<float>)\u2019:\n[REDACTED]/tmppzjfaosf.cpp:51:23: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   51 |     float min_val_f = _mm256_extractf32_ps(min_val, 0);\n      |                       ^~~~~~~~~~~~~~~~~~~~\n      |                       _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_72_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpn4x0872r.cpp: In function \u2018std::vector<float> rescale_to_unit_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpn4x0872r.cpp:49:23: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   49 |     float min_val_f = _mm256_extractf32_ps(min_val, 0);\n      |                       ^~~~~~~~~~~~~~~~~~~~\n      |                       _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_73_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpsxhiwjwm.cpp: In function \u2018uint64_t largest_divisor_simd(uint64_t)\u2019:\n[REDACTED]/tmpsxhiwjwm.cpp:32:21: error: \u2018_mm256_set_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set_epi64x\u2019?\n   32 |     __m256i n_vec = _mm256_set_epi64u(n >> 32, n >> 24, n >> 16, n >> 8, n >> 0);\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm256_set_epi64x\n[REDACTED]/tmpsxhiwjwm.cpp:36:27: error: \u2018_mm256_div_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi64\u2019?\n   36 |         __m256i div_vec = _mm256_div_epi64(n_vec, _mm256_slli_epi64(n_vec, 1));\n      |                           ^~~~~~~~~~~~~~~~\n      |                           _mm256_min_epi64\n[REDACTED]/tmpsxhiwjwm.cpp:37:33: error: \u2018_mm256_mod_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_xor_epi64\u2019?\n   37 |         __m256i remainder_vec = _mm256_mod_epi64(div_vec, n_vec);\n      |                                 ^~~~~~~~~~~~~~~~\n      |                                 _mm256_xor_epi64\n"}
{"task_id": "SimdBench_73_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvwx5hrvm.cpp: In function \u2018uint64_t largest_divisor_simd(uint64_t)\u2019:\n[REDACTED]/tmpvwx5hrvm.cpp:32:21: error: \u2018_mm256_set_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set_epi64x\u2019?\n   32 |     __m256i n_vec = _mm256_set_epi64u(n >> 32, n >> 24, n >> 16, n >> 8, n >> 0);\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm256_set_epi64x\n[REDACTED]/tmpvwx5hrvm.cpp:36:50: error: cannot convert \u2018__m256i\u2019 to \u2018uint64_t\u2019 {aka \u2018long unsigned int\u2019} in assignment\n   36 |         result |= _mm256_and_si256(n_vec, div_vec);\n      |                                                  ^\n"}
{"task_id": "SimdBench_73_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_73_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_73_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw6tsc99p.cpp: In function \u2018uint64_t largest_divisor_simd(uint64_t)\u2019:\n[REDACTED]/tmpw6tsc99p.cpp:32:21: error: \u2018_mm256_set_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set_epi64x\u2019?\n   32 |     __m256i n_vec = _mm256_set_epi64u(n >> 32, n >> 24, n >> 16, n >> 8, n >> 0);\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm256_set_epi64x\n[REDACTED]/tmpw6tsc99p.cpp:35:33: error: \u2018_mm256_cmplt_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi64\u2019?\n   35 |     while (_mm256_movemask_epi8(_mm256_cmplt_epi64(n_vec, result_vec)) != 0) {\n      |                                 ^~~~~~~~~~~~~~~~~~\n      |                                 _mm256_cmpgt_epi64\n"}
{"task_id": "SimdBench_74_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_74_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_74_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_74_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_74_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_75_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1vtzea82.cpp: In function \u2018std::vector<float> get_positive_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmp1vtzea82.cpp:37:42: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |     const __m256i mask = _mm256_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF);\n      |                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp1vtzea82.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp1vtzea82.cpp:43:39: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   43 |         __m256 temp = _mm256_loadu_ps(&l_ptr[i]);\n      |                                       ^~~~~~~~~\n      |                                       |\n      |                                       __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp1vtzea82.cpp:44:50: error: cannot convert \u2018const __m256i\u2019 to \u2018__m256\u2019\n   44 |         __m256 masked_temp = _mm256_and_ps(temp, mask);\n      |                                                  ^~~~\n      |                                                  |\n      |                                                  const __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:172:35: note:   initializing argument 2 of \u2018__m256 _mm256_and_ps(__m256, __m256)\u2019\n  172 | _mm256_and_ps (__m256 __A, __m256 __B)\n      |                            ~~~~~~~^~~\n[REDACTED]/tmp1vtzea82.cpp:45:37: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   45 |         _mm256_storeu_ps(result_ptr + i / 8, masked_temp);\n      |                          ~~~~~~~~~~~^~~~~~~\n      |                                     |\n      |                                     __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_75_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkbzf5a0w.cpp:33:17: error: \u2018__m256i\u2019 is not a namespace-name\n   33 | using namespace __m256i;\n      |                 ^~~~~~~\n[REDACTED]/tmpkbzf5a0w.cpp: In function \u2018std::vector<float> get_positive_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpkbzf5a0w.cpp:37:18: warning: ignoring attributes on template argument \u2018__m256\u2019 [-Wignored-attributes]\n   37 |     vector<__m256> v(n / 8);\n      |                  ^\n[REDACTED]/tmpkbzf5a0w.cpp:42:18: warning: ignoring attributes on template argument \u2018__m256\u2019 [-Wignored-attributes]\n   42 |     vector<__m256> result(n / 8);\n      |                  ^\n[REDACTED]/tmpkbzf5a0w.cpp:44:21: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   44 |         result[i] = _mm256_cmpgt_ps(v[i], _mm256_setzero_ps());\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm256_cmp_ps\n[REDACTED]/tmpkbzf5a0w.cpp:49:18: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   49 |         res[i] = _mm256_extractf32_ps(result[i], 0);\n      |                  ^~~~~~~~~~~~~~~~~~~~\n      |                  _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_75_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpyiw3bnhb.cpp: In function \u2018std::vector<float> get_positive_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpyiw3bnhb.cpp:37:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpyiw3bnhb.cpp:38:35: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   38 |     __m256 result = _mm_setzero_ps();\n      |                     ~~~~~~~~~~~~~~^~\n      |                                   |\n      |                                   __m128\n[REDACTED]/tmpyiw3bnhb.cpp:41:34: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   41 |         __m256 vec = _mm_loadu_ps(&l[i]);\n      |                      ~~~~~~~~~~~~^~~~~~~\n      |                                  |\n      |                                  __m128\n[REDACTED]/tmpyiw3bnhb.cpp:42:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         mask = _mm_cmpgt_ps(vec, _mm_setzero_ps());\n      |                             ^~~\n      |                             |\n      |                             __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpyiw3bnhb.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpyiw3bnhb.cpp:43:29: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         result = _mm_and_ps(result, mask);\n      |                             ^~~~~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:246:20: note:   initializing argument 1 of \u2018__m128 _mm_and_ps(__m128, __m128)\u2019\n  246 | _mm_and_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmpyiw3bnhb.cpp:48:28: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   48 |         if(_mm_movemask_ps(mask, _mm_castps_si128(_mm_loadu_ps(&l[i]))) != 0){\n      |                            ^~~~\n      |                            |\n      |                            __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:820:25: note:   initializing argument 1 of \u2018int _mm_movemask_ps(__m128)\u2019\n  820 | _mm_movemask_ps (__m128 __A)\n      |                  ~~~~~~~^~~\n"}
{"task_id": "SimdBench_75_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpg0pep0bl.cpp: In function \u2018std::vector<float> get_positive_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpg0pep0bl.cpp:37:33: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   37 |     __m256 mask = _mm_setzero_ps();\n      |                   ~~~~~~~~~~~~~~^~\n      |                                 |\n      |                                 __m128\n[REDACTED]/tmpg0pep0bl.cpp:38:35: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   38 |     __m256 result = _mm_setzero_ps();\n      |                     ~~~~~~~~~~~~~~^~\n      |                                   |\n      |                                   __m128\n[REDACTED]/tmpg0pep0bl.cpp:41:34: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   41 |         __m256 vec = _mm_loadu_ps(&l[i]);\n      |                      ~~~~~~~~~~~~^~~~~~~\n      |                                  |\n      |                                  __m128\n[REDACTED]/tmpg0pep0bl.cpp:42:40: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   42 |         __m256 pos_mask = _mm_cmpgt_ps(vec, _mm_setzero_ps());\n      |                                        ^~~\n      |                                        |\n      |                                        __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpg0pep0bl.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:384:22: note:   initializing argument 1 of \u2018__m128 _mm_cmpgt_ps(__m128, __m128)\u2019\n  384 | _mm_cmpgt_ps (__m128 __A, __m128 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmpg0pep0bl.cpp:43:26: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   43 |         mask = _mm_or_ps(mask, pos_mask);\n      |                          ^~~~\n      |                          |\n      |                          __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpg0pep0bl.cpp:44:28: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   44 |         result = _mm_or_ps(result, vec);\n      |                            ^~~~~~\n      |                            |\n      |                            __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:258:19: note:   initializing argument 1 of \u2018__m128 _mm_or_ps(__m128, __m128)\u2019\n  258 | _mm_or_ps (__m128 __A, __m128 __B)\n      |            ~~~~~~~^~~\n[REDACTED]/tmpg0pep0bl.cpp:56:25: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   56 |         if(_mm_testz_ps(mask, _mm_set1_ps(1.0f))){\n      |                         ^~~~\n      |                         |\n      |                         __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpg0pep0bl.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1124:22: note:   initializing argument 1 of \u2018int _mm_testz_ps(__m128, __m128)\u2019\n 1124 | _mm_testz_ps (__m128 __M, __m128 __V)\n      |               ~~~~~~~^~~\n"}
{"task_id": "SimdBench_75_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpf5a29uvk.cpp: In function \u2018std::vector<float> get_positive_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpf5a29uvk.cpp:38:19: error: \u2018_mm256_cmpgt_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_cmp_ps\u2019?\n   38 |     __m256 mask = _mm256_cmpgt_ps(v, _mm256_setzero_ps());\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm256_cmp_ps\n"}
{"task_id": "SimdBench_76_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvk_ag7y0.cpp: In function \u2018bool is_prime_simd(int64_t)\u2019:\n[REDACTED]/tmpvk_ag7y0.cpp:37:40: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i sqrt_n_vec = _mm256_sqrt_ps(_mm256_cvtepi32_ps(n_vec));\n      |                          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n[REDACTED]/tmpvk_ag7y0.cpp:38:71: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     __m256i mask_vec = _mm256_cmpgt_epi32(sqrt_n_vec, _mm256_set_epi32(0, 0, 0, 0));\n      |                                                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpvk_ag7y0.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpvk_ag7y0.cpp:40:38: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   40 |     for (__m256i i = _mm256_set_epi32(1, 3, 5, 7); i != _mm256_set_epi32(0, 0, 0, 0); i += 4) {\n      |                      ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpvk_ag7y0.cpp:40:73: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   40 |     for (__m256i i = _mm256_set_epi32(1, 3, 5, 7); i != _mm256_set_epi32(0, 0, 0, 0); i += 4) {\n      |                                                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpvk_ag7y0.cpp:42:27: error: \u2018_mm256_mod_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_xor_epi64\u2019?\n   42 |         __m256i mod_vec = _mm256_mod_epi64(n_vec, div_vec);\n      |                           ^~~~~~~~~~~~~~~~\n      |                           _mm256_xor_epi64\n"}
{"task_id": "SimdBench_76_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpfpgtan07.cpp: In function \u2018bool is_prime_simd(int64_t)\u2019:\n[REDACTED]/tmpfpgtan07.cpp:34:40: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   34 |     __m256i sqrt_n_vec = _mm256_sqrt_ps(_mm256_cvtepi32_ps(n_vec));\n      |                          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n[REDACTED]/tmpfpgtan07.cpp:39:28: error: \u2018begin\u2019 was not declared in this scope; did you mean \u2018std::begin\u2019?\n   39 |     for (__m256i divisor : divisors_mask) {\n      |                            ^~~~~~~~~~~~~\n      |                            std::begin\nIn file included from /usr/include/c++/13/string:53,\n                 from /usr/include/c++/13/bits/locale_classes.h:40,\n                 from /usr/include/c++/13/bits/ios_base.h:41,\n                 from /usr/include/c++/13/ios:44,\n                 from /usr/include/c++/13/ostream:40,\n                 from /usr/include/c++/13/iostream:41,\n                 from [REDACTED]/tmpfpgtan07.cpp:1:\n/usr/include/c++/13/bits/range_access.h:114:37: note: \u2018std::begin\u2019 declared here\n  114 |   template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;\n      |                                     ^~~~~\n[REDACTED]/tmpfpgtan07.cpp:39:28: error: \u2018end\u2019 was not declared in this scope; did you mean \u2018std::end\u2019?\n   39 |     for (__m256i divisor : divisors_mask) {\n      |                            ^~~~~~~~~~~~~\n      |                            std::end\n/usr/include/c++/13/bits/range_access.h:116:37: note: \u2018std::end\u2019 declared here\n  116 |   template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;\n      |                                     ^~~\n[REDACTED]/tmpfpgtan07.cpp:40:46: error: cannot convert \u2018__m256i\u2019 to \u2018long long int\u2019\n   40 |         __m256i dividend = _mm256_set_epi64x(divisor, divisor, divisor, divisor);\n      |                                              ^~~~~~~\n      |                                              |\n      |                                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpfpgtan07.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:30: note:   initializing argument 1 of \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      |                    ~~~~~~~~~~^~~\n[REDACTED]/tmpfpgtan07.cpp:41:69: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   41 |         __m256i quotient = _mm256_div_ps(_mm256_cvtepi32_ps(n_vec), dividend);\n      |                                                                     ^~~~~~~~\n      |                                                                     |\n      |                                                                     __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:241:35: note:   initializing argument 2 of \u2018__m256 _mm256_div_ps(__m256, __m256)\u2019\n  241 | _mm256_div_ps (__m256 __A, __m256 __B)\n      |                            ~~~~~~~^~~\n[REDACTED]/tmpfpgtan07.cpp:42:84: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   42 |         __m256i remainder = _mm256_sub_ps(_mm256_cvtepi32_ps(n_vec), _mm256_mul_ps(quotient, dividend));\n      |                                                                                    ^~~~~~~~\n      |                                                                                    |\n      |                                                                                    __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_76_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpusc2hsav.cpp: In function \u2018bool is_prime_simd(int64_t)\u2019:\n[REDACTED]/tmpusc2hsav.cpp:37:40: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i sqrt_n_vec = _mm256_sqrt_ps(_mm256_set1_ps(sqrt((double)n)));\n      |                          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        __m256\n"}
{"task_id": "SimdBench_76_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_76_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpy6efvdq7.cpp: In function \u2018bool is_prime_simd(int64_t)\u2019:\n[REDACTED]/tmpy6efvdq7.cpp:37:58: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   37 |     __m256i sqrt_n_vec = _mm256_sqrt_ps(_mm256_set_epi64x((int64_t)sqrt(n), (int64_t)sqrt(n)));\n      |                                         ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpy6efvdq7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpy6efvdq7.cpp:41:32: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |     int count = _mm_popcnt_u32(_mm_extract_epi32(mask_vec, 0)) +\n      |                                ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpy6efvdq7.cpp:42:32: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |                 _mm_popcnt_u32(_mm_extract_epi32(mask_vec, 1)) +\n      |                                ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpy6efvdq7.cpp:43:32: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |                 _mm_popcnt_u32(_mm_extract_epi32(mask_vec, 2)) +\n      |                                ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpy6efvdq7.cpp:44:32: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   44 |                 _mm_popcnt_u32(_mm_extract_epi32(mask_vec, 3));\n      |                                ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_77_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpnn2mkxsh.cpp: In function \u2018std::string solve_simd(const std::string&)\u2019:\n[REDACTED]/tmpnn2mkxsh.cpp:42:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   42 |     __m256i mask = _mm_setzero_si256(); // Initialize mask with zeros\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpnn2mkxsh.cpp:45:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   45 |         __m256i vec = _mm_loadu_si256((__m256i*)&s[i]); // Load 4 bytes into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpnn2mkxsh.cpp:46:32: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   46 |         __m256i reversed_vec = _mm_xor_si256(vec, mask); // Reverse case if character is lowercase\n      |                                ^~~~~~~~~~~~~\n      |                                _mm_xor_si64\n[REDACTED]/tmpnn2mkxsh.cpp:47:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   47 |         _mm_storeu_si256((__m256i*)&s[i], reversed_vec); // Store the result back into the string\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmpnn2mkxsh.cpp:48:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |         mask = _mm_cmpgt_epi8(mask, _mm_cmplt_epi8(vec, _mm_set1_epi8('Z'))); // Update mask for next iteration\n      |                                                    ^~~\n      |                                                    |\n      |                                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpnn2mkxsh.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1357:25: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi8(__m128i, __m128i)\u2019\n 1357 | _mm_cmplt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpnn2mkxsh.cpp:57:14: error: assignment of read-only location \u2018(& s)->std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\n   57 |         s[i] = c;\n"}
{"task_id": "SimdBench_77_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmps4g_t8bl.cpp: In function \u2018std::string solve_simd(const std::string&)\u2019:\n[REDACTED]/tmps4g_t8bl.cpp:42:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   42 |     __m256i mask = _mm_setzero_si256(); // Initialize mask with zeros\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmps4g_t8bl.cpp:45:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   45 |         __m256i vec = _mm_loadu_si256((__m256i*)&s[i]); // Load 4 characters into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmps4g_t8bl.cpp:46:32: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   46 |         __m256i reversed_vec = _mm_xor_si256(vec, mask); // Reverse the case of each character\n      |                                ^~~~~~~~~~~~~\n      |                                _mm_xor_si64\n[REDACTED]/tmps4g_t8bl.cpp:47:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   47 |         _mm_storeu_si256((__m256i*)&s[i], reversed_vec); // Store the reversed characters back into the string\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmps4g_t8bl.cpp:48:28: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in assignment\n   48 |         mask = _mm_set_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); // Clear the mask\n      |                ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                            |\n      |                            __m128i\n[REDACTED]/tmps4g_t8bl.cpp:57:14: error: assignment of read-only location \u2018(& s)->std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\n   57 |         s[i] = c;\n"}
{"task_id": "SimdBench_77_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp1u2r29gq.cpp: In function \u2018std::string solve_simd(const std::string&)\u2019:\n[REDACTED]/tmp1u2r29gq.cpp:42:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   42 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmp1u2r29gq.cpp:46:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   46 |         __m256i word = _mm_loadu_si256((__m256i*)&s[i]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmp1u2r29gq.cpp:47:33: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   47 |         __m256i reversed_word = _mm_xor_si256(word, mask);\n      |                                 ^~~~~~~~~~~~~\n      |                                 _mm_xor_si64\n[REDACTED]/tmp1u2r29gq.cpp:48:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   48 |         result = _mm_or_si256(result, reversed_word);\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp1u2r29gq.cpp:16:\n[REDACTED]/tmp1u2r29gq.cpp:53:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   53 |             result = _mm_insert_epi8(result, toupper(s[i]), i / 8);\n      |                      ^~~~~~~~~~~~~~~\n[REDACTED]/tmp1u2r29gq.cpp:55:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   55 |             result = _mm_insert_epi8(result, s[i], i / 8);\n      |                      ^~~~~~~~~~~~~~~\n[REDACTED]/tmp1u2r29gq.cpp:61:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   61 |         res.push_back((char)_mm_extract_epi8(result, i));\n      |                             ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_77_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_6_4t_ka.cpp: In function \u2018std::string solve_simd(const std::string&)\u2019:\n[REDACTED]/tmp_6_4t_ka.cpp:42:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   42 |     __m256i mask = _mm_setzero_si256(); // Initialize mask with zeros\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmp_6_4t_ka.cpp:45:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   45 |         __m256i vec = _mm_loadu_si256((__m256i*)&s[i]); // Load 4 characters into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp_6_4t_ka.cpp:46:32: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   46 |         __m256i reversed_vec = _mm_xor_si256(vec, mask); // Reverse case for each character in the vector\n      |                                ^~~~~~~~~~~~~\n      |                                _mm_xor_si64\n[REDACTED]/tmp_6_4t_ka.cpp:47:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   47 |         _mm_storeu_si256((__m256i*)&s[i], reversed_vec); // Store the reversed vector back into the string\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n[REDACTED]/tmp_6_4t_ka.cpp:48:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |         mask = _mm_cmpgt_epi8(mask, _mm_set1_epi8(0)); // Update mask to check if there are still letters left to process\n      |                               ^~~~\n      |                               |\n      |                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_6_4t_ka.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp_6_4t_ka.cpp:57:13: error: decrement of read-only variable \u2018len\u2019\n   57 |         s[--len] = c;\n      |             ^~~\n[REDACTED]/tmp_6_4t_ka.cpp:57:18: error: assignment of read-only location \u2018(& s)->std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)((int)(-- len))))\u2019\n   57 |         s[--len] = c;\n"}
{"task_id": "SimdBench_77_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6h0n00nh.cpp: In function \u2018std::string solve_simd(const std::string&)\u2019:\n[REDACTED]/tmp6h0n00nh.cpp:44:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   44 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmp6h0n00nh.cpp:48:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   48 |         __m256i word = _mm_loadu_si256((__m256i*)&s[i]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmp6h0n00nh.cpp:49:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   49 |         __m256i lower_mask = _mm_cmplt_epi8(word, _mm_set1_epi8('Z'));\n      |                                             ^~~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp6h0n00nh.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1357:25: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi8(__m128i, __m128i)\u2019\n 1357 | _mm_cmplt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp6h0n00nh.cpp:50:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   50 |         __m256i upper_mask = _mm_cmpgt_epi8(word, _mm_set1_epi8('z'));\n      |                                             ^~~~\n      |                                             |\n      |                                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp6h0n00nh.cpp:52:58: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   52 |         __m256i lower_result = _mm_and_si256(lower_mask, _mm_xor_si256(word, _mm_set1_epi8(' ')));\n      |                                                          ^~~~~~~~~~~~~\n      |                                                          _mm_xor_si64\n[REDACTED]/tmp6h0n00nh.cpp:52:32: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   52 |         __m256i lower_result = _mm_and_si256(lower_mask, _mm_xor_si256(word, _mm_set1_epi8(' ')));\n      |                                ^~~~~~~~~~~~~\n      |                                _mm_and_si64\n[REDACTED]/tmp6h0n00nh.cpp:55:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   55 |         result = _mm_or_si256(result, lower_result);\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp6h0n00nh.cpp:16:\n[REDACTED]/tmp6h0n00nh.cpp:61:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   61 |             result = _mm_insert_epi8(result, s[i], i / 8);\n      |                      ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6h0n00nh.cpp:63:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   63 |             result = _mm_insert_epi8(result, s[i] + 32, i / 8);\n      |                      ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6h0n00nh.cpp:69:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   69 |         res.push_back(static_cast<char>(_mm_extract_epi8(result, i)));\n      |                                         ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_78_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbv9zftzc.cpp: In function \u2018std::vector<int> sort_third_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpbv9zftzc.cpp:55:29: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   55 |         __m256i sorted_v1 = _mm256_sort_ps(v1, v2, v3);\n      |                             ^~~~~~~~~~~~~~\n      |                             _mm256_sqrt_ps\n[REDACTED]/tmpbv9zftzc.cpp:63:17: error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<int>\u2019 and \u2018__m256i\u2019)\n   63 |         *ptr = l[*ptr];\n      |                 ^\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmpbv9zftzc.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:1126:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](size_type) [with _Tp = int; _Alloc = std::allocator<int>; reference = int&; size_type = long unsigned int]\u2019\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1126:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/usr/include/c++/13/bits/stl_vector.h:1145:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](size_type) const [with _Tp = int; _Alloc = std::allocator<int>; const_reference = const int&; size_type = long unsigned int]\u2019\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1145:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_78_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpf73ldwt4.cpp: In function \u2018std::vector<int> sort_third_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpf73ldwt4.cpp:47:53: error: \u2018_MM_SORT_DESCENDING\u2019 was not declared in this scope\n   47 |         __m256i sorted_vec = _mm256_sort_epi32(vec, _MM_SORT_DESCENDING);\n      |                                                     ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpf73ldwt4.cpp:47:30: error: \u2018_mm256_sort_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_xor_epi32\u2019?\n   47 |         __m256i sorted_vec = _mm256_sort_epi32(vec, _MM_SORT_DESCENDING);\n      |                              ^~~~~~~~~~~~~~~~~\n      |                              _mm256_xor_epi32\n"}
{"task_id": "SimdBench_78_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphvsx93o4.cpp: In function \u2018std::vector<int> sort_third_simd(std::vector<int>)\u2019:\n[REDACTED]/tmphvsx93o4.cpp:47:19: error: \u2018_m256i_cast_ptr\u2019 was not declared in this scope\n   47 |         std::sort(_m256i_cast_ptr<int>(vec), _m256i_cast_ptr<int>(vec) + 3);\n      |                   ^~~~~~~~~~~~~~~\n[REDACTED]/tmphvsx93o4.cpp:47:35: error: expected primary-expression before \u2018int\u2019\n   47 |         std::sort(_m256i_cast_ptr<int>(vec), _m256i_cast_ptr<int>(vec) + 3);\n      |                                   ^~~\n[REDACTED]/tmphvsx93o4.cpp:47:62: error: expected primary-expression before \u2018int\u2019\n   47 |         std::sort(_m256i_cast_ptr<int>(vec), _m256i_cast_ptr<int>(vec) + 3);\n      |                                                              ^~~\n"}
{"task_id": "SimdBench_78_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpuuxstqyp.cpp: In function \u2018std::vector<int> sort_third_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpuuxstqyp.cpp:51:50: error: \u2018_MM_SORT_DESCENDING\u2019 was not declared in this scope\n   51 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                                                  ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpuuxstqyp.cpp:51:30: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   51 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                              ^~~~~~~~~~~~~~\n      |                              _mm256_sqrt_ps\n[REDACTED]/tmpuuxstqyp.cpp:59:50: error: \u2018_MM_SORT_DESCENDING\u2019 was not declared in this scope\n   59 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                                                  ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpuuxstqyp.cpp:59:30: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   59 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                              ^~~~~~~~~~~~~~\n      |                              _mm256_sqrt_ps\n[REDACTED]/tmpuuxstqyp.cpp:63:50: error: \u2018_MM_SORT_DESCENDING\u2019 was not declared in this scope\n   63 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                                                  ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpuuxstqyp.cpp:63:30: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   63 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                              ^~~~~~~~~~~~~~\n      |                              _mm256_sqrt_ps\n"}
{"task_id": "SimdBench_78_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw8syvqoo.cpp: In function \u2018std::vector<int> sort_third_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpw8syvqoo.cpp:47:50: error: \u2018_MM_SORT_DESCENDING\u2019 was not declared in this scope\n   47 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                                                  ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpw8syvqoo.cpp:47:30: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   47 |         __m256i sorted_vec = _mm256_sort_ps(vec, _MM_SORT_DESCENDING);\n      |                              ^~~~~~~~~~~~~~\n      |                              _mm256_sqrt_ps\n"}
{"task_id": "SimdBench_79_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp89f5bi2h.cpp: In function \u2018float max_element_simd(std::vector<float>)\u2019:\n[REDACTED]/tmp89f5bi2h.cpp:34:21: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   34 |     float max_val = _mm256_extractf32_ps(v, 0);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_79_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkr60xv3q.cpp: In function \u2018float max_element_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpkr60xv3q.cpp:33:28: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in initialization\n   33 |     __m256 v = _mm_loadu_ps(&l[0]);\n      |                ~~~~~~~~~~~~^~~~~~~\n      |                            |\n      |                            __m128\n[REDACTED]/tmpkr60xv3q.cpp:37:25: error: cannot convert \u2018__m128\u2019 to \u2018__m256\u2019 in assignment\n   37 |         v = _mm_loadu_ps(&l[i]);\n      |             ~~~~~~~~~~~~^~~~~~~\n      |                         |\n      |                         __m128\n[REDACTED]/tmpkr60xv3q.cpp:38:28: error: cannot convert \u2018__m256\u2019 to \u2018__m128\u2019\n   38 |         max_v = _mm_max_ps(max_v, v);\n      |                            ^~~~~\n      |                            |\n      |                            __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpkr60xv3q.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:238:20: note:   initializing argument 1 of \u2018__m128 _mm_max_ps(__m128, __m128)\u2019\n  238 | _mm_max_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpkr60xv3q.cpp:16:\n[REDACTED]/tmpkr60xv3q.cpp:43:51: error: cannot convert a value of type \u2018__m256\u2019 to vector type \u2018__m128\u2019 which has different size\n   43 |         max_val = std::max(max_val, _mm_cvtss_f32(_mm_extract_ps(max_v, i)));\n      |                                                   ^~~~~~~~~~~~~~\n[REDACTED]/tmpkr60xv3q.cpp:43:51: error: cannot convert \u2018int\u2019 to \u2018__m128\u2019\n   43 |         max_val = std::max(max_val, _mm_cvtss_f32(_mm_extract_ps(max_v, i)));\n      |                                                   ^~~~~~~~~~~~~~\n      |                                                   |\n      |                                                   int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:973:23: note:   initializing argument 1 of \u2018float _mm_cvtss_f32(__m128)\u2019\n  973 | _mm_cvtss_f32 (__m128 __A)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_79_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp715llsxi.cpp: In function \u2018float max_element_simd(std::vector<float>)\u2019:\n[REDACTED]/tmp715llsxi.cpp:34:21: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   34 |     float max_val = _mm256_extractf32_ps(v, 0);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_79_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqfa9xq6a.cpp: In function \u2018float max_element_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpqfa9xq6a.cpp:34:21: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   34 |     float max_val = _mm256_extractf32_ps(v, 0);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_79_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5leg87qc.cpp: In function \u2018float max_element_simd(std::vector<float>)\u2019:\n[REDACTED]/tmp5leg87qc.cpp:34:21: error: \u2018_mm256_extractf32_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_extractf32x4_ps\u2019?\n   34 |     float max_val = _mm256_extractf32_ps(v, 0);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     _mm256_extractf32x4_ps\n"}
{"task_id": "SimdBench_80_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2s20177h.cpp: In function \u2018int fizz_buzz_simd(int)\u2019:\n[REDACTED]/tmp2s20177h.cpp:39:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   39 |     __m256i mask = _mm_set_epi32(1, 1, 1, 1);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp2s20177h.cpp:40:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   40 |     __m256i num = _mm_set_epi32(0, 0, 0, 0);\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmp2s20177h.cpp:43:15: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   43 |         num = _mm_loadu_si256((__m256i*)&i);\n      |               ^~~~~~~~~~~~~~~\n      |               _mm_loadu_si16\n[REDACTED]/tmp2s20177h.cpp:44:15: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   44 |         num = _mm_and_si256(num, mask);\n      |               ^~~~~~~~~~~~~\n      |               _mm_and_si64\n[REDACTED]/tmp2s20177h.cpp:45:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |         num = _mm_or_si256(num, _mm_cmpeq_epi32(num, _mm_set_epi32(7, 7, 7, 7)));\n      |                                                 ^~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2s20177h.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmp2s20177h.cpp:45:15: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   45 |         num = _mm_or_si256(num, _mm_cmpeq_epi32(num, _mm_set_epi32(7, 7, 7, 7)));\n      |               ^~~~~~~~~~~~\n      |               _mm_or_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp2s20177h.cpp:16:\n[REDACTED]/tmp2s20177h.cpp:46:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   46 |         count += _mm_popcnt_u32(_mm_extract_epi32(num, 0)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp2s20177h.cpp:47:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   47 |                  _mm_popcnt_u32(_mm_extract_epi32(num, 1)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp2s20177h.cpp:48:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   48 |                  _mm_popcnt_u32(_mm_extract_epi32(num, 2)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp2s20177h.cpp:49:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   49 |                  _mm_popcnt_u32(_mm_extract_epi32(num, 3));\n      |                                 ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_80_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpq2mmwu2t.cpp: In function \u2018int fizz_buzz_simd(int)\u2019:\n[REDACTED]/tmpq2mmwu2t.cpp:37:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i mask = _mm_set_epi32(0, 0, 0, 0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n"}
{"task_id": "SimdBench_80_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8iq_4aoa.cpp:41:68: error: macro \"_mm_test_all_zeros\" requires 2 arguments, but only 1 given\n   41 |         if ((n % 11 == 0 || n % 13 == 0) && _mm_test_all_zeros(mask)) {\n      |                                                                    ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp8iq_4aoa.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:89: note: macro \"_mm_test_all_zeros\" defined here\n   89 | #define _mm_test_all_zeros(M, V) _mm_testz_si128 ((M), (V))\n      | \n[REDACTED]/tmp8iq_4aoa.cpp: In function \u2018int fizz_buzz_simd(int)\u2019:\n[REDACTED]/tmp8iq_4aoa.cpp:37:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i mask = _mm_set_epi32(0, 0, 0, 0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp8iq_4aoa.cpp:41:45: error: \u2018_mm_test_all_zeros\u2019 was not declared in this scope\n   41 |         if ((n % 11 == 0 || n % 13 == 0) && _mm_test_all_zeros(mask)) {\n      |                                             ^~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8iq_4aoa.cpp:45:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |         mask = _mm_add_epi32(mask, _mm_set_epi32(n / 11, n / 13, n / 11, n / 13));\n      |                              ^~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp8iq_4aoa.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_80_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpigy4zead.cpp: In function \u2018int fizz_buzz_simd(int)\u2019:\n[REDACTED]/tmpigy4zead.cpp:41:86: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   41 |         if ((n % 11 == 0 || n % 13 == 0) && _mm256_testz_si256(mask, _mm256_set_epi32(n & 0xFF, n >> 8 & 0xFF, n >> 16 & 0xFF, n >> 24 & 0xFF))) {\n      |                                                                      ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpigy4zead.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_80_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpn7srd8lw.cpp: In function \u2018int fizz_buzz_simd(int)\u2019:\n[REDACTED]/tmpn7srd8lw.cpp:37:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i mask = _mm_set_epi32(0, 0, 0, 0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpn7srd8lw.cpp:16:\n[REDACTED]/tmpn7srd8lw.cpp:41:63: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         if ((n % 11 == 0 || n % 13 == 0) && _mm_test_all_ones(mask)) {\n      |                                                               ^\n      |                                                               |\n      |                                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpn7srd8lw.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpn7srd8lw.cpp:44:16: error: \u2018_mm_slli_si256\u2019 was not declared in this scope; did you mean \u2018_mm_slli_si64\u2019?\n   44 |         mask = _mm_slli_si256(mask, 4);\n      |                ^~~~~~~~~~~~~~\n      |                _mm_slli_si64\n"}
{"task_id": "SimdBench_81_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpt5_34eec.cpp: In lambda function:\n[REDACTED]/tmpt5_34eec.cpp:49:74: error: invalid operands of types \u2018float\u2019 and \u2018int\u2019 to binary \u2018operator%\u2019\n   49 |     std::copy_if(l.begin(), l.end(), temp.begin(), [](float x){ return x % 2 == 0; });\n      |                                                                        ~ ^ ~\n      |                                                                        |   |\n      |                                                                        |   int\n      |                                                                        float\n"}
{"task_id": "SimdBench_81_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpur98ojvv.cpp: In function \u2018std::vector<float> sort_even_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpur98ojvv.cpp:52:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   52 |         __m256 v = _mm256_loadu_ps(ptr + i * 8);\n      |                                    ~~~~^~~~~~~\n      |                                        |\n      |                                        __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpur98ojvv.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpur98ojvv.cpp:53:45: error: \u2018_MM_FROUND_TO_NEAREST_INT_PIO_2\u2019 was not declared in this scope\n   53 |         __m256 sorted_v = _mm256_sort_ps(v, _MM_FROUND_TO_NEAREST_INT_PIO_2);\n      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpur98ojvv.cpp:53:27: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   53 |         __m256 sorted_v = _mm256_sort_ps(v, _MM_FROUND_TO_NEAREST_INT_PIO_2);\n      |                           ^~~~~~~~~~~~~~\n      |                           _mm256_sqrt_ps\n[REDACTED]/tmpur98ojvv.cpp:54:30: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   54 |         _mm256_storeu_ps(ptr + i * 8, sorted_v);\n      |                          ~~~~^~~~~~~\n      |                              |\n      |                              __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n[REDACTED]/tmpur98ojvv.cpp:59:41: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   59 |         __m256 v1 = _mm256_loadu_ps(ptr + i);\n      |                                     ~~~~^~~\n      |                                         |\n      |                                         __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpur98ojvv.cpp:60:45: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   60 |         __m256 v2 = _mm256_loadu_ps(ptr + i + 4);\n      |                                     ~~~~~~~~^~~\n      |                                             |\n      |                                             __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpur98ojvv.cpp:62:30: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   62 |         _mm256_storeu_ps(ptr + i, sorted_v);\n      |                          ~~~~^~~\n      |                              |\n      |                              __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_81_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbtcmvaa0.cpp: In function \u2018std::vector<float> sort_even_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpbtcmvaa0.cpp:59:28: error: \u2018_mm256_sort_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_sqrt_ps\u2019?\n   59 |     __m256 sorted_v_even = _mm256_sort_ps(v_even);\n      |                            ^~~~~~~~~~~~~~\n      |                            _mm256_sqrt_ps\n"}
{"task_id": "SimdBench_81_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_81_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_82_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplfr71saw.cpp:38:97: error: macro \"_mm256_shuffle_epi32\" passed 3 arguments, but takes just 2\n   38 |         __m256i sum = _mm256_add_epi32(_mm256_add_epi32(vec, _mm256_shuffle_epi32(vec, vec, 0b01)), _mm256_shuffle_epi32(vec, vec, 0b10));\n      |                                                                                                 ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmplfr71saw.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:616: note: macro \"_mm256_shuffle_epi32\" defined here\n  616 | #define _mm256_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmplfr71saw.cpp:38:136: error: macro \"_mm256_shuffle_epi32\" passed 3 arguments, but takes just 2\n   38 |         __m256i sum = _mm256_add_epi32(_mm256_add_epi32(vec, _mm256_shuffle_epi32(vec, vec, 0b01)), _mm256_shuffle_epi32(vec, vec, 0b10));\n      |                                                                                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:616: note: macro \"_mm256_shuffle_epi32\" defined here\n  616 | #define _mm256_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmplfr71saw.cpp: In function \u2018bool triples_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmplfr71saw.cpp:38:62: error: \u2018_mm256_shuffle_epi32\u2019 was not declared in this scope\n   38 |         __m256i sum = _mm256_add_epi32(_mm256_add_epi32(vec, _mm256_shuffle_epi32(vec, vec, 0b01)), _mm256_shuffle_epi32(vec, vec, 0b10));\n      |                                                              ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_82_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_82_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxh4811t_.cpp: In function \u2018bool triples_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpxh4811t_.cpp:41:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   41 |         __m256 sum = _mm256_add_epi32(_mm256_add_epi32(a, b), c);\n      |                      ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      __m256i\n[REDACTED]/tmpxh4811t_.cpp:42:42: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   42 |         __m256 mask = _mm256_cmpgt_epi32(sum, _mm256_setzero_si256());\n      |                                          ^~~\n      |                                          |\n      |                                          __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpxh4811t_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:273:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpgt_epi32(__m256i, __m256i)\u2019\n  273 | _mm256_cmpgt_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmpxh4811t_.cpp:43:42: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   43 |         __m256 result = _mm256_and_si256(mask, _mm256_xor_si256(a, b));\n      |                                          ^~~~\n      |                                          |\n      |                                          __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:179:27: note:   initializing argument 1 of \u2018__m256i _mm256_and_si256(__m256i, __m256i)\u2019\n  179 | _mm256_and_si256 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpxh4811t_.cpp:44:46: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   44 |         __m256 xor_result = _mm256_xor_si256(result, c);\n      |                                              ^~~~~~\n      |                                              |\n      |                                              __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:913:27: note:   initializing argument 1 of \u2018__m256i _mm256_xor_si256(__m256i, __m256i)\u2019\n  913 | _mm256_xor_si256 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpxh4811t_.cpp:46:34: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   46 |         v0 = _mm256_or_si256(v0, xor_result);\n      |                                  ^~~~~~~~~~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:574:39: note:   initializing argument 2 of \u2018__m256i _mm256_or_si256(__m256i, __m256i)\u2019\n  574 | _mm256_or_si256 (__m256i __A, __m256i __B)\n      |                               ~~~~~~~~^~~\n[REDACTED]/tmpxh4811t_.cpp:47:34: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   47 |         v1 = _mm256_or_si256(v1, xor_result);\n      |                                  ^~~~~~~~~~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:574:39: note:   initializing argument 2 of \u2018__m256i _mm256_or_si256(__m256i, __m256i)\u2019\n  574 | _mm256_or_si256 (__m256i __A, __m256i __B)\n      |                               ~~~~~~~~^~~\n[REDACTED]/tmpxh4811t_.cpp:48:34: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   48 |         v2 = _mm256_or_si256(v2, xor_result);\n      |                                  ^~~~~~~~~~\n      |                                  |\n      |                                  __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:574:39: note:   initializing argument 2 of \u2018__m256i _mm256_or_si256(__m256i, __m256i)\u2019\n  574 | _mm256_or_si256 (__m256i __A, __m256i __B)\n      |                               ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_82_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmph6hrmodu.cpp: In function \u2018bool triples_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmph6hrmodu.cpp:42:24: error: \u2018_mm256_cmpneq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi32\u2019?\n   42 |         __m256i mask = _mm256_cmpneq_epi32(sum, v0);\n      |                        ^~~~~~~~~~~~~~~~~~~\n      |                        _mm256_cmpeq_epi32\n"}
{"task_id": "SimdBench_82_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpx8emqa22.cpp: In function \u2018bool triples_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpx8emqa22.cpp:45:21: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   45 |     __m256i count = _mm256_popcnt_u32(_mm256_movemask_epi8(mask));\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_popcnt_u32\n[REDACTED]/tmpx8emqa22.cpp:47:18: error: cannot convert \u2018__vector(4) long int\u2019 to \u2018bool\u2019 in return\n   47 |     return count > 0;\n      |            ~~~~~~^~~\n      |                  |\n      |                  __vector(4) long int\n"}
{"task_id": "SimdBench_83_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwok6bvui.cpp: In function \u2018std::vector<int> incr_list_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpwok6bvui.cpp:35:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |             ptr[i] = _mm_add_epi32(ptr[i], _mm_set1_epi32(1));\n      |                                    ~~~~~^\n      |                                         |\n      |                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpwok6bvui.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:40:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |             ptr[i] = _mm_add_epi32(ptr[i], _mm_set1_epi32(1));\n      |                                    ~~~~~^\n      |                                         |\n      |                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:41:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |             ptr[i + 1] = _mm_add_epi32(ptr[i + 1], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:42:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |             ptr[i + 2] = _mm_add_epi32(ptr[i + 2], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:43:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |             ptr[i + 3] = _mm_add_epi32(ptr[i + 3], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:44:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |             ptr[i + 4] = _mm_add_epi32(ptr[i + 4], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:45:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |             ptr[i + 5] = _mm_add_epi32(ptr[i + 5], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:46:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   46 |             ptr[i + 6] = _mm_add_epi32(ptr[i + 6], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpwok6bvui.cpp:47:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   47 |             ptr[i + 7] = _mm_add_epi32(ptr[i + 7], _mm_set1_epi32(1));\n      |                                        ~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_83_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp4cmbu6iu.cpp: In function \u2018std::vector<int> incr_list_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp4cmbu6iu.cpp:35:39: error: cannot convert \u2018const __m256*\u2019 to \u2018const __m256i_u*\u2019\n   35 |         __m256 v = _mm256_loadu_si256(reinterpret_cast<const __m256*>(&l[0]));\n      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       const __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp4cmbu6iu.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp4cmbu6iu.cpp:36:30: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   36 |         v = _mm256_add_epi32(v, _mm256_set1_epi32(1));\n      |                              ^\n      |                              |\n      |                              __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:27: note:   initializing argument 1 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmp4cmbu6iu.cpp:37:29: error: cannot convert \u2018__m256*\u2019 to \u2018__m256i_u*\u2019\n   37 |         _mm256_storeu_si256(reinterpret_cast<__m256*>(&l[0]), v);\n      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                             |\n      |                             __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:33: note:   initializing argument 1 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                      ~~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_83_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_06w2rdi.cpp: In function \u2018std::vector<int> incr_list_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp_06w2rdi.cpp:36:37: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |         __m256i mask = _mm_set_epi32(0, 0, 0, -1);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                     |\n      |                                     __m128i\n[REDACTED]/tmp_06w2rdi.cpp:38:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |             __m256i v = _mm_loadu_si256(ptr);\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmp_06w2rdi.cpp:39:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |             v = _mm_add_epi32(v, mask);\n      |                               ^\n      |                               |\n      |                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_06w2rdi.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp_06w2rdi.cpp:40:13: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   40 |             _mm_storeu_si256(ptr, v);\n      |             ^~~~~~~~~~~~~~~~\n      |             _mm_storeu_si16\n[REDACTED]/tmp_06w2rdi.cpp:46:41: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   46 |             __m128i mask = _mm_set_epi32(0, -1);\n      |                            ~~~~~~~~~~~~~^~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmp_06w2rdi.cpp:57:41: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   57 |             __m128i mask = _mm_set_epi32(-1);\n      |                            ~~~~~~~~~~~~~^~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmp_06w2rdi.cpp:68:41: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   68 |             __m128i mask = _mm_set_epi32(-1);\n      |                            ~~~~~~~~~~~~~^~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmp_06w2rdi.cpp:79:41: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   79 |             __m128i mask = _mm_set_epi32(-1);\n      |                            ~~~~~~~~~~~~~^~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmp_06w2rdi.cpp:90:41: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   90 |             __m128i mask = _mm_set_epi32(-1);\n      |                            ~~~~~~~~~~~~~^~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_83_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpq7mgrj7h.cpp: In function \u2018std::vector<int> incr_list_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpq7mgrj7h.cpp:45:13: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   45 |             _mm_storeu_si256(result_ptr, sum);\n      |             ^~~~~~~~~~~~~~~~\n      |             _mm_storeu_si16\n"}
{"task_id": "SimdBench_83_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_84_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp18moqroj.cpp: In function \u2018bool pairs_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp18moqroj.cpp:38:59: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   38 |         if (_mm256_movemask_epi8(_mm256_cmp_eq_epi32(sum, _mm_setzero_si256())) != 0) {\n      |                                                           ^~~~~~~~~~~~~~~~~\n      |                                                           _mm_setzero_si64\n[REDACTED]/tmp18moqroj.cpp:38:34: error: \u2018_mm256_cmp_eq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi32\u2019?\n   38 |         if (_mm256_movemask_epi8(_mm256_cmp_eq_epi32(sum, _mm_setzero_si256())) != 0) {\n      |                                  ^~~~~~~~~~~~~~~~~~~\n      |                                  _mm256_cmpeq_epi32\n"}
{"task_id": "SimdBench_84_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw600may9.cpp: In function \u2018bool pairs_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpw600may9.cpp:38:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         __m256i sum = _mm_add_epi32(a[i], b[i]);\n      |                                     ~~~^\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpw600may9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpw600may9.cpp:39:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         __m256i neg_sum = _mm_sub_epi32(sum, c[i]);\n      |                                         ^~~\n      |                                         |\n      |                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpw600may9.cpp:40:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         __m256i diff = _mm_sub_epi32(d[i], neg_sum);\n      |                                      ~~~^\n      |                                         |\n      |                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpw600may9.cpp:41:47: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   41 |         __m256i mask = _mm_cmpneq_epi32(diff, _mm_setzero_si256());\n      |                                               ^~~~~~~~~~~~~~~~~\n      |                                               _mm_setzero_si64\n[REDACTED]/tmpw600may9.cpp:41:24: error: \u2018_mm_cmpneq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_cmpeq_epi32\u2019?\n   41 |         __m256i mask = _mm_cmpneq_epi32(diff, _mm_setzero_si256());\n      |                        ^~~~~~~~~~~~~~~~\n      |                        _mm_cmpeq_epi32\n[REDACTED]/tmpw600may9.cpp:42:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         found |= _mm_movemask_epi8(mask) != 0;\n      |                                    ^~~~\n      |                                    |\n      |                                    __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_84_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpoh0vybzs.cpp: In function \u2018bool pairs_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpoh0vybzs.cpp:35:24: error: \u2018_mm256_cmpneq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi32\u2019?\n   35 |         __m256i mask = _mm256_cmpneq_epi32(diff, _mm256_setzero_si256()); // Create a mask indicating which elements differ from the zero vector\n      |                        ^~~~~~~~~~~~~~~~~~~\n      |                        _mm256_cmpeq_epi32\n[REDACTED]/tmpoh0vybzs.cpp:38:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   38 |     return _mm_testz_si256(v, v); // Check if all elements in the zero vector are zero\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_84_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_84_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7tzj8_gl.cpp: In function \u2018bool pairs_sum_to_zero_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp7tzj8_gl.cpp:31:33: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     __m256i v = _mm256_set_epi32(l[0], l[1], l[2], l[3]);\n      |                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp7tzj8_gl.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7tzj8_gl.cpp:32:54: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |     __m256i v_neg = _mm256_sub_epi32(_mm256_set_epi32(0, 0, 0, 0), v);\n      |                                      ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7tzj8_gl.cpp:36:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   36 |         __m256i v_i = _mm256_set_epi32(l[i], l[i+1], l[i+2], l[i+3]);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7tzj8_gl.cpp:37:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i v_i_neg = _mm256_sub_epi32(_mm256_set_epi32(0, 0, 0, 0), v_i);\n      |                                            ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7tzj8_gl.cpp:40:24: error: \u2018_mm256_cmpneq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi32\u2019?\n   40 |         __m256i mask = _mm256_cmpneq_epi32(v_sum, v_i_sum);\n      |                        ^~~~~~~~~~~~~~~~~~~\n      |                        _mm256_cmpeq_epi32\n[REDACTED]/tmp7tzj8_gl.cpp:41:65: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   41 |         __m256i result = _mm256_and_si256(mask, _mm256_set_epi32(1, 1, 1, 1));\n      |                                                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_85_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_85_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_85_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpcc7gski1.cpp: In function \u2018std::string change_base_simd(int64_t, int8_t)\u2019:\n[REDACTED]/tmpcc7gski1.cpp:44:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   44 |     __m256i x_vec = _mm256_set_epi64x((int64_t)x >> 32, (int64_t)x & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpcc7gski1.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpcc7gski1.cpp:45:39: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   45 |     __m256i base_vec = _mm256_set_epi8(base - 1, base - 1, base - 1, base - 1, base - 1, base - 1, base - 1, base - 1);\n      |                        ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpcc7gski1.cpp:48:33: error: \u2018_mm256_div_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi64\u2019?\n   48 |         __m256i remainder_vec = _mm256_div_epi64(x_vec, base_vec);\n      |                                 ^~~~~~~~~~~~~~~~\n      |                                 _mm256_min_epi64\n[REDACTED]/tmpcc7gski1.cpp:49:60: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   49 |         __m256i digit_vec = _mm256_sub_epi8(_mm256_set_epi8(9, 9, 9, 9, 9, 9, 9, 9), remainder_vec);\n      |                                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_85_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpp_itvobu.cpp:37:1: error: stray \u2018`\u2019 in program\n   37 | ```cpp\n      | ^\n[REDACTED]/tmpp_itvobu.cpp:37:2: error: stray \u2018`\u2019 in program\n   37 | ```cpp\n      |  ^\n[REDACTED]/tmpp_itvobu.cpp:37:3: error: stray \u2018`\u2019 in program\n   37 | ```cpp\n      |   ^\n[REDACTED]/tmpp_itvobu.cpp:37:4: error: \u2018cpp\u2019 does not name a type\n   37 | ```cpp\n      |    ^~~\n"}
{"task_id": "SimdBench_85_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_86_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7s2h9bj7.cpp: In function \u2018bool is_palindrome_simd(std::string)\u2019:\n[REDACTED]/tmp7s2h9bj7.cpp:32:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   32 |     __m256i mask = _mm_set1_epi8(0);\n      |                    ~~~~~~~~~~~~~^~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp7s2h9bj7.cpp:33:22: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   33 |     __m256i result = _mm_setzero_si256();\n      |                      ^~~~~~~~~~~~~~~~~\n      |                      _mm_setzero_si64\n[REDACTED]/tmp7s2h9bj7.cpp:36:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |         __m256i word = _mm_loadu_si256((__m256i*)&text[i * 4]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmp7s2h9bj7.cpp:37:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i reversed_word = _mm_shuffle_epi8(word, word);\n      |                                                  ^~~~\n      |                                                  |\n      |                                                  __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37,\n                 from [REDACTED]/tmp7s2h9bj7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmp7s2h9bj7.cpp:39:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         result = _mm_or_si256(result, _mm_cmpeq_epi8(word, reversed_word));\n      |                                                      ^~~~\n      |                                                      |\n      |                                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp7s2h9bj7.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp7s2h9bj7.cpp:39:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   39 |         result = _mm_or_si256(result, _mm_cmpeq_epi8(word, reversed_word));\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmp7s2h9bj7.cpp:44:39: error: \u2018_mm_cmpneq_epi8\u2019 was not declared in this scope; did you mean \u2018_mm_cmpeq_epi8\u2019?\n   44 |         result = _mm_or_si256(result, _mm_cmpneq_epi8(_mm_set1_epi8(c), _mm_set1_epi8(text[n - i - 1])));\n      |                                       ^~~~~~~~~~~~~~~\n      |                                       _mm_cmpeq_epi8\n[REDACTED]/tmp7s2h9bj7.cpp:44:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   44 |         result = _mm_or_si256(result, _mm_cmpneq_epi8(_mm_set1_epi8(c), _mm_set1_epi8(text[n - i - 1])));\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmp7s2h9bj7.cpp:47:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   47 |     return _mm_movemask_epi8(result) == 0;\n      |                              ^~~~~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_86_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpaz9_tmz6.cpp: In function \u2018bool is_palindrome_simd(std::string)\u2019:\n[REDACTED]/tmpaz9_tmz6.cpp:32:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   32 |     __m256i vec1 = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpaz9_tmz6.cpp:36:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |         __m256i word = _mm_loadu_si256((__m256i*)&text[i * 4]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmpaz9_tmz6.cpp:37:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   37 |         vec1 = _mm_or_si256(vec1, word);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpaz9_tmz6.cpp:38:16: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   38 |         vec2 = _mm_xor_si256(vec2, word);\n      |                ^~~~~~~~~~~~~\n      |                _mm_xor_si64\n[REDACTED]/tmpaz9_tmz6.cpp:43:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   43 |         vec1 = _mm_or_si256(vec1, _mm_loadu_si32((int*)&text[i]));\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpaz9_tmz6.cpp:44:16: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   44 |         vec2 = _mm_xor_si256(vec2, _mm_loadu_si32((int*)&text[i]));\n      |                ^~~~~~~~~~~~~\n      |                _mm_xor_si64\n[REDACTED]/tmpaz9_tmz6.cpp:48:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   48 |     return _mm_testz_si256(vec1, vec1);\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_86_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpojyjzf4l.cpp:27:1: error: stray \u2018`\u2019 in program\n   27 | ```c++\n      | ^\n[REDACTED]/tmpojyjzf4l.cpp:27:2: error: stray \u2018`\u2019 in program\n   27 | ```c++\n      |  ^\n[REDACTED]/tmpojyjzf4l.cpp:27:3: error: stray \u2018`\u2019 in program\n   27 | ```c++\n      |   ^\n[REDACTED]/tmpojyjzf4l.cpp:27:4: error: \u2018c\u2019 does not name a type\n   27 | ```c++\n      |    ^\n"}
{"task_id": "SimdBench_86_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpj77stv8y.cpp: In function \u2018bool is_palindrome_simd(std::string)\u2019:\n[REDACTED]/tmpj77stv8y.cpp:35:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   35 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpj77stv8y.cpp:36:20: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |     __m256i left = _mm_loadu_si256((__m256i*)&text[0]);\n      |                    ^~~~~~~~~~~~~~~\n      |                    _mm_loadu_si16\n[REDACTED]/tmpj77stv8y.cpp:40:31: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         mask = _mm_cmpeq_epi8(left, right);\n      |                               ^~~~\n      |                               |\n      |                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpj77stv8y.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpj77stv8y.cpp:46:27: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   46 |     mask = _mm_cmpeq_epi8(left, right);\n      |                           ^~~~\n      |                           |\n      |                           __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpj77stv8y.cpp:47:27: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in assignment\n   47 |     left = _mm_loadu_si128((__m128i*)&text[32]);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           __m128i\n[REDACTED]/tmpj77stv8y.cpp:48:28: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in assignment\n   48 |     right = _mm_loadu_si128((__m128i*)&text[len-32]);\n      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                            |\n      |                            __m128i\n[REDACTED]/tmpj77stv8y.cpp:49:32: error: \u2018_mm_cmpneq_epi8\u2019 was not declared in this scope; did you mean \u2018_mm_cmpeq_epi8\u2019?\n   49 |     mask = _mm_and_si128(mask, _mm_cmpneq_epi8(left, right));\n      |                                ^~~~~~~~~~~~~~~\n      |                                _mm_cmpeq_epi8\n[REDACTED]/tmpj77stv8y.cpp:51:28: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   51 |     return _mm_testz_si128(mask, mask);\n      |                            ^~~~\n      |                            |\n      |                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpj77stv8y.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:67:26: note:   initializing argument 1 of \u2018int _mm_testz_si128(__m128i, __m128i)\u2019\n   67 | _mm_testz_si128 (__m128i __M, __m128i __V)\n      |                  ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_86_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpel05kc3o.cpp: In function \u2018bool is_palindrome_simd(std::string)\u2019:\n[REDACTED]/tmpel05kc3o.cpp:44:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   44 |         __m256 cmp = _mm256_cmpeq_epi8(vec1, vec2);\n      |                      ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                       |\n      |                                       __m256i\n[REDACTED]/tmpel05kc3o.cpp:47:33: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   47 |         if(_mm256_movemask_epi8(cmp) != 0){\n      |                                 ^~~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpel05kc3o.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:433:31: note:   initializing argument 1 of \u2018int _mm256_movemask_epi8(__m256i)\u2019\n  433 | _mm256_movemask_epi8 (__m256i __A)\n      |                       ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_87_AVX", "passed": false, "result": "failed: Command '['/usr/bin/g++', '/home/diac/private/SimdBench-1B3F/simdbench/simdbench_gs49c6ed/tmpmjbex6q_.cpp', '-mavx', '-mavx2', '-std=c++17', '-I/home/diac/private/SimdBench-1B3F/simdbench/../simdbench/utils', '-O0', '-o', '/home/diac/private/SimdBench-1B3F/simdbench/simdbench_gs49c6ed/tmpmjbex6q_.out']' timed out after 3.75 seconds"}
{"task_id": "SimdBench_87_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8grakm8p.cpp:29:1: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      | ^\n[REDACTED]/tmp8grakm8p.cpp:29:2: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |  ^\n[REDACTED]/tmp8grakm8p.cpp:29:3: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |   ^\n[REDACTED]/tmp8grakm8p.cpp:29:4: error: \u2018c\u2019 does not name a type\n   29 | ```c++\n      |    ^\n[REDACTED]/tmp8grakm8p.cpp:44:1: error: ISO C++ forbids declaration of \u2018decode_shift_simd\u2019 with no type [-fpermissive]\n   44 | decode_shift_simd(std::string s){\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8grakm8p.cpp: In function \u2018int decode_shift_simd(std::string)\u2019:\n[REDACTED]/tmp8grakm8p.cpp:205:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018257\u2019 to \u20181\u2019 [-Woverflow]\n  205 |     __m256i v129 = _mm256_set1_epi8((int)'a' + 160);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:210:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018262\u2019 to \u20186\u2019 [-Woverflow]\n  210 |     __m256i v133 = _mm256_set1_epi8((int)'a' + 165);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:215:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018267\u2019 to \u201811\u2019 [-Woverflow]\n  215 |     __m256i v137 = _mm256_set1_epi8((int)'a' + 170);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:220:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018272\u2019 to \u201816\u2019 [-Woverflow]\n  220 |     __m256i v141 = _mm256_set1_epi8((int)'a' + 175);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:225:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018277\u2019 to \u201821\u2019 [-Woverflow]\n  225 |     __m256i v145 = _mm256_set1_epi8((int)'a' + 180);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:230:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018282\u2019 to \u201826\u2019 [-Woverflow]\n  230 |     __m256i v149 = _mm256_set1_epi8((int)'a' + 185);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:235:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018287\u2019 to \u201831\u2019 [-Woverflow]\n  235 |     __m256i v153 = _mm256_set1_epi8((int)'a' + 190);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:240:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018292\u2019 to \u201836\u2019 [-Woverflow]\n  240 |     __m256i v157 = _mm256_set1_epi8((int)'a' + 195);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:242:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018260\u2019 to \u20184\u2019 [-Woverflow]\n  242 |     __m256i v159 = _mm256_set1_epi8((int)'A' + 195);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:243:5: error: \u2018__m260\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  243 |     __m260 = _mm256_set1_epi8((int)'Z' - 195);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:245:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018297\u2019 to \u201841\u2019 [-Woverflow]\n  245 |     __m256i v161 = _mm256_set1_epi8((int)'a' + 200);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:247:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018265\u2019 to \u20189\u2019 [-Woverflow]\n  247 |     __m256i v163 = _mm256_set1_epi8((int)'A' + 200);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:248:5: error: \u2018__m264\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  248 |     __m264 = _mm256_set1_epi8((int)'Z' - 200);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:250:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018302\u2019 to \u201846\u2019 [-Woverflow]\n  250 |     __m256i v165 = _mm256_set1_epi8((int)'a' + 205);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:252:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018270\u2019 to \u201814\u2019 [-Woverflow]\n  252 |     __m256i v167 = _mm256_set1_epi8((int)'A' + 205);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:253:5: error: \u2018__m268\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  253 |     __m268 = _mm256_set1_epi8((int)'Z' - 205);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:255:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018307\u2019 to \u201851\u2019 [-Woverflow]\n  255 |     __m256i v169 = _mm256_set1_epi8((int)'a' + 210);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:257:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018275\u2019 to \u201819\u2019 [-Woverflow]\n  257 |     __m256i v171 = _mm256_set1_epi8((int)'A' + 210);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:258:5: error: \u2018__m272\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  258 |     __m272 = _mm256_set1_epi8((int)'Z' - 210);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmp8grakm8p.cpp:260:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018312\u2019 to \u201856\u2019 [-Woverflow]\n  260 |     __m256i v173 = _mm256_set1_epi8((int)'a' + 215);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:262:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018280\u2019 to \u201824\u2019 [-Woverflow]\n  262 |     __m256i v175 = _mm256_set1_epi8((int)'A' + 215);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:263:5: error: \u2018__m276\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  263 |     __m276 = _mm256_set1_epi8((int)'Z' - 215);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:265:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018317\u2019 to \u201861\u2019 [-Woverflow]\n  265 |     __m256i v177 = _mm256_set1_epi8((int)'a' + 220);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:267:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018285\u2019 to \u201829\u2019 [-Woverflow]\n  267 |     __m256i v179 = _mm256_set1_epi8((int)'A' + 220);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:268:5: error: \u2018__m280\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  268 |     __m280 = _mm256_set1_epi8((int)'Z' - 220);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:268:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-130\u2019 to \u2018126\u2019 [-Woverflow]\n  268 |     __m280 = _mm256_set1_epi8((int)'Z' - 220);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:270:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018322\u2019 to \u201866\u2019 [-Woverflow]\n  270 |     __m256i v181 = _mm256_set1_epi8((int)'a' + 225);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:272:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018290\u2019 to \u201834\u2019 [-Woverflow]\n  272 |     __m256i v183 = _mm256_set1_epi8((int)'A' + 225);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:273:5: error: \u2018__m284\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  273 |     __m284 = _mm256_set1_epi8((int)'Z' - 225);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:273:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-135\u2019 to \u2018121\u2019 [-Woverflow]\n  273 |     __m284 = _mm256_set1_epi8((int)'Z' - 225);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:275:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018327\u2019 to \u201871\u2019 [-Woverflow]\n  275 |     __m256i v185 = _mm256_set1_epi8((int)'a' + 230);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:277:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018295\u2019 to \u201839\u2019 [-Woverflow]\n  277 |     __m256i v187 = _mm256_set1_epi8((int)'A' + 230);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:278:5: error: \u2018__m288\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  278 |     __m288 = _mm256_set1_epi8((int)'Z' - 230);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:278:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-140\u2019 to \u2018116\u2019 [-Woverflow]\n  278 |     __m288 = _mm256_set1_epi8((int)'Z' - 230);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:280:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018337\u2019 to \u201881\u2019 [-Woverflow]\n  280 |     __m256i v189 = _mm256_set1_epi8((int)'a' + 240);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:282:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018305\u2019 to \u201849\u2019 [-Woverflow]\n  282 |     __m256i v191 = _mm256_set1_epi8((int)'A' + 240);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:283:5: error: \u2018__m292\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  283 |     __m292 = _mm256_set1_epi8((int)'Z' - 240);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmp8grakm8p.cpp:283:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-150\u2019 to \u2018106\u2019 [-Woverflow]\n  283 |     __m292 = _mm256_set1_epi8((int)'Z' - 240);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:285:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018342\u2019 to \u201886\u2019 [-Woverflow]\n  285 |     __m256i v193 = _mm256_set1_epi8((int)'a' + 245);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:287:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018310\u2019 to \u201854\u2019 [-Woverflow]\n  287 |     __m256i v195 = _mm256_set1_epi8((int)'A' + 245);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:288:5: error: \u2018__m296\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  288 |     __m296 = _mm256_set1_epi8((int)'Z' - 245);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:288:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-155\u2019 to \u2018101\u2019 [-Woverflow]\n  288 |     __m296 = _mm256_set1_epi8((int)'Z' - 245);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:290:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018347\u2019 to \u201891\u2019 [-Woverflow]\n  290 |     __m256i v197 = _mm256_set1_epi8((int)'a' + 250);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:292:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018315\u2019 to \u201859\u2019 [-Woverflow]\n  292 |     __m256i v199 = _mm256_set1_epi8((int)'A' + 250);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:293:5: error: \u2018__m300\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  293 |     __m300 = _mm256_set1_epi8((int)'Z' - 250);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:293:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-160\u2019 to \u201896\u2019 [-Woverflow]\n  293 |     __m300 = _mm256_set1_epi8((int)'Z' - 250);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:295:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018352\u2019 to \u201896\u2019 [-Woverflow]\n  295 |     __m256i v301 = _mm256_set1_epi8((int)'a' + 255);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:296:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-133\u2019 to \u2018123\u2019 [-Woverflow]\n  296 |     __m256i v302 = _mm256_set1_epi8((int)'z' - 255);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:297:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018320\u2019 to \u201864\u2019 [-Woverflow]\n  297 |     __m256i v303 = _mm256_set1_epi8((int)'A' + 255);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:298:5: error: \u2018__m304\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  298 |     __m304 = _mm256_set1_epi8((int)'Z' - 255);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:298:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-165\u2019 to \u201891\u2019 [-Woverflow]\n  298 |     __m304 = _mm256_set1_epi8((int)'Z' - 255);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:300:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018357\u2019 to \u2018101\u2019 [-Woverflow]\n  300 |     __m256i v305 = _mm256_set1_epi8((int)'a' + 260);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:301:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-138\u2019 to \u2018118\u2019 [-Woverflow]\n  301 |     __m256i v306 = _mm256_set1_epi8((int)'z' - 260);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:302:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018325\u2019 to \u201869\u2019 [-Woverflow]\n  302 |     __m256i v307 = _mm256_set1_epi8((int)'A' + 260);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:303:5: error: \u2018__m308\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  303 |     __m308 = _mm256_set1_epi8((int)'Z' - 260);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:303:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-170\u2019 to \u201886\u2019 [-Woverflow]\n  303 |     __m308 = _mm256_set1_epi8((int)'Z' - 260);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:305:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018362\u2019 to \u2018106\u2019 [-Woverflow]\n  305 |     __m256i v309 = _mm256_set1_epi8((int)'a' + 265);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:306:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-143\u2019 to \u2018113\u2019 [-Woverflow]\n  306 |     __m260 = _mm256_set1_epi8((int)'z' - 265);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:307:5: error: \u2018__m261\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  307 |     __m261 = _mm256_set1_epi8((int)'A' + 265);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:307:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018330\u2019 to \u201874\u2019 [-Woverflow]\n  307 |     __m261 = _mm256_set1_epi8((int)'A' + 265);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:308:5: error: \u2018__m312\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  308 |     __m312 = _mm256_set1_epi8((int)'Z' - 265);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmp8grakm8p.cpp:308:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-175\u2019 to \u201881\u2019 [-Woverflow]\n  308 |     __m312 = _mm256_set1_epi8((int)'Z' - 265);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:310:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018367\u2019 to \u2018111\u2019 [-Woverflow]\n  310 |     __m256i v313 = _mm256_set1_epi8((int)'a' + 270);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:311:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-148\u2019 to \u2018108\u2019 [-Woverflow]\n  311 |     __m264 = _mm256_set1_epi8((int)'z' - 270);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:312:5: error: \u2018__m265\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  312 |     __m265 = _mm256_set1_epi8((int)'A' + 270);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:312:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018335\u2019 to \u201879\u2019 [-Woverflow]\n  312 |     __m265 = _mm256_set1_epi8((int)'A' + 270);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:313:5: error: \u2018__m316\u2019 was not declared in this scope; did you mean \u2018__m16\u2019?\n  313 |     __m316 = _mm256_set1_epi8((int)'Z' - 270);\n      |     ^~~~~~\n      |     __m16\n[REDACTED]/tmp8grakm8p.cpp:313:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-180\u2019 to \u201876\u2019 [-Woverflow]\n  313 |     __m316 = _mm256_set1_epi8((int)'Z' - 270);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:315:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018372\u2019 to \u2018116\u2019 [-Woverflow]\n  315 |     __m256i v317 = _mm256_set1_epi8((int)'a' + 275);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:316:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-153\u2019 to \u2018103\u2019 [-Woverflow]\n  316 |     __m268 = _mm256_set1_epi8((int)'z' - 275);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:317:5: error: \u2018__m269\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  317 |     __m269 = _mm256_set1_epi8((int)'A' + 275);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:317:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018340\u2019 to \u201884\u2019 [-Woverflow]\n  317 |     __m269 = _mm256_set1_epi8((int)'A' + 275);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:318:5: error: \u2018__m320\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  318 |     __m320 = _mm256_set1_epi8((int)'Z' - 275);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:318:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-185\u2019 to \u201871\u2019 [-Woverflow]\n  318 |     __m320 = _mm256_set1_epi8((int)'Z' - 275);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:320:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018377\u2019 to \u2018121\u2019 [-Woverflow]\n  320 |     __m256i v321 = _mm256_set1_epi8((int)'a' + 280);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:321:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-158\u2019 to \u201898\u2019 [-Woverflow]\n  321 |     __m272 = _mm256_set1_epi8((int)'z' - 280);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:322:5: error: \u2018__m273\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  322 |     __m273 = _mm256_set1_epi8((int)'A' + 280);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:322:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018345\u2019 to \u201889\u2019 [-Woverflow]\n  322 |     __m273 = _mm256_set1_epi8((int)'A' + 280);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:323:5: error: \u2018__m324\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  323 |     __m324 = _mm256_set1_epi8((int)'Z' - 280);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:323:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-190\u2019 to \u201866\u2019 [-Woverflow]\n  323 |     __m324 = _mm256_set1_epi8((int)'Z' - 280);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:325:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018382\u2019 to \u2018126\u2019 [-Woverflow]\n  325 |     __m256i v325 = _mm256_set1_epi8((int)'a' + 285);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:326:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-163\u2019 to \u201893\u2019 [-Woverflow]\n  326 |     __m276 = _mm256_set1_epi8((int)'z' - 285);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:327:5: error: \u2018__m277\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  327 |     __m277 = _mm256_set1_epi8((int)'A' + 285);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:327:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018350\u2019 to \u201894\u2019 [-Woverflow]\n  327 |     __m277 = _mm256_set1_epi8((int)'A' + 285);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:328:5: error: \u2018__m328\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  328 |     __m328 = _mm256_set1_epi8((int)'Z' - 285);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:328:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-195\u2019 to \u201861\u2019 [-Woverflow]\n  328 |     __m328 = _mm256_set1_epi8((int)'Z' - 285);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:330:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018387\u2019 to \u2018-125\u2019 [-Woverflow]\n  330 |     __m256i v329 = _mm256_set1_epi8((int)'a' + 290);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:331:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-168\u2019 to \u201888\u2019 [-Woverflow]\n  331 |     __m280 = _mm256_set1_epi8((int)'z' - 290);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:332:5: error: \u2018__m281\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  332 |     __m281 = _mm256_set1_epi8((int)'A' + 290);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:332:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018355\u2019 to \u201899\u2019 [-Woverflow]\n  332 |     __m281 = _mm256_set1_epi8((int)'A' + 290);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:333:5: error: \u2018__m332\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  333 |     __m332 = _mm256_set1_epi8((int)'Z' - 290);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:333:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-200\u2019 to \u201856\u2019 [-Woverflow]\n  333 |     __m332 = _mm256_set1_epi8((int)'Z' - 290);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:335:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018392\u2019 to \u2018-120\u2019 [-Woverflow]\n  335 |     __m256i v333 = _mm256_set1_epi8((int)'a' + 295);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:336:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-173\u2019 to \u201883\u2019 [-Woverflow]\n  336 |     __m284 = _mm256_set1_epi8((int)'z' - 295);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:337:5: error: \u2018__m285\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  337 |     __m285 = _mm256_set1_epi8((int)'A' + 295);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:337:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018360\u2019 to \u2018104\u2019 [-Woverflow]\n  337 |     __m285 = _mm256_set1_epi8((int)'A' + 295);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:338:5: error: \u2018__m336\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  338 |     __m336 = _mm256_set1_epi8((int)'Z' - 295);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:338:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-205\u2019 to \u201851\u2019 [-Woverflow]\n  338 |     __m336 = _mm256_set1_epi8((int)'Z' - 295);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:340:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018397\u2019 to \u2018-115\u2019 [-Woverflow]\n  340 |     __m256i v337 = _mm256_set1_epi8((int)'a' + 300);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:341:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-178\u2019 to \u201878\u2019 [-Woverflow]\n  341 |     __m288 = _mm256_set1_epi8((int)'z' - 300);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:342:5: error: \u2018__m289\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  342 |     __m289 = _mm256_set1_epi8((int)'A' + 300);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:342:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018365\u2019 to \u2018109\u2019 [-Woverflow]\n  342 |     __m289 = _mm256_set1_epi8((int)'A' + 300);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:343:5: error: \u2018__m340\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  343 |     __m340 = _mm256_set1_epi8((int)'Z' - 300);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:343:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-210\u2019 to \u201846\u2019 [-Woverflow]\n  343 |     __m340 = _mm256_set1_epi8((int)'Z' - 300);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:345:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018402\u2019 to \u2018-110\u2019 [-Woverflow]\n  345 |     __m256i v341 = _mm256_set1_epi8((int)'a' + 305);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:346:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-183\u2019 to \u201873\u2019 [-Woverflow]\n  346 |     __m292 = _mm256_set1_epi8((int)'z' - 305);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:347:5: error: \u2018__m293\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  347 |     __m293 = _mm256_set1_epi8((int)'A' + 305);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:347:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018370\u2019 to \u2018114\u2019 [-Woverflow]\n  347 |     __m293 = _mm256_set1_epi8((int)'A' + 305);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:348:5: error: \u2018__m344\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  348 |     __m344 = _mm256_set1_epi8((int)'Z' - 305);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:348:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-215\u2019 to \u201841\u2019 [-Woverflow]\n  348 |     __m344 = _mm256_set1_epi8((int)'Z' - 305);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:350:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018407\u2019 to \u2018-105\u2019 [-Woverflow]\n  350 |     __m256i v345 = _mm256_set1_epi8((int)'a' + 310);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:351:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-188\u2019 to \u201868\u2019 [-Woverflow]\n  351 |     __m296 = _mm256_set1_epi8((int)'z' - 310);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:352:5: error: \u2018__m297\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  352 |     __m297 = _mm256_set1_epi8((int)'A' + 310);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:352:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018375\u2019 to \u2018119\u2019 [-Woverflow]\n  352 |     __m297 = _mm256_set1_epi8((int)'A' + 310);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:353:5: error: \u2018__m348\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  353 |     __m348 = _mm256_set1_epi8((int)'Z' - 310);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:353:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-220\u2019 to \u201836\u2019 [-Woverflow]\n  353 |     __m348 = _mm256_set1_epi8((int)'Z' - 310);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:355:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018412\u2019 to \u2018-100\u2019 [-Woverflow]\n  355 |     __m256i v351 = _mm256_set1_epi8((int)'a' + 315);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:356:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-193\u2019 to \u201863\u2019 [-Woverflow]\n  356 |     __m300 = _mm256_set1_epi8((int)'z' - 315);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:357:5: error: \u2018__m301\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  357 |     __m301 = _mm256_set1_epi8((int)'A' + 315);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:357:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018380\u2019 to \u2018124\u2019 [-Woverflow]\n  357 |     __m301 = _mm256_set1_epi8((int)'A' + 315);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:358:5: error: \u2018__m352\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  358 |     __m352 = _mm256_set1_epi8((int)'Z' - 315);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:358:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-225\u2019 to \u201831\u2019 [-Woverflow]\n  358 |     __m352 = _mm256_set1_epi8((int)'Z' - 315);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:360:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018417\u2019 to \u2018-95\u2019 [-Woverflow]\n  360 |     __m256i v353 = _mm256_set1_epi8((int)'a' + 320);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:361:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-198\u2019 to \u201858\u2019 [-Woverflow]\n  361 |     __m304 = _mm256_set1_epi8((int)'z' - 320);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:362:5: error: \u2018__m305\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  362 |     __m305 = _mm256_set1_epi8((int)'A' + 320);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmp8grakm8p.cpp:362:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018385\u2019 to \u2018-127\u2019 [-Woverflow]\n  362 |     __m305 = _mm256_set1_epi8((int)'A' + 320);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:363:5: error: \u2018__m356\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  363 |     __m356 = _mm256_set1_epi8((int)'Z' - 320);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmp8grakm8p.cpp:363:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-230\u2019 to \u201826\u2019 [-Woverflow]\n  363 |     __m356 = _mm256_set1_epi8((int)'Z' - 320);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:365:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018422\u2019 to \u2018-90\u2019 [-Woverflow]\n  365 |     __m256i v357 = _mm256_set1_epi8((int)'a' + 325);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:366:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-203\u2019 to \u201853\u2019 [-Woverflow]\n  366 |     __m308 = _mm256_set1_epi8((int)'z' - 325);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:367:5: error: \u2018__m310\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  367 |     __m310 = _mm256_set1_epi8((int)'A' + 325);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmp8grakm8p.cpp:367:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018390\u2019 to \u2018-122\u2019 [-Woverflow]\n  367 |     __m310 = _mm256_set1_epi8((int)'A' + 325);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmp8grakm8p.cpp:368:5: error: \u2018__m360\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  368 |     __m360 = _mm25\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmp8grakm8p.cpp:368:14: error: \u2018_mm25\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  368 |     __m360 = _mm25\n      |              ^~~~~\n      |              __m256\n[REDACTED]/tmp8grakm8p.cpp:380:21: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  380 | bool humaneval_check() {\n      |                     ^~\n[REDACTED]/tmp8grakm8p.cpp:380:21: note: remove parentheses to default-initialize a variable\n  380 | bool humaneval_check() {\n      |                     ^~\n      |                     --\n[REDACTED]/tmp8grakm8p.cpp:380:21: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmp8grakm8p.cpp:380:24: error: a function-definition is not allowed here before \u2018{\u2019 token\n  380 | bool humaneval_check() {\n      |                        ^\n[REDACTED]/tmp8grakm8p.cpp:398:40: error: a function-definition is not allowed here before \u2018{\u2019 token\n  398 | bool correctness_check(int iterations) {\n      |                                        ^\n[REDACTED]/tmp8grakm8p.cpp:420:9: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  420 | int main(){\n      |         ^~\n[REDACTED]/tmp8grakm8p.cpp:420:9: note: remove parentheses to default-initialize a variable\n  420 | int main(){\n      |         ^~\n      |         --\n[REDACTED]/tmp8grakm8p.cpp:420:9: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmp8grakm8p.cpp:420:11: error: a function-definition is not allowed here before \u2018{\u2019 token\n  420 | int main(){\n      |           ^\n[REDACTED]/tmp8grakm8p.cpp:424:2: error: expected \u2018}\u2019 at end of input\n  424 | }\n      |  ^\n[REDACTED]/tmp8grakm8p.cpp:44:33: note: to match this \u2018{\u2019\n   44 | decode_shift_simd(std::string s){\n      |                                 ^\n[REDACTED]/tmp8grakm8p.cpp:424:2: warning: no return statement in function returning non-void [-Wreturn-type]\n  424 | }\n      |  ^\n"}
{"task_id": "SimdBench_87_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6nq3jgpr.cpp:29:1: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      | ^\n[REDACTED]/tmp6nq3jgpr.cpp:29:2: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |  ^\n[REDACTED]/tmp6nq3jgpr.cpp:29:3: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |   ^\n[REDACTED]/tmp6nq3jgpr.cpp:29:4: error: \u2018c\u2019 does not name a type\n   29 | ```c++\n      |    ^\n[REDACTED]/tmp6nq3jgpr.cpp:44:1: error: ISO C++ forbids declaration of \u2018decode_shift_simd\u2019 with no type [-fpermissive]\n   44 | decode_shift_simd(std::string s){\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp6nq3jgpr.cpp: In function \u2018int decode_shift_simd(std::string)\u2019:\n[REDACTED]/tmp6nq3jgpr.cpp:81:13: error: redeclaration of \u2018__m256i vw\u2019\n   81 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:82:13: error: redeclaration of \u2018__m256i vx\u2019\n   82 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:83:13: error: redeclaration of \u2018__m256i vy\u2019\n   83 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:84:13: error: redeclaration of \u2018__m256i vz\u2019\n   84 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:85:13: error: redeclaration of \u2018__m256i vw\u2019\n   85 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:86:13: error: redeclaration of \u2018__m256i vx\u2019\n   86 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:87:13: error: redeclaration of \u2018__m256i vy\u2019\n   87 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:88:13: error: redeclaration of \u2018__m256i vz\u2019\n   88 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:89:13: error: redeclaration of \u2018__m256i vw\u2019\n   89 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:90:13: error: redeclaration of \u2018__m256i vx\u2019\n   90 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:91:13: error: redeclaration of \u2018__m256i vy\u2019\n   91 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:92:13: error: redeclaration of \u2018__m256i vz\u2019\n   92 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:93:13: error: redeclaration of \u2018__m256i vw\u2019\n   93 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:94:13: error: redeclaration of \u2018__m256i vx\u2019\n   94 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:95:13: error: redeclaration of \u2018__m256i vy\u2019\n   95 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:96:13: error: redeclaration of \u2018__m256i vz\u2019\n   96 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:97:13: error: redeclaration of \u2018__m256i vw\u2019\n   97 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:98:13: error: redeclaration of \u2018__m256i vx\u2019\n   98 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:99:13: error: redeclaration of \u2018__m256i vy\u2019\n   99 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:100:13: error: redeclaration of \u2018__m256i vz\u2019\n  100 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:101:13: error: redeclaration of \u2018__m256i vw\u2019\n  101 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:102:13: error: redeclaration of \u2018__m256i vx\u2019\n  102 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:103:13: error: redeclaration of \u2018__m256i vy\u2019\n  103 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:104:13: error: redeclaration of \u2018__m256i vz\u2019\n  104 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:105:13: error: redeclaration of \u2018__m256i vw\u2019\n  105 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:106:13: error: redeclaration of \u2018__m256i vx\u2019\n  106 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:107:13: error: redeclaration of \u2018__m256i vy\u2019\n  107 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:108:13: error: redeclaration of \u2018__m256i vz\u2019\n  108 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:109:13: error: redeclaration of \u2018__m256i vw\u2019\n  109 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:110:13: error: redeclaration of \u2018__m256i vx\u2019\n  110 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:111:13: error: redeclaration of \u2018__m256i vy\u2019\n  111 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:112:13: error: redeclaration of \u2018__m256i vz\u2019\n  112 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:113:13: error: redeclaration of \u2018__m256i vw\u2019\n  113 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:114:13: error: redeclaration of \u2018__m256i vx\u2019\n  114 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:115:13: error: redeclaration of \u2018__m256i vy\u2019\n  115 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:116:13: error: redeclaration of \u2018__m256i vz\u2019\n  116 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:117:13: error: redeclaration of \u2018__m256i vw\u2019\n  117 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:118:13: error: redeclaration of \u2018__m256i vx\u2019\n  118 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:119:13: error: redeclaration of \u2018__m256i vy\u2019\n  119 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:120:13: error: redeclaration of \u2018__m256i vz\u2019\n  120 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:121:13: error: redeclaration of \u2018__m256i vw\u2019\n  121 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:122:13: error: redeclaration of \u2018__m256i vx\u2019\n  122 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:123:13: error: redeclaration of \u2018__m256i vy\u2019\n  123 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:124:13: error: redeclaration of \u2018__m256i vz\u2019\n  124 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:125:13: error: redeclaration of \u2018__m256i vw\u2019\n  125 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:126:13: error: redeclaration of \u2018__m256i vx\u2019\n  126 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:127:13: error: redeclaration of \u2018__m256i vy\u2019\n  127 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:128:13: error: redeclaration of \u2018__m256i vz\u2019\n  128 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:129:13: error: redeclaration of \u2018__m256i vw\u2019\n  129 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:130:13: error: redeclaration of \u2018__m256i vx\u2019\n  130 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:131:13: error: redeclaration of \u2018__m256i vy\u2019\n  131 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:132:13: error: redeclaration of \u2018__m256i vz\u2019\n  132 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:133:13: error: redeclaration of \u2018__m256i vw\u2019\n  133 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:134:13: error: redeclaration of \u2018__m256i vx\u2019\n  134 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:135:13: error: redeclaration of \u2018__m256i vy\u2019\n  135 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:136:13: error: redeclaration of \u2018__m256i vz\u2019\n  136 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:137:13: error: redeclaration of \u2018__m256i vw\u2019\n  137 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:138:13: error: redeclaration of \u2018__m256i vx\u2019\n  138 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:139:13: error: redeclaration of \u2018__m256i vy\u2019\n  139 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:140:13: error: redeclaration of \u2018__m256i vz\u2019\n  140 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:141:13: error: redeclaration of \u2018__m256i vw\u2019\n  141 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:142:13: error: redeclaration of \u2018__m256i vx\u2019\n  142 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:143:13: error: redeclaration of \u2018__m256i vy\u2019\n  143 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:144:13: error: redeclaration of \u2018__m256i vz\u2019\n  144 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:145:13: error: redeclaration of \u2018__m256i vw\u2019\n  145 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:146:13: error: redeclaration of \u2018__m256i vx\u2019\n  146 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:147:13: error: redeclaration of \u2018__m256i vy\u2019\n  147 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:148:13: error: redeclaration of \u2018__m256i vz\u2019\n  148 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:149:13: error: redeclaration of \u2018__m256i vw\u2019\n  149 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:150:13: error: redeclaration of \u2018__m256i vx\u2019\n  150 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:151:13: error: redeclaration of \u2018__m256i vy\u2019\n  151 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:152:13: error: redeclaration of \u2018__m256i vz\u2019\n  152 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:153:13: error: redeclaration of \u2018__m256i vw\u2019\n  153 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:154:13: error: redeclaration of \u2018__m256i vx\u2019\n  154 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:155:13: error: redeclaration of \u2018__m256i vy\u2019\n  155 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:156:13: error: redeclaration of \u2018__m256i vz\u2019\n  156 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:157:13: error: redeclaration of \u2018__m256i vw\u2019\n  157 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:158:13: error: redeclaration of \u2018__m256i vx\u2019\n  158 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:159:13: error: redeclaration of \u2018__m256i vy\u2019\n  159 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:160:13: error: redeclaration of \u2018__m256i vz\u2019\n  160 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:161:13: error: redeclaration of \u2018__m256i vw\u2019\n  161 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:162:13: error: redeclaration of \u2018__m256i vx\u2019\n  162 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:163:13: error: redeclaration of \u2018__m256i vy\u2019\n  163 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:164:13: error: redeclaration of \u2018__m256i vz\u2019\n  164 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:165:13: error: redeclaration of \u2018__m256i vw\u2019\n  165 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:166:13: error: redeclaration of \u2018__m256i vx\u2019\n  166 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:167:13: error: redeclaration of \u2018__m256i vy\u2019\n  167 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:168:13: error: redeclaration of \u2018__m256i vz\u2019\n  168 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:169:13: error: redeclaration of \u2018__m256i vw\u2019\n  169 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:170:13: error: redeclaration of \u2018__m256i vx\u2019\n  170 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:171:13: error: redeclaration of \u2018__m256i vy\u2019\n  171 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:172:13: error: redeclaration of \u2018__m256i vz\u2019\n  172 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:173:13: error: redeclaration of \u2018__m256i vw\u2019\n  173 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:174:13: error: redeclaration of \u2018__m256i vx\u2019\n  174 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:175:13: error: redeclaration of \u2018__m256i vy\u2019\n  175 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:176:13: error: redeclaration of \u2018__m256i vz\u2019\n  176 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:177:13: error: redeclaration of \u2018__m256i vw\u2019\n  177 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:178:13: error: redeclaration of \u2018__m256i vx\u2019\n  178 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:179:13: error: redeclaration of \u2018__m256i vy\u2019\n  179 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:180:13: error: redeclaration of \u2018__m256i vz\u2019\n  180 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:181:13: error: redeclaration of \u2018__m256i vw\u2019\n  181 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:182:13: error: redeclaration of \u2018__m256i vx\u2019\n  182 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:183:13: error: redeclaration of \u2018__m256i vy\u2019\n  183 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:184:13: error: redeclaration of \u2018__m256i vz\u2019\n  184 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:185:13: error: redeclaration of \u2018__m256i vw\u2019\n  185 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:186:13: error: redeclaration of \u2018__m256i vx\u2019\n  186 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:187:13: error: redeclaration of \u2018__m256i vy\u2019\n  187 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:188:13: error: redeclaration of \u2018__m256i vz\u2019\n  188 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:189:13: error: redeclaration of \u2018__m256i vw\u2019\n  189 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:190:13: error: redeclaration of \u2018__m256i vx\u2019\n  190 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:191:13: error: redeclaration of \u2018__m256i vy\u2019\n  191 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:192:13: error: redeclaration of \u2018__m256i vz\u2019\n  192 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:193:13: error: redeclaration of \u2018__m256i vw\u2019\n  193 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:194:13: error: redeclaration of \u2018__m256i vx\u2019\n  194 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:195:13: error: redeclaration of \u2018__m256i vy\u2019\n  195 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:196:13: error: redeclaration of \u2018__m256i vz\u2019\n  196 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:197:13: error: redeclaration of \u2018__m256i vw\u2019\n  197 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:198:13: error: redeclaration of \u2018__m256i vx\u2019\n  198 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:199:13: error: redeclaration of \u2018__m256i vy\u2019\n  199 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:200:13: error: redeclaration of \u2018__m256i vz\u2019\n  200 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:201:13: error: redeclaration of \u2018__m256i vw\u2019\n  201 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:202:13: error: redeclaration of \u2018__m256i vx\u2019\n  202 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:203:13: error: redeclaration of \u2018__m256i vy\u2019\n  203 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:204:13: error: redeclaration of \u2018__m256i vz\u2019\n  204 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:205:13: error: redeclaration of \u2018__m256i vw\u2019\n  205 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:206:13: error: redeclaration of \u2018__m256i vx\u2019\n  206 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:207:13: error: redeclaration of \u2018__m256i vy\u2019\n  207 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:208:13: error: redeclaration of \u2018__m256i vz\u2019\n  208 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:209:13: error: redeclaration of \u2018__m256i vw\u2019\n  209 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:210:13: error: redeclaration of \u2018__m256i vx\u2019\n  210 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:211:13: error: redeclaration of \u2018__m256i vy\u2019\n  211 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:212:13: error: redeclaration of \u2018__m256i vz\u2019\n  212 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:213:13: error: redeclaration of \u2018__m256i vw\u2019\n  213 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:214:13: error: redeclaration of \u2018__m256i vx\u2019\n  214 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:215:13: error: redeclaration of \u2018__m256i vy\u2019\n  215 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:216:13: error: redeclaration of \u2018__m256i vz\u2019\n  216 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:217:13: error: redeclaration of \u2018__m256i vw\u2019\n  217 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:218:13: error: redeclaration of \u2018__m256i vx\u2019\n  218 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:219:13: error: redeclaration of \u2018__m256i vy\u2019\n  219 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:220:13: error: redeclaration of \u2018__m256i vz\u2019\n  220 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:221:13: error: redeclaration of \u2018__m256i vw\u2019\n  221 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:222:13: error: redeclaration of \u2018__m256i vx\u2019\n  222 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:223:13: error: redeclaration of \u2018__m256i vy\u2019\n  223 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:224:13: error: redeclaration of \u2018__m256i vz\u2019\n  224 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:225:13: error: redeclaration of \u2018__m256i vw\u2019\n  225 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:226:13: error: redeclaration of \u2018__m256i vx\u2019\n  226 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:227:13: error: redeclaration of \u2018__m256i vy\u2019\n  227 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:228:13: error: redeclaration of \u2018__m256i vz\u2019\n  228 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:229:13: error: redeclaration of \u2018__m256i vw\u2019\n  229 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:230:13: error: redeclaration of \u2018__m256i vx\u2019\n  230 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:231:13: error: redeclaration of \u2018__m256i vy\u2019\n  231 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:232:13: error: redeclaration of \u2018__m256i vz\u2019\n  232 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:233:13: error: redeclaration of \u2018__m256i vw\u2019\n  233 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:234:13: error: redeclaration of \u2018__m256i vx\u2019\n  234 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:235:13: error: redeclaration of \u2018__m256i vy\u2019\n  235 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:236:13: error: redeclaration of \u2018__m256i vz\u2019\n  236 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:237:13: error: redeclaration of \u2018__m256i vw\u2019\n  237 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:238:13: error: redeclaration of \u2018__m256i vx\u2019\n  238 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:239:13: error: redeclaration of \u2018__m256i vy\u2019\n  239 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:240:13: error: redeclaration of \u2018__m256i vz\u2019\n  240 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:241:13: error: redeclaration of \u2018__m256i vw\u2019\n  241 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:242:13: error: redeclaration of \u2018__m256i vx\u2019\n  242 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:243:13: error: redeclaration of \u2018__m256i vy\u2019\n  243 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:244:13: error: redeclaration of \u2018__m256i vz\u2019\n  244 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:245:13: error: redeclaration of \u2018__m256i vw\u2019\n  245 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:246:13: error: redeclaration of \u2018__m256i vx\u2019\n  246 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:247:13: error: redeclaration of \u2018__m256i vy\u2019\n  247 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:248:13: error: redeclaration of \u2018__m256i vz\u2019\n  248 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:249:13: error: redeclaration of \u2018__m256i vw\u2019\n  249 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:250:13: error: redeclaration of \u2018__m256i vx\u2019\n  250 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:251:13: error: redeclaration of \u2018__m256i vy\u2019\n  251 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:252:13: error: redeclaration of \u2018__m256i vz\u2019\n  252 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:253:13: error: redeclaration of \u2018__m256i vw\u2019\n  253 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:254:13: error: redeclaration of \u2018__m256i vx\u2019\n  254 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:255:13: error: redeclaration of \u2018__m256i vy\u2019\n  255 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:256:13: error: redeclaration of \u2018__m256i vz\u2019\n  256 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:257:13: error: redeclaration of \u2018__m256i vw\u2019\n  257 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:258:13: error: redeclaration of \u2018__m256i vx\u2019\n  258 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:259:13: error: redeclaration of \u2018__m256i vy\u2019\n  259 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:260:13: error: redeclaration of \u2018__m256i vz\u2019\n  260 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:261:13: error: redeclaration of \u2018__m256i vw\u2019\n  261 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:262:13: error: redeclaration of \u2018__m256i vx\u2019\n  262 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:263:13: error: redeclaration of \u2018__m256i vy\u2019\n  263 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:264:13: error: redeclaration of \u2018__m256i vz\u2019\n  264 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:265:13: error: redeclaration of \u2018__m256i vw\u2019\n  265 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:266:13: error: redeclaration of \u2018__m256i vx\u2019\n  266 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:267:13: error: redeclaration of \u2018__m256i vy\u2019\n  267 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:268:13: error: redeclaration of \u2018__m256i vz\u2019\n  268 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:269:13: error: redeclaration of \u2018__m256i vw\u2019\n  269 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:270:13: error: redeclaration of \u2018__m256i vx\u2019\n  270 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:271:13: error: redeclaration of \u2018__m256i vy\u2019\n  271 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:272:13: error: redeclaration of \u2018__m256i vz\u2019\n  272 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:273:13: error: redeclaration of \u2018__m256i vw\u2019\n  273 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:274:13: error: redeclaration of \u2018__m256i vx\u2019\n  274 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:275:13: error: redeclaration of \u2018__m256i vy\u2019\n  275 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:276:13: error: redeclaration of \u2018__m256i vz\u2019\n  276 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:277:13: error: redeclaration of \u2018__m256i vw\u2019\n  277 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:278:13: error: redeclaration of \u2018__m256i vx\u2019\n  278 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:279:13: error: redeclaration of \u2018__m256i vy\u2019\n  279 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:280:13: error: redeclaration of \u2018__m256i vz\u2019\n  280 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:281:13: error: redeclaration of \u2018__m256i vw\u2019\n  281 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:282:13: error: redeclaration of \u2018__m256i vx\u2019\n  282 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:283:13: error: redeclaration of \u2018__m256i vy\u2019\n  283 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:284:13: error: redeclaration of \u2018__m256i vz\u2019\n  284 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:285:13: error: redeclaration of \u2018__m256i vw\u2019\n  285 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:286:13: error: redeclaration of \u2018__m256i vx\u2019\n  286 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:287:13: error: redeclaration of \u2018__m256i vy\u2019\n  287 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:288:13: error: redeclaration of \u2018__m256i vz\u2019\n  288 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:289:13: error: redeclaration of \u2018__m256i vw\u2019\n  289 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:290:13: error: redeclaration of \u2018__m256i vx\u2019\n  290 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:291:13: error: redeclaration of \u2018__m256i vy\u2019\n  291 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:292:13: error: redeclaration of \u2018__m256i vz\u2019\n  292 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:293:13: error: redeclaration of \u2018__m256i vw\u2019\n  293 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:294:13: error: redeclaration of \u2018__m256i vx\u2019\n  294 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:295:13: error: redeclaration of \u2018__m256i vy\u2019\n  295 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:296:13: error: redeclaration of \u2018__m256i vz\u2019\n  296 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:297:13: error: redeclaration of \u2018__m256i vw\u2019\n  297 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:298:13: error: redeclaration of \u2018__m256i vx\u2019\n  298 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:299:13: error: redeclaration of \u2018__m256i vy\u2019\n  299 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:300:13: error: redeclaration of \u2018__m256i vz\u2019\n  300 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:301:13: error: redeclaration of \u2018__m256i vw\u2019\n  301 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:302:13: error: redeclaration of \u2018__m256i vx\u2019\n  302 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:303:13: error: redeclaration of \u2018__m256i vy\u2019\n  303 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:304:13: error: redeclaration of \u2018__m256i vz\u2019\n  304 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:305:13: error: redeclaration of \u2018__m256i vw\u2019\n  305 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:306:13: error: redeclaration of \u2018__m256i vx\u2019\n  306 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:307:13: error: redeclaration of \u2018__m256i vy\u2019\n  307 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:308:13: error: redeclaration of \u2018__m256i vz\u2019\n  308 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:309:13: error: redeclaration of \u2018__m256i vw\u2019\n  309 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:310:13: error: redeclaration of \u2018__m256i vx\u2019\n  310 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:311:13: error: redeclaration of \u2018__m256i vy\u2019\n  311 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:312:13: error: redeclaration of \u2018__m256i vz\u2019\n  312 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:313:13: error: redeclaration of \u2018__m256i vw\u2019\n  313 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:314:13: error: redeclaration of \u2018__m256i vx\u2019\n  314 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:315:13: error: redeclaration of \u2018__m256i vy\u2019\n  315 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:316:13: error: redeclaration of \u2018__m256i vz\u2019\n  316 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:317:13: error: redeclaration of \u2018__m256i vw\u2019\n  317 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:318:13: error: redeclaration of \u2018__m256i vx\u2019\n  318 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:319:13: error: redeclaration of \u2018__m256i vy\u2019\n  319 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:320:13: error: redeclaration of \u2018__m256i vz\u2019\n  320 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:321:13: error: redeclaration of \u2018__m256i vw\u2019\n  321 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:322:13: error: redeclaration of \u2018__m256i vx\u2019\n  322 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:323:13: error: redeclaration of \u2018__m256i vy\u2019\n  323 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:324:13: error: redeclaration of \u2018__m256i vz\u2019\n  324 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:325:13: error: redeclaration of \u2018__m256i vw\u2019\n  325 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:326:13: error: redeclaration of \u2018__m256i vx\u2019\n  326 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:327:13: error: redeclaration of \u2018__m256i vy\u2019\n  327 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:328:13: error: redeclaration of \u2018__m256i vz\u2019\n  328 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:329:13: error: redeclaration of \u2018__m256i vw\u2019\n  329 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:330:13: error: redeclaration of \u2018__m256i vx\u2019\n  330 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:331:13: error: redeclaration of \u2018__m256i vy\u2019\n  331 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:332:13: error: redeclaration of \u2018__m256i vz\u2019\n  332 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:333:13: error: redeclaration of \u2018__m256i vw\u2019\n  333 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:334:13: error: redeclaration of \u2018__m256i vx\u2019\n  334 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:335:13: error: redeclaration of \u2018__m256i vy\u2019\n  335 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:336:13: error: redeclaration of \u2018__m256i vz\u2019\n  336 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:337:13: error: redeclaration of \u2018__m256i vw\u2019\n  337 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:338:13: error: redeclaration of \u2018__m256i vx\u2019\n  338 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:339:13: error: redeclaration of \u2018__m256i vy\u2019\n  339 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:340:13: error: redeclaration of \u2018__m256i vz\u2019\n  340 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:341:13: error: redeclaration of \u2018__m256i vw\u2019\n  341 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:342:13: error: redeclaration of \u2018__m256i vx\u2019\n  342 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:343:13: error: redeclaration of \u2018__m256i vy\u2019\n  343 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:344:13: error: redeclaration of \u2018__m256i vz\u2019\n  344 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:345:13: error: redeclaration of \u2018__m256i vw\u2019\n  345 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:346:13: error: redeclaration of \u2018__m256i vx\u2019\n  346 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:347:13: error: redeclaration of \u2018__m256i vy\u2019\n  347 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:348:13: error: redeclaration of \u2018__m256i vz\u2019\n  348 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:349:13: error: redeclaration of \u2018__m256i vw\u2019\n  349 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:350:13: error: redeclaration of \u2018__m256i vx\u2019\n  350 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:351:13: error: redeclaration of \u2018__m256i vy\u2019\n  351 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:352:13: error: redeclaration of \u2018__m256i vz\u2019\n  352 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:353:13: error: redeclaration of \u2018__m256i vw\u2019\n  353 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:354:13: error: redeclaration of \u2018__m256i vx\u2019\n  354 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:355:13: error: redeclaration of \u2018__m256i vy\u2019\n  355 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:356:13: error: redeclaration of \u2018__m256i vz\u2019\n  356 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:357:13: error: redeclaration of \u2018__m256i vw\u2019\n  357 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:358:13: error: redeclaration of \u2018__m256i vx\u2019\n  358 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:359:13: error: redeclaration of \u2018__m256i vy\u2019\n  359 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:360:13: error: redeclaration of \u2018__m256i vz\u2019\n  360 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:361:13: error: redeclaration of \u2018__m256i vw\u2019\n  361 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:362:13: error: redeclaration of \u2018__m256i vx\u2019\n  362 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:363:13: error: redeclaration of \u2018__m256i vy\u2019\n  363 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:364:13: error: redeclaration of \u2018__m256i vz\u2019\n  364 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:365:13: error: redeclaration of \u2018__m256i vw\u2019\n  365 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:366:13: error: redeclaration of \u2018__m256i vx\u2019\n  366 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:367:13: error: redeclaration of \u2018__m256i vy\u2019\n  367 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:368:13: error: redeclaration of \u2018__m256i vz\u2019\n  368 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:369:13: error: redeclaration of \u2018__m256i vw\u2019\n  369 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:370:13: error: redeclaration of \u2018__m256i vx\u2019\n  370 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:371:13: error: redeclaration of \u2018__m256i vy\u2019\n  371 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:372:13: error: redeclaration of \u2018__m256i vz\u2019\n  372 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:373:13: error: redeclaration of \u2018__m256i vw\u2019\n  373 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:374:13: error: redeclaration of \u2018__m256i vx\u2019\n  374 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:375:13: error: redeclaration of \u2018__m256i vy\u2019\n  375 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:376:13: error: redeclaration of \u2018__m256i vz\u2019\n  376 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:377:13: error: redeclaration of \u2018__m256i vw\u2019\n  377 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:378:13: error: redeclaration of \u2018__m256i vx\u2019\n  378 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:379:13: error: redeclaration of \u2018__m256i vy\u2019\n  379 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:380:13: error: redeclaration of \u2018__m256i vz\u2019\n  380 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:381:13: error: redeclaration of \u2018__m256i vw\u2019\n  381 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:382:13: error: redeclaration of \u2018__m256i vx\u2019\n  382 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:383:13: error: redeclaration of \u2018__m256i vy\u2019\n  383 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:384:13: error: redeclaration of \u2018__m256i vz\u2019\n  384 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:385:13: error: redeclaration of \u2018__m256i vw\u2019\n  385 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:386:13: error: redeclaration of \u2018__m256i vx\u2019\n  386 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:387:13: error: redeclaration of \u2018__m256i vy\u2019\n  387 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:388:13: error: redeclaration of \u2018__m256i vz\u2019\n  388 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:389:13: error: redeclaration of \u2018__m256i vw\u2019\n  389 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:390:13: error: redeclaration of \u2018__m256i vx\u2019\n  390 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:391:13: error: redeclaration of \u2018__m256i vy\u2019\n  391 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:392:13: error: redeclaration of \u2018__m256i vz\u2019\n  392 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:393:13: error: redeclaration of \u2018__m256i vw\u2019\n  393 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:394:13: error: redeclaration of \u2018__m256i vx\u2019\n  394 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:395:13: error: redeclaration of \u2018__m256i vy\u2019\n  395 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:396:13: error: redeclaration of \u2018__m256i vz\u2019\n  396 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:397:13: error: redeclaration of \u2018__m256i vw\u2019\n  397 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:398:13: error: redeclaration of \u2018__m256i vx\u2019\n  398 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:399:13: error: redeclaration of \u2018__m256i vy\u2019\n  399 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:400:13: error: redeclaration of \u2018__m256i vz\u2019\n  400 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:401:13: error: redeclaration of \u2018__m256i vw\u2019\n  401 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:402:13: error: redeclaration of \u2018__m256i vx\u2019\n  402 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:403:13: error: redeclaration of \u2018__m256i vy\u2019\n  403 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:404:13: error: redeclaration of \u2018__m256i vz\u2019\n  404 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:405:13: error: redeclaration of \u2018__m256i vw\u2019\n  405 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:406:13: error: redeclaration of \u2018__m256i vx\u2019\n  406 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:407:13: error: redeclaration of \u2018__m256i vy\u2019\n  407 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:408:13: error: redeclaration of \u2018__m256i vz\u2019\n  408 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:409:13: error: redeclaration of \u2018__m256i vw\u2019\n  409 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:410:13: error: redeclaration of \u2018__m256i vx\u2019\n  410 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:411:13: error: redeclaration of \u2018__m256i vy\u2019\n  411 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:412:13: error: redeclaration of \u2018__m256i vz\u2019\n  412 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:413:13: error: redeclaration of \u2018__m256i vw\u2019\n  413 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:414:13: error: redeclaration of \u2018__m256i vx\u2019\n  414 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:415:13: error: redeclaration of \u2018__m256i vy\u2019\n  415 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:416:13: error: redeclaration of \u2018__m256i vz\u2019\n  416 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:417:13: error: redeclaration of \u2018__m256i vw\u2019\n  417 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:418:13: error: redeclaration of \u2018__m256i vx\u2019\n  418 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:419:13: error: redeclaration of \u2018__m256i vy\u2019\n  419 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:420:13: error: redeclaration of \u2018__m256i vz\u2019\n  420 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:421:13: error: redeclaration of \u2018__m256i vw\u2019\n  421 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:422:13: error: redeclaration of \u2018__m256i vx\u2019\n  422 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:423:13: error: redeclaration of \u2018__m256i vy\u2019\n  423 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:424:13: error: redeclaration of \u2018__m256i vz\u2019\n  424 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:425:13: error: redeclaration of \u2018__m256i vw\u2019\n  425 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:426:13: error: redeclaration of \u2018__m256i vx\u2019\n  426 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:427:13: error: redeclaration of \u2018__m256i vy\u2019\n  427 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:428:13: error: redeclaration of \u2018__m256i vz\u2019\n  428 |     __m256i vz = _mm256_set1_epi8('{');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:429:13: error: redeclaration of \u2018__m256i vw\u2019\n  429 |     __m256i vw = _mm256_set1_epi8('}');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:430:13: error: redeclaration of \u2018__m256i vx\u2019\n  430 |     __m256i vx = _mm256_set1_epi8('|');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:431:13: error: redeclaration of \u2018__m256i vy\u2019\n  431 |     __m256i vy = _mm256_set1_epi8('~');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:432:13: error: redeclaration of \u2018__m256i vz\u2019\n  432 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:433:13: error: redeclaration of \u2018__m256i vw\u2019\n  433 |     __m256i vw = _mm256_set1_epi8('&');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:77:13: note: \u2018__m256i vw\u2019 previously declared here\n   77 |     __m256i vw = _mm256_set1_epi8('#');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:434:13: error: redeclaration of \u2018__m256i vx\u2019\n  434 |     __m256i vx = _mm256_set1_epi8('(');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:78:13: note: \u2018__m256i vx\u2019 previously declared here\n   78 |     __m256i vx = _mm256_set1_epi8('$');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:435:13: error: redeclaration of \u2018__m256i vy\u2019\n  435 |     __m256i vy = _mm256_set1_epi8(')');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:79:13: note: \u2018__m256i vy\u2019 previously declared here\n   79 |     __m256i vy = _mm256_set1_epi8('%');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:436:13: error: redeclaration of \u2018__m256i vz\u2019\n  436 |     __m256i vz = _mm256_set1_epi8\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:80:13: note: \u2018__m256i vz\u2019 previously declared here\n   80 |     __m256i vz = _mm256_set1_epi8('^');\n      |             ^~\n[REDACTED]/tmp6nq3jgpr.cpp:448:21: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  448 | bool humaneval_check() {\n      |                     ^~\n[REDACTED]/tmp6nq3jgpr.cpp:448:21: note: remove parentheses to default-initialize a variable\n  448 | bool humaneval_check() {\n      |                     ^~\n      |                     --\n[REDACTED]/tmp6nq3jgpr.cpp:448:21: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmp6nq3jgpr.cpp:448:24: error: a function-definition is not allowed here before \u2018{\u2019 token\n  448 | bool humaneval_check() {\n      |                        ^\n[REDACTED]/tmp6nq3jgpr.cpp:466:40: error: a function-definition is not allowed here before \u2018{\u2019 token\n  466 | bool correctness_check(int iterations) {\n      |                                        ^\n[REDACTED]/tmp6nq3jgpr.cpp:488:9: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  488 | int main(){\n      |         ^~\n[REDACTED]/tmp6nq3jgpr.cpp:488:9: note: remove parentheses to default-initialize a variable\n  488 | int main(){\n      |         ^~\n      |         --\n[REDACTED]/tmp6nq3jgpr.cpp:488:9: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmp6nq3jgpr.cpp:488:11: error: a function-definition is not allowed here before \u2018{\u2019 token\n  488 | int main(){\n      |           ^\n[REDACTED]/tmp6nq3jgpr.cpp:492:2: error: expected \u2018}\u2019 at end of input\n  492 | }\n      |  ^\n[REDACTED]/tmp6nq3jgpr.cpp:44:33: note: to match this \u2018{\u2019\n   44 | decode_shift_simd(std::string s){\n      |                                 ^\n[REDACTED]/tmp6nq3jgpr.cpp:492:2: warning: no return statement in function returning non-void [-Wreturn-type]\n  492 | }\n      |  ^\n"}
{"task_id": "SimdBench_87_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpezc3u5z3.cpp:43:1: error: ISO C++ forbids declaration of \u2018decode_shift_simd\u2019 with no type [-fpermissive]\n   43 | decode_shift_simd(std::string s){\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpezc3u5z3.cpp: In function \u2018int decode_shift_simd(std::string)\u2019:\n[REDACTED]/tmpezc3u5z3.cpp:62:12: error: cannot convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019 in return\n   62 |     return result;\n      |            ^~~~~~\n      |            |\n      |            std::string {aka std::__cxx11::basic_string<char>}\n[REDACTED]/tmpezc3u5z3.cpp: At global scope:\n[REDACTED]/tmpezc3u5z3.cpp:64:13: error: redefinition of \u2018std::string encode_shift(std::string)\u2019\n   64 | std::string encode_shift(std::string s){\n      |             ^~~~~~~~~~~~\n[REDACTED]/tmpezc3u5z3.cpp:32:13: note: \u2018std::string encode_shift(std::string)\u2019 previously defined here\n   32 | std::string encode_shift(std::string s){\n      |             ^~~~~~~~~~~~\n[REDACTED]/tmpezc3u5z3.cpp: In function \u2018bool humaneval_check()\u2019:\n[REDACTED]/tmpezc3u5z3.cpp:88:56: error: no match for \u2018operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019})\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~\n      |                                          |                |\n      |                                          int              std::string {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h:33,\n                 from /usr/include/c++/13/bits/allocator.h:46,\n                 from /usr/include/c++/13/string:43,\n                 from /usr/include/c++/13/bits/locale_classes.h:40,\n                 from /usr/include/c++/13/bits/ios_base.h:41,\n                 from /usr/include/c++/13/ios:44,\n                 from /usr/include/c++/13/ostream:40,\n                 from /usr/include/c++/13/iostream:41,\n                 from [REDACTED]/tmpezc3u5z3.cpp:1:\n/usr/include/c++/13/bits/new_allocator.h:215:9: note: candidate: \u2018template<class _Up> bool std::operator==(const __new_allocator<char>&, const __new_allocator<_Tp>&)\u2019\n  215 |         operator==(const __new_allocator&, const __new_allocator<_Up>&)\n      |         ^~~~~~~~\n/usr/include/c++/13/bits/new_allocator.h:215:9: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__new_allocator<_Tp>\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/iosfwd:42,\n                 from /usr/include/c++/13/ios:40:\n/usr/include/c++/13/bits/postypes.h:192:5: note: candidate: \u2018template<class _StateT> bool std::operator==(const fpos<_StateT>&, const fpos<_StateT>&)\u2019\n  192 |     operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/postypes.h:192:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/allocator.h:237:5: note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const allocator<_CharT>&, const allocator<_T2>&)\u2019\n  237 |     operator==(const allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/allocator.h:237:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/string:48:\n/usr/include/c++/13/bits/stl_iterator.h:448:5: note: candidate: \u2018template<class _Iterator> constexpr bool std::operator==(const reverse_iterator<_Iterator>&, const reverse_iterator<_Iterator>&)\u2019\n  448 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:448:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/stl_iterator.h:493:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr bool std::operator==(const reverse_iterator<_Iterator>&, const reverse_iterator<_IteratorR>&)\u2019\n  493 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:493:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/stl_iterator.h:1678:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr bool std::operator==(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)\u2019\n 1678 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1678:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/stl_iterator.h:1748:5: note: candidate: \u2018template<class _Iterator> constexpr bool std::operator==(const move_iterator<_IteratorL>&, const move_iterator<_IteratorL>&)\u2019\n 1748 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1748:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/bits/stl_algobase.h:64,\n                 from /usr/include/c++/13/string:51:\n/usr/include/c++/13/bits/stl_pair.h:812:5: note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const pair<_T1, _T2>&, const pair<_T1, _T2>&)\u2019\n  812 |     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_pair.h:812:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/bits/basic_string.h:47,\n                 from /usr/include/c++/13/string:54:\n/usr/include/c++/13/string_view:609:5: note: candidate: \u2018template<class _CharT, class _Traits> constexpr bool std::operator==(basic_string_view<_CharT, _Traits>, basic_string_view<_CharT, _Traits>)\u2019\n  609 |     operator==(basic_string_view<_CharT, _Traits> __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/string_view:609:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018std::basic_string_view<_CharT, _Traits>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/string_view:616:5: note: candidate: \u2018template<class _CharT, class _Traits> constexpr bool std::operator==(basic_string_view<_CharT, _Traits>, __type_identity_t<basic_string_view<_CharT, _Traits> >)\u2019\n  616 |     operator==(basic_string_view<_CharT, _Traits> __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/string_view:616:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018std::basic_string_view<_CharT, _Traits>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/string_view:642:5: note: candidate: \u2018template<class _CharT, class _Traits> constexpr bool std::operator==(__type_identity_t<basic_string_view<_CharT, _Traits> >, basic_string_view<_CharT, _Traits>)\u2019\n  642 |     operator==(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/string_view:642:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018std::basic_string_view<_CharT, _Traits>\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/basic_string.h:3710:5: note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const __cxx11::basic_string<_CharT, _Traits, _Allocator>&, const __cxx11::basic_string<_CharT, _Traits, _Allocator>&)\u2019\n 3710 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:3710:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Allocator>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/basic_string.h:3727:5: note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const __cxx11::basic_string<_CharT, _Traits, _Allocator>&, const _CharT*)\u2019\n 3727 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:3727:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Allocator>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/basic_string.h:3774:5: note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const _CharT*, const __cxx11::basic_string<_CharT, _Traits, _Allocator>&)\u2019\n 3774 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:3774:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const _CharT*\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/bits/memory_resource.h:47,\n                 from /usr/include/c++/13/string:58:\n/usr/include/c++/13/tuple:1919:5: note: candidate: \u2018template<class ... _TElements, class ... _UElements> constexpr bool std::operator==(const tuple<_UTypes ...>&, const tuple<_UTypes ...>&)\u2019\n 1919 |     operator==(const tuple<_TElements...>& __t,\n      |     ^~~~~~~~\n/usr/include/c++/13/tuple:1919:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::tuple<_UTypes ...>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/bits/locale_facets.h:48,\n                 from /usr/include/c++/13/bits/basic_ios.h:37,\n                 from /usr/include/c++/13/ios:46:\n/usr/include/c++/13/bits/streambuf_iterator.h:234:5: note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const istreambuf_iterator<_CharT, _Traits>&, const istreambuf_iterator<_CharT, _Traits>&)\u2019\n  234 |     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/streambuf_iterator.h:234:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmpezc3u5z3.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:2040:5: note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const vector<_Tp, _Alloc>&, const vector<_Tp, _Alloc>&)\u2019\n 2040 |     operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:2040:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/map:63,\n                 from [REDACTED]/tmpezc3u5z3.cpp:3:\n/usr/include/c++/13/bits/stl_map.h:1513:5: note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const map<_Key, _Tp, _Compare, _Allocator>&, const map<_Key, _Tp, _Compare, _Allocator>&)\u2019\n 1513 |     operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_map.h:1513:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Allocator>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/map:64:\n/usr/include/c++/13/bits/stl_multimap.h:1134:5: note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const multimap<_Key, _Tp, _Compare, _Allocator>&, const multimap<_Key, _Tp, _Compare, _Allocator>&)\u2019\n 1134 |     operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_multimap.h:1134:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Allocator>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/unordered_map:41,\n                 from [REDACTED]/tmpezc3u5z3.cpp:4:\n/usr/include/c++/13/bits/unordered_map.h:2143:5: note: candidate: \u2018template<class _Key1, class _Tp1, class _Hash1, class _Pred1, class _Alloc1> bool std::operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&, const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&)\u2019\n 2143 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/unordered_map.h:2143:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/unordered_map.h:2157:5: note: candidate: \u2018template<class _Key1, class _Tp1, class _Hash1, class _Pred1, class _Alloc1> bool std::operator==(const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&, const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&)\u2019\n 2157 |     operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/unordered_map.h:2157:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/unordered_set:41,\n                 from [REDACTED]/tmpezc3u5z3.cpp:5:\n/usr/include/c++/13/bits/unordered_set.h:1813:5: note: candidate: \u2018template<class _Value1, class _Hash1, class _Pred1, class _Alloc1> bool std::operator==(const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&, const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&)\u2019\n 1813 |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/unordered_set.h:1813:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/unordered_set.h:1827:5: note: candidate: \u2018template<class _Value1, class _Hash1, class _Pred1, class _Alloc1> bool std::operator==(const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&, const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&)\u2019\n 1827 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/unordered_set.h:1827:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\nIn file included from /usr/include/c++/13/random:53,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpezc3u5z3.cpp:14:\n/usr/include/c++/13/bits/random.tcc:1908:5: note: candidate: \u2018template<class _RealType1> bool std::operator==(const normal_distribution<_RealType>&, const normal_distribution<_RealType>&)\u2019\n 1908 |     operator==(const std::normal_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/random.tcc:1908:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:88:59: note:   mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and \u2018int\u2019\n   88 |         pass = pass && (decode_shift_simd(encoded_str) == str);\n      |                                                           ^~~\n/usr/include/c++/13/bits/allocator.h:216:7: note: candidate: \u2018bool std::operator==(const allocator<char>&, const allocator<char>&)\u2019\n  216 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/allocator.h:216:18: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const std::allocator<char>&\u2019\n  216 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/13/bits/ios_base.h:46:\n/usr/include/c++/13/system_error:449:3: note: candidate: \u2018bool std::operator==(const error_code&, const error_code&)\u2019\n  449 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/13/system_error:449:32: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const std::error_code&\u2019\n  449 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/system_error:465:3: note: candidate: \u2018bool std::operator==(const error_code&, const error_condition&)\u2019\n  465 |   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/13/system_error:465:32: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const std::error_code&\u2019\n  465 |   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/system_error:480:3: note: candidate: \u2018bool std::operator==(const error_condition&, const error_condition&)\u2019\n  480 |   operator==(const error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/13/system_error:480:37: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const std::error_condition&\u2019\n  480 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/system_error:517:3: note: candidate: \u2018bool std::operator==(const error_condition&, const error_code&)\u2019\n  517 |   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/13/system_error:517:37: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const std::error_condition&\u2019\n  517 |   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n[REDACTED]/tmpezc3u5z3.cpp: In function \u2018bool correctness_check(int)\u2019:\n[REDACTED]/tmpezc3u5z3.cpp:107:21: error: no matching function for call to \u2018allclose(std::__cxx11::basic_string<char>&, int&)\u2019\n  107 |         if(!allclose(result, result_simd)){\n      |             ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/utils.hpp:208:6: note: candidate: \u2018template<class T> bool allclose(const std::vector<_RealType>&, const std::vector<_RealType>&, double, double, bool)\u2019\n  208 | bool allclose(const std::vector<T>& a, const std::vector<T>& b, \\\n      |      ^~~~~~~~\n[REDACTED]/utils.hpp:208:6: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:107:21: note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const std::vector<_RealType>\u2019\n  107 |         if(!allclose(result, result_simd)){\n      |             ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/utils.hpp:241:6: note: candidate: \u2018template<class T> bool allclose(const T&, const T&, double, double, bool)\u2019\n  241 | bool allclose(const T& a, const T& b, double rtol = 1e-5, double atol = 1e-8, bool equal_nan = true) {\n      |      ^~~~~~~~\n[REDACTED]/utils.hpp:241:6: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpezc3u5z3.cpp:107:21: note:   deduced conflicting types for parameter \u2018const T\u2019 (\u2018std::__cxx11::basic_string<char>\u2019 and \u2018int\u2019)\n  107 |         if(!allclose(result, result_simd)){\n      |             ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_87_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwuunr1kx.cpp:29:1: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      | ^\n[REDACTED]/tmpwuunr1kx.cpp:29:2: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |  ^\n[REDACTED]/tmpwuunr1kx.cpp:29:3: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |   ^\n[REDACTED]/tmpwuunr1kx.cpp:29:4: error: \u2018c\u2019 does not name a type\n   29 | ```c++\n      |    ^\n[REDACTED]/tmpwuunr1kx.cpp:44:1: error: ISO C++ forbids declaration of \u2018decode_shift_simd\u2019 with no type [-fpermissive]\n   44 | decode_shift_simd(std::string s){\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpwuunr1kx.cpp: In function \u2018int decode_shift_simd(std::string)\u2019:\n[REDACTED]/tmpwuunr1kx.cpp:205:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018257\u2019 to \u20181\u2019 [-Woverflow]\n  205 |     __m256i v129 = _mm256_set1_epi8((int)'a' + 160);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:210:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018262\u2019 to \u20186\u2019 [-Woverflow]\n  210 |     __m256i v133 = _mm256_set1_epi8((int)'a' + 165);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:215:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018267\u2019 to \u201811\u2019 [-Woverflow]\n  215 |     __m256i v137 = _mm256_set1_epi8((int)'a' + 170);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:220:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018272\u2019 to \u201816\u2019 [-Woverflow]\n  220 |     __m256i v141 = _mm256_set1_epi8((int)'a' + 175);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:225:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018277\u2019 to \u201821\u2019 [-Woverflow]\n  225 |     __m256i v145 = _mm256_set1_epi8((int)'a' + 180);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:230:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018282\u2019 to \u201826\u2019 [-Woverflow]\n  230 |     __m256i v149 = _mm256_set1_epi8((int)'a' + 185);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:235:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018287\u2019 to \u201831\u2019 [-Woverflow]\n  235 |     __m256i v153 = _mm256_set1_epi8((int)'a' + 190);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:240:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018292\u2019 to \u201836\u2019 [-Woverflow]\n  240 |     __m256i v157 = _mm256_set1_epi8((int)'a' + 195);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:242:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018260\u2019 to \u20184\u2019 [-Woverflow]\n  242 |     __m256i v159 = _mm256_set1_epi8((int)'A' + 195);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:243:5: error: \u2018__m260\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  243 |     __m260 = _mm256_set1_epi8((int)'Z' - 195);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:245:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018297\u2019 to \u201841\u2019 [-Woverflow]\n  245 |     __m256i v161 = _mm256_set1_epi8((int)'a' + 200);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:247:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018265\u2019 to \u20189\u2019 [-Woverflow]\n  247 |     __m256i v163 = _mm256_set1_epi8((int)'A' + 200);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:248:5: error: \u2018__m264\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  248 |     __m264 = _mm256_set1_epi8((int)'Z' - 200);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:250:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018302\u2019 to \u201846\u2019 [-Woverflow]\n  250 |     __m256i v165 = _mm256_set1_epi8((int)'a' + 205);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:252:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018270\u2019 to \u201814\u2019 [-Woverflow]\n  252 |     __m256i v167 = _mm256_set1_epi8((int)'A' + 205);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:253:5: error: \u2018__m268\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  253 |     __m268 = _mm256_set1_epi8((int)'Z' - 205);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:255:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018307\u2019 to \u201851\u2019 [-Woverflow]\n  255 |     __m256i v169 = _mm256_set1_epi8((int)'a' + 210);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:257:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018275\u2019 to \u201819\u2019 [-Woverflow]\n  257 |     __m256i v171 = _mm256_set1_epi8((int)'A' + 210);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:258:5: error: \u2018__m272\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  258 |     __m272 = _mm256_set1_epi8((int)'Z' - 210);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmpwuunr1kx.cpp:260:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018312\u2019 to \u201856\u2019 [-Woverflow]\n  260 |     __m256i v173 = _mm256_set1_epi8((int)'a' + 215);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:262:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018280\u2019 to \u201824\u2019 [-Woverflow]\n  262 |     __m256i v175 = _mm256_set1_epi8((int)'A' + 215);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:263:5: error: \u2018__m276\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  263 |     __m276 = _mm256_set1_epi8((int)'Z' - 215);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:265:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018317\u2019 to \u201861\u2019 [-Woverflow]\n  265 |     __m256i v177 = _mm256_set1_epi8((int)'a' + 220);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:267:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018285\u2019 to \u201829\u2019 [-Woverflow]\n  267 |     __m256i v179 = _mm256_set1_epi8((int)'A' + 220);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:268:5: error: \u2018__m280\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  268 |     __m280 = _mm256_set1_epi8((int)'Z' - 220);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:268:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-130\u2019 to \u2018126\u2019 [-Woverflow]\n  268 |     __m280 = _mm256_set1_epi8((int)'Z' - 220);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:270:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018322\u2019 to \u201866\u2019 [-Woverflow]\n  270 |     __m256i v181 = _mm256_set1_epi8((int)'a' + 225);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:272:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018290\u2019 to \u201834\u2019 [-Woverflow]\n  272 |     __m256i v183 = _mm256_set1_epi8((int)'A' + 225);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:273:5: error: \u2018__m284\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  273 |     __m284 = _mm256_set1_epi8((int)'Z' - 225);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:273:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-135\u2019 to \u2018121\u2019 [-Woverflow]\n  273 |     __m284 = _mm256_set1_epi8((int)'Z' - 225);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:275:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018327\u2019 to \u201871\u2019 [-Woverflow]\n  275 |     __m256i v185 = _mm256_set1_epi8((int)'a' + 230);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:277:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018295\u2019 to \u201839\u2019 [-Woverflow]\n  277 |     __m256i v187 = _mm256_set1_epi8((int)'A' + 230);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:278:5: error: \u2018__m288\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  278 |     __m288 = _mm256_set1_epi8((int)'Z' - 230);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:278:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-140\u2019 to \u2018116\u2019 [-Woverflow]\n  278 |     __m288 = _mm256_set1_epi8((int)'Z' - 230);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:280:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018337\u2019 to \u201881\u2019 [-Woverflow]\n  280 |     __m256i v189 = _mm256_set1_epi8((int)'a' + 240);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:282:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018305\u2019 to \u201849\u2019 [-Woverflow]\n  282 |     __m256i v191 = _mm256_set1_epi8((int)'A' + 240);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:283:5: error: \u2018__m292\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  283 |     __m292 = _mm256_set1_epi8((int)'Z' - 240);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmpwuunr1kx.cpp:283:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-150\u2019 to \u2018106\u2019 [-Woverflow]\n  283 |     __m292 = _mm256_set1_epi8((int)'Z' - 240);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:285:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018342\u2019 to \u201886\u2019 [-Woverflow]\n  285 |     __m256i v193 = _mm256_set1_epi8((int)'a' + 245);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:287:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018310\u2019 to \u201854\u2019 [-Woverflow]\n  287 |     __m256i v195 = _mm256_set1_epi8((int)'A' + 245);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:288:5: error: \u2018__m296\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  288 |     __m296 = _mm256_set1_epi8((int)'Z' - 245);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:288:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-155\u2019 to \u2018101\u2019 [-Woverflow]\n  288 |     __m296 = _mm256_set1_epi8((int)'Z' - 245);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:290:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018347\u2019 to \u201891\u2019 [-Woverflow]\n  290 |     __m256i v197 = _mm256_set1_epi8((int)'a' + 250);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:292:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018315\u2019 to \u201859\u2019 [-Woverflow]\n  292 |     __m256i v199 = _mm256_set1_epi8((int)'A' + 250);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:293:5: error: \u2018__m300\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  293 |     __m300 = _mm256_set1_epi8((int)'Z' - 250);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:293:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-160\u2019 to \u201896\u2019 [-Woverflow]\n  293 |     __m300 = _mm256_set1_epi8((int)'Z' - 250);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:295:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018352\u2019 to \u201896\u2019 [-Woverflow]\n  295 |     __m256i v301 = _mm256_set1_epi8((int)'a' + 255);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:296:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-133\u2019 to \u2018123\u2019 [-Woverflow]\n  296 |     __m256i v302 = _mm256_set1_epi8((int)'z' - 255);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:297:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018320\u2019 to \u201864\u2019 [-Woverflow]\n  297 |     __m256i v303 = _mm256_set1_epi8((int)'A' + 255);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:298:5: error: \u2018__m304\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  298 |     __m304 = _mm256_set1_epi8((int)'Z' - 255);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:298:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-165\u2019 to \u201891\u2019 [-Woverflow]\n  298 |     __m304 = _mm256_set1_epi8((int)'Z' - 255);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:300:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018357\u2019 to \u2018101\u2019 [-Woverflow]\n  300 |     __m256i v305 = _mm256_set1_epi8((int)'a' + 260);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:301:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-138\u2019 to \u2018118\u2019 [-Woverflow]\n  301 |     __m256i v306 = _mm256_set1_epi8((int)'z' - 260);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:302:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018325\u2019 to \u201869\u2019 [-Woverflow]\n  302 |     __m256i v307 = _mm256_set1_epi8((int)'A' + 260);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:303:5: error: \u2018__m308\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  303 |     __m308 = _mm256_set1_epi8((int)'Z' - 260);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:303:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-170\u2019 to \u201886\u2019 [-Woverflow]\n  303 |     __m308 = _mm256_set1_epi8((int)'Z' - 260);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:305:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018362\u2019 to \u2018106\u2019 [-Woverflow]\n  305 |     __m256i v309 = _mm256_set1_epi8((int)'a' + 265);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:306:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-143\u2019 to \u2018113\u2019 [-Woverflow]\n  306 |     __m260 = _mm256_set1_epi8((int)'z' - 265);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:307:5: error: \u2018__m261\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  307 |     __m261 = _mm256_set1_epi8((int)'A' + 265);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:307:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018330\u2019 to \u201874\u2019 [-Woverflow]\n  307 |     __m261 = _mm256_set1_epi8((int)'A' + 265);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:308:5: error: \u2018__m312\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  308 |     __m312 = _mm256_set1_epi8((int)'Z' - 265);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmpwuunr1kx.cpp:308:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-175\u2019 to \u201881\u2019 [-Woverflow]\n  308 |     __m312 = _mm256_set1_epi8((int)'Z' - 265);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:310:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018367\u2019 to \u2018111\u2019 [-Woverflow]\n  310 |     __m256i v313 = _mm256_set1_epi8((int)'a' + 270);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:311:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-148\u2019 to \u2018108\u2019 [-Woverflow]\n  311 |     __m264 = _mm256_set1_epi8((int)'z' - 270);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:312:5: error: \u2018__m265\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  312 |     __m265 = _mm256_set1_epi8((int)'A' + 270);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:312:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018335\u2019 to \u201879\u2019 [-Woverflow]\n  312 |     __m265 = _mm256_set1_epi8((int)'A' + 270);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:313:5: error: \u2018__m316\u2019 was not declared in this scope; did you mean \u2018__m16\u2019?\n  313 |     __m316 = _mm256_set1_epi8((int)'Z' - 270);\n      |     ^~~~~~\n      |     __m16\n[REDACTED]/tmpwuunr1kx.cpp:313:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-180\u2019 to \u201876\u2019 [-Woverflow]\n  313 |     __m316 = _mm256_set1_epi8((int)'Z' - 270);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:315:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018372\u2019 to \u2018116\u2019 [-Woverflow]\n  315 |     __m256i v317 = _mm256_set1_epi8((int)'a' + 275);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:316:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-153\u2019 to \u2018103\u2019 [-Woverflow]\n  316 |     __m268 = _mm256_set1_epi8((int)'z' - 275);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:317:5: error: \u2018__m269\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  317 |     __m269 = _mm256_set1_epi8((int)'A' + 275);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:317:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018340\u2019 to \u201884\u2019 [-Woverflow]\n  317 |     __m269 = _mm256_set1_epi8((int)'A' + 275);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:318:5: error: \u2018__m320\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  318 |     __m320 = _mm256_set1_epi8((int)'Z' - 275);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:318:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-185\u2019 to \u201871\u2019 [-Woverflow]\n  318 |     __m320 = _mm256_set1_epi8((int)'Z' - 275);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:320:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018377\u2019 to \u2018121\u2019 [-Woverflow]\n  320 |     __m256i v321 = _mm256_set1_epi8((int)'a' + 280);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:321:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-158\u2019 to \u201898\u2019 [-Woverflow]\n  321 |     __m272 = _mm256_set1_epi8((int)'z' - 280);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:322:5: error: \u2018__m273\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  322 |     __m273 = _mm256_set1_epi8((int)'A' + 280);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:322:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018345\u2019 to \u201889\u2019 [-Woverflow]\n  322 |     __m273 = _mm256_set1_epi8((int)'A' + 280);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:323:5: error: \u2018__m324\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  323 |     __m324 = _mm256_set1_epi8((int)'Z' - 280);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:323:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-190\u2019 to \u201866\u2019 [-Woverflow]\n  323 |     __m324 = _mm256_set1_epi8((int)'Z' - 280);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:325:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018382\u2019 to \u2018126\u2019 [-Woverflow]\n  325 |     __m256i v325 = _mm256_set1_epi8((int)'a' + 285);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:326:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-163\u2019 to \u201893\u2019 [-Woverflow]\n  326 |     __m276 = _mm256_set1_epi8((int)'z' - 285);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:327:5: error: \u2018__m277\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  327 |     __m277 = _mm256_set1_epi8((int)'A' + 285);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:327:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018350\u2019 to \u201894\u2019 [-Woverflow]\n  327 |     __m277 = _mm256_set1_epi8((int)'A' + 285);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:328:5: error: \u2018__m328\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  328 |     __m328 = _mm256_set1_epi8((int)'Z' - 285);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:328:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-195\u2019 to \u201861\u2019 [-Woverflow]\n  328 |     __m328 = _mm256_set1_epi8((int)'Z' - 285);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:330:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018387\u2019 to \u2018-125\u2019 [-Woverflow]\n  330 |     __m256i v329 = _mm256_set1_epi8((int)'a' + 290);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:331:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-168\u2019 to \u201888\u2019 [-Woverflow]\n  331 |     __m280 = _mm256_set1_epi8((int)'z' - 290);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:332:5: error: \u2018__m281\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  332 |     __m281 = _mm256_set1_epi8((int)'A' + 290);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:332:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018355\u2019 to \u201899\u2019 [-Woverflow]\n  332 |     __m281 = _mm256_set1_epi8((int)'A' + 290);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:333:5: error: \u2018__m332\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  333 |     __m332 = _mm256_set1_epi8((int)'Z' - 290);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:333:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-200\u2019 to \u201856\u2019 [-Woverflow]\n  333 |     __m332 = _mm256_set1_epi8((int)'Z' - 290);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:335:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018392\u2019 to \u2018-120\u2019 [-Woverflow]\n  335 |     __m256i v333 = _mm256_set1_epi8((int)'a' + 295);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:336:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-173\u2019 to \u201883\u2019 [-Woverflow]\n  336 |     __m284 = _mm256_set1_epi8((int)'z' - 295);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:337:5: error: \u2018__m285\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  337 |     __m285 = _mm256_set1_epi8((int)'A' + 295);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:337:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018360\u2019 to \u2018104\u2019 [-Woverflow]\n  337 |     __m285 = _mm256_set1_epi8((int)'A' + 295);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:338:5: error: \u2018__m336\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  338 |     __m336 = _mm256_set1_epi8((int)'Z' - 295);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:338:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-205\u2019 to \u201851\u2019 [-Woverflow]\n  338 |     __m336 = _mm256_set1_epi8((int)'Z' - 295);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:340:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018397\u2019 to \u2018-115\u2019 [-Woverflow]\n  340 |     __m256i v337 = _mm256_set1_epi8((int)'a' + 300);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:341:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-178\u2019 to \u201878\u2019 [-Woverflow]\n  341 |     __m288 = _mm256_set1_epi8((int)'z' - 300);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:342:5: error: \u2018__m289\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  342 |     __m289 = _mm256_set1_epi8((int)'A' + 300);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:342:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018365\u2019 to \u2018109\u2019 [-Woverflow]\n  342 |     __m289 = _mm256_set1_epi8((int)'A' + 300);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:343:5: error: \u2018__m340\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  343 |     __m340 = _mm256_set1_epi8((int)'Z' - 300);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:343:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-210\u2019 to \u201846\u2019 [-Woverflow]\n  343 |     __m340 = _mm256_set1_epi8((int)'Z' - 300);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:345:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018402\u2019 to \u2018-110\u2019 [-Woverflow]\n  345 |     __m256i v341 = _mm256_set1_epi8((int)'a' + 305);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:346:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-183\u2019 to \u201873\u2019 [-Woverflow]\n  346 |     __m292 = _mm256_set1_epi8((int)'z' - 305);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:347:5: error: \u2018__m293\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  347 |     __m293 = _mm256_set1_epi8((int)'A' + 305);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:347:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018370\u2019 to \u2018114\u2019 [-Woverflow]\n  347 |     __m293 = _mm256_set1_epi8((int)'A' + 305);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:348:5: error: \u2018__m344\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  348 |     __m344 = _mm256_set1_epi8((int)'Z' - 305);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:348:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-215\u2019 to \u201841\u2019 [-Woverflow]\n  348 |     __m344 = _mm256_set1_epi8((int)'Z' - 305);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:350:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018407\u2019 to \u2018-105\u2019 [-Woverflow]\n  350 |     __m256i v345 = _mm256_set1_epi8((int)'a' + 310);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:351:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-188\u2019 to \u201868\u2019 [-Woverflow]\n  351 |     __m296 = _mm256_set1_epi8((int)'z' - 310);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:352:5: error: \u2018__m297\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  352 |     __m297 = _mm256_set1_epi8((int)'A' + 310);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:352:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018375\u2019 to \u2018119\u2019 [-Woverflow]\n  352 |     __m297 = _mm256_set1_epi8((int)'A' + 310);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:353:5: error: \u2018__m348\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  353 |     __m348 = _mm256_set1_epi8((int)'Z' - 310);\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:353:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-220\u2019 to \u201836\u2019 [-Woverflow]\n  353 |     __m348 = _mm256_set1_epi8((int)'Z' - 310);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:355:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018412\u2019 to \u2018-100\u2019 [-Woverflow]\n  355 |     __m256i v351 = _mm256_set1_epi8((int)'a' + 315);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:356:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-193\u2019 to \u201863\u2019 [-Woverflow]\n  356 |     __m300 = _mm256_set1_epi8((int)'z' - 315);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:357:5: error: \u2018__m301\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  357 |     __m301 = _mm256_set1_epi8((int)'A' + 315);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:357:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018380\u2019 to \u2018124\u2019 [-Woverflow]\n  357 |     __m301 = _mm256_set1_epi8((int)'A' + 315);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:358:5: error: \u2018__m352\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  358 |     __m352 = _mm256_set1_epi8((int)'Z' - 315);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:358:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-225\u2019 to \u201831\u2019 [-Woverflow]\n  358 |     __m352 = _mm256_set1_epi8((int)'Z' - 315);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:360:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018417\u2019 to \u2018-95\u2019 [-Woverflow]\n  360 |     __m256i v353 = _mm256_set1_epi8((int)'a' + 320);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:361:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-198\u2019 to \u201858\u2019 [-Woverflow]\n  361 |     __m304 = _mm256_set1_epi8((int)'z' - 320);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:362:5: error: \u2018__m305\u2019 was not declared in this scope; did you mean \u2018__m32\u2019?\n  362 |     __m305 = _mm256_set1_epi8((int)'A' + 320);\n      |     ^~~~~~\n      |     __m32\n[REDACTED]/tmpwuunr1kx.cpp:362:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018385\u2019 to \u2018-127\u2019 [-Woverflow]\n  362 |     __m305 = _mm256_set1_epi8((int)'A' + 320);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:363:5: error: \u2018__m356\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  363 |     __m356 = _mm256_set1_epi8((int)'Z' - 320);\n      |     ^~~~~~\n      |     __m256\n[REDACTED]/tmpwuunr1kx.cpp:363:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-230\u2019 to \u201826\u2019 [-Woverflow]\n  363 |     __m356 = _mm256_set1_epi8((int)'Z' - 320);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:365:46: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018422\u2019 to \u2018-90\u2019 [-Woverflow]\n  365 |     __m256i v357 = _mm256_set1_epi8((int)'a' + 325);\n      |                                     ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:366:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018-203\u2019 to \u201853\u2019 [-Woverflow]\n  366 |     __m308 = _mm256_set1_epi8((int)'z' - 325);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:367:5: error: \u2018__m310\u2019 was not declared in this scope; did you mean \u2018__m512\u2019?\n  367 |     __m310 = _mm256_set1_epi8((int)'A' + 325);\n      |     ^~~~~~\n      |     __m512\n[REDACTED]/tmpwuunr1kx.cpp:367:40: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018390\u2019 to \u2018-122\u2019 [-Woverflow]\n  367 |     __m310 = _mm256_set1_epi8((int)'A' + 325);\n      |                               ~~~~~~~~~^~~~~\n[REDACTED]/tmpwuunr1kx.cpp:368:5: error: \u2018__m360\u2019 was not declared in this scope; did you mean \u2018__m64\u2019?\n  368 |     __m360 = _mm25\n      |     ^~~~~~\n      |     __m64\n[REDACTED]/tmpwuunr1kx.cpp:368:14: error: \u2018_mm25\u2019 was not declared in this scope; did you mean \u2018__m256\u2019?\n  368 |     __m360 = _mm25\n      |              ^~~~~\n      |              __m256\n[REDACTED]/tmpwuunr1kx.cpp:380:21: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  380 | bool humaneval_check() {\n      |                     ^~\n[REDACTED]/tmpwuunr1kx.cpp:380:21: note: remove parentheses to default-initialize a variable\n  380 | bool humaneval_check() {\n      |                     ^~\n      |                     --\n[REDACTED]/tmpwuunr1kx.cpp:380:21: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmpwuunr1kx.cpp:380:24: error: a function-definition is not allowed here before \u2018{\u2019 token\n  380 | bool humaneval_check() {\n      |                        ^\n[REDACTED]/tmpwuunr1kx.cpp:398:40: error: a function-definition is not allowed here before \u2018{\u2019 token\n  398 | bool correctness_check(int iterations) {\n      |                                        ^\n[REDACTED]/tmpwuunr1kx.cpp:420:9: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  420 | int main(){\n      |         ^~\n[REDACTED]/tmpwuunr1kx.cpp:420:9: note: remove parentheses to default-initialize a variable\n  420 | int main(){\n      |         ^~\n      |         --\n[REDACTED]/tmpwuunr1kx.cpp:420:9: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmpwuunr1kx.cpp:420:11: error: a function-definition is not allowed here before \u2018{\u2019 token\n  420 | int main(){\n      |           ^\n[REDACTED]/tmpwuunr1kx.cpp:424:2: error: expected \u2018}\u2019 at end of input\n  424 | }\n      |  ^\n[REDACTED]/tmpwuunr1kx.cpp:44:33: note: to match this \u2018{\u2019\n   44 | decode_shift_simd(std::string s){\n      |                                 ^\n[REDACTED]/tmpwuunr1kx.cpp:424:2: warning: no return statement in function returning non-void [-Wreturn-type]\n  424 | }\n      |  ^\n"}
{"task_id": "SimdBench_88_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzqxsm7h1.cpp: In function \u2018bool below_threshold_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpzqxsm7h1.cpp:29:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i threshold = _mm_set_epi32(t, t, t, t);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpzqxsm7h1.cpp:34:15: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   34 |         vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&l[i]));\n      |               ^~~~~~~~~~~~~~~\n      |               _mm_loadu_si16\n[REDACTED]/tmpzqxsm7h1.cpp:35:36: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         result &= (_mm_cmpgt_epi32(vec, threshold) == _mm_setzero_si256());\n      |                                    ^~~\n      |                                    |\n      |                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpzqxsm7h1.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1387:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi32(__m128i, __m128i)\u2019\n 1387 | _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpzqxsm7h1.cpp:35:55: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   35 |         result &= (_mm_cmpgt_epi32(vec, threshold) == _mm_setzero_si256());\n      |                                                       ^~~~~~~~~~~~~~~~~\n      |                                                       _mm_setzero_si64\n"}
{"task_id": "SimdBench_88_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_88_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_88_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_88_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpy8way889.cpp: In function \u2018bool below_threshold_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpy8way889.cpp:29:38: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i threshold = _mm_set_epi32(t, t, t, t);\n      |                         ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                      |\n      |                                      __m128i\n[REDACTED]/tmpy8way889.cpp:34:15: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   34 |         vec = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&l[i]));\n      |               ^~~~~~~~~~~~~~~\n      |               _mm_loadu_si16\n[REDACTED]/tmpy8way889.cpp:35:19: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   35 |         result &= _mm_testz_si256(vec, threshold);\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_testz_si128\n"}
{"task_id": "SimdBench_89_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpduq7zaa0.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpduq7zaa0.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(-1);\n      |                    ~~~~~~~~~~~~~~^~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpduq7zaa0.cpp:36:21: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i stack = _mm_setzero_si256();\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpduq7zaa0.cpp:16:\n[REDACTED]/tmpduq7zaa0.cpp:40:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   40 |             stack = _mm_insert_epi32(stack, i, 0);\n      |                     ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpduq7zaa0.cpp:42:16: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   42 |             if(_mm_testz_si256(mask, stack)){\n      |                ^~~~~~~~~~~~~~~\n      |                _mm_testz_si128\n[REDACTED]/tmpduq7zaa0.cpp:45:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   45 |             stack = _mm_extract_epi32(stack, 0);\n      |                     ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpduq7zaa0.cpp:49:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   49 |     return _mm_testz_si256(mask, stack);\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_89_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpak9_9way.cpp:47:59: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   47 |             stack = _mm_shuffle_epi32(stack, stack, 0b1100);\n      |                                                           ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpak9_9way.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpak9_9way.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpak9_9way.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(0);\n      |                    ~~~~~~~~~~~~~~^~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpak9_9way.cpp:36:21: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i stack = _mm_setzero_si256();\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpak9_9way.cpp:16:\n[REDACTED]/tmpak9_9way.cpp:40:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   40 |             __m256i new_stack = _mm_insert_epi32(stack, i, 0);\n      |                                 ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpak9_9way.cpp:41:55: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   41 |             mask = _mm_or_si256(mask, _mm_cmpgt_epi32(_mm_loadu_si256(&new_stack), _mm_setzero_si256()));\n      |                                                       ^~~~~~~~~~~~~~~\n      |                                                       _mm_loadu_si16\n[REDACTED]/tmpak9_9way.cpp:41:20: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   41 |             mask = _mm_or_si256(mask, _mm_cmpgt_epi32(_mm_loadu_si256(&new_stack), _mm_setzero_si256()));\n      |                    ^~~~~~~~~~~~\n      |                    _mm_or_si64\n[REDACTED]/tmpak9_9way.cpp:43:36: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |             __m256i popped_index = _mm_extract_epi32(stack, 0);\n      |                                    ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpak9_9way.cpp:44:34: error: could not convert \u2018(((((popped_index >= __m256i{((long long int)i), ((long long int)i), ((long long int)i), ((long long int)i)}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) | ((((popped_index < (__m256i){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}))\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   44 |             if(popped_index >= i || popped_index < 0){\n      |                ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n      |                                  |\n      |                                  __vector(4) long int\n[REDACTED]/tmpak9_9way.cpp:47:21: error: \u2018_mm_shuffle_epi32\u2019 was not declared in this scope\n   47 |             stack = _mm_shuffle_epi32(stack, stack, 0b1100);\n      |                     ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpak9_9way.cpp:51:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   51 |     return _mm_testz_si256(mask, mask);\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_89_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpc8of45q0.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpc8of45q0.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(-1);\n      |                    ~~~~~~~~~~~~~~^~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpc8of45q0.cpp:36:21: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i stack = _mm_setzero_si256();\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpc8of45q0.cpp:16:\n[REDACTED]/tmpc8of45q0.cpp:40:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   40 |             stack = _mm_insert_epi32(stack, i, 0);\n      |                     ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpc8of45q0.cpp:42:16: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   42 |             if(_mm_testz_si256(mask, stack)){\n      |                ^~~~~~~~~~~~~~~\n      |                _mm_testz_si128\n[REDACTED]/tmpc8of45q0.cpp:45:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   45 |             stack = _mm_extract_epi32(stack, 0);\n      |                     ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpc8of45q0.cpp:49:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   49 |     return _mm_testz_si256(mask, stack);\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_89_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi95_0zij.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpi95_0zij.cpp:35:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi8(0);\n      |                    ~~~~~~~~~~~~~^~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpi95_0zij.cpp:36:21: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i stack = _mm_setzero_si256();\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpi95_0zij.cpp:16:\n[REDACTED]/tmpi95_0zij.cpp:41:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |             stack = _mm_insert_epi8(stack, 1, 0);\n      |                     ^~~~~~~~~~~~~~~\n[REDACTED]/tmpi95_0zij.cpp:43:21: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   43 |             stack = _mm_andnot_si256(_mm_set1_epi8(1), stack);\n      |                     ^~~~~~~~~~~~~~~~\n      |                     _mm_andnot_si64\n[REDACTED]/tmpi95_0zij.cpp:46:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   46 |         if(_mm_testz_si256(mask, stack)){\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_89_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw71io3uw.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpw71io3uw.cpp:34:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   34 |     __m256i mask = _mm_set1_epi8(0);\n      |                    ~~~~~~~~~~~~~^~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpw71io3uw.cpp:35:22: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   35 |     __m256i result = _mm_setzero_si256();\n      |                      ^~~~~~~~~~~~~~~~~\n      |                      _mm_setzero_si64\n[REDACTED]/tmpw71io3uw.cpp:38:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |         __m256i current = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&brackets[i]));\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpw71io3uw.cpp:42:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         __m256i match = _mm_cmpeq_epi8(current, next);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpw71io3uw.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpw71io3uw.cpp:43:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   43 |         result = _mm_or_si256(result, match);\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmpw71io3uw.cpp:46:16: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   46 |         mask = _mm_andnot_si256(match, mask);\n      |                ^~~~~~~~~~~~~~~~\n      |                _mm_andnot_si64\n"}
{"task_id": "SimdBench_90_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3m6hwm49.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmp3m6hwm49.cpp:31:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   31 |     __m256i mask = _mm_set1_epi32(0);\n      |                    ~~~~~~~~~~~~~~^~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmp3m6hwm49.cpp:34:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   34 |         __m256i vec = _mm_loadu_si256((__m256i*)&brackets[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp3m6hwm49.cpp:35:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i cmp = _mm_cmpeq_epi8(vec, _mm_set1_epi8('('));\n      |                                      ^~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp3m6hwm49.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmp3m6hwm49.cpp:36:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   36 |         mask = _mm_or_si256(mask, cmp);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n"}
{"task_id": "SimdBench_90_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp84vnxqad.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmp84vnxqad.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(-1);\n      |                    ~~~~~~~~~~~~~~^~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmp84vnxqad.cpp:36:19: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i acc = _mm_setzero_si256();\n      |                   ^~~~~~~~~~~~~~~~~\n      |                   _mm_setzero_si64\n[REDACTED]/tmp84vnxqad.cpp:39:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i current = _mm_loadu_si256((__m256i*)&brackets[i]);\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmp84vnxqad.cpp:42:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         __m256i diff = _mm_sub_epi32(current, next);\n      |                                      ^~~~~~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp84vnxqad.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp84vnxqad.cpp:44:15: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   44 |         acc = _mm_or_si256(acc, diff);\n      |               ^~~~~~~~~~~~\n      |               _mm_or_si64\n[REDACTED]/tmp84vnxqad.cpp:48:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |     return _mm_movemask_epi8(acc) != 0;\n      |                              ^~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_90_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgc5qvuyc.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpgc5qvuyc.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(0);\n      |                    ~~~~~~~~~~~~~~^~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpgc5qvuyc.cpp:36:21: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i stack = _mm_setzero_si256();\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpgc5qvuyc.cpp:16:\n[REDACTED]/tmpgc5qvuyc.cpp:41:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |             __m256i new_stack = _mm_insert_epi32(stack, i, 0);\n      |                                 ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpgc5qvuyc.cpp:44:16: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   44 |             if(_mm_testz_si256(mask, stack)){\n      |                ^~~~~~~~~~~~~~~\n      |                _mm_testz_si128\n[REDACTED]/tmpgc5qvuyc.cpp:47:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   47 |             __m256i index = _mm_extract_epi32(stack, 0);\n      |                             ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpgc5qvuyc.cpp:48:52: error: cannot convert \u2018__m256i\u2019 to \u2018int\u2019\n   48 |             mask = _mm_andnot_si256(_mm_set1_epi32(index), mask);\n      |                                                    ^~~~~\n      |                                                    |\n      |                                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpgc5qvuyc.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:645:21: note:   initializing argument 1 of \u2018__m128i _mm_set1_epi32(int)\u2019\n  645 | _mm_set1_epi32 (int __A)\n      |                 ~~~~^~~\n[REDACTED]/tmpgc5qvuyc.cpp:48:20: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   48 |             mask = _mm_andnot_si256(_mm_set1_epi32(index), mask);\n      |                    ^~~~~~~~~~~~~~~~\n      |                    _mm_andnot_si64\n[REDACTED]/tmpgc5qvuyc.cpp:49:35: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   49 |             stack = _mm_sub_epi32(stack, _mm_set1_epi32(1));\n      |                                   ^~~~~\n      |                                   |\n      |                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpgc5qvuyc.cpp:53:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   53 |     return _mm_testz_si256(mask, stack);\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_90_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphgntqdg5.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmphgntqdg5.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(-1);\n      |                    ~~~~~~~~~~~~~~^~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmphgntqdg5.cpp:36:22: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i result = _mm_setzero_si256();\n      |                      ^~~~~~~~~~~~~~~~~\n      |                      _mm_setzero_si64\n[REDACTED]/tmphgntqdg5.cpp:39:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i current = _mm_loadu_si256((__m256i*)&brackets[i]);\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmphgntqdg5.cpp:43:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         __m256i check = _mm_cmpeq_epi8(current, next);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmphgntqdg5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmphgntqdg5.cpp:44:18: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   44 |         result = _mm_or_si256(result, check);\n      |                  ^~~~~~~~~~~~\n      |                  _mm_or_si64\n[REDACTED]/tmphgntqdg5.cpp:56:74: error: cannot convert \u2018__m128i\u2019 to \u2018long long int\u2019 in assignment\n   56 |         result[0] &= ~_mm_cmpgt_epi8(_mm_set1_epi8(c), _mm_set1_epi8(')'));\n      |                                                                          ^\n[REDACTED]/tmphgntqdg5.cpp:59:12: error: \u2018_mm_testz_si256\u2019 was not declared in this scope; did you mean \u2018_mm_testz_si128\u2019?\n   59 |     return _mm_testz_si256(mask, result);\n      |            ^~~~~~~~~~~~~~~\n      |            _mm_testz_si128\n"}
{"task_id": "SimdBench_90_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpc67f9njx.cpp: In function \u2018bool correct_bracketing_simd(std::string)\u2019:\n[REDACTED]/tmpc67f9njx.cpp:35:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set1_epi32(-1);\n      |                    ~~~~~~~~~~~~~~^~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpc67f9njx.cpp:36:19: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   36 |     __m256i sum = _mm_setzero_si256();\n      |                   ^~~~~~~~~~~~~~~~~\n      |                   _mm_setzero_si64\n[REDACTED]/tmpc67f9njx.cpp:39:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i current = _mm_loadu_si256((__m256i*)&brackets[i]);\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpc67f9njx.cpp:42:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         __m256i diff = _mm_sub_epi32(next, current);\n      |                                      ^~~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpc67f9njx.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpc67f9njx.cpp:43:26: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   43 |         __m256i result = _mm_and_si256(diff, mask);\n      |                          ^~~~~~~~~~~~~\n      |                          _mm_and_si64\n[REDACTED]/tmpc67f9njx.cpp:45:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |         sum = _mm_add_epi32(sum, result);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpc67f9njx.cpp:16:\n[REDACTED]/tmpc67f9njx.cpp:48:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   48 |     int total_sum = _mm_extract_epi32(sum, 0) + _mm_extract_epi32(sum, 1) +\n      |                     ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpc67f9njx.cpp:48:49: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   48 |     int total_sum = _mm_extract_epi32(sum, 0) + _mm_extract_epi32(sum, 1) +\n      |                                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpc67f9njx.cpp:49:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   49 |                      _mm_extract_epi32(sum, 2) + _mm_extract_epi32(sum, 3);\n      |                      ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpc67f9njx.cpp:49:50: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   49 |                      _mm_extract_epi32(sum, 2) + _mm_extract_epi32(sum, 3);\n      |                                                  ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_91_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2ecgyorm.cpp: In function \u2018std::vector<float> derivative_simd(std::vector<float>)\u2019:\n[REDACTED]/tmp2ecgyorm.cpp:41:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   41 |         __m256 x = _mm256_loadu_ps(ptr + i);\n      |                                    ~~~~^~~\n      |                                        |\n      |                                        __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2ecgyorm.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmp2ecgyorm.cpp:43:34: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm256_storeu_ps(res_ptr + i, dx);\n      |                          ~~~~~~~~^~~\n      |                                  |\n      |                                  __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_91_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmx8wtm67.cpp: In function \u2018std::vector<float> derivative_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpmx8wtm67.cpp:41:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   41 |         __m256 x = _mm256_loadu_ps(ptr + i);\n      |                                    ~~~~^~~\n      |                                        |\n      |                                        __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpmx8wtm67.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpmx8wtm67.cpp:43:34: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm256_storeu_ps(res_ptr + i, dx);\n      |                          ~~~~~~~~^~~\n      |                                  |\n      |                                  __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_91_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmnqkboq_.cpp: In function \u2018std::vector<float> derivative_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpmnqkboq_.cpp:40:43: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   40 |         __m256 temp = _mm256_loadu_ps(ptr + i);\n      |                                       ~~~~^~~\n      |                                           |\n      |                                           __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpmnqkboq_.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpmnqkboq_.cpp:41:52: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   41 |         __m256 next_temp = _mm256_loadu_ps(ptr + i + 1);\n      |                                            ~~~~~~~~^~~\n      |                                                    |\n      |                                                    __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpmnqkboq_.cpp:43:33: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm256_storeu_ps(result + i, diff);\n      |                          ~~~~~~~^~~\n      |                                 |\n      |                                 __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\nIn file included from /usr/include/c++/13/vector:65,\n                 from [REDACTED]/tmpmnqkboq_.cpp:2:\n/usr/include/c++/13/bits/stl_uninitialized.h: In instantiation of \u2018constexpr bool std::__check_constructible() [with _ValueType = float; _Tp = __vector(8) float&]\u2019:\n/usr/include/c++/13/bits/stl_uninitialized.h:182:4:   required from \u2018_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = __vector(8) float*; _ForwardIterator = float*]\u2019\n/usr/include/c++/13/bits/stl_uninitialized.h:373:37:   required from \u2018_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = __vector(8) float*; _ForwardIterator = float*; _Tp = float]\u2019\n/usr/include/c++/13/bits/stl_vector.h:1695:33:   required from \u2018void std::vector<_Tp, _Alloc>::_M_range_initialize(_ForwardIterator, _ForwardIterator, std::forward_iterator_tag) [with _ForwardIterator = __vector(8) float*; _Tp = float; _Alloc = std::allocator<float>]\u2019\n/usr/include/c++/13/bits/stl_vector.h:711:23:   required from \u2018std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&) [with _InputIterator = __vector(8) float*; <template-parameter-2-2> = void; _Tp = float; _Alloc = std::allocator<float>; allocator_type = std::allocator<float>]\u2019\n[REDACTED]/tmpmnqkboq_.cpp:51:44:   required from here\n/usr/include/c++/13/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type\n   90 |       static_assert(is_constructible<_ValueType, _Tp>::value,\n      |                                                        ^~~~~\n/usr/include/c++/13/bits/stl_uninitialized.h:90:56: note: \u2018std::integral_constant<bool, false>::value\u2019 evaluates to false\n"}
{"task_id": "SimdBench_91_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbcrc6qku.cpp: In function \u2018std::vector<float> derivative_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpbcrc6qku.cpp:41:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   41 |         __m256 x = _mm256_loadu_ps(ptr + i);\n      |                                    ~~~~^~~\n      |                                        |\n      |                                        __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbcrc6qku.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpbcrc6qku.cpp:43:34: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm256_storeu_ps(res_ptr + i, dx);\n      |                          ~~~~~~~~^~~\n      |                                  |\n      |                                  __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_91_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpawlxkaex.cpp: In function \u2018std::vector<float> derivative_simd(std::vector<float>)\u2019:\n[REDACTED]/tmpawlxkaex.cpp:41:40: error: cannot convert \u2018__m256*\u2019 to \u2018const float*\u2019\n   41 |         __m256 x = _mm256_loadu_ps(ptr + i);\n      |                                    ~~~~^~~\n      |                                        |\n      |                                        __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpawlxkaex.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:903:31: note:   initializing argument 1 of \u2018__m256 _mm256_loadu_ps(const float*)\u2019\n  903 | _mm256_loadu_ps (float const *__P)\n      |                  ~~~~~~~~~~~~~^~~\n[REDACTED]/tmpawlxkaex.cpp:43:34: error: cannot convert \u2018__m256*\u2019 to \u2018float*\u2019\n   43 |         _mm256_storeu_ps(res_ptr + i, dx);\n      |                          ~~~~~~~~^~~\n      |                                  |\n      |                                  __m256*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:909:26: note:   initializing argument 1 of \u2018void _mm256_storeu_ps(float*, __m256)\u2019\n  909 | _mm256_storeu_ps (float *__P, __m256 __A)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_92_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjtw7sdmy.cpp: In function \u2018int vowels_count_simd(std::string)\u2019:\n[REDACTED]/tmpjtw7sdmy.cpp:35:32: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   35 |     __m256i mask = _mm_set_epi8(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0);\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpjtw7sdmy.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpjtw7sdmy.cpp:36:34: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   36 |     __m256i vowels = _mm_set_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U');\n      |                      ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpjtw7sdmy.cpp:39:22: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i ch = _mm_loadu_si256((__m256i*)str);\n      |                      ^~~~~~~~~~~~~~~\n      |                      _mm_loadu_si16\n[REDACTED]/tmpjtw7sdmy.cpp:41:46: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         ch = _mm_or_si256(ch, _mm_cmpeq_epi8(ch, vowels));\n      |                                              ^~\n      |                                              |\n      |                                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpjtw7sdmy.cpp:41:14: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   41 |         ch = _mm_or_si256(ch, _mm_cmpeq_epi8(ch, vowels));\n      |              ^~~~~~~~~~~~\n      |              _mm_or_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpjtw7sdmy.cpp:16:\n[REDACTED]/tmpjtw7sdmy.cpp:42:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |         count += _mm_popcnt_u32(_mm_extract_epi32(ch, 0)) + _mm_popcnt_u32(_mm_extract_epi32(ch, 1)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpjtw7sdmy.cpp:42:76: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |         count += _mm_popcnt_u32(_mm_extract_epi32(ch, 0)) + _mm_popcnt_u32(_mm_extract_epi32(ch, 1)) +\n      |                                                                            ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpjtw7sdmy.cpp:43:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |                  _mm_popcnt_u32(_mm_extract_epi32(ch, 2)) + _mm_popcnt_u32(_mm_extract_epi32(ch, 3));\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpjtw7sdmy.cpp:43:76: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |                  _mm_popcnt_u32(_mm_extract_epi32(ch, 2)) + _mm_popcnt_u32(_mm_extract_epi32(ch, 3));\n      |                                                                            ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_92_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpg9fpdmnz.cpp:33:34: warning: character constant too long for its type\n   33 |     __m256i mask = _mm_set1_epi8('aeiouAEIOU');\n      |                                  ^~~~~~~~~~~~\n[REDACTED]/tmpg9fpdmnz.cpp: In function \u2018int vowels_count_simd(std::string)\u2019:\n[REDACTED]/tmpg9fpdmnz.cpp:33:34: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u20181162432341\u2019 to \u201885\u2019 [-Woverflow]\n[REDACTED]/tmpg9fpdmnz.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set1_epi8('aeiouAEIOU');\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpg9fpdmnz.cpp:34:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   34 |     __m256i str = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&s[0]));\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n[REDACTED]/tmpg9fpdmnz.cpp:35:37: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |     __m256i result = _mm_cmpeq_epi8(str, mask);\n      |                                     ^~~\n      |                                     |\n      |                                     __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpg9fpdmnz.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpg9fpdmnz.cpp:16:\n[REDACTED]/tmpg9fpdmnz.cpp:36:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   36 |     count += _mm_popcnt_u32(_mm_extract_epi32(result, 0));\n      |                             ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpg9fpdmnz.cpp:37:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   37 |     count += _mm_popcnt_u32(_mm_extract_epi32(result, 1));\n      |                             ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpg9fpdmnz.cpp:38:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   38 |     count += _mm_popcnt_u32(_mm_extract_epi32(result, 2));\n      |                             ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpg9fpdmnz.cpp:39:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   39 |     count += _mm_popcnt_u32(_mm_extract_epi32(result, 3));\n      |                             ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_92_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpyjevc_c8.cpp:33:34: warning: character constant too long for its type\n   33 |     __m256i mask = _mm_set1_epi8('aeiouAEIOU');\n      |                                  ^~~~~~~~~~~~\n[REDACTED]/tmpyjevc_c8.cpp: In function \u2018int vowels_count_simd(std::string)\u2019:\n[REDACTED]/tmpyjevc_c8.cpp:33:34: warning: overflow in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u20181162432341\u2019 to \u201885\u2019 [-Woverflow]\n[REDACTED]/tmpyjevc_c8.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set1_epi8('aeiouAEIOU');\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpyjevc_c8.cpp:34:19: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   34 |     __m256i str = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&s[0]));\n      |                   ^~~~~~~~~~~~~~~\n      |                   _mm_loadu_si16\n[REDACTED]/tmpyjevc_c8.cpp:37:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i result = _mm_or_si256(_mm_cmpeq_epi8(str, mask), _mm_and_si256(_mm_cmpgt_epi8(str, _mm_set1_epi8('y')), _mm_set1_epi8(1)));\n      |                                                      ^~~\n      |                                                      |\n      |                                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpyjevc_c8.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpyjevc_c8.cpp:37:95: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i result = _mm_or_si256(_mm_cmpeq_epi8(str, mask), _mm_and_si256(_mm_cmpgt_epi8(str, _mm_set1_epi8('y')), _mm_set1_epi8(1)));\n      |                                                                                               ^~~\n      |                                                                                               |\n      |                                                                                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpyjevc_c8.cpp:37:66: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   37 |         __m256i result = _mm_or_si256(_mm_cmpeq_epi8(str, mask), _mm_and_si256(_mm_cmpgt_epi8(str, _mm_set1_epi8('y')), _mm_set1_epi8(1)));\n      |                                                                  ^~~~~~~~~~~~~\n      |                                                                  _mm_and_si64\n[REDACTED]/tmpyjevc_c8.cpp:37:26: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   37 |         __m256i result = _mm_or_si256(_mm_cmpeq_epi8(str, mask), _mm_and_si256(_mm_cmpgt_epi8(str, _mm_set1_epi8('y')), _mm_set1_epi8(1)));\n      |                          ^~~~~~~~~~~~\n      |                          _mm_or_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpyjevc_c8.cpp:16:\n[REDACTED]/tmpyjevc_c8.cpp:38:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   38 |         count += _mm_popcnt_u32(_mm_extract_epi32(result, 0));\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpyjevc_c8.cpp:39:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   39 |         count += _mm_popcnt_u32(_mm_extract_epi32(result, 1));\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpyjevc_c8.cpp:40:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   40 |         count += _mm_popcnt_u32(_mm_extract_epi32(result, 2));\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpyjevc_c8.cpp:41:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |         count += _mm_popcnt_u32(_mm_extract_epi32(result, 3));\n      |                                 ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_92_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplrtb9dlg.cpp: In function \u2018int vowels_count_simd(std::string)\u2019:\n[REDACTED]/tmplrtb9dlg.cpp:33:32: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   33 |     __m256i mask = _mm_set_epi8(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0);\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmplrtb9dlg.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmplrtb9dlg.cpp:34:34: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   34 |     __m256i vowels = _mm_set_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U');\n      |                      ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmplrtb9dlg.cpp:37:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   37 |         __m256i word = _mm_loadu_si256((__m256i*)&s[i]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmplrtb9dlg.cpp:38:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         __m256i result = _mm_or_si256(_mm_cmpeq_epi8(word, vowels), mask);\n      |                                                      ^~~~\n      |                                                      |\n      |                                                      __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmplrtb9dlg.cpp:38:26: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   38 |         __m256i result = _mm_or_si256(_mm_cmpeq_epi8(word, vowels), mask);\n      |                          ^~~~~~~~~~~~\n      |                          _mm_or_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmplrtb9dlg.cpp:16:\n[REDACTED]/tmplrtb9dlg.cpp:39:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   39 |         count += _mm_popcnt_u32(_mm_extract_epi32(result, 0)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmplrtb9dlg.cpp:40:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   40 |                  _mm_popcnt_u32(_mm_extract_epi32(result, 1)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmplrtb9dlg.cpp:41:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |                  _mm_popcnt_u32(_mm_extract_epi32(result, 2)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmplrtb9dlg.cpp:42:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |                  _mm_popcnt_u32(_mm_extract_epi32(result, 3));\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmplrtb9dlg.cpp:47:46: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   47 |         if (_mm_test_all_ones(_mm_cmpeq_epi8(_mm_loadu_si256((__m256i*)&s[i]), vowels))) {\n      |                                              ^~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_92_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxfk5339l.cpp: In function \u2018int vowels_count_simd(std::string)\u2019:\n[REDACTED]/tmpxfk5339l.cpp:34:32: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   34 |     __m256i mask = _mm_set_epi8(97, 101, 105, 111, 117, 99, 104, 111, 114, 116); // ASCII values of 'a', 'e', 'i', 'o', 'u'\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpxfk5339l.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpxfk5339l.cpp:35:38: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   35 |     __m256i lower_mask = _mm_set_epi8(97, 101, 105, 111, 117, 99, 104, 111, 114, 116);\n      |                          ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpxfk5339l.cpp:36:38: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   36 |     __m256i upper_mask = _mm_set_epi8(65, 69, 73, 79, 85, 97, 101, 105, 111, 114);\n      |                          ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpxfk5339l.cpp:39:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i vec = _mm_loadu_si256((__m256i*)&s[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpxfk5339l.cpp:16:\n[REDACTED]/tmpxfk5339l.cpp:43:33: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |         count += _mm_popcnt_u32(_mm_extract_epi32(vec, 0)) +\n      |                                 ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpxfk5339l.cpp:44:31: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   44 |                _mm_popcnt_u32(_mm_extract_epi32(vec, 1)) +\n      |                               ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpxfk5339l.cpp:45:31: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   45 |                _mm_popcnt_u32(_mm_extract_epi32(vec, 2)) +\n      |                               ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpxfk5339l.cpp:46:31: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   46 |                _mm_popcnt_u32(_mm_extract_epi32(vec, 3));\n      |                               ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_93_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_b5syxdo.cpp: In function \u2018int digitSum_simd(std::string)\u2019:\n[REDACTED]/tmp_b5syxdo.cpp:40:20: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   40 |         vec_char = _mm_loadu_si256((__m256i*)&s[i]);\n      |                    ^~~~~~~~~~~~~~~\n      |                    _mm_loadu_si16\n[REDACTED]/tmp_b5syxdo.cpp:44:11: error: \u2018_mm256_reduce_add_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   44 |     sum = _mm256_reduce_add_epi8(vec_sum);\n      |           ^~~~~~~~~~~~~~~~~~~~~~\n      |           _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_93_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_93_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp71pkuvdz.cpp: In function \u2018int digitSum_simd(std::string)\u2019:\n[REDACTED]/tmp71pkuvdz.cpp:42:11: error: \u2018i\u2019 was not declared in this scope\n   42 |     for(; i < s.size(); ++i){\n      |           ^\n[REDACTED]/tmp71pkuvdz.cpp:50:42: error: \u2018_MM_FMA3_ACCUMULATE\u2019 was not declared in this scope\n   50 |     return _mm256_reduce_add_epi32(vsum, _MM_FMA3_ACCUMULATE);\n      |                                          ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp71pkuvdz.cpp:50:12: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   50 |     return _mm256_reduce_add_epi32(vsum, _MM_FMA3_ACCUMULATE);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n      |            _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_93_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp48ktt6pf.cpp: In function \u2018int digitSum_simd(std::string)\u2019:\n[REDACTED]/tmp48ktt6pf.cpp:36:102: error: \u2018_mm256_cmplt_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi8\u2019?\n   36 |         vstr = _mm256_or_si256(vstr, _mm256_and_si256(_mm256_cmpgt_epi8(vch, _mm256_set1_epi8('0')), _mm256_cmplt_epi8(vch, _mm256_set1_epi8('9'))));\n      |                                                                                                      ^~~~~~~~~~~~~~~~~\n      |                                                                                                      _mm256_cmpgt_epi8\n[REDACTED]/tmp48ktt6pf.cpp:37:60: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         vsum = _mm256_add_epi32(vsum, _mm256_cvtepi8_epi32(vstr));\n      |                                                            ^~~~\n      |                                                            |\n      |                                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmp48ktt6pf.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:447:31: note:   initializing argument 1 of \u2018__m256i _mm256_cvtepi8_epi32(__m128i)\u2019\n  447 | _mm256_cvtepi8_epi32 (__m128i __X)\n      |                       ~~~~~~~~^~~\n[REDACTED]/tmp48ktt6pf.cpp:47:12: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   47 |     return _mm256_reduce_add_epi32(vsum);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n      |            _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_93_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpwdolaipk.cpp:16:\n[REDACTED]/tmpwdolaipk.cpp: In function \u2018int digitSum_simd(std::string)\u2019:\n[REDACTED]/tmpwdolaipk.cpp:39:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   39 |         vsum = _mm256_add_epi32(vsum, _mm256_extract_epi32(vtemp, 0));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpwdolaipk.cpp:40:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   40 |         vsum = _mm256_add_epi32(vsum, _mm256_extract_epi32(vtemp, 1));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpwdolaipk.cpp:41:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   41 |         vsum = _mm256_add_epi32(vsum, _mm256_extract_epi32(vtemp, 2));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpwdolaipk.cpp:42:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   42 |         vsum = _mm256_add_epi32(vsum, _mm256_extract_epi32(vtemp, 3));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_94_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpujm8dlu9.cpp: In function \u2018std::vector<int> pluck_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpujm8dlu9.cpp:32:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   32 |     __m256i min_even = _mm_setzero_si256();\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmpujm8dlu9.cpp:36:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |         __m256i vec = _mm_loadu_si256((__m256i*)&arr[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpujm8dlu9.cpp:38:31: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   38 |         __m256i even_values = _mm_and_si256(even_mask, vec);\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_and_si64\n[REDACTED]/tmpujm8dlu9.cpp:39:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         __m256i even_min = _mm_min_epi32(even_values, min_even);\n      |                                          ^~~~~~~~~~~\n      |                                          |\n      |                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpujm8dlu9.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:300:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi32(__m128i, __m128i)\u2019\n  300 | _mm_min_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpujm8dlu9.cpp:41:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         if(_mm_movemask_epi8(even_min) != 0){\n      |                              ^~~~~~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpujm8dlu9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpujm8dlu9.cpp:49:26: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   49 |         result.push_back(_mm_extract_epi32(min_even, 0));\n      |                          ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_94_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpp7et02wp.cpp:16:\n[REDACTED]/tmpp7et02wp.cpp: In function \u2018std::vector<int> pluck_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpp7et02wp.cpp:41:39: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   41 |         __m256i current_even_values = _mm256_extract_epi32(even_values, i);\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       int\n"}
{"task_id": "SimdBench_94_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpighj2kl4.cpp:38:91: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   38 |         __m256i mask = _mm_cmpgt_epi32(_mm_shuffle_epi32(vec, vec, _MM_SHUFFLE(0, 1, 2, 3)), _mm_setzero_si256());\n      |                                                                                           ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpighj2kl4.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpighj2kl4.cpp: In function \u2018std::vector<int> pluck_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpighj2kl4.cpp:32:24: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   32 |     __m256i min_even = _mm_setzero_si256();\n      |                        ^~~~~~~~~~~~~~~~~\n      |                        _mm_setzero_si64\n[REDACTED]/tmpighj2kl4.cpp:37:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   37 |         __m256i vec = _mm_loadu_si256((__m256i*)&arr[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpighj2kl4.cpp:38:40: error: \u2018_mm_shuffle_epi32\u2019 was not declared in this scope\n   38 |         __m256i mask = _mm_cmpgt_epi32(_mm_shuffle_epi32(vec, vec, _MM_SHUFFLE(0, 1, 2, 3)), _mm_setzero_si256());\n      |                                        ^~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpighj2kl4.cpp:16:\n[REDACTED]/tmpighj2kl4.cpp:39:93: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   39 |         __m256i even_mask = _mm_and_si256(mask, _mm_cmpeq_epi32(vec, _mm_cvtsi32_si256((int)_mm_extract_epi32(vec, 0))));\n      |                                                                                             ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpighj2kl4.cpp:39:70: error: \u2018_mm_cvtsi32_si256\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi32_si64\u2019?\n   39 |         __m256i even_mask = _mm_and_si256(mask, _mm_cmpeq_epi32(vec, _mm_cvtsi32_si256((int)_mm_extract_epi32(vec, 0))));\n      |                                                                      ^~~~~~~~~~~~~~~~~\n      |                                                                      _mm_cvtsi32_si64\n[REDACTED]/tmpighj2kl4.cpp:39:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i even_mask = _mm_and_si256(mask, _mm_cmpeq_epi32(vec, _mm_cvtsi32_si256((int)_mm_extract_epi32(vec, 0))));\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\n[REDACTED]/tmpighj2kl4.cpp:43:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         __m256i even_min = _mm_min_epi32(even_values, min_even);\n      |                                          ^~~~~~~~~~~\n      |                                          |\n      |                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:300:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi32(__m128i, __m128i)\u2019\n  300 | _mm_min_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpighj2kl4.cpp:44:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |         __m256i even_min_index = _mm_min_epi32(even_indices, min_index);\n      |                                                ^~~~~~~~~~~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:300:24: note:   initializing argument 1 of \u2018__m128i _mm_min_epi32(__m128i, __m128i)\u2019\n  300 | _mm_min_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpighj2kl4.cpp:51:76: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   51 |         if(arr[i] % 2 == 0 && (min_even == _mm_setzero_si256() || arr[i] < _mm_extract_epi32(min_even, 0))) {\n      |                                                                            ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpighj2kl4.cpp:52:37: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   52 |             min_even = _mm_set_epi32(arr[i], arr[i]);\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmpighj2kl4.cpp:53:38: error: too few arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   53 |             min_index = _mm_set_epi32(i, i);\n      |                         ~~~~~~~~~~~~~^~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmpighj2kl4.cpp:58:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   58 |     result.push_back(_mm_extract_epi32(min_even, 0));\n      |                      ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpighj2kl4.cpp:59:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   59 |     result.push_back(_mm_extract_epi32(min_index, 0));\n      |                      ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_94_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgcd_ewwi.cpp: In function \u2018std::vector<int> pluck_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpgcd_ewwi.cpp:34:48: error: \u2018_mm256_cmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   34 |     __m256i even_mask = _mm256_and_si256(mask, _mm256_cmpge_epi32(vec, _mm256_set1_epi32(0)));\n      |                                                ^~~~~~~~~~~~~~~~~~\n      |                                                _mm256_cmpgt_epi32\n[REDACTED]/tmpgcd_ewwi.cpp:36:114: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   36 |     __m256i min_even_values = _mm256_min_epu32(even_values, _mm256_permutevar_epi32(even_values, _mm256_set_epi32(0, 7, 4, 1)));\n      |                                                                                                  ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpgcd_ewwi.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpgcd_ewwi.cpp:36:61: error: \u2018_mm256_permutevar_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi32\u2019?\n   36 |     __m256i min_even_values = _mm256_min_epu32(even_values, _mm256_permutevar_epi32(even_values, _mm256_set_epi32(0, 7, 4, 1)));\n      |                                                             ^~~~~~~~~~~~~~~~~~~~~~~\n      |                                                             _mm256_permutexvar_epi32\n[REDACTED]/tmpgcd_ewwi.cpp:37:27: error: \u2018_mm256_pcmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   37 |     __m256i min_indices = _mm256_pcmpge_epi32(min_even_values, _mm256_setzero_si256());\n      |                           ^~~~~~~~~~~~~~~~~~~\n      |                           _mm256_cmpgt_epi32\n[REDACTED]/tmpgcd_ewwi.cpp:38:90: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     __m256i indices = _mm256_packs_epi32(_mm256_packs_epi32(min_indices, _mm256_set_epi32(0, 0)), _mm256_set_epi32(0, 0));\n      |                                                                          ~~~~~~~~~~~~~~~~^~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpgcd_ewwi.cpp:38:115: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     __m256i indices = _mm256_packs_epi32(_mm256_packs_epi32(min_indices, _mm256_set_epi32(0, 0)), _mm256_set_epi32(0, 0));\n      |                                                                                                   ~~~~~~~~~~~~~~~~^~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_94_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo7xvubrw.cpp: In function \u2018std::vector<int> pluck_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpo7xvubrw.cpp:34:48: error: \u2018_mm256_cmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   34 |     __m256i even_mask = _mm256_and_si256(mask, _mm256_cmpge_epi32(vec, _mm256_set1_epi32(0)));\n      |                                                ^~~~~~~~~~~~~~~~~~\n      |                                                _mm256_cmpgt_epi32\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpo7xvubrw.cpp:16:\n[REDACTED]/tmpo7xvubrw.cpp:41:34: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   41 |         __m256i current_values = _mm256_extract_epi32(even_values, i);\n      |                                  ^~~~~~~~~~~~~~~~~~~~\n      |                                  |\n      |                                  int\n[REDACTED]/tmpo7xvubrw.cpp:42:44: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   42 |         __m256i current_min = _mm256_min_ps(_mm256_set1_ps(min_even_value), _mm256_castsi256_ps(current_values));\n      |                               ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256\n[REDACTED]/tmpo7xvubrw.cpp:43:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   43 |         min_even_value = _mm_cvtss_f32(current_min);\n      |                                        ^~~~~~~~~~~\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpo7xvubrw.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:973:23: note:   initializing argument 1 of \u2018float _mm_cvtss_f32(__m128)\u2019\n  973 | _mm_cvtss_f32 (__m128 __A)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpo7xvubrw.cpp:44:78: error: \u2018_mm256_argmin_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_min_ps\u2019?\n   44 |         min_index = std::max(min_index, _mm256_extract_epi32(current_values, _mm256_argmin_ps(current_min)));\n      |                                                                              ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpo7xvubrw.cpp:44:41: error: invalid use of void expression\n   44 |         min_index = std::max(min_index, _mm256_extract_epi32(current_values, _mm256_argmin_ps(current_min)));\n      |                                         ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_95_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpsmeta467.cpp: In function \u2018int search_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpsmeta467.cpp:43:39: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   43 |     __m256i max_count = _mm_set1_epi32(0);\n      |                         ~~~~~~~~~~~~~~^~~\n      |                                       |\n      |                                       __m128i\n[REDACTED]/tmpsmeta467.cpp:46:74: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   46 |         __m256i count = _mm_popcnt_u32(_mm_movemask_epi8(_mm_cmpeq_epi32(*vec, *end)));\n      |                                                                          ^~~~\n      |                                                                          |\n      |                                                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpsmeta467.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpsmeta467.cpp:47:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   47 |         if (_mm_cmpgt_epi32(count, max_count)) {\n      |                             ^~~~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1387:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi32(__m128i, __m128i)\u2019\n 1387 | _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpsmeta467.cpp:55:33: error: could not convert \u2018(((((__m256i{((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i)))} <= max_count) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) & ((lst.std::vector<int>::operator[](((std::vector<int>::size_type)i)) > 0) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}))\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   55 |         if (lst[i] <= max_count && lst[i] > 0) {\n"}
{"task_id": "SimdBench_95_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp23fc0m91.cpp: In function \u2018int search_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp23fc0m91.cpp:47:41: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   47 |         __m256i count = _mm256_set_epi32(0, 0, 0, 0);\n      |                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp23fc0m91.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp23fc0m91.cpp:51:62: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   51 |         __m256i max_count = _mm256_max_epi32(_mm256_set_epi32(0, 0, 0, 0), count);\n      |                                              ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp23fc0m91.cpp:58:29: error: could not convert \u2018(((*(max_freq_vec + ((sizetype)(((long unsigned int)i) * 32)))) >= __m256i{((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i)))}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   58 |         if (max_freq_vec[i] >= lst[i]) {\n"}
{"task_id": "SimdBench_95_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp3lj4g_98.cpp:16:\n[REDACTED]/tmp3lj4g_98.cpp: In function \u2018int search_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp3lj4g_98.cpp:55:42: error: \u2018count\u2019 was not declared in this scope; did you mean \u2018std::count\u2019?\n   55 |         result[i] = _mm256_extract_epi32(count, i);\n      |                                          ^~~~~\nIn file included from /usr/include/c++/13/algorithm:73,\n                 from [REDACTED]/utils.hpp:8,\n                 from [REDACTED]/tmp3lj4g_98.cpp:14:\n/usr/include/c++/13/pstl/glue_algorithm_defs.h:101:1: note: \u2018std::count\u2019 declared here\n  101 | count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n      | ^~~~~\n[REDACTED]/tmp3lj4g_98.cpp:55:21: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in assignment\n   55 |         result[i] = _mm256_extract_epi32(count, i);\n      |                     ^~~~~~~~~~~~~~~~~~~~\n      |                     |\n      |                     int\n[REDACTED]/tmp3lj4g_98.cpp:60:27: error: could not convert \u2018((((((*(result + ((sizetype)(((long unsigned int)i) * 32)))) > (__m256i){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) & (((((*(result + ((sizetype)(((long unsigned int)i) * 32)))) >= __m256i{((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i)))}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}))\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   60 |         if (result[i] > 0 && result[i] >= lst[i]) {\n"}
{"task_id": "SimdBench_95_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpojednr_3.cpp: In function \u2018int search_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpojednr_3.cpp:47:41: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   47 |         __m256i count = _mm256_set_epi32(0, 0, 0, 0);\n      |                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpojednr_3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpojednr_3.cpp:49:46: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   49 |             count += _mm256_add_epi32(count, _mm256_extract_epi32(vec[i], 0));\n      |                                              ^~~~~~~~~~~~~~~~~~~~\n      |                                              |\n      |                                              int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpojednr_3.cpp:52:36: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   52 |             if (_mm256_cmpgt_epi32(_mm256_extract_epi32(count, i), _mm256_extract_epi32(vec[i], 0))) {\n      |                                    ^~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:273:29: note:   initializing argument 1 of \u2018__m256i _mm256_cmpgt_epi32(__m256i, __m256i)\u2019\n  273 | _mm256_cmpgt_epi32 (__m256i __A, __m256i __B)\n      |                     ~~~~~~~~^~~\n[REDACTED]/tmpojednr_3.cpp:53:61: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in assignment\n   53 |                 max_freq[_mm256_extract_epi32(vec[i], 0)] = _mm256_extract_epi32(count, i);\n      |                                                             ^~~~~~~~~~~~~~~~~~~~\n      |                                                             |\n      |                                                             int\n[REDACTED]/tmpojednr_3.cpp:61:30: error: could not convert \u2018((((((*(max_freq + ((sizetype)(((long unsigned int)i) * 32)))) >= __m256i{((long long int)i), ((long long int)i), ((long long int)i), ((long long int)i)}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) & (((((*(max_freq + ((sizetype)(((long unsigned int)i) * 32)))) > __m256i{((long long int)result), ((long long int)result), ((long long int)result), ((long long int)result)}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}))\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   61 |         if (max_freq[i] >= i && max_freq[i] > result) {\n      |             ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                              |\n      |                              __vector(4) long int\n[REDACTED]/tmpojednr_3.cpp:62:32: error: cannot convert \u2018__m256i\u2019 to \u2018int\u2019 in assignment\n   62 |             result = max_freq[i];\n      |                      ~~~~~~~~~~^\n      |                                |\n      |                                __m256i\n"}
{"task_id": "SimdBench_95_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwxf091a9.cpp: In function \u2018int search_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpwxf091a9.cpp:59:41: error: invalid type argument of unary \u2018*\u2019 (have \u2018__m256i\u2019)\n   59 |             *result = _mm256_set1_epi32(*count);\n      |                                         ^~~~~~\n[REDACTED]/tmpwxf091a9.cpp:66:31: error: could not convert \u2018((((((* result) == __m256i{((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i)))}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) & (((((* result) >= __m256i{((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i))), ((long long int)lst.std::vector<int>::operator[](((std::vector<int>::size_type)i)))}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}))\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   66 |         if (*result == lst[i] && *result >= lst[i]) {\n"}
{"task_id": "SimdBench_96_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvlmbkb17.cpp: In function \u2018bool will_it_fly_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpvlmbkb17.cpp:35:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   35 |     __m256i reversed_vec = _mm256_permutevar_ps(vec, _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                 ^~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpvlmbkb17.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:642:30: note:   initializing argument 1 of \u2018__m256 _mm256_permutevar_ps(__m256, __m256i)\u2019\n  642 | _mm256_permutevar_ps (__m256 __A, __m256i __C)\n      |                       ~~~~~~~^~~\n[REDACTED]/tmpvlmbkb17.cpp:38:19: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   38 |     __m256i sum = _mm256_reduce_add_epi32(mask, _mm256_set1_epi32(0));\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi32\n[REDACTED]/tmpvlmbkb17.cpp:39:43: error: cannot convert \u2018__vector(4) long int\u2019 to \u2018bool\u2019 in return\n   39 |     return _mm256_movemask_epi8(sum) == 0 && sum <= w;\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                           |\n      |                                           __vector(4) long int\n"}
{"task_id": "SimdBench_96_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptt52um6d.cpp: In function \u2018bool will_it_fly_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmptt52um6d.cpp:35:28: error: \u2018_mm256_permutevar_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi32\u2019?\n   35 |     __m256i reversed_vec = _mm256_permutevar_epi32(vec, _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0));\n      |                            ^~~~~~~~~~~~~~~~~~~~~~~\n      |                            _mm256_permutexvar_epi32\n[REDACTED]/tmptt52um6d.cpp:39:19: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   39 |     __m256i sum = _mm256_reduce_add_epi32(_mm256_loadu_si256(reinterpret_cast<const __m256i*>(&q[0])));\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi32\n[REDACTED]/tmptt52um6d.cpp:40:45: error: cannot convert \u2018__m256i\u2019 to \u2018bool\u2019 in initialization\n   40 |     bool is_less_than_w = _mm256_cmpgt_epi32(sum, _mm256_set1_epi32(w));\n      |                           ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                             |\n      |                                             __m256i\n"}
{"task_id": "SimdBench_96_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5zqvlcem.cpp: In function \u2018bool will_it_fly_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmp5zqvlcem.cpp:35:71: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   35 |     __m256i reversed_vec = _mm256_permutevar_epi8(vec, _mm256_set_epi8(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                        ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp5zqvlcem.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp5zqvlcem.cpp:35:28: error: \u2018_mm256_permutevar_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi8\u2019?\n   35 |     __m256i reversed_vec = _mm256_permutevar_epi8(vec, _mm256_set_epi8(7, 6, 5, 4, 3, 2, 1, 0));\n      |                            ^~~~~~~~~~~~~~~~~~~~~~\n      |                            _mm256_permutexvar_epi8\n[REDACTED]/tmp5zqvlcem.cpp:40:19: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   40 |     __m256i sum = _mm256_reduce_add_epi32(vec);\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi32\n[REDACTED]/tmp5zqvlcem.cpp:42:29: error: cannot convert \u2018__vector(4) long int\u2019 to \u2018bool\u2019 in initialization\n   42 |     bool can_fly = sum <= w && is_balanced;\n      |                    ~~~~~~~~~^~~~~~~~~~~~~~\n      |                             |\n      |                             __vector(4) long int\n"}
{"task_id": "SimdBench_96_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8e63smfz.cpp: In function \u2018bool will_it_fly_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmp8e63smfz.cpp:35:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   35 |     __m256i reversed_vec = _mm256_permutevar_ps(vec, _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                 ^~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8e63smfz.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:642:30: note:   initializing argument 1 of \u2018__m256 _mm256_permutevar_ps(__m256, __m256i)\u2019\n  642 | _mm256_permutevar_ps (__m256 __A, __m256i __C)\n      |                       ~~~~~~~^~~\n[REDACTED]/tmp8e63smfz.cpp:38:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |     int count = _mm_popcnt_u32(_mm_movemask_epi8(mask));\n      |                                                  ^~~~\n      |                                                  |\n      |                                                  __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp8e63smfz.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmp8e63smfz.cpp:41:15: error: \u2018_mm_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   41 |     int sum = _mm_reduce_add_epi32(vec);\n      |               ^~~~~~~~~~~~~~~~~~~~\n      |               _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_96_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxysoxem2.cpp: In function \u2018bool will_it_fly_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpxysoxem2.cpp:35:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   35 |     __m256i reversed_vec = _mm256_permutevar_ps(vec, _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                 ^~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpxysoxem2.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:642:30: note:   initializing argument 1 of \u2018__m256 _mm256_permutevar_ps(__m256, __m256i)\u2019\n  642 | _mm256_permutevar_ps (__m256 __A, __m256i __C)\n      |                       ~~~~~~~^~~\n[REDACTED]/tmpxysoxem2.cpp:38:19: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   38 |     __m256i sum = _mm256_reduce_add_epi32(mask, _mm256_setzero_si256());\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi32\n[REDACTED]/tmpxysoxem2.cpp:39:43: error: cannot convert \u2018__vector(4) long int\u2019 to \u2018bool\u2019 in return\n   39 |     return _mm256_movemask_epi8(sum) == 0 && sum <= w;\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n      |                                           |\n      |                                           __vector(4) long int\n"}
{"task_id": "SimdBench_97_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqcv5okag.cpp:47:93: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   47 |         __m128i reversed_last_element = _mm_shuffle_epi32(last_element, last_element, 0b1100);\n      |                                                                                             ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpqcv5okag.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpqcv5okag.cpp: In function \u2018int smallest_change_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpqcv5okag.cpp:38:53: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   38 |         __m256i reversed_vec = _mm256_permutevar_ps(vec, _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0));\n      |                                                     ^~~\n      |                                                     |\n      |                                                     __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqcv5okag.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:642:30: note:   initializing argument 1 of \u2018__m256 _mm256_permutevar_ps(__m256, __m256i)\u2019\n  642 | _mm256_permutevar_ps (__m256 __A, __m256i __C)\n      |                       ~~~~~~~^~~\n[REDACTED]/tmpqcv5okag.cpp:47:41: error: \u2018_mm_shuffle_epi32\u2019 was not declared in this scope\n   47 |         __m128i reversed_last_element = _mm_shuffle_epi32(last_element, last_element, 0b1100);\n      |                                         ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_97_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxl87f1g3.cpp: In function \u2018int smallest_change_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpxl87f1g3.cpp:37:76: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i reversed_pair = _mm256_permutevar_ps(pair, _mm256_set_epi32(3, 2, 1, 0));\n      |                                                            ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpxl87f1g3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpxl87f1g3.cpp:40:51: error: cannot convert \u2018int\u2019 to \u2018__m128i\u2019\n   40 |         _mm_storeu_si128((__m128i*)(vec_arr + i), _mm256_extract_epi16(count, 0));\n      |                                                   ^~~~~~~~~~~~~~~~~~~~\n      |                                                   |\n      |                                                   int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpxl87f1g3.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_97_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppkpaj1l2.cpp: In function \u2018int smallest_change_simd(std::vector<int>)\u2019:\n[REDACTED]/tmppkpaj1l2.cpp:42:41: error: \u2018_mm_movemask_epi32\u2019 was not declared in this scope; did you mean \u2018_mm_movemask_epi8\u2019?\n   42 |     int mismatch_count = _mm_popcnt_u32(_mm_movemask_epi32(cmp));\n      |                                         ^~~~~~~~~~~~~~~~~~\n      |                                         _mm_movemask_epi8\n"}
{"task_id": "SimdBench_97_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp82d7eys9.cpp: In function \u2018int smallest_change_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp82d7eys9.cpp:44:20: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   44 |         changes += _mm256_popcnt_u32(_mm256_extract_epi32(cmp_result, 0)) +\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_popcnt_u32\n"}
{"task_id": "SimdBench_97_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_lj7zeee.cpp: In function \u2018int smallest_change_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp_lj7zeee.cpp:42:20: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   42 |         changes += _mm256_popcnt_u32(_mm256_movemask_epi8(diff));\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_popcnt_u32\n"}
{"task_id": "SimdBench_98_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_98_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkhdb9rsz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > total_match_simd(const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpkhdb9rsz.cpp:45:52: error: \u2018_mm256_count_nonzero\u2019 was not declared in this scope\n   45 |         v1 = _mm256_add_epi32(v1, _mm256_sub_epi32(_mm256_count_nonzero(str1), _mm256_count_nonzero(str2)));\n      |                                                    ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpkhdb9rsz.cpp:52:52: error: \u2018_mm256_count_nonzero\u2019 was not declared in this scope\n   52 |         v1 = _mm256_add_epi32(v1, _mm256_sub_epi32(_mm256_count_nonzero(str1), _mm256_count_nonzero(str2)));\n      |                                                    ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_98_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_98_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppx1mmzy3.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > total_match_simd(const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmppx1mmzy3.cpp:44:52: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   44 |         sum1 = _mm_add_epi32(sum1, _mm256_sad_epu8(_mm_loadu_si256(vec1 + i), _mm_loadu_si256(vec2 + i)));\n      |                                                    ^~~~~~~~~~~~~~~\n      |                                                    _mm_loadu_si16\n[REDACTED]/tmppx1mmzy3.cpp:48:49: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   48 |         sum1 = _mm_add_epi32(sum1, _mm_sad_epu8(_mm_loadu_si256(vec1 + i), _mm_loadu_si256(vec2 + i)));\n      |                                                 ^~~~~~~~~~~~~~~\n      |                                                 _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmppx1mmzy3.cpp:16:\n[REDACTED]/tmppx1mmzy3.cpp:51:36: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   51 |     int count1 = _mm_cvtsi128_si32(_mm_extract_epi32(sum1, 0));\n      |                                    ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmppx1mmzy3.cpp:52:36: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   52 |     int count2 = _mm_cvtsi128_si32(_mm_extract_epi32(sum2, 0));\n      |                                    ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_98_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbahq6r5v.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > total_match_simd(const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpbahq6r5v.cpp:48:42: error: \u2018_mm256_popcnt_u8\u2019 was not declared in this scope; did you mean \u2018_mm256_popcnt_epi8\u2019?\n   48 |         count1 = _mm256_add_epi8(count1, _mm256_popcnt_u8(str1));\n      |                                          ^~~~~~~~~~~~~~~~\n      |                                          _mm256_popcnt_epi8\n[REDACTED]/tmpbahq6r5v.cpp:67:16: error: \u2018_mm256_popcnt_u8\u2019 was not declared in this scope; did you mean \u2018_mm256_popcnt_epi8\u2019?\n   67 |             if(_mm256_popcnt_u8(_mm256_loadu_si256(vec1 + i)) < _mm256_popcnt_u8(_mm256_loadu_si256(vec2 + i))){\n      |                ^~~~~~~~~~~~~~~~\n      |                _mm256_popcnt_epi8\n"}
{"task_id": "SimdBench_99_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5ti4krtc.cpp: In function \u2018bool is_simple_power_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmp5ti4krtc.cpp:32:38: error: too many arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   32 |     __m256i x_vec = _mm256_set_epi64x(x >> 32, x >> 24, x >> 16, x >> 8, x >> 0);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp5ti4krtc.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp5ti4krtc.cpp:33:38: error: too many arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   33 |     __m256i n_vec = _mm256_set_epi64x(n >> 32, n >> 24, n >> 16, n >> 8, n >> 0);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmp5ti4krtc.cpp:35:22: error: \u2018_mm256_cmp_eq_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi64\u2019?\n   35 |     __m256i result = _mm256_cmp_eq_epi64(x_vec, n_vec);\n      |                      ^~~~~~~~~~~~~~~~~~~\n      |                      _mm256_cmpeq_epi64\n"}
{"task_id": "SimdBench_99_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp9s18c1oa.cpp:16:\n[REDACTED]/tmp9s18c1oa.cpp: In function \u2018bool is_simple_power_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmp9s18c1oa.cpp:38:26: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019 in initialization\n   38 |         __m256i x_byte = _mm256_extract_epi64(x_vec, i);\n      |                          ^~~~~~~~~~~~~~~~~~~~\n      |                          |\n      |                          long long int\n[REDACTED]/tmp9s18c1oa.cpp:39:26: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019 in initialization\n   39 |         __m256i n_byte = _mm256_extract_epi64(n_vec, i);\n      |                          ^~~~~~~~~~~~~~~~~~~~\n      |                          |\n      |                          long long int\n[REDACTED]/tmp9s18c1oa.cpp:45:33: error: \u2018_mm256_div_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi64\u2019?\n   45 |         if (!_mm256_testz_si256(_mm256_div_epi64(x_byte, n_byte), _mm256_div_epi64(x_byte, n_byte))) continue;\n      |                                 ^~~~~~~~~~~~~~~~\n      |                                 _mm256_min_epi64\n"}
{"task_id": "SimdBench_99_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpngxpqprv.cpp: In function \u2018bool is_simple_power_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpngxpqprv.cpp:33:38: error: too many arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   33 |     __m256i x_vec = _mm256_set_epi64x(x >> 32, x >> 24, x >> 16, x >> 8, x >> 0);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpngxpqprv.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpngxpqprv.cpp:34:38: error: too many arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   34 |     __m256i n_vec = _mm256_set_epi64x(n >> 32, n >> 24, n >> 16, n >> 8, n >> 0);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_99_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_e2mhar9.cpp: In function \u2018bool is_simple_power_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmp_e2mhar9.cpp:40:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |     int count = _mm_popcnt_u32(_mm_movemask_epi8(cmp_result));\n      |                                                  ^~~~~~~~~~\n      |                                                  |\n      |                                                  __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_e2mhar9.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_99_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxxj3nsgw.cpp: In function \u2018bool is_simple_power_simd(uint64_t, uint64_t)\u2019:\n[REDACTED]/tmpxxj3nsgw.cpp:40:42: error: cannot convert \u2018__mmask8\u2019 {aka \u2018unsigned char\u2019} to \u2018__m256\u2019 in initialization\n   40 |     __m256 mask = _mm256_cmpeq_epi64_mask(result, _mm256_setzero_si256());\n      |                   ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                          |\n      |                                          __mmask8 {aka unsigned char}\n[REDACTED]/tmpxxj3nsgw.cpp:41:32: error: cannot convert \u2018__m256\u2019 to \u2018unsigned int\u2019\n   41 |     int count = _mm_popcnt_u32(mask);\n      |                                ^~~~\n      |                                |\n      |                                __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/x86gprintrin.h:73,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:27,\n                 from [REDACTED]/tmpxxj3nsgw.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/popcntintrin.h:35:30: note:   initializing argument 1 of \u2018int _mm_popcnt_u32(unsigned int)\u2019\n   35 | _mm_popcnt_u32 (unsigned int __X)\n      |                 ~~~~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_100_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpguiwln8p.cpp: In function \u2018int hex_key_simd(const std::string&)\u2019:\n[REDACTED]/tmpguiwln8p.cpp:45:32: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   45 |     __m256i mask = _mm_set_epi8(0, 0, 0, 0, 0, 0, 0, 0); // Initialize mask with zeros\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpguiwln8p.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpguiwln8p.cpp:48:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   48 |         __m256i vec = _mm_loadu_si256((__m256i *)(&str[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpguiwln8p.cpp:49:62: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   49 |         __m256i prime_mask = _mm_cmpeq_epi8(vec, _mm_set_epi8('2', '3', '5', '7', 'B', 'D', 'F', 'A')); // Compare each byte with prime digits\n      |                                                  ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpguiwln8p.cpp:50:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   50 |         mask = _mm_or_si256(mask, prime_mask); // Update mask with prime digits found\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpguiwln8p.cpp:54:38: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   54 |     __m256i sum = _mm_sad_epu8(mask, _mm_setzero_si256());\n      |                                      ^~~~~~~~~~~~~~~~~\n      |                                      _mm_setzero_si64\n[REDACTED]/tmpguiwln8p.cpp:55:25: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   55 |     sum = _mm_add_epi32(sum, sum);\n      |                         ^~~\n      |                         |\n      |                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpguiwln8p.cpp:56:25: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   56 |     sum = _mm_add_epi32(sum, sum);\n      |                         ^~~\n      |                         |\n      |                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpguiwln8p.cpp:57:25: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   57 |     sum = _mm_add_epi32(sum, sum);\n      |                         ^~~\n      |                         |\n      |                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpguiwln8p.cpp:16:\n[REDACTED]/tmpguiwln8p.cpp:61:69: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   61 |         sum = _mm_add_epi32(sum, _mm_extract_epi32(_mm_shuffle_epi8(sum, sum), i));\n      |                                                                     ^~~\n      |                                                                     |\n      |                                                                     __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpguiwln8p.cpp:64:29: error: cannot convert \u2018__m256i\u2019 to \u2018int\u2019\n   64 |     return _mm_cvtsi32_si64(sum);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/mmintrin.h:77:23: note:   initializing argument 1 of \u2018__m64 _mm_cvtsi32_si64(int)\u2019\n   77 | _mm_cvtsi32_si64 (int __i)\n      |                   ~~~~^~~\n"}
{"task_id": "SimdBench_100_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2w5css8e.cpp: In function \u2018int hex_key_simd(const std::string&)\u2019:\n[REDACTED]/tmp2w5css8e.cpp:40:32: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   40 |     __m256i mask = _mm_set_epi8(0, 0, 0, 0, 0, 0, 0, 0); // Initialize mask with zeros\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2w5css8e.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmp2w5css8e.cpp:43:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   43 |         __m256i vec = _mm_loadu_si256((__m256i *)(&str[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmp2w5css8e.cpp:44:62: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   44 |         __m256i prime_mask = _mm_cmpeq_epi8(vec, _mm_set_epi8('2', '3', '5', '7', 'B', 'D', 'F', 'A')); // Compare each byte with prime digits\n      |                                                  ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmp2w5css8e.cpp:45:51: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |         count += _mm_popcnt_u32(_mm_movemask_epi8(prime_mask)); // Count the number of set bits\n      |                                                   ^~~~~~~~~~\n      |                                                   |\n      |                                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_100_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbne71ff3.cpp: In function \u2018int hex_key_simd(const std::string&)\u2019:\n[REDACTED]/tmpbne71ff3.cpp:32:48: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |     const __m256i prime_mask = _mm256_set_epi32(2, 3, 5, 7);\n      |                                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbne71ff3.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpbne71ff3.cpp:33:47: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   33 |     const __m256i hex_digits = _mm256_set_epi8('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F');\n      |                                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmpbne71ff3.cpp:39:18: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   39 |         count += _mm256_popcnt_u32(_mm256_extract_epi32(prime_count, 0)) +\n      |                  ^~~~~~~~~~~~~~~~~\n      |                  _mm_popcnt_u32\n"}
{"task_id": "SimdBench_100_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6bd_45_0.cpp: In function \u2018int hex_key_simd(const std::string&)\u2019:\n[REDACTED]/tmp6bd_45_0.cpp:41:42: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   41 |     const __m256i mask2 = _mm256_set_epi8(0, 1, 0, 1, 0, 1, 0, 1);\n      |                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp6bd_45_0.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6bd_45_0.cpp:42:42: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   42 |     const __m256i mask3 = _mm256_set_epi8(0, 0, 1, 1, 0, 0, 1, 1);\n      |                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6bd_45_0.cpp:43:42: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   43 |     const __m256i mask5 = _mm256_set_epi8(0, 0, 0, 0, 1, 1, 1, 1);\n      |                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6bd_45_0.cpp:44:42: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   44 |     const __m256i mask7 = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 1, 1);\n      |                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6bd_45_0.cpp:45:42: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   45 |     const __m256i maskB = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 1);\n      |                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6bd_45_0.cpp:46:42: error: too few arguments to function \u2018__m256i _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   46 |     const __m256i maskD = _mm256_set_epi8(0, 0, 0, 0, 0, 0, 0, 1);\n      |                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1294:1: note: declared here\n 1294 | _mm256_set_epi8  (char __q31, char __q30, char __q29, char __q28,\n      | ^~~~~~~~~~~~~~~\n[REDACTED]/tmp6bd_45_0.cpp:57:22: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   57 |     __m256i count2 = _mm256_popcnt_u32(_mm256_extract_epi32(digit2, 0));\n      |                      ^~~~~~~~~~~~~~~~~\n      |                      _mm_popcnt_u32\n"}
{"task_id": "SimdBench_100_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgk1e3t3n.cpp: In function \u2018int hex_key_simd(const std::string&)\u2019:\n[REDACTED]/tmpgk1e3t3n.cpp:40:32: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   40 |     __m256i mask = _mm_set_epi8(0, 0, 0, 0, 0, 0, 0, 0); // Initialize mask with zeros\n      |                    ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpgk1e3t3n.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpgk1e3t3n.cpp:45:51: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   45 |             mask = _mm_add_epi8(mask, _mm_set_epi8(1, 1, 1, 1, 1, 1, 1, 1)); // Set corresponding bits in mask\n      |                                       ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpgk1e3t3n.cpp:49:19: error: \u2018_mm_reduce_add_epi8\u2019 was not declared in this scope; did you mean \u2018_mm_reduce_add_ph\u2019?\n   49 |     __m256i sum = _mm_reduce_add_epi8(mask);\n      |                   ^~~~~~~~~~~~~~~~~~~\n      |                   _mm_reduce_add_ph\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpgk1e3t3n.cpp:16:\n[REDACTED]/tmpgk1e3t3n.cpp:50:13: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   50 |     count = _mm_extract_epi8(sum, 0);\n      |             ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_101_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpr6cx8zh1.cpp: In function \u2018bool is_happy_simd(const std::string&)\u2019:\n[REDACTED]/tmpr6cx8zh1.cpp:29:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i mask = _mm_set1_epi8(0xFF);\n      |                    ~~~~~~~~~~~~~^~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpr6cx8zh1.cpp:30:25: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   30 |     __m256i prev_char = _mm_setzero_si256();\n      |                         ^~~~~~~~~~~~~~~~~\n      |                         _mm_setzero_si64\n[REDACTED]/tmpr6cx8zh1.cpp:33:33: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         __m256i current_chars = _mm_loadu_si256((__m256i*)&s[i]);\n      |                                 ^~~~~~~~~~~~~~~\n      |                                 _mm_loadu_si16\n[REDACTED]/tmpr6cx8zh1.cpp:34:34: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   34 |         __m256i distinct_chars = _mm_andnot_si256(current_chars, prev_char);\n      |                                  ^~~~~~~~~~~~~~~~\n      |                                  _mm_andnot_si64\n[REDACTED]/tmpr6cx8zh1.cpp:36:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         if(_mm_movemask_epi8(distinct_chars) == 0xFFFFFFFF) return false;\n      |                              ^~~~~~~~~~~~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpr6cx8zh1.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_101_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplsh0h8og.cpp: In function \u2018bool is_happy_simd(const std::string&)\u2019:\n[REDACTED]/tmplsh0h8og.cpp:34:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   34 |     __m256i mask = _mm_set1_epi8(0);\n      |                    ~~~~~~~~~~~~~^~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmplsh0h8og.cpp:35:25: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   35 |     __m256i prev_char = _mm_setzero_si256();\n      |                         ^~~~~~~~~~~~~~~~~\n      |                         _mm_setzero_si64\n[REDACTED]/tmplsh0h8og.cpp:38:33: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |         __m256i current_chars = _mm_loadu_si256((__m256i*)&s[i]);\n      |                                 ^~~~~~~~~~~~~~~\n      |                                 _mm_loadu_si16\n[REDACTED]/tmplsh0h8og.cpp:42:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(current_chars, prev_char));\n      |                                                  ^~~~~~~~~~~~~\n      |                                                  |\n      |                                                  __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmplsh0h8og.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmplsh0h8og.cpp:42:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   42 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(current_chars, prev_char));\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmplsh0h8og.cpp:51:27: error: could not convert \u2018(((((__m256i{((long long int)c), ((long long int)c), ((long long int)c), ((long long int)c)} == prev_char) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) != (__vector(4) long int){0, 0, 0, 0}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}) | ((((int)c) == ((int)(& s)->std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(i + 1))))) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0}))\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   51 |         if(c == prev_char || c == s[i + 1])\n"}
{"task_id": "SimdBench_101_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp49ia9fbp.cpp: In function \u2018bool is_happy_simd(const std::string&)\u2019:\n[REDACTED]/tmp49ia9fbp.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set1_epi8(0xFF);\n      |                    ~~~~~~~~~~~~~^~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp49ia9fbp.cpp:34:25: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   34 |     __m256i prev_char = _mm_setzero_si256();\n      |                         ^~~~~~~~~~~~~~~~~\n      |                         _mm_setzero_si64\n[REDACTED]/tmp49ia9fbp.cpp:37:33: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   37 |         __m256i current_chars = _mm_loadu_si256((__m256i*)&s[i]);\n      |                                 ^~~~~~~~~~~~~~~\n      |                                 _mm_loadu_si16\n[REDACTED]/tmp49ia9fbp.cpp:38:32: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   38 |         __m256i unique_chars = _mm_andnot_si256(current_chars, prev_char);\n      |                                ^~~~~~~~~~~~~~~~\n      |                                _mm_andnot_si64\n[REDACTED]/tmp49ia9fbp.cpp:40:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |         if(_mm_movemask_epi8(unique_chars) == 0xFFFFFFFF) return false;\n      |                              ^~~~~~~~~~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp49ia9fbp.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_101_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpnddw00jl.cpp: In function \u2018bool is_happy_simd(const std::string&)\u2019:\n[REDACTED]/tmpnddw00jl.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set1_epi8(0);\n      |                    ~~~~~~~~~~~~~^~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpnddw00jl.cpp:34:25: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   34 |     __m256i prev_char = _mm_setzero_si256();\n      |                         ^~~~~~~~~~~~~~~~~\n      |                         _mm_setzero_si64\n[REDACTED]/tmpnddw00jl.cpp:37:32: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   37 |         __m256i current_char = _mm_loadu_si256((__m256i*)&s[i]);\n      |                                ^~~~~~~~~~~~~~~\n      |                                _mm_loadu_si16\n[REDACTED]/tmpnddw00jl.cpp:41:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(current_char, next_char));\n      |                                                  ^~~~~~~~~~~~\n      |                                                  |\n      |                                                  __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpnddw00jl.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpnddw00jl.cpp:41:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   41 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(current_char, next_char));\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpnddw00jl.cpp:42:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(current_char, prev_char));\n      |                                                  ^~~~~~~~~~~~\n      |                                                  |\n      |                                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpnddw00jl.cpp:53:79: error: cannot convert \u2018char\u2019 to \u2018__m128i\u2019\n   53 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(_mm_set1_epi8(current_char), next_char));\n      |                                                                               ^~~~~~~~~\n      |                                                                               |\n      |                                                                               char\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:38: note:   initializing argument 2 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                              ~~~~~~~~^~~\n[REDACTED]/tmpnddw00jl.cpp:53:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   53 |         mask = _mm_or_si256(mask, _mm_cmpeq_epi8(_mm_set1_epi8(current_char), next_char));\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpnddw00jl.cpp:57:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   57 |     return _mm_movemask_epi8(mask) == 0;\n      |                              ^~~~\n      |                              |\n      |                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_101_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpyes52vps.cpp: In function \u2018bool is_happy_simd(const std::string&)\u2019:\n[REDACTED]/tmpyes52vps.cpp:33:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   33 |     __m256i mask = _mm_set1_epi8(0);\n      |                    ~~~~~~~~~~~~~^~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpyes52vps.cpp:34:25: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   34 |     __m256i prev_char = _mm_setzero_si256();\n      |                         ^~~~~~~~~~~~~~~~~\n      |                         _mm_setzero_si64\n[REDACTED]/tmpyes52vps.cpp:37:33: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   37 |         __m256i current_chars = _mm_loadu_si256((__m256i*)&s[i]);\n      |                                 ^~~~~~~~~~~~~~~\n      |                                 _mm_loadu_si16\n[REDACTED]/tmpyes52vps.cpp:38:34: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   38 |         __m256i distinct_chars = _mm_andnot_si256(current_chars, prev_char);\n      |                                  ^~~~~~~~~~~~~~~~\n      |                                  _mm_andnot_si64\n[REDACTED]/tmpyes52vps.cpp:40:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   40 |         mask = _mm_or_si256(mask, distinct_chars);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpyes52vps.cpp:45:29: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   45 |     __m256i current_chars = _mm_loadu_si256((__m256i*)&s[len - 3]);\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm_loadu_si16\n[REDACTED]/tmpyes52vps.cpp:46:30: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   46 |     __m256i distinct_chars = _mm_andnot_si256(current_chars, prev_char);\n      |                              ^~~~~~~~~~~~~~~~\n      |                              _mm_andnot_si64\n[REDACTED]/tmpyes52vps.cpp:47:12: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   47 |     mask = _mm_or_si256(mask, distinct_chars);\n      |            ^~~~~~~~~~~~\n      |            _mm_or_si64\n[REDACTED]/tmpyes52vps.cpp:49:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   49 |     return _mm_movemask_epi8(mask) != 0;\n      |                              ^~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpyes52vps.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_102_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_102_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpuifw7_a4.cpp: In function \u2018bool prime_length_simd(const std::string&)\u2019:\n[REDACTED]/tmpuifw7_a4.cpp:35:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   35 |     __m256i mask = _mm_set_epi32(0, 0, 0, 0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpuifw7_a4.cpp:36:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i count = _mm_set_epi32(0, 0, 0, 0);\n      |                     ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpuifw7_a4.cpp:39:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   39 |         __m256i word = _mm_loadu_si256((__m256i*)&str[i]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmpuifw7_a4.cpp:40:57: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   40 |         __m256i ones = _mm_cmpeq_epi8(word, _mm_set_epi8(0));\n      |                                             ~~~~~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpuifw7_a4.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpuifw7_a4.cpp:42:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   42 |         mask = _mm_or_si256(mask, ones);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmpuifw7_a4.cpp:43:71: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         count = _mm_add_epi32(count, _mm_popcnt_u32(_mm_movemask_epi8(ones)));\n      |                                                                       ^~~~\n      |                                                                       |\n      |                                                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpuifw7_a4.cpp:46:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   46 |     int totalOnes = _mm_movemask_epi8(mask);\n      |                                       ^~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpuifw7_a4.cpp:16:\n[REDACTED]/tmpuifw7_a4.cpp:47:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   47 |     int totalCount = _mm_extract_epi32(count, 0);\n      |                      ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_102_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqqtr51mf.cpp: In function \u2018bool prime_length_simd(const std::string&)\u2019:\n[REDACTED]/tmpqqtr51mf.cpp:55:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   55 |     __m256i mask = _mm_set_epi32(0, 0, 0, 0);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpqqtr51mf.cpp:57:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   57 |         __m256i word = _mm_loadu_si256((__m256i*)(&c_str[i * 4]));\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpqqtr51mf.cpp:16:\n[REDACTED]/tmpqqtr51mf.cpp:58:39: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   58 |         int word_len = _mm_popcnt_u32(_mm_extract_epi32(word, 0)) +\n      |                                       ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpqqtr51mf.cpp:59:39: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   59 |                        _mm_popcnt_u32(_mm_extract_epi32(word, 1)) +\n      |                                       ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpqqtr51mf.cpp:60:39: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   60 |                        _mm_popcnt_u32(_mm_extract_epi32(word, 2)) +\n      |                                       ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpqqtr51mf.cpp:61:39: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   61 |                        _mm_popcnt_u32(_mm_extract_epi32(word, 3));\n      |                                       ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpqqtr51mf.cpp:62:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   62 |         mask |= _mm_cmpgt_epi32(mask, _mm_set_epi32(word_len, word_len, word_len, word_len));\n      |                                 ^~~~\n      |                                 |\n      |                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpqqtr51mf.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1387:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi32(__m128i, __m128i)\u2019\n 1387 | _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmpqqtr51mf.cpp:66:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   66 |     bool is_prime_word = _mm_movemask_epi8(mask) != 0;\n      |                                            ^~~~\n      |                                            |\n      |                                            __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_102_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmplus7nuky.cpp: In function \u2018bool prime_length_simd(const std::string&)\u2019:\n[REDACTED]/tmplus7nuky.cpp:33:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i vec_len = _mm256_set_epi32(len >> 0, len >> 4, len >> 8, len >> 12);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmplus7nuky.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmplus7nuky.cpp:34:64: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask = _mm256_cmpgt_epi32(vec_len, _mm256_set_epi32(1, 1, 1, 1));\n      |                                                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmplus7nuky.cpp:35:21: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   35 |     __m256i count = _mm256_popcnt_u32(_mm256_and_si256(mask, vec_len));\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_popcnt_u32\n"}
{"task_id": "SimdBench_102_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8wfnwtyb.cpp: In function \u2018bool prime_length_simd(const std::string&)\u2019:\n[REDACTED]/tmp8wfnwtyb.cpp:33:39: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i len_vec = _mm256_set_epi32(len >> 24, len >> 16, len >> 8, len);\n      |                       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp8wfnwtyb.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp8wfnwtyb.cpp:35:21: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   35 |     __m256i count = _mm256_popcnt_u32(_mm256_and_si256(mask, len_vec));\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_popcnt_u32\n"}
{"task_id": "SimdBench_103_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2julzr0o.cpp: In function \u2018std::string solve_simd(uint64_t)\u2019:\n[REDACTED]/tmp2julzr0o.cpp:40:58: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   40 |         __m256i digit = _mm256_and_si256(_mm256_set_epi32(N & mask), _mm256_set_epi32(1));\n      |                                          ~~~~~~~~~~~~~~~~^~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2julzr0o.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp2julzr0o.cpp:40:86: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   40 |         __m256i digit = _mm256_and_si256(_mm256_set_epi32(N & mask), _mm256_set_epi32(1));\n      |                                                                      ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp2julzr0o.cpp:46:29: error: could not convert \u2018((i != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   46 |     for (__m256i i = sum; i != _mm256_setzero_si256(); i = _mm256_srlv_epi32(i, _mm256_set_epi32(8))) {\n      |                           ~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                             |\n      |                             __vector(4) long int\n[REDACTED]/tmp2julzr0o.cpp:46:97: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   46 |     for (__m256i i = sum; i != _mm256_setzero_si256(); i = _mm256_srlv_epi32(i, _mm256_set_epi32(8))) {\n      |                                                                                 ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp2julzr0o.cpp:48:24: error: \u2018bitset\u2019 is not a member of \u2018std\u2019\n   48 |         result += std::bitset<32>(value).to_string();\n      |                        ^~~~~~\n[REDACTED]/tmp2julzr0o.cpp:18:1: note: \u2018std::bitset\u2019 is defined in header \u2018<bitset>\u2019; did you forget to \u2018#include <bitset>\u2019?\n   17 | #include <x86intrin.h>\n  +++ |+#include <bitset>\n   18 | \n[REDACTED]/tmp2julzr0o.cpp:48:42: error: request for member \u2018to_string\u2019 in \u2018value\u2019, which is of non-class type \u2018uint32_t\u2019 {aka \u2018unsigned int\u2019}\n   48 |         result += std::bitset<32>(value).to_string();\n      |                                          ^~~~~~~~~\n"}
{"task_id": "SimdBench_103_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_103_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpz8qpxdza.cpp: In function \u2018std::string solve_simd(uint64_t)\u2019:\n[REDACTED]/tmpz8qpxdza.cpp:39:41: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   39 |         __m256i digit = _mm256_set_epi32(N & mask, (N >> 8) & mask, (N >> 16) & mask, (N >> 24) & mask);\n      |                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpz8qpxdza.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_103_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5zvfac3o.cpp: In function \u2018std::string solve_simd(uint64_t)\u2019:\n[REDACTED]/tmp5zvfac3o.cpp:40:41: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   40 |         __m256i digit = _mm256_set_epi32(N & mask);\n      |                         ~~~~~~~~~~~~~~~~^~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp5zvfac3o.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_103_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpajlr8gjc.cpp: In function \u2018std::string solve_simd(uint64_t)\u2019:\n[REDACTED]/tmpajlr8gjc.cpp:40:41: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   40 |         __m256i digit = _mm256_set_epi32((int)n % 10, (int)(n / 10) % 10, (int)(n / 100) % 10, (int)(n / 1000) % 10);\n      |                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpajlr8gjc.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpajlr8gjc.cpp:45:44: error: \u2018_mm256_sad_epu32\u2019 was not declared in this scope; did you mean \u2018_mm256_sad_epu8\u2019?\n   45 |     uint64_t result = _mm256_extract_epi32(_mm256_sad_epu32(sum, _mm256_setzero_si256()), 0);\n      |                                            ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_104_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppvo81bwo.cpp: In function \u2018int add_simd(std::vector<int>)\u2019:\n[REDACTED]/tmppvo81bwo.cpp:39:19: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   39 |         result += _mm256_reduce_add_epi32(sum);\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi32\n[REDACTED]/tmppvo81bwo.cpp:44:16: error: cannot convert \u2018__m256i\u2019 to \u2018int\u2019 in assignment\n   44 |         result += ptr[n - 1];\n      |         ~~~~~~~^~~~~~~~~~~~~\n      |                |\n      |                __m256i\n"}
{"task_id": "SimdBench_104_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp12nd_d2b.cpp: In function \u2018int add_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp12nd_d2b.cpp:38:15: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   38 |     result += _mm256_reduce_add_epi32(even_at_odd_indices);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~\n      |               _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_104_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp19_6tbnq.cpp: In function \u2018int add_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp19_6tbnq.cpp:37:47: error: too many arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i odd_indices = _mm256_set_epi32(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7, i+8, i+9, i+10, i+11, i+12, i+13, i+14, i+15, i+16, i+17, i+18, i+19, i+20, i+21, i+22, i+23, i+24, i+25, i+26, i+27, i+28, i+29);\n      |                               ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp19_6tbnq.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_104_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_luxuvbl.cpp: In function \u2018int add_simd(std::vector<int>)\u2019:\n[REDACTED]/tmp_luxuvbl.cpp:37:48: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i even_indices = _mm256_set_epi32(i, i+1, i+2, i+3);\n      |                                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp_luxuvbl.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_luxuvbl.cpp:41:19: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   41 |         result += _mm256_reduce_add_epi32(even_values_summed);\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_104_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjus0d4az.cpp: In function \u2018int add_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpjus0d4az.cpp:31:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     __m256i vec1 = _mm256_set_epi32(lst[0], lst[2], lst[4], lst[6]);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpjus0d4az.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpjus0d4az.cpp:32:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |     __m256i vec2 = _mm256_set_epi32(lst[1], lst[3], lst[5], lst[7]);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpjus0d4az.cpp:34:112: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i even_elements = _mm256_and_si256(_mm256_cmpgt_epi32(vec1, _mm256_setzero_si256()), _mm256_set_epi32(1, 0, 1, 0));\n      |                                                                                                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpjus0d4az.cpp:35:51: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   35 |     __m256i sum = _mm256_add_epi32(even_elements, _mm256_extract_epi32(vec2, 0));\n      |                                                   ^~~~~~~~~~~~~~~~~~~~\n      |                                                   |\n      |                                                   int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpjus0d4az.cpp:37:15: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   37 |     result += _mm256_reduce_add_epi32(sum);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~\n      |               _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_105_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp846p074f.cpp: In function \u2018std::string encrypt_simd(const std::string&)\u2019:\n[REDACTED]/tmp846p074f.cpp:36:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i key = _mm_set_epi32(0, 1, 2, 3); // Rotate by 2*2 places\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmp846p074f.cpp:42:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   42 |         __m256i input = _mm_loadu_si256((__m256i*)(&str[i]));\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmp846p074f.cpp:43:26: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   43 |         __m256i output = _mm_xor_si256(input, key);\n      |                          ^~~~~~~~~~~~~\n      |                          _mm_xor_si64\n[REDACTED]/tmp846p074f.cpp:44:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   44 |         _mm_storeu_si256((__m256i*)&result[i], output);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_105_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmfcqc8fe.cpp: In function \u2018std::string encrypt_simd(const std::string&)\u2019:\n[REDACTED]/tmpmfcqc8fe.cpp:37:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i key = _mm_set_epi32(0x1a, 0x1b, 0x1c, 0x1d); // Rotate the alphabet by 4 positions\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmpmfcqc8fe.cpp:41:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   41 |         __m256i input = _mm_loadu_si256((__m256i*)(&str[i]));\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmpmfcqc8fe.cpp:42:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         __m256i shifted = _mm_add_epi32(input, key);\n      |                                         ^~~~~\n      |                                         |\n      |                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpmfcqc8fe.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpmfcqc8fe.cpp:43:60: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   43 |         __m256i masked = _mm_and_si24(shifted, _mm_set_epi8(0x61, 0x7a, 0x6e, 0x69, 0x6f, 0x72, 0x6c, 0x68));\n      |                                                ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpmfcqc8fe.cpp:43:26: error: \u2018_mm_and_si24\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   43 |         __m256i masked = _mm_and_si24(shifted, _mm_set_epi8(0x61, 0x7a, 0x6e, 0x69, 0x6f, 0x72, 0x6c, 0x68));\n      |                          ^~~~~~~~~~~~\n      |                          _mm_and_si64\n[REDACTED]/tmpmfcqc8fe.cpp:44:62: error: too few arguments to function \u2018__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char)\u2019\n   44 |         __m256i unmasked = _mm_xor_si256(masked, _mm_set_epi8(0x61, 0x7a, 0x6e, 0x69, 0x6f, 0x72, 0x6c, 0x68));\n      |                                                  ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:619:1: note: declared here\n  619 | _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n      | ^~~~~~~~~~~~\n[REDACTED]/tmpmfcqc8fe.cpp:44:28: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   44 |         __m256i unmasked = _mm_xor_si256(masked, _mm_set_epi8(0x61, 0x7a, 0x6e, 0x69, 0x6f, 0x72, 0x6c, 0x68));\n      |                            ^~~~~~~~~~~~~\n      |                            _mm_xor_si64\n[REDACTED]/tmpmfcqc8fe.cpp:45:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   45 |         _mm_storeu_si256((__m256i*)(&result[i]), unmasked);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_105_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2034txxj.cpp: In function \u2018std::string encrypt_simd(const std::string&)\u2019:\n[REDACTED]/tmp2034txxj.cpp:36:32: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i key = _mm_set_epi32(0, 1, 2, 3); // Rotate the alphabet by 2 * 2 places\n      |                   ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                |\n      |                                __m128i\n[REDACTED]/tmp2034txxj.cpp:38:27: error: no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(const int&)\u2019\n   38 |     std::string result(len);\n      |                           ^\nIn file included from /usr/include/c++/13/string:54,\n                 from /usr/include/c++/13/bits/locale_classes.h:40,\n                 from /usr/include/c++/13/bits/ios_base.h:41,\n                 from /usr/include/c++/13/ios:44,\n                 from /usr/include/c++/13/ostream:40,\n                 from /usr/include/c++/13/iostream:41,\n                 from [REDACTED]/tmp2034txxj.cpp:1:\n/usr/include/c++/13/bits/basic_string.h:795:9: note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&) [with <template-parameter-2-2> = _Tp; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  795 |         basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n      |         ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:795:9: note:   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/13/bits/move.h:37,\n                 from /usr/include/c++/13/bits/exception_ptr.h:41,\n                 from /usr/include/c++/13/exception:164,\n                 from /usr/include/c++/13/ios:41:\n/usr/include/c++/13/type_traits: In substitution of \u2018template<bool _Cond, class _Tp> using std::enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = void]\u2019:\n/usr/include/c++/13/bits/basic_string.h:144:8:   required by substitution of \u2018template<class _CharT, class _Traits, class _Alloc> template<class _Tp, class _Res> using std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_If_sv = std::enable_if_t<std::__and_<std::is_convertible<const _Tp&, std::basic_string_view<_CharT, _Traits> >, std::__not_<std::is_convertible<const _Tp*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>*> >, std::__not_<std::is_convertible<const _Tp&, const _CharT*> > >::value, _Res> [with _Tp = int; _Res = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n/usr/include/c++/13/bits/basic_string.h:792:30:   required from here\n/usr/include/c++/13/type_traits:2610:11: error: no type named \u2018type\u2019 in \u2018struct std::enable_if<false, void>\u2019\n 2610 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;\n      |           ^~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:783:9: note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Tp&, size_type, size_type, const _Alloc&) [with <template-parameter-2-2> = _Tp; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  783 |         basic_string(const _Tp& __t, size_type __pos, size_type __n,\n      |         ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:783:9: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp2034txxj.cpp:38:27: note:   candidate expects 4 arguments, 1 provided\n   38 |     std::string result(len);\n      |                           ^\n/usr/include/c++/13/bits/basic_string.h:760:9: note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with <template-parameter-2-2> = _InputIterator; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  760 |         basic_string(_InputIterator __beg, _InputIterator __end,\n      |         ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:760:9: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp2034txxj.cpp:38:27: note:   candidate expects 3 arguments, 1 provided\n   38 |     std::string result(len);\n      |                           ^\n/usr/include/c++/13/bits/basic_string.h:664:7: note: candidate: \u2018template<class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  664 |       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:664:7: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp2034txxj.cpp:38:27: note:   candidate expects 3 arguments, 1 provided\n   38 |     std::string result(len);\n      |                           ^\n/usr/include/c++/13/bits/basic_string.h:641:7: note: candidate: \u2018template<class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  641 |       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:641:7: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp2034txxj.cpp:38:24: note:   cannot convert \u2018len\u2019 (type \u2018const int\u2019) to type \u2018const char*\u2019\n   38 |     std::string result(len);\n      |                        ^~~\n/usr/include/c++/13/bits/basic_string.h:716:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  716 |       basic_string(basic_string&& __str, const _Alloc& __a)\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:716:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:711:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  711 |       basic_string(const basic_string& __str, const _Alloc& __a)\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:711:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:706:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  706 |       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:706:45: note:   no known conversion for argument 1 from \u2018const int\u2019 to \u2018std::initializer_list<char>\u2019\n  706 |       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/13/bits/basic_string.h:677:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  677 |       basic_string(basic_string&& __str) noexcept\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:677:35: note:   no known conversion for argument 1 from \u2018const int\u2019 to \u2018std::__cxx11::basic_string<char>&&\u2019\n  677 |       basic_string(basic_string&& __str) noexcept\n      |                    ~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/bits/basic_string.h:619:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; size_type = long unsigned int]\u2019\n  619 |       basic_string(const _CharT* __s, size_type __n,\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:619:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:599:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, size_type, size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; size_type = long unsigned int]\u2019\n  599 |       basic_string(const basic_string& __str, size_type __pos,\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:599:7: note:   candidate expects 4 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:581:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, size_type, size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; size_type = long unsigned int]\u2019\n  581 |       basic_string(const basic_string& __str, size_type __pos,\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:581:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:564:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; size_type = long unsigned int]\u2019\n  564 |       basic_string(const basic_string& __str, size_type __pos,\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:564:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:547:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  547 |       basic_string(const basic_string& __str)\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:547:40: note:   no known conversion for argument 1 from \u2018const int\u2019 to \u2018const std::__cxx11::basic_string<char>&\u2019\n  547 |       basic_string(const basic_string& __str)\n      |                    ~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/bits/basic_string.h:535:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  535 |       basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:535:34: note:   no known conversion for argument 1 from \u2018const int\u2019 to \u2018const std::allocator<char>&\u2019\n  535 |       basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n      |                    ~~~~~~~~~~~~~~^~~\n/usr/include/c++/13/bits/basic_string.h:522:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  522 |       basic_string()\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:522:7: note:   candidate expects 0 arguments, 1 provided\n/usr/include/c++/13/bits/basic_string.h:176:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(__sv_wrapper, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n  176 |       basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      |       ^~~~~~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:176:7: note:   candidate expects 2 arguments, 1 provided\n[REDACTED]/tmp2034txxj.cpp:42:29: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   42 |         __m256i src_block = _mm_loadu_si256((__m256i*)src + i);\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm_loadu_si16\n[REDACTED]/tmp2034txxj.cpp:43:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         __m256i shifted_block = _mm_add_epi32(src_block, key);\n      |                                               ^~~~~~~~~\n      |                                               |\n      |                                               __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp2034txxj.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp2034txxj.cpp:44:33: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |         dest = _mm_shuffle_epi8(shifted_block, shifted_block);\n      |                                 ^~~~~~~~~~~~~\n      |                                 |\n      |                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37,\n                 from [REDACTED]/tmp2034txxj.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmp2034txxj.cpp:45:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   45 |         _mm_storeu_si256((__m256i*)&result[i], dest);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_105_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmv64ijpk.cpp: In function \u2018std::string encrypt_simd(const std::string&)\u2019:\n[REDACTED]/tmpmv64ijpk.cpp:38:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   38 |     __m256i mask = _mm_set_epi32(0, 1, 2, 3);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpmv64ijpk.cpp:39:34: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   39 |     __m256i shift = _mm_set_epi32(2 * 2, 4 * 2, 6 * 2, 8 * 2);\n      |                     ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                  |\n      |                                  __m128i\n[REDACTED]/tmpmv64ijpk.cpp:42:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   42 |         __m256i data = _mm_loadu_si256((__m256i*)src + i);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmpmv64ijpk.cpp:43:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         __m256i shifted = _mm_add_epi32(data, shift);\n      |                                         ^~~~\n      |                                         |\n      |                                         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpmv64ijpk.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpmv64ijpk.cpp:44:26: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   44 |         __m256i masked = _mm_and_si256(shifted, mask);\n      |                          ^~~~~~~~~~~~~\n      |                          _mm_and_si64\n[REDACTED]/tmpmv64ijpk.cpp:45:26: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   45 |         __m256i result = _mm_xor_si256(masked, data);\n      |                          ^~~~~~~~~~~~~\n      |                          _mm_xor_si64\n[REDACTED]/tmpmv64ijpk.cpp:46:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   46 |         _mm_storeu_si256((__m256i*)dst + i, result);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_105_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6ai4z4i0.cpp: In function \u2018std::string encrypt_simd(const std::string&)\u2019:\n[REDACTED]/tmp6ai4z4i0.cpp:36:31: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i key = _mm_set_epi8(alphabet[0], alphabet[1], alphabet[2], alphabet[3],\n      |                   ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m128i\n   37 |                                  alphabet[4], alphabet[5], alphabet[6], alphabet[7],\n      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   38 |                                  alphabet[8], alphabet[9], alphabet[10], alphabet[11],\n      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   39 |                                  alphabet[12], alphabet[13], alphabet[14], alphabet[15]);\n      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp6ai4z4i0.cpp:41:21: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   41 |     __m256i input = _mm_loadu_si256((__m256i*)&s[0]);\n      |                     ^~~~~~~~~~~~~~~\n      |                     _mm_loadu_si16\n[REDACTED]/tmp6ai4z4i0.cpp:45:18: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   45 |         output = _mm_xor_si256(input, key);\n      |                  ^~~~~~~~~~~~~\n      |                  _mm_xor_si64\n[REDACTED]/tmp6ai4z4i0.cpp:46:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   46 |         input = _mm_add_epi8(output, _mm_set_epi8(shift, shift, shift, shift,\n      |                              ^~~~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp6ai4z4i0.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1058:23: note:   initializing argument 1 of \u2018__m128i _mm_add_epi8(__m128i, __m128i)\u2019\n 1058 | _mm_add_epi8 (__m128i __A, __m128i __B)\n      |               ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp6ai4z4i0.cpp:16:\n[REDACTED]/tmp6ai4z4i0.cpp:54:32: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   54 |         result.push_back((char)_mm_extract_epi8(output, i));\n      |                                ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_106_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_106_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_106_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgflcbnm5.cpp: In function \u2018std::string encode_simd(const std::string&)\u2019:\n[REDACTED]/tmpgflcbnm5.cpp:53:56: error: too many arguments to function \u2018__m256i _mm256_shuffle_epi8(__m256i, __m256i)\u2019\n   53 |             __m256i shifted_vowel = _mm256_shuffle_epi8(_mm256_set1_epi8(shift_table[j]), vowel_mask, 0b1010);\n      |                                     ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpgflcbnm5.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:588:1: note: declared here\n  588 | _mm256_shuffle_epi8 (__m256i __X, __m256i __Y)\n      | ^~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_106_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmppilif_6d.cpp:16:\n[REDACTED]/tmppilif_6d.cpp: In function \u2018std::string encode_simd(const std::string&)\u2019:\n[REDACTED]/tmppilif_6d.cpp:47:26: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   47 |         __m256i v_char = _mm256_extract_epi8(v_message, i);\n      |                          ^~~~~~~~~~~~~~~~~~~\n      |                          |\n      |                          int\n[REDACTED]/tmppilif_6d.cpp:63:12: error: \u2018_mm256_cvtsi256_si64\u2019 was not declared in this scope; did you mean \u2018_mm256_cvtsi256_si32\u2019?\n   63 |     return _mm256_cvtsi256_si64(v_message);\n      |            ^~~~~~~~~~~~~~~~~~~~\n      |            _mm256_cvtsi256_si32\n"}
{"task_id": "SimdBench_106_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp97q4m90i.cpp: In function \u2018std::string encode_simd(const std::string&)\u2019:\n[REDACTED]/tmp97q4m90i.cpp:42:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   42 |     __m256i mask = _mm_set_epi32(0x000000FF, 0x000000FF, 0x000000FF, 0x000000FF);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp97q4m90i.cpp:43:41: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   43 |     __m256i swapped_mask = _mm_set_epi32(0xFF000000, 0xFF000000, 0xFF000000, 0xFF000000);\n      |                            ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                         |\n      |                                         __m128i\n[REDACTED]/tmp97q4m90i.cpp:44:43: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   44 |     __m256i swapped_vowels = _mm_set_epi32(0x00000000, 0x00000000, 0x00000000, 0x00000000);\n      |                              ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                           |\n      |                                           __m128i\n[REDACTED]/tmp97q4m90i.cpp:47:25: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   47 |         __m256i input = _mm_loadu_si256((__m256i*)&message[i]);\n      |                         ^~~~~~~~~~~~~~~\n      |                         _mm_loadu_si16\n[REDACTED]/tmp97q4m90i.cpp:50:33: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   50 |         __m256i swapped_input = _mm_xor_si256(input, swapped_mask);\n      |                                 ^~~~~~~~~~~~~\n      |                                 _mm_xor_si64\n[REDACTED]/tmp97q4m90i.cpp:61:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   61 |         _mm_storeu_si256((__m256i*)&message[i], swapped_vowels);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_107_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmph5ucd64l.cpp:60:45: error: macro \"_mm_test_all_zeros\" requires 2 arguments, but only 1 given\n   60 |     bool all_upper = _mm_test_all_zeros(mask);\n      |                                             ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmph5ucd64l.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:89: note: macro \"_mm_test_all_zeros\" defined here\n   89 | #define _mm_test_all_zeros(M, V) _mm_testz_si128 ((M), (V))\n      | \n[REDACTED]/tmph5ucd64l.cpp: In function \u2018bool check_dict_case_simd(std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >)\u2019:\n[REDACTED]/tmph5ucd64l.cpp:47:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   47 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmph5ucd64l.cpp:50:77: error: no match for \u2018operator[]\u2019 (operand types are \u2018std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >\u2019 and \u2018size_t\u2019 {aka \u2018long unsigned int\u2019})\n   50 |         __m256i key = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&dict[i]));\n      |                                                                             ^\nIn file included from /usr/include/c++/13/map:63,\n                 from [REDACTED]/tmph5ucd64l.cpp:3:\n/usr/include/c++/13/bits/stl_map.h:504:7: note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::operator[](const key_type&) [with _Key = std::__cxx11::basic_string<char>; _Tp = std::__cxx11::basic_string<char>; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >; mapped_type = std::__cxx11::basic_string<char>; key_type = std::__cxx11::basic_string<char>]\u2019\n  504 |       operator[](const key_type& __k)\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_map.h:504:34: note:   no known conversion for argument 1 from \u2018size_t\u2019 {aka \u2018long unsigned int\u2019} to \u2018const std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >::key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n  504 |       operator[](const key_type& __k)\n      |                  ~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/13/bits/stl_map.h:524:7: note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::operator[](key_type&&) [with _Key = std::__cxx11::basic_string<char>; _Tp = std::__cxx11::basic_string<char>; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >; mapped_type = std::__cxx11::basic_string<char>; key_type = std::__cxx11::basic_string<char>]\u2019\n  524 |       operator[](key_type&& __k)\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_map.h:524:29: note:   no known conversion for argument 1 from \u2018size_t\u2019 {aka \u2018long unsigned int\u2019} to \u2018std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >::key_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n  524 |       operator[](key_type&& __k)\n      |                  ~~~~~~~~~~~^~~\n[REDACTED]/tmph5ucd64l.cpp:50:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   50 |         __m256i key = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&dict[i]));\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmph5ucd64l.cpp:51:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   51 |         __m256i lower_mask = _mm_cmplt_epi8(key, _mm_set1_epi8('Z'));\n      |                                             ^~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmph5ucd64l.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1357:25: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi8(__m128i, __m128i)\u2019\n 1357 | _mm_cmplt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmph5ucd64l.cpp:52:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   52 |         __m256i upper_mask = _mm_cmpgt_epi8(key, _mm_set1_epi8('A'));\n      |                                             ^~~\n      |                                             |\n      |                                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmph5ucd64l.cpp:54:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   54 |         mask = _mm_or_si256(mask, lower_mask);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmph5ucd64l.cpp:59:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   59 |     bool all_lower = _mm_test_all_ones(mask);\n      |                                        ^\n      |                                        |\n      |                                        __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1351:26: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi32(__m128i, __m128i)\u2019\n 1351 | _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmph5ucd64l.cpp:60:22: error: \u2018_mm_test_all_zeros\u2019 was not declared in this scope\n   60 |     bool all_upper = _mm_test_all_zeros(mask);\n      |                      ^~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_107_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmn93ow8p.cpp: In function \u2018bool check_dict_case_simd(std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >)\u2019:\n[REDACTED]/tmpmn93ow8p.cpp:45:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   45 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpmn93ow8p.cpp:53:29: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   53 |         __m256i key_bytes = _mm_loadu_si256(reinterpret_cast<const __m256i*>(&key[0]));\n      |                             ^~~~~~~~~~~~~~~\n      |                             _mm_loadu_si16\n[REDACTED]/tmpmn93ow8p.cpp:57:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   57 |         __m256i lower_mask = _mm_cmplt_epi8(key_bytes, _mm_set1_epi8('A'));\n      |                                             ^~~~~~~~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpmn93ow8p.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1357:25: note:   initializing argument 1 of \u2018__m128i _mm_cmplt_epi8(__m128i, __m128i)\u2019\n 1357 | _mm_cmplt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpmn93ow8p.cpp:58:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   58 |         __m256i upper_mask = _mm_cmpgt_epi8(key_bytes, _mm_set1_epi8('Z'));\n      |                                             ^~~~~~~~~\n      |                                             |\n      |                                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpmn93ow8p.cpp:61:42: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   61 |         all_lower &= !__builtin_popcount(mask);\n      |                                          ^~~~\n      |                                          |\n      |                                          __m256i\n<built-in>: note:   initializing argument 1 of \u2018int __builtin_popcount(unsigned int)\u2019\n[REDACTED]/tmpmn93ow8p.cpp:65:42: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   65 |         all_upper &= !__builtin_popcount(mask);\n      |                                          ^~~~\n      |                                          |\n      |                                          __m256i\n<built-in>: note:   initializing argument 1 of \u2018int __builtin_popcount(unsigned int)\u2019\n"}
{"task_id": "SimdBench_107_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptglw5ix5.cpp: In function \u2018bool check_dict_case_simd(std::map<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >)\u2019:\n[REDACTED]/tmptglw5ix5.cpp:43:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   43 |     __m256i mask = _mm_setzero_si256();\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmptglw5ix5.cpp:51:43: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   51 |         __m256i key_m128 = _mm_loadu_si128((__m128i*)key);\n      |                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                                           |\n      |                                           __m128i\n[REDACTED]/tmptglw5ix5.cpp:52:45: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   52 |         __m256i value_m128 = _mm_loadu_si128((__m128i*)value);\n      |                              ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~\n      |                                             |\n      |                                             __m128i\n[REDACTED]/tmptglw5ix5.cpp:54:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   54 |         __m256i key_m256 = _mm_shuffle_epi8(key_m128, key_m128);\n      |                                             ^~~~~~~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37,\n                 from [REDACTED]/tmptglw5ix5.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmptglw5ix5.cpp:55:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   55 |         __m256i value_m256 = _mm_shuffle_epi8(value_m128, value_m128);\n      |                                               ^~~~~~~~~~\n      |                                               |\n      |                                               __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmptglw5ix5.cpp:57:34: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   57 |         __m256i key_m128_lower = _mm_and_si256(key_m128, _mm_set1_epi8('a'));\n      |                                  ^~~~~~~~~~~~~\n      |                                  _mm_and_si64\n[REDACTED]/tmptglw5ix5.cpp:63:38: error: \u2018_mm_xor_si256\u2019 was not declared in this scope; did you mean \u2018_mm_xor_si64\u2019?\n   63 |         __m256i key_m128_not_lower = _mm_xor_si256(key_m128_lower, _mm_set1_epi8('a'));\n      |                                      ^~~~~~~~~~~~~\n      |                                      _mm_xor_si64\n[REDACTED]/tmptglw5ix5.cpp:69:16: error: \u2018_mm_or_si256\u2019 was not declared in this scope; did you mean \u2018_mm_or_si64\u2019?\n   69 |         mask = _mm_or_si256(mask, key_m128_not_lower);\n      |                ^~~~~~~~~~~~\n      |                _mm_or_si64\n[REDACTED]/tmptglw5ix5.cpp:74:30: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   74 |         if(_mm_movemask_epi8(mask) != 0) {\n      |                              ^~~~\n      |                              |\n      |                              __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmptglw5ix5.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_107_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpun5eyxnh.cpp: In lambda function:\n[REDACTED]/tmpun5eyxnh.cpp:50:67: error: no matching function for call to \u2018tolower(const std::string&)\u2019\n   50 |                    [](const std::string& str){ return std::tolower(str); });\n      |                                                       ~~~~~~~~~~~~^~~~~\nIn file included from /usr/include/c++/13/bits/basic_ios.h:37,\n                 from /usr/include/c++/13/ios:46,\n                 from /usr/include/c++/13/ostream:40,\n                 from /usr/include/c++/13/iostream:41,\n                 from [REDACTED]/tmpun5eyxnh.cpp:1:\n/usr/include/c++/13/bits/locale_facets.h:2681:5: note: candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const locale&)\u2019\n 2681 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n/usr/include/c++/13/bits/locale_facets.h:2681:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpun5eyxnh.cpp:50:67: note:   candidate expects 2 arguments, 1 provided\n   50 |                    [](const std::string& str){ return std::tolower(str); });\n      |                                                       ~~~~~~~~~~~~^~~~~\nIn file included from /usr/include/c++/13/cctype:42,\n                 from /usr/include/c++/13/bits/localefwd.h:42,\n                 from /usr/include/c++/13/ios:43:\n/usr/include/ctype.h:122:12: note: candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c) __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no known conversion for argument 1 from \u2018const std::string\u2019 {aka \u2018const std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      |                     ~~~~^~~\n[REDACTED]/tmpun5eyxnh.cpp: In lambda function:\n[REDACTED]/tmpun5eyxnh.cpp:62:67: error: no matching function for call to \u2018toupper(const std::string&)\u2019\n   62 |                    [](const std::string& str){ return std::toupper(str); });\n      |                                                       ~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/bits/locale_facets.h:2675:5: note: candidate: \u2018template<class _CharT> _CharT std::toupper(_CharT, const locale&)\u2019\n 2675 |     toupper(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n/usr/include/c++/13/bits/locale_facets.h:2675:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmpun5eyxnh.cpp:62:67: note:   candidate expects 2 arguments, 1 provided\n   62 |                    [](const std::string& str){ return std::toupper(str); });\n      |                                                       ~~~~~~~~~~~~^~~~~\n/usr/include/ctype.h:125:12: note: candidate: \u2018int toupper(int)\u2019\n  125 | extern int toupper (int __c) __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:125:25: note:   no known conversion for argument 1 from \u2018const std::string\u2019 {aka \u2018const std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019\n  125 | extern int toupper (int __c) __THROW;\n      |                     ~~~~^~~\n"}
{"task_id": "SimdBench_107_AVX", "passed": false, "result": "no intrinsic in code"}
{"task_id": "SimdBench_108_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_108_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpiy_eclqu.cpp: In function \u2018std::vector<int> count_up_to_simd(int)\u2019:\n[REDACTED]/tmpiy_eclqu.cpp:52:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   52 |     __m256i limit = _mm256_set_epi32(n - 1, n - 1, n - 1, n - 1);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpiy_eclqu.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpiy_eclqu.cpp:58:50: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   58 |             __m256i start_mask = _mm256_set_epi32(start, start, start, start);\n      |                                  ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpiy_eclqu.cpp:59:48: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   59 |             __m256i end_mask = _mm256_set_epi32(end, end, end, end);\n      |                                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpiy_eclqu.cpp:60:49: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   60 |             __m256i step_mask = _mm256_set_epi32(i, i, i, i);\n      |                                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpiy_eclqu.cpp:69:62: error: \u2018_mm256_cmplt_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   69 |             mask = _mm256_or_si256(mask, _mm256_andnot_si256(_mm256_cmplt_epi32(start_mask, limit), start_mask));\n      |                                                              ^~~~~~~~~~~~~~~~~~\n      |                                                              _mm256_cmpgt_epi32\n"}
{"task_id": "SimdBench_108_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_108_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_108_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_109_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppahs08qt.cpp: In function \u2018int count_upper_simd(const std::string&)\u2019:\n[REDACTED]/tmppahs08qt.cpp:29:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   29 |     __m256i mask = _mm_set_epi32(0x41, 0x41, 0x41, 0x41); // Mask for uppercase vowels: A, E, I, O, U\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmppahs08qt.cpp:30:22: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   30 |     __m256i result = _mm_setzero_si256(); // Initialize result to zero\n      |                      ^~~~~~~~~~~~~~~~~\n      |                      _mm_setzero_si64\n[REDACTED]/tmppahs08qt.cpp:33:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   33 |         __m256i word = _mm_loadu_si256((__m256i*)&s[i]); // Load 4 characters at a time\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmppahs08qt.cpp:34:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   34 |         __m256i upper_word = _mm_cmpeq_epi8(word, mask); // Compare each character with the mask\n      |                                             ^~~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmppahs08qt.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmppahs08qt.cpp:35:58: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   35 |         __m256i count = _mm_popcnt_u32(_mm_movemask_epi8(upper_word)); // Count the number of set bits\n      |                                                          ^~~~~~~~~~\n      |                                                          |\n      |                                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmppahs08qt.cpp:36:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         result = _mm_add_epi32(result, count); // Add the count to the result\n      |                                ^~~~~~\n      |                                |\n      |                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmppahs08qt.cpp:16:\n[REDACTED]/tmppahs08qt.cpp:39:12: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   39 |     return _mm_extract_epi32(result, 0); // Extract the final result from the vector\n      |            ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_109_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_8tsrhbg.cpp: In function \u2018int count_upper_simd(const std::string&)\u2019:\n[REDACTED]/tmp_8tsrhbg.cpp:34:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   34 |     __m256i mask = _mm_set_epi32(0x41, 0x41, 0x41, 0x41); // Mask for uppercase vowels: A, E, I, O, U\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp_8tsrhbg.cpp:38:39: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   38 |         upper_vowels = _mm_cmpeq_epi8(_mm_loadu_si256((__m256i *)str), mask);\n      |                                       ^~~~~~~~~~~~~~~\n      |                                       _mm_loadu_si16\n[REDACTED]/tmp_8tsrhbg.cpp:39:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   39 |         result += _mm_popcnt_u32(_mm_movemask_epi8(upper_vowels));\n      |                                                    ^~~~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_8tsrhbg.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_109_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgkv3ma0b.cpp: In function \u2018int count_upper_simd(const std::string&)\u2019:\n[REDACTED]/tmpgkv3ma0b.cpp:30:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   30 |     __m256i mask = _mm_set_epi32(0x41, 0x41, 0x41, 0x41); // Mask for uppercase vowels: A, E, I, O, U\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpgkv3ma0b.cpp:31:27: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |     __m256i upper_chars = _mm_loadu_si256((__m256i *)ptr);\n      |                           ^~~~~~~~~~~~~~~\n      |                           _mm_loadu_si16\n[REDACTED]/tmpgkv3ma0b.cpp:33:27: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   33 |     while (upper_chars != _mm_setzero_si256()) {\n      |                           ^~~~~~~~~~~~~~~~~\n      |                           _mm_setzero_si64\n[REDACTED]/tmpgkv3ma0b.cpp:34:31: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   34 |         __m256i lower_chars = _mm_and_si256(upper_chars, mask);\n      |                               ^~~~~~~~~~~~~\n      |                               _mm_and_si64\n[REDACTED]/tmpgkv3ma0b.cpp:36:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   36 |         result += _mm_popcnt_u32(_mm_movemask_epi8(upper_mask));\n      |                                                    ^~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpgkv3ma0b.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpgkv3ma0b.cpp:37:23: error: \u2018_mm_srli_si256\u2019 was not declared in this scope; did you mean \u2018_mm_srli_si64\u2019?\n   37 |         upper_chars = _mm_srli_si256(upper_chars, 8);\n      |                       ^~~~~~~~~~~~~~\n      |                       _mm_srli_si64\n"}
{"task_id": "SimdBench_109_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbo8yx9rh.cpp: In function \u2018int count_upper_simd(const std::string&)\u2019:\n[REDACTED]/tmpbo8yx9rh.cpp:32:47: error: cannot convert \u2018__m128i\u2019 to \u2018const __m256i\u2019 in initialization\n   32 |     const __m256i upper_vowels = _mm_set_epi32(0x41, 0x45, 0x49, 0x4F); // 'A', 'E', 'I', 'O'\n      |                                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                               |\n      |                                               __m128i\n[REDACTED]/tmpbo8yx9rh.cpp:36:24: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   36 |         __m256i word = _mm_loadu_si256((__m256i*)&s[i]);\n      |                        ^~~~~~~~~~~~~~~\n      |                        _mm_loadu_si16\n[REDACTED]/tmpbo8yx9rh.cpp:37:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   37 |         __m256i mask = _mm_cmpeq_epi8(word, upper_vowels);\n      |                                       ^~~~\n      |                                       |\n      |                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpbo8yx9rh.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1339:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpeq_epi8(__m128i, __m128i)\u2019\n 1339 | _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpbo8yx9rh.cpp:38:51: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   38 |         count += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n      |                                                   ^~~~\n      |                                                   |\n      |                                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_109_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp18dtcn5e.cpp: In function \u2018int count_upper_simd(const std::string&)\u2019:\n[REDACTED]/tmp18dtcn5e.cpp:30:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   30 |     __m256i mask = _mm_set_epi32(0x41, 0x41, 0x41, 0x41); // Mask for uppercase vowels: A, E, I, O, U\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp18dtcn5e.cpp:31:28: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   31 |     __m256i upper_vowels = _mm_loadu_si256((__m256i *)str);\n      |                            ^~~~~~~~~~~~~~~\n      |                            _mm_loadu_si16\n[REDACTED]/tmp18dtcn5e.cpp:32:20: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   32 |     upper_vowels = _mm_and_si256(upper_vowels, mask);\n      |                    ^~~~~~~~~~~~~\n      |                    _mm_and_si64\n[REDACTED]/tmp18dtcn5e.cpp:33:47: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   33 |     upper_vowels = _mm_sad_epu8(upper_vowels, _mm_setzero_si256());\n      |                                               ^~~~~~~~~~~~~~~~~\n      |                                               _mm_setzero_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp18dtcn5e.cpp:16:\n[REDACTED]/tmp18dtcn5e.cpp:34:14: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   34 |     result = _mm_extract_epi32(upper_vowels, 0);\n      |              ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_110_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzsaaiy_b.cpp: In function \u2018std::vector<int> make_a_pile_simd(int)\u2019:\n[REDACTED]/tmpzsaaiy_b.cpp:34:48: error: could not convert \u2018((i != n_vec) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   34 |     for (__m256i i = _mm256_setzero_si256(); i != n_vec; i = _mm256_add_epi32(i, _mm256_set_epi32(2, 2, 2, 2, 2, 2, 2, 2))) {\n      |                                              ~~^~~~~~~~\n      |                                                |\n      |                                                __vector(4) long int\n[REDACTED]/tmpzsaaiy_b.cpp:37:46: error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<int>\u2019 and \u2018__m256i\u2019)\n   37 |         _mm256_storeu_si256((__m256i*)&result[i], next_value);\n      |                                              ^\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmpzsaaiy_b.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:1126:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](size_type) [with _Tp = int; _Alloc = std::allocator<int>; reference = int&; size_type = long unsigned int]\u2019\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1126:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/usr/include/c++/13/bits/stl_vector.h:1145:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](size_type) const [with _Tp = int; _Alloc = std::allocator<int>; const_reference = const int&; size_type = long unsigned int]\u2019\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1145:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_110_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjr8sgh7w.cpp: In function \u2018std::vector<int> make_a_pile_simd(int)\u2019:\n[REDACTED]/tmpjr8sgh7w.cpp:34:48: error: could not convert \u2018((i != n_vec) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   34 |     for (__m256i i = _mm256_setzero_si256(); i != n_vec; i = _mm256_add_epi32(i, _mm256_set_epi32(2, 2, 2, 2, 2, 2, 2, 2))) {\n      |                                              ~~^~~~~~~~\n      |                                                |\n      |                                                __vector(4) long int\n[REDACTED]/tmpjr8sgh7w.cpp:37:46: error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<int>\u2019 and \u2018__m256i\u2019)\n   37 |         _mm256_storeu_si256((__m256i*)&result[i], next_value);\n      |                                              ^\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmpjr8sgh7w.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:1126:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](size_type) [with _Tp = int; _Alloc = std::allocator<int>; reference = int&; size_type = long unsigned int]\u2019\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1126:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/usr/include/c++/13/bits/stl_vector.h:1145:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](size_type) const [with _Tp = int; _Alloc = std::allocator<int>; const_reference = const int&; size_type = long unsigned int]\u2019\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1145:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_110_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpcoecn8va.cpp: In function \u2018std::vector<int> make_a_pile_simd(int)\u2019:\n[REDACTED]/tmpcoecn8va.cpp:35:31: error: could not convert \u2018((i != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   35 |     for (__m256i i = n_vec; i != _mm256_setzero_si256(); i = _mm256_add_epi32(i, _mm256_set_epi32(2, 2, 2, 2, 2, 2, 2, 2))) {\n      |                             ~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __vector(4) long int\n"}
{"task_id": "SimdBench_110_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpati5e194.cpp: In function \u2018std::vector<int> make_a_pile_simd(int)\u2019:\n[REDACTED]/tmpati5e194.cpp:35:29: error: could not convert \u2018((i != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   35 |     for (__m256i i = v_n; i != _mm256_setzero_si256(); i >>= 2) {\n      |                           ~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                             |\n      |                             __vector(4) long int\n"}
{"task_id": "SimdBench_110_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8cbjxh_x.cpp:37:107: error: macro \"_mm256_shuffle_epi32\" passed 8 arguments, but takes just 2\n   37 |         __m256i next_value = _mm256_add_epi32(i, _mm256_shuffle_epi32(odd_even, odd_even, 0, 2, 1, 3, 4, 6));\n      |                                                                                                           ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmp8cbjxh_x.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:616: note: macro \"_mm256_shuffle_epi32\" defined here\n  616 | #define _mm256_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmp8cbjxh_x.cpp: In function \u2018std::vector<int> make_a_pile_simd(int)\u2019:\n[REDACTED]/tmp8cbjxh_x.cpp:35:29: error: could not convert \u2018((i != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   35 |     for (__m256i i = v_n; i != _mm256_setzero_si256(); i >>= 2) {\n      |                           ~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                             |\n      |                             __vector(4) long int\n[REDACTED]/tmp8cbjxh_x.cpp:37:50: error: \u2018_mm256_shuffle_epi32\u2019 was not declared in this scope\n   37 |         __m256i next_value = _mm256_add_epi32(i, _mm256_shuffle_epi32(odd_even, odd_even, 0, 2, 1, 3, 4, 6));\n      |                                                  ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp8cbjxh_x.cpp:38:46: error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<int>\u2019 and \u2018__m256i\u2019)\n   38 |         _mm256_storeu_si256((__m256i*)&result[i], next_value);\n      |                                              ^\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmp8cbjxh_x.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:1126:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](size_type) [with _Tp = int; _Alloc = std::allocator<int>; reference = int&; size_type = long unsigned int]\u2019\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1126:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1126 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/usr/include/c++/13/bits/stl_vector.h:1145:7: note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](size_type) const [with _Tp = int; _Alloc = std::allocator<int>; const_reference = const int&; size_type = long unsigned int]\u2019\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:1145:28: note:   no known conversion for argument 1 from \u2018__m256i\u2019 to \u2018std::vector<int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1145 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_111_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3hgbay8e.cpp: In function \u2018std::string rounded_avg_simd(int64_t, int64_t)\u2019:\n[REDACTED]/tmp3hgbay8e.cpp:48:36: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   48 |         __m256i avg = _mm256_div_ps(_mm256_castsi256_ps(num), _mm256_set1_ps(4));\n      |                       ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m256\n[REDACTED]/tmp3hgbay8e.cpp:49:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   49 |         sum = _mm256_add_ps(sum, avg);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp3hgbay8e.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp3hgbay8e.cpp:50:57: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   50 |         count = _mm256_add_epi32(count, _mm256_set_epi32(4));\n      |                                         ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp3hgbay8e.cpp:55:55: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   55 |     __m256i final_sum = _mm256_hadd_ps(_mm256_hadd_ps(sum, sum), sum);\n      |                                                       ^~~\n      |                                                       |\n      |                                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:270:24: note:   initializing argument 1 of \u2018__m256 _mm256_hadd_ps(__m256, __m256)\u2019\n  270 | _mm256_hadd_ps (__m256 __X, __m256 __Y)\n      |                 ~~~~~~~^~~\n[REDACTED]/tmp3hgbay8e.cpp:58:23: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   58 |     float total_sum = _mm256_reduce_add_ps(final_sum);\n      |                       ^~~~~~~~~~~~~~~~~~~~\n      |                       _mm256_reduce_add_ph\n[REDACTED]/tmp3hgbay8e.cpp:59:27: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   59 |     int64_t total_count = _mm256_reduce_add_epi32(final_count);\n      |                           ^~~~~~~~~~~~~~~~~~~~~~~\n      |                           _mm512_reduce_add_epi32\n[REDACTED]/tmp3hgbay8e.cpp:66:40: warning: format \u2018%b\u2019 expects argument of type \u2018unsigned int\u2019, but argument 4 has type \u2018int64_t\u2019 {aka \u2018long int\u2019} [-Wformat=]\n   66 |     snprintf(binary, sizeof(binary), \"%b\", rounded_average);\n      |                                       ~^   ~~~~~~~~~~~~~~~\n      |                                        |   |\n      |                                        |   int64_t {aka long int}\n      |                                        unsigned int\n      |                                       %lb\n"}
{"task_id": "SimdBench_111_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpebbluxjt.cpp: In function \u2018std::string rounded_avg_simd(int64_t, int64_t)\u2019:\n[REDACTED]/tmpebbluxjt.cpp:49:57: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   49 |         count = _mm256_add_epi64(count, _mm256_set_epi32(1, 1, 1, 1));\n      |                                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpebbluxjt.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpebbluxjt.cpp:53:19: error: \u2018_mm256_div_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi64\u2019?\n   53 |     __m256i avg = _mm256_div_epi64(sum, count);\n      |                   ^~~~~~~~~~~~~~~~\n      |                   _mm256_min_epi64\n[REDACTED]/tmpebbluxjt.cpp:54:51: error: \u2018_MM_FROUND_TO_NEAREST_TIE\u2019 was not declared in this scope\n   54 |     __m256i rounded_avg = _mm256_round_epi32(avg, _MM_FROUND_TO_NEAREST_TIE);\n      |                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpebbluxjt.cpp:54:27: error: \u2018_mm256_round_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_rorv_epi32\u2019?\n   54 |     __m256i rounded_avg = _mm256_round_epi32(avg, _MM_FROUND_TO_NEAREST_TIE);\n      |                           ^~~~~~~~~~~~~~~~~~\n      |                           _mm256_rorv_epi32\n"}
{"task_id": "SimdBench_111_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9w9bauq7.cpp: In function \u2018std::string rounded_avg_simd(int64_t, int64_t)\u2019:\n[REDACTED]/tmp9w9bauq7.cpp:44:29: error: no matching function for call to \u2018max(int64_t&, int)\u2019\n   44 |     int64_t start = std::max(n, 1);\n      |                     ~~~~~~~~^~~~~~\nIn file included from /usr/include/c++/13/string:51,\n                 from /usr/include/c++/13/bits/locale_classes.h:40,\n                 from /usr/include/c++/13/bits/ios_base.h:41,\n                 from /usr/include/c++/13/ios:44,\n                 from /usr/include/c++/13/ostream:40,\n                 from /usr/include/c++/13/iostream:41,\n                 from [REDACTED]/tmp9w9bauq7.cpp:1:\n/usr/include/c++/13/bits/stl_algobase.h:257:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const _Tp&, const _Tp&)\u2019\n  257 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algobase.h:257:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:44:29: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   44 |     int64_t start = std::max(n, 1);\n      |                     ~~~~~~~~^~~~~~\n/usr/include/c++/13/bits/stl_algobase.h:303:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  303 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algobase.h:303:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:44:29: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   44 |     int64_t start = std::max(n, 1);\n      |                     ~~~~~~~~^~~~~~\nIn file included from /usr/include/c++/13/algorithm:61,\n                 from [REDACTED]/utils.hpp:8,\n                 from [REDACTED]/tmp9w9bauq7.cpp:14:\n/usr/include/c++/13/bits/stl_algo.h:5795:5: note: candidate: \u2018template<class _Tp> constexpr _Tp std::max(initializer_list<_Tp>)\u2019\n 5795 |     max(initializer_list<_Tp> __l)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algo.h:5795:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:44:29: note:   mismatched types \u2018std::initializer_list<_Tp>\u2019 and \u2018long int\u2019\n   44 |     int64_t start = std::max(n, 1);\n      |                     ~~~~~~~~^~~~~~\n/usr/include/c++/13/bits/stl_algo.h:5805:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr _Tp std::max(initializer_list<_Tp>, _Compare)\u2019\n 5805 |     max(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algo.h:5805:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:44:29: note:   mismatched types \u2018std::initializer_list<_Tp>\u2019 and \u2018long int\u2019\n   44 |     int64_t start = std::max(n, 1);\n      |                     ~~~~~~~~^~~~~~\n[REDACTED]/tmp9w9bauq7.cpp:45:27: error: no matching function for call to \u2018min(int64_t&, int)\u2019\n   45 |     int64_t end = std::min(m, 100); // Assuming max value for simplicity\n      |                   ~~~~~~~~^~~~~~~~\n/usr/include/c++/13/bits/stl_algobase.h:233:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  233 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algobase.h:233:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:45:27: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   45 |     int64_t end = std::min(m, 100); // Assuming max value for simplicity\n      |                   ~~~~~~~~^~~~~~~~\n/usr/include/c++/13/bits/stl_algobase.h:281:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  281 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algobase.h:281:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:45:27: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   45 |     int64_t end = std::min(m, 100); // Assuming max value for simplicity\n      |                   ~~~~~~~~^~~~~~~~\n/usr/include/c++/13/bits/stl_algo.h:5775:5: note: candidate: \u2018template<class _Tp> constexpr _Tp std::min(initializer_list<_Tp>)\u2019\n 5775 |     min(initializer_list<_Tp> __l)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algo.h:5775:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:45:27: note:   mismatched types \u2018std::initializer_list<_Tp>\u2019 and \u2018long int\u2019\n   45 |     int64_t end = std::min(m, 100); // Assuming max value for simplicity\n      |                   ~~~~~~~~^~~~~~~~\n/usr/include/c++/13/bits/stl_algo.h:5785:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr _Tp std::min(initializer_list<_Tp>, _Compare)\u2019\n 5785 |     min(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^~~\n/usr/include/c++/13/bits/stl_algo.h:5785:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp9w9bauq7.cpp:45:27: note:   mismatched types \u2018std::initializer_list<_Tp>\u2019 and \u2018long int\u2019\n   45 |     int64_t end = std::min(m, 100); // Assuming max value for simplicity\n      |                   ~~~~~~~~^~~~~~~~\n[REDACTED]/tmp9w9bauq7.cpp:64:54: error: \u2018_MM_REDUCE_ADD_EPI32_ACCUMULATOR\u2019 was not declared in this scope\n   64 |     int64_t total_sum = _mm256_reduce_add_epi32(sum, _MM_REDUCE_ADD_EPI32_ACCUMULATOR);\n      |                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp9w9bauq7.cpp:64:25: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   64 |     int64_t total_sum = _mm256_reduce_add_epi32(sum, _MM_REDUCE_ADD_EPI32_ACCUMULATOR);\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~\n      |                         _mm512_reduce_add_epi32\n[REDACTED]/tmp9w9bauq7.cpp:71:10: error: \u2018bitset\u2019 is not a member of \u2018std\u2019\n   71 |     std::bitset<32> bits(rounded_avg);\n      |          ^~~~~~\n[REDACTED]/tmp9w9bauq7.cpp:18:1: note: \u2018std::bitset\u2019 is defined in header \u2018<bitset>\u2019; did you forget to \u2018#include <bitset>\u2019?\n   17 | #include <x86intrin.h>\n  +++ |+#include <bitset>\n   18 | \n[REDACTED]/tmp9w9bauq7.cpp:71:21: error: \u2018bits\u2019 was not declared in this scope\n   71 |     std::bitset<32> bits(rounded_avg);\n      |                     ^~~~\n"}
{"task_id": "SimdBench_111_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7821dir4.cpp: In function \u2018std::string rounded_avg_simd(int64_t, int64_t)\u2019:\n[REDACTED]/tmp7821dir4.cpp:48:36: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   48 |         __m256i avg = _mm256_div_ps(_mm256_castsi256_ps(num), _mm256_set1_ps(4));\n      |                       ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m256\n[REDACTED]/tmp7821dir4.cpp:49:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   49 |         sum = _mm256_add_ps(sum, avg);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp7821dir4.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp7821dir4.cpp:50:57: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   50 |         count = _mm256_add_epi32(count, _mm256_set_epi32(4));\n      |                                         ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7821dir4.cpp:55:25: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   55 |     int64_t total_sum = _mm256_reduce_add_ps(sum, _mm256_set1_ps(0)).u64[0];\n      |                         ^~~~~~~~~~~~~~~~~~~~\n      |                         _mm256_reduce_add_ph\n[REDACTED]/tmp7821dir4.cpp:56:27: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   56 |     int64_t total_count = _mm256_reduce_add_epi32(count, _mm256_set1_epi32(0)).u32[0];\n      |                           ^~~~~~~~~~~~~~~~~~~~~~~\n      |                           _mm512_reduce_add_epi32\n[REDACTED]/tmp7821dir4.cpp:62:17: error: \u2018bitset\u2019 is not a member of \u2018std\u2019\n   62 |     return std::bitset<64>(rounded_avg).to_string().substr(0, 6);\n      |                 ^~~~~~\n[REDACTED]/tmp7821dir4.cpp:18:1: note: \u2018std::bitset\u2019 is defined in header \u2018<bitset>\u2019; did you forget to \u2018#include <bitset>\u2019?\n   17 | #include <x86intrin.h>\n  +++ |+#include <bitset>\n   18 | \n[REDACTED]/tmp7821dir4.cpp:62:41: error: request for member \u2018to_string\u2019 in \u2018rounded_avg\u2019, which is of non-class type \u2018int64_t\u2019 {aka \u2018long int\u2019}\n   62 |     return std::bitset<64>(rounded_avg).to_string().substr(0, 6);\n      |                                         ^~~~~~~~~\n"}
{"task_id": "SimdBench_111_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7mexl5gf.cpp: In function \u2018std::string rounded_avg_simd(int64_t, int64_t)\u2019:\n[REDACTED]/tmp7mexl5gf.cpp:48:36: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   48 |         __m256i avg = _mm256_div_ps(_mm256_castsi256_ps(num), _mm256_set1_ps(4));\n      |                       ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                    |\n      |                                    __m256\n[REDACTED]/tmp7mexl5gf.cpp:49:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   49 |         sum = _mm256_add_ps(sum, avg);\n      |                             ^~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp7mexl5gf.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp7mexl5gf.cpp:50:57: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   50 |         count = _mm256_add_epi32(count, _mm256_set_epi32(4));\n      |                                         ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7mexl5gf.cpp:55:55: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   55 |     __m256i final_sum = _mm256_hadd_ps(_mm256_hadd_ps(sum, sum), sum);\n      |                                                       ^~~\n      |                                                       |\n      |                                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:270:24: note:   initializing argument 1 of \u2018__m256 _mm256_hadd_ps(__m256, __m256)\u2019\n  270 | _mm256_hadd_ps (__m256 __X, __m256 __Y)\n      |                 ~~~~~~~^~~\n[REDACTED]/tmp7mexl5gf.cpp:58:23: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   58 |     float total_sum = _mm256_reduce_add_ps(final_sum);\n      |                       ^~~~~~~~~~~~~~~~~~~~\n      |                       _mm256_reduce_add_ph\n[REDACTED]/tmp7mexl5gf.cpp:59:27: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   59 |     int64_t total_count = _mm256_reduce_add_epi32(final_count);\n      |                           ^~~~~~~~~~~~~~~~~~~~~~~\n      |                           _mm512_reduce_add_epi32\n[REDACTED]/tmp7mexl5gf.cpp:65:23: error: aggregate \u2018std::stringstream ss\u2019 has incomplete type and cannot be defined\n   65 |     std::stringstream ss;\n      |                       ^~\n[REDACTED]/tmp7mexl5gf.cpp:66:16: error: \u2018bitset\u2019 is not a member of \u2018std\u2019\n   66 |     ss << std::bitset<64>(rounded_average).to_string().substr(64 - 16);\n      |                ^~~~~~\n[REDACTED]/tmp7mexl5gf.cpp:18:1: note: \u2018std::bitset\u2019 is defined in header \u2018<bitset>\u2019; did you forget to \u2018#include <bitset>\u2019?\n   17 | #include <x86intrin.h>\n  +++ |+#include <bitset>\n   18 | \n[REDACTED]/tmp7mexl5gf.cpp:66:44: error: request for member \u2018to_string\u2019 in \u2018rounded_average\u2019, which is of non-class type \u2018int64_t\u2019 {aka \u2018long int\u2019}\n   66 |     ss << std::bitset<64>(rounded_average).to_string().substr(64 - 16);\n      |                                            ^~~~~~~~~\n"}
{"task_id": "SimdBench_112_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpipitgfkd.cpp: In function \u2018std::vector<int> func_simd(int)\u2019:\n[REDACTED]/tmpipitgfkd.cpp:47:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   47 |     __m256i mask = _mm_set_epi32(0, 1, 0, 1); // Mask to select even indices\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpipitgfkd.cpp:50:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   50 |         __m256i vec = _mm_loadu_si256((__m256i*)&result[i]); // Load 4 elements into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpipitgfkd.cpp:51:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   51 |         __m256i even_mask = _mm_and_si256(vec, mask); // Select even indices\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\n[REDACTED]/tmpipitgfkd.cpp:52:28: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   52 |         __m256i odd_mask = _mm_andnot_si256(even_mask); // Select odd indices\n      |                            ^~~~~~~~~~~~~~~~\n      |                            _mm_andnot_si64\n[REDACTED]/tmpipitgfkd.cpp:54:47: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   54 |         __m256i even_factorial = _mm_set_epi32(1, 1, 2, 6); // Precomputed factorials for even indices\n      |                                  ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                               |\n      |                                               __m128i\n[REDACTED]/tmpipitgfkd.cpp:55:40: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   55 |         __m256i odd_sum = _mm_set_epi32(1, 1, 3, 6); // Precomputed sums for odd indices\n      |                           ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                        |\n      |                                        __m128i\n[REDACTED]/tmpipitgfkd.cpp:57:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   57 |         __m256i even_result = _mm_mul_epi32(even_factorial, even_mask); // Multiply by precomputed factorials\n      |                                             ^~~~~~~~~~~~~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpipitgfkd.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:334:24: note:   initializing argument 1 of \u2018__m128i _mm_mul_epi32(__m128i, __m128i)\u2019\n  334 | _mm_mul_epi32 (__m128i __X, __m128i __Y)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpipitgfkd.cpp:58:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   58 |         __m256i odd_result = _mm_add_epi32(odd_sum, odd_mask); // Add precomputed sums\n      |                                            ^~~~~~~\n      |                                            |\n      |                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpipitgfkd.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmpipitgfkd.cpp:60:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   60 |         _mm_storeu_si256((__m256i*)&result[i], even_result); // Store results back into the vector\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_112_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp43b99gbb.cpp: In function \u2018std::vector<int> func_simd(int)\u2019:\n[REDACTED]/tmp43b99gbb.cpp:47:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   47 |     __m256i mask = _mm_set_epi32(0, 0, 0, 1); // Mask to select even indices\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp43b99gbb.cpp:50:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   50 |         if (_mm_testz_si128(mask, _mm_loadu_si128((__m128i*)&result[i]))) {\n      |                             ^~~~\n      |                             |\n      |                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmp43b99gbb.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:67:26: note:   initializing argument 1 of \u2018int _mm_testz_si128(__m128i, __m128i)\u2019\n   67 | _mm_testz_si128 (__m128i __M, __m128i __V)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmp43b99gbb.cpp:52:47: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   52 |             __m256i factorials = _mm_set_epi32(1, 1, 2, 6); // Precomputed factorials for even indices\n      |                                  ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                               |\n      |                                               __m128i\n[REDACTED]/tmp43b99gbb.cpp:53:56: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   53 |             __m256i current_factorial = _mm_loadu_si128((__m128i*)&factorials[i / 4]);\n      |                                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                                        |\n      |                                                        __m128i\n[REDACTED]/tmp43b99gbb.cpp:54:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   54 |             __m256i next_factorial = _mm_add_epi32(current_factorial, _mm_loadu_si128((__m128i*)&factorials[(i + 1) / 4]));\n      |                                                    ^~~~~~~~~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp43b99gbb.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp43b99gbb.cpp:55:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   55 |             __m256i result_value = _mm_mullo_epi32(next_factorial, _mm_loadu_si128((__m128i*)&result[i]));\n      |                                                    ^~~~~~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:326:26: note:   initializing argument 1 of \u2018__m128i _mm_mullo_epi32(__m128i, __m128i)\u2019\n  326 | _mm_mullo_epi32 (__m128i __X, __m128i __Y)\n      |                  ~~~~~~~~^~~\n[REDACTED]/tmp43b99gbb.cpp:56:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   56 |             _mm_storeu_si128((__m128i*)&result[i], result_value);\n      |                                                    ^~~~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n[REDACTED]/tmp43b99gbb.cpp:59:41: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   59 |             __m256i sums = _mm_set_epi32(1, 3, 6, 10); // Precomputed sums for odd indices\n      |                            ~~~~~~~~~~~~~^~~~~~~~~~~~~\n      |                                         |\n      |                                         __m128i\n[REDACTED]/tmp43b99gbb.cpp:60:50: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   60 |             __m256i current_sum = _mm_loadu_si128((__m128i*)&sums[i / 4]);\n      |                                   ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                                  |\n      |                                                  __m128i\n[REDACTED]/tmp43b99gbb.cpp:61:46: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   61 |             __m256i next_sum = _mm_add_epi32(current_sum, _mm_loadu_si128((__m128i*)&sums[(i + 1) / 4]));\n      |                                              ^~~~~~~~~~~\n      |                                              |\n      |                                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp43b99gbb.cpp:62:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   62 |             __m256i result_value = _mm_add_epi32(next_sum, _mm_loadu_si128((__m128i*)&result[i]));\n      |                                                  ^~~~~~~~\n      |                                                  |\n      |                                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmp43b99gbb.cpp:63:52: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   63 |             _mm_storeu_si128((__m128i*)&result[i], result_value);\n      |                                                    ^~~~~~~~~~~~\n      |                                                    |\n      |                                                    __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_112_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptmf48iux.cpp: In function \u2018std::vector<int> func_simd(int)\u2019:\n[REDACTED]/tmptmf48iux.cpp:61:43: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   61 |             __m256i num = _mm256_set_epi32(idx, idx + 1, idx + 2, idx + 3);\n      |                           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmptmf48iux.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmptmf48iux.cpp:62:44: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   62 |             __m256i fact = _mm256_set_epi32(1, 1, 1, 1);\n      |                            ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmptmf48iux.cpp:71:43: error: \u2018sum\u2019 was not declared in this scope; did you mean \u2018num\u2019?\n   71 |             _mm256_storeu_si256(sums + i, sum);\n      |                                           ^~~\n      |                                           num\n"}
{"task_id": "SimdBench_112_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_112_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp13l0rfts.cpp: In function \u2018std::vector<int> func_simd(int)\u2019:\n[REDACTED]/tmp13l0rfts.cpp:62:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m256i_u*\u2019\n   62 |             _mm256_storeu_si256(factorials[i / 2], current_factorial);\n      |                                 ~~~~~~~~~~~~~~~~^\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp13l0rfts.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:33: note:   initializing argument 1 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                      ~~~~~~~~~~~^~~\n[REDACTED]/tmp13l0rfts.cpp:69:43: error: cannot convert \u2018__m256i\u2019 to \u2018__m256i_u*\u2019\n   69 |             _mm256_storeu_si256(sums[i / 2], current_sum);\n      |                                 ~~~~~~~~~~^\n      |                                           |\n      |                                           __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:933:33: note:   initializing argument 1 of \u2018void _mm256_storeu_si256(__m256i_u*, __m256i)\u2019\n  933 | _mm256_storeu_si256 (__m256i_u *__P, __m256i __A)\n      |                      ~~~~~~~~~~~^~~\n"}
{"task_id": "SimdBench_113_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppli0ep9g.cpp: In function \u2018std::vector<int> even_odd_palindrome_simd(int)\u2019:\n[REDACTED]/tmppli0ep9g.cpp:36:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmppli0ep9g.cpp:37:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i result = _mm_set_epi32(0, 0, 0, 0);\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n[REDACTED]/tmppli0ep9g.cpp:41:23: error: \u2018_mm_cvtsi32_si256\u2019 was not declared in this scope; did you mean \u2018_mm_cvtsi32_si64\u2019?\n   41 |         __m256i num = _mm_cvtsi32_si256(i);\n      |                       ^~~~~~~~~~~~~~~~~\n      |                       _mm_cvtsi32_si64\n[REDACTED]/tmppli0ep9g.cpp:42:49: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   42 |         __m256i reversed_num = _mm_shuffle_epi8(num, num);\n      |                                                 ^~~\n      |                                                 |\n      |                                                 __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:37,\n                 from [REDACTED]/tmppli0ep9g.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/tmmintrin.h:136:27: note:   initializing argument 1 of \u2018__m128i _mm_shuffle_epi8(__m128i, __m128i)\u2019\n  136 | _mm_shuffle_epi8 (__m128i __X, __m128i __Y)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmppli0ep9g.cpp:43:38: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |         __m256i diff = _mm_sub_epi32(reversed_num, num);\n      |                                      ^~~~~~~~~~~~\n      |                                      |\n      |                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmppli0ep9g.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1118:24: note:   initializing argument 1 of \u2018__m128i _mm_sub_epi32(__m128i, __m128i)\u2019\n 1118 | _mm_sub_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmppli0ep9g.cpp:45:51: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   45 |         __m256i even_mask = _mm_cmpeq_epi32(diff, _mm_setzero_si256());\n      |                                                   ^~~~~~~~~~~~~~~~~\n      |                                                   _mm_setzero_si64\n[REDACTED]/tmppli0ep9g.cpp:48:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   48 |         result = _mm_add_epi32(result, even_mask);\n      |                                ^~~~~~\n      |                                |\n      |                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\n[REDACTED]/tmppli0ep9g.cpp:49:32: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   49 |         result = _mm_add_epi32(result, odd_mask);\n      |                                ^~~~~~\n      |                                |\n      |                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1070:24: note:   initializing argument 1 of \u2018__m128i _mm_add_epi32(__m128i, __m128i)\u2019\n 1070 | _mm_add_epi32 (__m128i __A, __m128i __B)\n      |                ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmppli0ep9g.cpp:54:22: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   54 |     int even_count = _mm_extract_epi32(result, 0);\n      |                      ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmppli0ep9g.cpp:55:21: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   55 |     int odd_count = _mm_extract_epi32(result, 1);\n      |                     ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_113_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9r3tcjia.cpp: In function \u2018std::vector<int> even_odd_palindrome_simd(int)\u2019:\n[REDACTED]/tmp9r3tcjia.cpp:36:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i mask = _mm_set_epi32(1, 1, 1, 1); // Initialize mask with all ones\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmp9r3tcjia.cpp:41:59: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |             result[0] += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n      |                                                           ^~~~\n      |                                                           |\n      |                                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp9r3tcjia.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmp9r3tcjia.cpp:43:59: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   43 |             result[1] += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n      |                                                           ^~~~\n      |                                                           |\n      |                                                           __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_113_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvehyv6kc.cpp: In function \u2018std::vector<int> even_odd_palindrome_simd(int)\u2019:\n[REDACTED]/tmpvehyv6kc.cpp:36:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i mask = _mm_set_epi32(0, 1, 0, 1); // Mask to check if a number is even or odd\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpvehyv6kc.cpp:39:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   39 |         __m256i num = _mm_set_epi32(i, i, i, i); // Convert number to 4-byte integers\n      |                       ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmpvehyv6kc.cpp:40:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   40 |         __m256i even_mask = _mm_and_si256(num, mask); // Check if number is even\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\n[REDACTED]/tmpvehyv6kc.cpp:41:28: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   41 |         __m256i odd_mask = _mm_andnot_si256(even_mask, mask); // Check if number is odd\n      |                            ^~~~~~~~~~~~~~~~\n      |                            _mm_andnot_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpvehyv6kc.cpp:16:\n[REDACTED]/tmpvehyv6kc.cpp:43:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |         int even_count = _mm_popcnt_u32(_mm_extract_epi32(even_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(even_mask, 1));\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpvehyv6kc.cpp:43:91: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |         int even_count = _mm_popcnt_u32(_mm_extract_epi32(even_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(even_mask, 1));\n      |                                                                                           ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpvehyv6kc.cpp:44:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   44 |         int odd_count = _mm_popcnt_u32(_mm_extract_epi32(odd_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(odd_mask, 1));\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpvehyv6kc.cpp:44:89: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   44 |         int odd_count = _mm_popcnt_u32(_mm_extract_epi32(odd_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(odd_mask, 1));\n      |                                                                                         ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_113_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpfaud8t5q.cpp: In function \u2018std::vector<int> even_odd_palindrome_simd(int)\u2019:\n[REDACTED]/tmpfaud8t5q.cpp:36:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i mask = _mm_set_epi32(1, 0, 1, 0); // Mask to check if a number is even or odd\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpfaud8t5q.cpp:38:35: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   38 |     for (__m256i i = _mm_set_epi32(1, 2, 3, 4); i <= _mm_set_epi32(n / 2, n / 2 + 1, n / 2 + 2, n / 2 + 3); i += 4) {\n      |                      ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                   |\n      |                                   __m128i\n[REDACTED]/tmpfaud8t5q.cpp:38:51: error: comparing vectors with different number of elements\n   38 |     for (__m256i i = _mm_set_epi32(1, 2, 3, 4); i <= _mm_set_epi32(n / 2, n / 2 + 1, n / 2 + 2, n / 2 + 3); i += 4) {\n      |                                                 ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpfaud8t5q.cpp:38:51: note: operand types are \u2018__m256i\u2019 and \u2018__m128i\u2019\n[REDACTED]/tmpfaud8t5q.cpp:39:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   39 |         __m256i even_mask = _mm_and_si256(i, mask); // Check if the number is even\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\n[REDACTED]/tmpfaud8t5q.cpp:40:28: error: \u2018_mm_andnot_si256\u2019 was not declared in this scope; did you mean \u2018_mm_andnot_si64\u2019?\n   40 |         __m256i odd_mask = _mm_andnot_si256(even_mask, mask); // Check if the number is odd\n      |                            ^~~~~~~~~~~~~~~~\n      |                            _mm_andnot_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpfaud8t5q.cpp:16:\n[REDACTED]/tmpfaud8t5q.cpp:42:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |         int even_count = _mm_popcnt_u32(_mm_extract_epi32(even_mask, 0)) +\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpfaud8t5q.cpp:43:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |                          _mm_popcnt_u32(_mm_extract_epi32(even_mask, 1));\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpfaud8t5q.cpp:44:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   44 |         int odd_count = _mm_popcnt_u32(_mm_extract_epi32(odd_mask, 0)) +\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpfaud8t5q.cpp:45:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   45 |                         _mm_popcnt_u32(_mm_extract_epi32(odd_mask, 1));\n      |                                        ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_113_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpairtr22q.cpp: In function \u2018std::vector<int> even_odd_palindrome_simd(int)\u2019:\n[REDACTED]/tmpairtr22q.cpp:36:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   36 |     __m256i mask = _mm_set_epi32(0, 1, 0, 1); // Mask to check if a number is even or odd\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpairtr22q.cpp:39:36: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   39 |         __m256i num = _mm_set_epi32(i, i, i, i); // Convert number to 4-byte integers\n      |                       ~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                    |\n      |                                    __m128i\n[REDACTED]/tmpairtr22q.cpp:40:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   40 |         __m256i even_mask = _mm_and_si256(num, mask); // Check if number is even\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpairtr22q.cpp:16:\n[REDACTED]/tmpairtr22q.cpp:41:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |         int even_count = _mm_popcnt_u32(_mm_extract_epi32(even_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(even_mask, 1));\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpairtr22q.cpp:41:91: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   41 |         int even_count = _mm_popcnt_u32(_mm_extract_epi32(even_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(even_mask, 1));\n      |                                                                                           ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpairtr22q.cpp:42:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |         int odd_count = _mm_popcnt_u32(_mm_extract_epi32(~even_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(~even_mask, 1));\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpairtr22q.cpp:42:91: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   42 |         int odd_count = _mm_popcnt_u32(_mm_extract_epi32(~even_mask, 0)) + _mm_popcnt_u32(_mm_extract_epi32(~even_mask, 1));\n      |                                                                                           ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_114_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpc3218gck.cpp: In function \u2018int count_nums_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpc3218gck.cpp:54:19: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   54 |         result += _mm256_popcnt_u32(_mm256_extract_epi32(sum_masked, 0)) +\n      |                   ^~~~~~~~~~~~~~~~~\n      |                   _mm_popcnt_u32\n"}
{"task_id": "SimdBench_114_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_114_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_114_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpmi3yt2ky.cpp: In function \u2018int count_nums_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpmi3yt2ky.cpp:57:42: error: too few arguments to function \u2018__m256i _mm256_hadd_epi32(__m256i, __m256i)\u2019\n   57 |     __m256i final_sum = _mm256_hadd_epi32(_mm256_hadd_epi32(sum, sum));\n      |                         ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpmi3yt2ky.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:295:1: note: declared here\n  295 | _mm256_hadd_epi32 (__m256i __X, __m256i __Y)\n      | ^~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43:\n[REDACTED]/tmpmi3yt2ky.cpp:59:17: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in assignment\n   59 |     final_sum = _mm256_extract_epi32(final_sum, 0);\n      |                 ^~~~~~~~~~~~~~~~~~~~\n      |                 |\n      |                 int\n[REDACTED]/tmpmi3yt2ky.cpp:61:12: error: invalid \u2018static_cast\u2019 from type \u2018__m256i\u2019 to type \u2018int\u2019\n   61 |     return static_cast<int>(final_sum);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_114_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpj5xp8_p7.cpp: In function \u2018int count_nums_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpj5xp8_p7.cpp:51:69: error: \u2018_mm256_sad_epu32\u2019 was not declared in this scope; did you mean \u2018_mm256_sad_epu8\u2019?\n   51 |         __m256i sum_digits = _mm256_add_epi32(sum, _mm256_sub_epi32(_mm256_sad_epu32(sign_bit, _mm256_setzero_si256()), _mm256_setzero_si256()));\n      |                                                                     ^~~~~~~~~~~~~~~~\n      |                                                                     _mm256_sad_epu8\n"}
{"task_id": "SimdBench_115_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpafqd1pww.cpp: In function \u2018bool move_one_ball_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpafqd1pww.cpp:40:18: error: \u2018_mm256_sort_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_xor_epi32\u2019?\n   40 |     sorted_vec = _mm256_sort_epi32(sorted_vec, vec);\n      |                  ^~~~~~~~~~~~~~~~~\n      |                  _mm256_xor_epi32\n[REDACTED]/tmpafqd1pww.cpp:44:86: error: expected \u2018)\u2019 before \u2018{\u2019 token\n   44 |         if (_mm256_cmpgt_epi32(sorted_vec, _mm256_loadu_si256((__m256i*)&arr[i + 1])) {\n      |            ~                                                                         ^~\n      |                                                                                      )\n[REDACTED]/tmpafqd1pww.cpp:44:31: error: could not convert \u2018_mm256_cmpgt_epi32(sorted_vec, _mm256_loadu_si256(((const __m256i_u*)((__m256i*)(& arr.std::vector<int>::operator[](((std::vector<int>::size_type)(i + 1))))))))\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   44 |         if (_mm256_cmpgt_epi32(sorted_vec, _mm256_loadu_si256((__m256i*)&arr[i + 1])) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n[REDACTED]/tmpafqd1pww.cpp:47:5: error: expected primary-expression before \u2018}\u2019 token\n   47 |     }\n      |     ^\n"}
{"task_id": "SimdBench_115_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpie_m_930.cpp: In function \u2018bool move_one_ball_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpie_m_930.cpp:41:30: error: could not convert \u2018_mm256_cmpgt_epi32(vec, next_vec)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   41 |         if(_mm256_cmpgt_epi32(vec, next_vec))\n      |            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256i\n"}
{"task_id": "SimdBench_115_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_115_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_115_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpkbxsrlx2.cpp:16:\n[REDACTED]/tmpkbxsrlx2.cpp: In function \u2018bool move_one_ball_simd(std::vector<int>)\u2019:\n[REDACTED]/tmpkbxsrlx2.cpp:51:22: error: the last argument must be a 1-bit immediate\n   51 |         if(arr[i] != _mm256_extract_epi32(sorted_vec, i)){\n      |                      ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpkbxsrlx2.cpp:51:22: error: selector must be an integer constant in the range [0, 3]\n   51 |         if(arr[i] != _mm256_extract_epi32(sorted_vec, i)){\n      |                      ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_116_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdhd_ozsm.cpp: In function \u2018std::string myexchange_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmpdhd_ozsm.cpp:46:24: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   46 |         __m256i temp = _mm256_blendv_epi32(vec1[i], vec2[i], even_mask);\n      |                        ^~~~~~~~~~~~~~~~~~~\n      |                        _mm256_blend_epi32\n[REDACTED]/tmpdhd_ozsm.cpp:60:25: error: assignment of read-only location \u2018(& lst1)->std::vector<int>::operator[](((std::vector<int>::size_type)i))\u2019\n   60 |                 lst1[i] = lst2[j];\n"}
{"task_id": "SimdBench_116_AVX", "passed": false, "result": "runtime failed: "}
{"task_id": "SimdBench_116_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpwel0i9fv.cpp: In function \u2018std::string myexchange_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmpwel0i9fv.cpp:41:48: error: \u2018_mm256_movemask_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_movemask_epi8\u2019?\n   41 |         __m256i even_count = _mm256_popcnt_u32(_mm256_movemask_epi32(even_mask));\n      |                                                ^~~~~~~~~~~~~~~~~~~~~\n      |                                                _mm256_movemask_epi8\n[REDACTED]/tmpwel0i9fv.cpp:41:30: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   41 |         __m256i even_count = _mm256_popcnt_u32(_mm256_movemask_epi32(even_mask));\n      |                              ^~~~~~~~~~~~~~~~~\n      |                              _mm_popcnt_u32\n[REDACTED]/tmpwel0i9fv.cpp:44:24: error: could not convert \u2018((even_count > odd_count) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   44 |         if (even_count > odd_count) {\n      |             ~~~~~~~~~~~^~~~~~~~~~~\n      |                        |\n      |                        __vector(4) long int\n"}
{"task_id": "SimdBench_116_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_116_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_117_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphfldk8on.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > odd_count_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmphfldk8on.cpp:68:57: error: \u2018_mm256_cmplt_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi8\u2019?\n   68 |         count = _mm256_or_si256(count, _mm256_and_si256(_mm256_cmplt_epi8(_mm256_cmpgt_epi8(int_array[i], _mm256_set1_epi8('0')), _mm256_set1_epi8('9'))));\n      |                                                         ^~~~~~~~~~~~~~~~~\n      |                                                         _mm256_cmpgt_epi8\n"}
{"task_id": "SimdBench_117_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmppvulc2d6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > odd_count_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmppvulc2d6.cpp:58:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   58 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmppvulc2d6.cpp:59:21: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   59 |     __m256i count = _mm_setzero_si256();\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm_setzero_si64\n[REDACTED]/tmppvulc2d6.cpp:62:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   62 |         __m256i vec = _mm_loadu_si256((__m256i*)&lst[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmppvulc2d6.cpp:64:71: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   64 |         count = _mm_add_epi32(count, _mm_popcnt_u32(_mm_movemask_epi8(odd_mask)));\n      |                                                                       ^~~~~~~~\n      |                                                                       |\n      |                                                                       __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmppvulc2d6.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_117_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpoefu3x8h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > odd_count_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpoefu3x8h.cpp:59:20: error: \u2018_mm_setzero_si256\u2019 was not declared in this scope; did you mean \u2018_mm_setzero_si64\u2019?\n   59 |     __m256i mask = _mm_setzero_si256(); // Initialize mask with zeros\n      |                    ^~~~~~~~~~~~~~~~~\n      |                    _mm_setzero_si64\n[REDACTED]/tmpoefu3x8h.cpp:62:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   62 |         __m256i vec = _mm_loadu_si256((__m256i*)&lst[i]); // Load 8 strings into a vector\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpoefu3x8h.cpp:16:\n[REDACTED]/tmpoefu3x8h.cpp:65:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   65 |         __m256i count = _mm_popcnt_u32(_mm_extract_epi32(vec, 0)) +\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpoefu3x8h.cpp:66:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   66 |                          _mm_popcnt_u32(_mm_extract_epi32(vec, 1)) +\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpoefu3x8h.cpp:67:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   67 |                          _mm_popcnt_u32(_mm_extract_epi32(vec, 2)) +\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpoefu3x8h.cpp:68:41: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   68 |                          _mm_popcnt_u32(_mm_extract_epi32(vec, 3));\n      |                                         ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpoefu3x8h.cpp:71:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   71 |         _mm_storeu_si256((__m256i*)&result[i], count);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_117_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptp9m9_4c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > odd_count_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmptp9m9_4c.cpp:59:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   59 |     __m256i mask = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); // Mask for odd numbers\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmptp9m9_4c.cpp:62:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   62 |         __m256i vec = _mm_loadu_si256((__m256i*)&lst[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmptp9m9_4c.cpp:65:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   65 |         __m256i odd_bytes = _mm_and_si256(vec, mask);\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmptp9m9_4c.cpp:16:\n[REDACTED]/tmptp9m9_4c.cpp:68:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   68 |         __m256i count = _mm_popcnt_u32(_mm_extract_epi32(odd_bytes, 0)) +\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmptp9m9_4c.cpp:69:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   69 |                         _mm_popcnt_u32(_mm_extract_epi32(odd_bytes, 1)) +\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmptp9m9_4c.cpp:70:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   70 |                         _mm_popcnt_u32(_mm_extract_epi32(odd_bytes, 2)) +\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmptp9m9_4c.cpp:71:40: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   71 |                         _mm_popcnt_u32(_mm_extract_epi32(odd_bytes, 3));\n      |                                        ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmptp9m9_4c.cpp:74:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   74 |         _mm_storeu_si256((__m256i*)&result[i], count);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
{"task_id": "SimdBench_117_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpei_v_50a.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char> > odd_count_simd(const std::vector<std::__cxx11::basic_string<char> >&)\u2019:\n[REDACTED]/tmpei_v_50a.cpp:58:33: error: too many arguments to function \u2018__m128i _mm_set_epi32(int, int, int, int)\u2019\n   58 |     __m256i mask = _mm_set_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpei_v_50a.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:605:1: note: declared here\n  605 | _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n      | ^~~~~~~~~~~~~\n[REDACTED]/tmpei_v_50a.cpp:58:33: error: cannot convert \u2018__m128i\u2019 to \u2018__m256i\u2019 in initialization\n   58 |     __m256i mask = _mm_set_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n      |                    ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                 |\n      |                                 __m128i\n[REDACTED]/tmpei_v_50a.cpp:61:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   61 |         __m256i vec = _mm_loadu_si256((__m256i*)&lst[i]);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpei_v_50a.cpp:62:43: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   62 |         __m256i odd_mask = _mm_cmpgt_epi8(vec, mask);\n      |                                           ^~~\n      |                                           |\n      |                                           __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1375:25: note:   initializing argument 1 of \u2018__m128i _mm_cmpgt_epi8(__m128i, __m128i)\u2019\n 1375 | _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n      |                 ~~~~~~~~^~~\n[REDACTED]/tmpei_v_50a.cpp:63:58: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   63 |         __m256i count = _mm_popcnt_u32(_mm_movemask_epi8(odd_mask));\n      |                                                          ^~~~~~~~\n      |                                                          |\n      |                                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpei_v_50a.cpp:64:32: error: invalid \u2018static_cast\u2019 from type \u2018__m256i\u2019 to type \u2018int\u2019\n   64 |         counts[i / vec_size] = static_cast<int>(count);\n      |                                ^~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpei_v_50a.cpp:69:27: error: aggregate \u2018std::stringstream ss\u2019 has incomplete type and cannot be defined\n   69 |         std::stringstream ss;\n      |                           ^~\n"}
{"task_id": "SimdBench_118_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw4pz2euq.cpp: In function \u2018int64_t minSubArraySum_simd(const std::vector<long int>&)\u2019:\n[REDACTED]/tmpw4pz2euq.cpp:40:19: error: \u2018_mm256_blendv_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_blendv_epi8\u2019?\n   40 |         min_sum = _mm256_blendv_epi64(min_sum_temp, min_sum, _mm256_cmpgt_epi64(sum, min_sum));\n      |                   ^~~~~~~~~~~~~~~~~~~\n      |                   _mm256_blendv_epi8\n"}
{"task_id": "SimdBench_118_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpldd0j76f.cpp: In function \u2018int64_t minSubArraySum_simd(const std::vector<long int>&)\u2019:\n[REDACTED]/tmpldd0j76f.cpp:51:48: error: request for member \u2018begin\u2019 in \u2018min_sum\u2019, which is of non-class type \u2018__m256i\u2019\n   51 |     int64_t result = *std::max_element(min_sum.begin(), min_sum.end());\n      |                                                ^~~~~\n[REDACTED]/tmpldd0j76f.cpp:51:65: error: request for member \u2018end\u2019 in \u2018min_sum\u2019, which is of non-class type \u2018__m256i\u2019\n   51 |     int64_t result = *std::max_element(min_sum.begin(), min_sum.end());\n      |                                                                 ^~~\n"}
{"task_id": "SimdBench_118_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpy1v8iu1y.cpp: In function \u2018int64_t minSubArraySum_simd(const std::vector<long int>&)\u2019:\n[REDACTED]/tmpy1v8iu1y.cpp:42:31: error: could not convert \u2018_mm256_cmpgt_epi64(sum, _mm256_set1_epi64x(9223372036854775807))\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   42 |         if (_mm256_cmpgt_epi64(sum, _mm256_set1_epi64x(INT64_MAX))) {\n      |             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               __m256i\n[REDACTED]/tmpy1v8iu1y.cpp:48:23: error: \u2018_mm256_reduce_min_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_min_epi64\u2019?\n   48 |     int64_t min_val = _mm256_reduce_min_epi64(min_sum);\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~\n      |                       _mm512_reduce_min_epi64\n"}
{"task_id": "SimdBench_118_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpe7wvp4sw.cpp: In function \u2018int64_t minSubArraySum_simd(const std::vector<long int>&)\u2019:\n[REDACTED]/tmpe7wvp4sw.cpp:51:22: error: \u2018_mm256_reduce_min_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_min_epi64\u2019?\n   51 |     int64_t result = _mm256_reduce_min_epi64(min_sum);\n      |                      ^~~~~~~~~~~~~~~~~~~~~~~\n      |                      _mm512_reduce_min_epi64\n"}
{"task_id": "SimdBench_118_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:61,\n                 from [REDACTED]/tmpqso5rq3n.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h: In function \u2018int64_t minSubArraySum_simd(const std::vector<long int>&)\u2019:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h:7926:1: error: inlining failed in call to \u2018always_inline\u2019 \u2018__m256i _mm256_min_epi64(__m256i, __m256i)\u2019: target specific option mismatch\n 7926 | _mm256_min_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqso5rq3n.cpp:43:35: note: called from here\n   43 |         min_sum = _mm256_min_epi64(min_sum, sum);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h:7926:1: error: inlining failed in call to \u2018always_inline\u2019 \u2018__m256i _mm256_min_epi64(__m256i, __m256i)\u2019: target specific option mismatch\n 7926 | _mm256_min_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqso5rq3n.cpp:43:35: note: called from here\n   43 |         min_sum = _mm256_min_epi64(min_sum, sum);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h:7926:1: error: inlining failed in call to \u2018always_inline\u2019 \u2018__m256i _mm256_min_epi64(__m256i, __m256i)\u2019: target specific option mismatch\n 7926 | _mm256_min_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqso5rq3n.cpp:49:35: note: called from here\n   49 |         min_sum = _mm256_min_epi64(min_sum, sum);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h:7926:1: error: inlining failed in call to \u2018always_inline\u2019 \u2018__m256i _mm256_min_epi64(__m256i, __m256i)\u2019: target specific option mismatch\n 7926 | _mm256_min_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqso5rq3n.cpp:49:35: note: called from here\n   49 |         min_sum = _mm256_min_epi64(min_sum, sum);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h:7926:1: error: inlining failed in call to \u2018always_inline\u2019 \u2018__m256i _mm256_min_epi64(__m256i, __m256i)\u2019: target specific option mismatch\n 7926 | _mm256_min_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43:\n[REDACTED]/tmpqso5rq3n.cpp:53:22: note: called from here\n   53 |     int64_t result = _mm256_extract_epi64(_mm256_min_epi64(min_sum, _mm256_set1_epi64x(0)), 0);\n      |                      ^~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx512vlintrin.h:7926:1: error: inlining failed in call to \u2018always_inline\u2019 \u2018__m256i _mm256_min_epi64(__m256i, __m256i)\u2019: target specific option mismatch\n 7926 | _mm256_min_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqso5rq3n.cpp:53:22: note: called from here\n   53 |     int64_t result = _mm256_extract_epi64(_mm256_min_epi64(min_sum, _mm256_set1_epi64x(0)), 0);\n      |                      ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_119_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpno6ia3bb.cpp: In function \u2018int max_fill_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmpno6ia3bb.cpp:57:28: error: could not convert \u2018((sum >> j) & (__m256i){1, 1, 1, 1})\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   57 |             if ((sum >> j) & 1) {\n      |                 ~~~~~~~~~~~^~~\n      |                            |\n      |                            __m256i\n"}
{"task_id": "SimdBench_119_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5sm13xe5.cpp: In function \u2018int max_fill_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmp5sm13xe5.cpp:52:21: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   52 |     int total_sum = _mm256_reduce_add_epi32(sum_mask, _mm256_set1_epi32(0)); // Sum up all elements in the sum mask\n      |                     ^~~~~~~~~~~~~~~~~~~~~~~\n      |                     _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_119_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_119_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp9bxgnc_x.cpp:16:\n[REDACTED]/tmp9bxgnc_x.cpp: In function \u2018int max_fill_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmp9bxgnc_x.cpp:56:33: error: \u2018_mm256_div_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_min_epi32\u2019?\n   56 |     return _mm256_extract_epi32(_mm256_div_epi32(min_sum, _mm256_set1_epi32(capacity)), 0);\n      |                                 ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_119_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpg79zhu13.cpp: In function \u2018int max_fill_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmpg79zhu13.cpp:52:22: error: \u2018_mm256_reduce_add_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   52 |         total_sum += _mm256_reduce_add_epi8(sum);\n      |                      ^~~~~~~~~~~~~~~~~~~~~~\n      |                      _mm256_reduce_add_ph\n[REDACTED]/tmpg79zhu13.cpp:53:59: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   53 |         sum = _mm256_permutevar_epi8(sum, _mm256_set_epi32(0, 1, 2, 3)); // Shuffle the sum\n      |                                           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpg79zhu13.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpg79zhu13.cpp:53:15: error: \u2018_mm256_permutevar_epi8\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi8\u2019?\n   53 |         sum = _mm256_permutevar_epi8(sum, _mm256_set_epi32(0, 1, 2, 3)); // Shuffle the sum\n      |               ^~~~~~~~~~~~~~~~~~~~~~\n      |               _mm256_permutexvar_epi8\n"}
{"task_id": "SimdBench_120_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp38pua72y.cpp: In function \u2018int64_t solution_simd(const std::vector<short int>&)\u2019:\n[REDACTED]/tmp38pua72y.cpp:28:36: error: too few arguments to function \u2018__m256i _mm256_set_epi16(short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int)\u2019\n   28 |     __m256i mask = _mm256_set_epi16(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp38pua72y.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1282:1: note: declared here\n 1282 | _mm256_set_epi16 (short __q15, short __q14, short __q13, short __q12,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp38pua72y.cpp:30:23: error: \u2018_mm256_reduce_add_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   30 |     __m256i odd_sum = _mm256_reduce_add_epi16(odd_mask);\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~\n      |                       _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_120_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpkojnbbv_.cpp: In function \u2018int64_t solution_simd(const std::vector<short int>&)\u2019:\n[REDACTED]/tmpkojnbbv_.cpp:30:23: error: \u2018_mm_loadu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_loadu_si16\u2019?\n   30 |         __m256i vec = _mm_loadu_si256((__m256i*)ptr);\n      |                       ^~~~~~~~~~~~~~~\n      |                       _mm_loadu_si16\n[REDACTED]/tmpkojnbbv_.cpp:31:59: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   31 |         __m256i mask = _mm_cmplt_epi16(_mm_set1_epi16(1), vec); // Check if element is odd\n      |                                                           ^~~\n      |                                                           |\n      |                                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpkojnbbv_.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1363:39: note:   initializing argument 2 of \u2018__m128i _mm_cmplt_epi16(__m128i, __m128i)\u2019\n 1363 | _mm_cmplt_epi16 (__m128i __A, __m128i __B)\n      |                               ~~~~~~~~^~~\n[REDACTED]/tmpkojnbbv_.cpp:32:84: error: cannot convert \u2018size_t\u2019 {aka \u2018long unsigned int\u2019} to \u2018__m128i\u2019\n   32 |         __m256i even_mask = _mm_and_si256(mask, _mm_cmpgt_epi16(_mm_set1_epi16(0), i)); // Check if position is even\n      |                                                                                    ^\n      |                                                                                    |\n      |                                                                                    size_t {aka long unsigned int}\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1381:39: note:   initializing argument 2 of \u2018__m128i _mm_cmpgt_epi16(__m128i, __m128i)\u2019\n 1381 | _mm_cmpgt_epi16 (__m128i __A, __m128i __B)\n      |                               ~~~~~~~~^~~\n[REDACTED]/tmpkojnbbv_.cpp:32:29: error: \u2018_mm_and_si256\u2019 was not declared in this scope; did you mean \u2018_mm_and_si64\u2019?\n   32 |         __m256i even_mask = _mm_and_si256(mask, _mm_cmpgt_epi16(_mm_set1_epi16(0), i)); // Check if position is even\n      |                             ^~~~~~~~~~~~~\n      |                             _mm_and_si64\n[REDACTED]/tmpkojnbbv_.cpp:34:66: error: \u2018_MM_REDUCE_ADD_EPI32_A\u2019 was not declared in this scope\n   34 |         sum = _mm_add_epi64(sum, _mm256_reduce_add_epi32(result, _MM_REDUCE_ADD_EPI32_A));\n      |                                                                  ^~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpkojnbbv_.cpp:34:34: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   34 |         sum = _mm_add_epi64(sum, _mm256_reduce_add_epi32(result, _MM_REDUCE_ADD_EPI32_A));\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~\n      |                                  _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_120_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjux86wfm.cpp: In function \u2018int64_t solution_simd(const std::vector<short int>&)\u2019:\n[REDACTED]/tmpjux86wfm.cpp:28:36: error: too few arguments to function \u2018__m256i _mm256_set_epi16(short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int)\u2019\n   28 |     __m256i mask = _mm256_set_epi16(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpjux86wfm.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1282:1: note: declared here\n 1282 | _mm256_set_epi16 (short __q15, short __q14, short __q13, short __q12,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpjux86wfm.cpp:30:19: error: \u2018_mm256_reduce_add_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   30 |     __m256i sum = _mm256_reduce_add_epi16(odd_elements);\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_120_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp037g6bme.cpp: In function \u2018int64_t solution_simd(const std::vector<short int>&)\u2019:\n[REDACTED]/tmp037g6bme.cpp:31:16: error: no match for \u2018operator<\u2019 (operand types are \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019} and \u2018std::vector<short int>::const_iterator\u2019)\n   31 |     while (ptr < lst.end()) {\n      |            ~~~ ^ ~~~~~~~~~\n      |            |            |\n      |            |            std::vector<short int>::const_iterator\n      |            const int16_t* {aka const short int*}\nIn file included from /usr/include/c++/13/string:48,\n                 from /usr/include/c++/13/bits/locale_classes.h:40,\n                 from /usr/include/c++/13/bits/ios_base.h:41,\n                 from /usr/include/c++/13/ios:44,\n                 from /usr/include/c++/13/ostream:40,\n                 from /usr/include/c++/13/iostream:41,\n                 from [REDACTED]/tmp037g6bme.cpp:1:\n/usr/include/c++/13/bits/stl_iterator.h:455:5: note: candidate: \u2018template<class _Iterator> constexpr bool std::operator<(const reverse_iterator<_Iterator>&, const reverse_iterator<_Iterator>&)\u2019\n  455 |     operator<(const reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:455:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/stl_iterator.h:500:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr bool std::operator<(const reverse_iterator<_Iterator>&, const reverse_iterator<_IteratorR>&)\u2019\n  500 |     operator<(const reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:500:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/stl_iterator.h:1705:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr bool std::operator<(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)\u2019\n 1705 |     operator<(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1705:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/stl_iterator.h:1770:5: note: candidate: \u2018template<class _Iterator> constexpr bool std::operator<(const move_iterator<_IteratorL>&, const move_iterator<_IteratorL>&)\u2019\n 1770 |     operator<(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1770:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/bits/stl_algobase.h:64,\n                 from /usr/include/c++/13/string:51:\n/usr/include/c++/13/bits/stl_pair.h:835:5: note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator<(const pair<_T1, _T2>&, const pair<_T1, _T2>&)\u2019\n  835 |     operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_pair.h:835:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/bits/basic_string.h:47,\n                 from /usr/include/c++/13/string:54:\n/usr/include/c++/13/string_view:671:5: note: candidate: \u2018template<class _CharT, class _Traits> constexpr bool std::operator<(basic_string_view<_CharT, _Traits>, basic_string_view<_CharT, _Traits>)\u2019\n  671 |     operator< (basic_string_view<_CharT, _Traits> __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/string_view:671:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018std::basic_string_view<_CharT, _Traits>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/string_view:678:5: note: candidate: \u2018template<class _CharT, class _Traits> constexpr bool std::operator<(basic_string_view<_CharT, _Traits>, __type_identity_t<basic_string_view<_CharT, _Traits> >)\u2019\n  678 |     operator< (basic_string_view<_CharT, _Traits> __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/string_view:678:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018std::basic_string_view<_CharT, _Traits>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/string_view:686:5: note: candidate: \u2018template<class _CharT, class _Traits> constexpr bool std::operator<(__type_identity_t<basic_string_view<_CharT, _Traits> >, basic_string_view<_CharT, _Traits>)\u2019\n  686 |     operator< (__type_identity_t<basic_string_view<_CharT, _Traits>> __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/string_view:686:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   \u2018__gnu_cxx::__normal_iterator<const short int*, std::vector<short int> >\u2019 is not derived from \u2018std::basic_string_view<_CharT, _Traits>\u2019\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/basic_string.h:3829:5: note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator<(const __cxx11::basic_string<_CharT, _Traits, _Allocator>&, const __cxx11::basic_string<_CharT, _Traits, _Allocator>&)\u2019\n 3829 |     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:3829:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Allocator>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/basic_string.h:3843:5: note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator<(const __cxx11::basic_string<_CharT, _Traits, _Allocator>&, const _CharT*)\u2019\n 3843 |     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:3843:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Allocator>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/basic_string.h:3856:5: note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator<(const _CharT*, const __cxx11::basic_string<_CharT, _Traits, _Allocator>&)\u2019\n 3856 |     operator<(const _CharT* __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/basic_string.h:3856:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   \u2018std::vector<short int>::const_iterator\u2019 is not derived from \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Allocator>\u2019\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/bits/memory_resource.h:47,\n                 from /usr/include/c++/13/string:58:\n/usr/include/c++/13/tuple:1961:5: note: candidate: \u2018template<class ... _TElements, class ... _UElements> constexpr bool std::operator<(const tuple<_UTypes ...>&, const tuple<_UTypes ...>&)\u2019\n 1961 |     operator<(const tuple<_TElements...>& __t,\n      |     ^~~~~~~~\n/usr/include/c++/13/tuple:1961:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::tuple<_UTypes ...>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/vector:66,\n                 from [REDACTED]/tmp037g6bme.cpp:2:\n/usr/include/c++/13/bits/stl_vector.h:2079:5: note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator<(const vector<_Tp, _Alloc>&, const vector<_Tp, _Alloc>&)\u2019\n 2079 |     operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:2079:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/map:63,\n                 from [REDACTED]/tmp037g6bme.cpp:3:\n/usr/include/c++/13/bits/stl_map.h:1551:5: note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator<(const map<_Key, _Tp, _Compare, _Allocator>&, const map<_Key, _Tp, _Compare, _Allocator>&)\u2019\n 1551 |     operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_map.h:1551:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Allocator>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/map:64:\n/usr/include/c++/13/bits/stl_multimap.h:1172:5: note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator<(const multimap<_Key, _Tp, _Compare, _Allocator>&, const multimap<_Key, _Tp, _Compare, _Allocator>&)\u2019\n 1172 |     operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_multimap.h:1172:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Allocator>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/stl_iterator.h:1250:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator<(const __normal_iterator<_IteratorL, _Container>&, const __normal_iterator<_IteratorR, _Container>&)\u2019\n 1250 |     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1250:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\n/usr/include/c++/13/bits/stl_iterator.h:1258:5: note: candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator<(const __normal_iterator<_Iterator, _Container>&, const __normal_iterator<_Iterator, _Container>&)\u2019\n 1258 |     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1258:5: note:   template argument deduction/substitution failed:\n[REDACTED]/tmp037g6bme.cpp:31:26: note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019 and \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019}\n   31 |     while (ptr < lst.end()) {\n      |                          ^\nIn file included from /usr/include/c++/13/bits/ios_base.h:46:\n/usr/include/c++/13/system_error:324:3: note: candidate: \u2018bool std::operator<(const error_code&, const error_code&)\u2019\n  324 |   operator<(const error_code& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/13/system_error:324:31: note:   no known conversion for argument 1 from \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019} to \u2018const std::error_code&\u2019\n  324 |   operator<(const error_code& __lhs, const error_code& __rhs) noexcept\n      |             ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/13/system_error:507:3: note: candidate: \u2018bool std::operator<(const error_condition&, const error_condition&)\u2019\n  507 |   operator<(const error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/13/system_error:507:36: note:   no known conversion for argument 1 from \u2018const int16_t*\u2019 {aka \u2018const short int*\u2019} to \u2018const std::error_condition&\u2019\n  507 |   operator<(const error_condition& __lhs,\n      |             ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n[REDACTED]/tmp037g6bme.cpp:40:27: error: \u2018_mm256_reduce_add_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   40 |         __m256i sum_odd = _mm256_reduce_add_epi16(odd_even);\n      |                           ^~~~~~~~~~~~~~~~~~~~~~~\n      |                           _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_120_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw8ea04fb.cpp: In function \u2018int64_t solution_simd(const std::vector<short int>&)\u2019:\n[REDACTED]/tmpw8ea04fb.cpp:28:36: error: too few arguments to function \u2018__m256i _mm256_set_epi16(short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int, short int)\u2019\n   28 |     __m256i mask = _mm256_set_epi16(0, 1, 0, 1, 0, 1, 0, 1);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpw8ea04fb.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1282:1: note: declared here\n 1282 | _mm256_set_epi16 (short __q15, short __q14, short __q13, short __q12,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpw8ea04fb.cpp:31:19: error: \u2018_mm256_reduce_add_epi16\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   31 |     __m256i sum = _mm256_reduce_add_epi16(odd_elements);\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_121_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpjfyn4k67.cpp: In function \u2018int add_elements_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpjfyn4k67.cpp:47:5: error: \u2018_mm256_storeu_si128\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si128\u2019?\n   47 |     _mm256_storeu_si128((__m128i*)&result, sum);\n      |     ^~~~~~~~~~~~~~~~~~~\n      |     _mm_storeu_si128\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpjfyn4k67.cpp:16:\n[REDACTED]/tmpjfyn4k67.cpp:48:41: error: cannot convert \u2018int\u2019 to \u2018__m128i\u2019\n   48 |     _mm_storeu_si128((__m128i*)&result, _mm256_extract_epi32(sum, 4));\n      |                                         ^~~~~~~~~~~~~~~~~~~~\n      |                                         |\n      |                                         int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpjfyn4k67.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_121_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpj5kwy322.cpp:16:\n[REDACTED]/tmpj5kwy322.cpp: In function \u2018int add_elements_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpj5kwy322.cpp:43:19: error: the last argument must be a 1-bit immediate\n   43 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpj5kwy322.cpp:43:19: error: selector must be an integer constant in the range [0, 3]\n   43 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_121_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_121_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpstjts3_g.cpp:16:\n[REDACTED]/tmpstjts3_g.cpp: In function \u2018int add_elements_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpstjts3_g.cpp:39:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   39 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 0));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpstjts3_g.cpp:40:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   40 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 1));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpstjts3_g.cpp:41:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   41 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 2));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpstjts3_g.cpp:42:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   42 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 3));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpstjts3_g.cpp:50:41: error: \u2018_MM_FMAE\u2019 was not declared in this scope\n   50 |     return _mm256_reduce_add_epi32(sum, _MM_FMAE);\n      |                                         ^~~~~~~~\n[REDACTED]/tmpstjts3_g.cpp:50:12: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   50 |     return _mm256_reduce_add_epi32(sum, _MM_FMAE);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n      |            _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_121_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpl6xwtiwa.cpp:16:\n[REDACTED]/tmpl6xwtiwa.cpp: In function \u2018int add_elements_simd(std::vector<int>, int)\u2019:\n[REDACTED]/tmpl6xwtiwa.cpp:38:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   38 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 0));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpl6xwtiwa.cpp:39:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   39 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 1));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpl6xwtiwa.cpp:40:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   40 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 2));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmpl6xwtiwa.cpp:41:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   41 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(vec, 3));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_122_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpl3qoliyi.cpp: In function \u2018bool is_sorted_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpl3qoliyi.cpp:37:20: error: could not convert \u2018((next_vec != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   37 |     while(next_vec != _mm256_setzero_si256()){\n      |           ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                    |\n      |                    __vector(4) long int\n[REDACTED]/tmpl3qoliyi.cpp:38:30: error: could not convert \u2018_mm256_cmpgt_epi32(vec, next_vec)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   38 |         if(_mm256_cmpgt_epi32(vec, next_vec)) return false;\n      |            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256i\n"}
{"task_id": "SimdBench_122_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpr6sz9gc6.cpp: In function \u2018bool is_sorted_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpr6sz9gc6.cpp:37:20: error: could not convert \u2018((next_vec != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   37 |     while(next_vec != _mm256_setzero_si256()){\n      |           ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                    |\n      |                    __vector(4) long int\n[REDACTED]/tmpr6sz9gc6.cpp:38:30: error: could not convert \u2018_mm256_cmpgt_epi32(vec, next_vec)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   38 |         if(_mm256_cmpgt_epi32(vec, next_vec)) return false;\n      |            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256i\n"}
{"task_id": "SimdBench_122_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_122_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpowepphnt.cpp: In function \u2018bool is_sorted_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpowepphnt.cpp:41:47: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   41 |         __m256 cmp_result = _mm256_cmpgt_epi32(current_vec, vec);\n      |                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                               |\n      |                                               __m256i\n[REDACTED]/tmpowepphnt.cpp:44:33: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   44 |         if(_mm256_movemask_epi8(cmp_result) != 0){\n      |                                 ^~~~~~~~~~\n      |                                 |\n      |                                 __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpowepphnt.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:433:31: note:   initializing argument 1 of \u2018int _mm256_movemask_epi8(__m256i)\u2019\n  433 | _mm256_movemask_epi8 (__m256i __A)\n      |                       ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_122_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprmwfv3o9.cpp: In function \u2018bool is_sorted_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmprmwfv3o9.cpp:37:20: error: could not convert \u2018((next_vec != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   37 |     while(next_vec != _mm256_setzero_si256()){\n      |           ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                    |\n      |                    __vector(4) long int\n[REDACTED]/tmprmwfv3o9.cpp:38:30: error: could not convert \u2018_mm256_cmpgt_epi32(vec, next_vec)\u2019 from \u2018__m256i\u2019 to \u2018bool\u2019\n   38 |         if(_mm256_cmpgt_epi32(vec, next_vec)) return false;\n      |            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                              |\n      |                              __m256i\n"}
{"task_id": "SimdBench_123_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqquzo3di.cpp:16:\n[REDACTED]/tmpqquzo3di.cpp: In function \u2018int prod_signs_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpqquzo3di.cpp:49:19: error: the last argument must be a 1-bit immediate\n   49 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpqquzo3di.cpp:49:19: error: selector must be an integer constant in the range [0, 3]\n   49 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_123_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpacbkcxzg.cpp:16:\n[REDACTED]/tmpacbkcxzg.cpp: In function \u2018int prod_signs_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpacbkcxzg.cpp:49:19: error: the last argument must be a 1-bit immediate\n   49 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpacbkcxzg.cpp:49:19: error: selector must be an integer constant in the range [0, 3]\n   49 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_123_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp97z1ubip.cpp:16:\n[REDACTED]/tmp97z1ubip.cpp: In function \u2018int prod_signs_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp97z1ubip.cpp:51:19: error: the last argument must be a 1-bit immediate\n   51 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmp97z1ubip.cpp:51:19: error: selector must be an integer constant in the range [0, 3]\n   51 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_123_AVX", "passed": false, "result": "compilation failed: In file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpvc9pk1fg.cpp:16:\n[REDACTED]/tmpvc9pk1fg.cpp: In function \u2018int prod_signs_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpvc9pk1fg.cpp:49:19: error: the last argument must be a 1-bit immediate\n   49 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpvc9pk1fg.cpp:49:19: error: selector must be an integer constant in the range [0, 3]\n   49 |         result += _mm256_extract_epi32(sum, i);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_123_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8ng__78d.cpp: In function \u2018int prod_signs_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp8ng__78d.cpp:42:105: error: \u2018_mm256_cmplt_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   42 |         sign = _mm256_mul_epi32(sign, _mm256_and_si256(_mm256_cmpgt_epi32(vec, _mm256_setzero_si256()), _mm256_cmplt_epi32(vec, _mm256_setzero_si256())));\n      |                                                                                                         ^~~~~~~~~~~~~~~~~~\n      |                                                                                                         _mm256_cmpgt_epi32\n"}
{"task_id": "SimdBench_124_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp3zaiqxb2.cpp: In function \u2018std::vector<int> minPath_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmp3zaiqxb2.cpp:78:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019 in initialization\n   78 |         __m256 v_result = _mm256_set1_epi32(result[i - 1]);\n      |                           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256i\n[REDACTED]/tmp3zaiqxb2.cpp:81:48: error: cannot convert \u2018const __m256*\u2019 to \u2018const __m256i_u*\u2019\n   81 |             __m256 v_grid = _mm256_loadu_si256(reinterpret_cast<const __m256*>(&grid[j]));\n      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                                |\n      |                                                const __m256*\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp3zaiqxb2.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmp3zaiqxb2.cpp:83:45: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   83 |             __m256 v_min = _mm256_min_epu32(v_result, v_grid);\n      |                                             ^~~~~~~~\n      |                                             |\n      |                                             __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:426:27: note:   initializing argument 1 of \u2018__m256i _mm256_min_epu32(__m256i, __m256i)\u2019\n  426 | _mm256_min_epu32 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmp3zaiqxb2.cpp:84:41: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   84 |             v_result = _mm256_max_epu32(v_result, v_min);\n      |                                         ^~~~~~~~\n      |                                         |\n      |                                         __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:384:27: note:   initializing argument 1 of \u2018__m256i _mm256_max_epu32(__m256i, __m256i)\u2019\n  384 | _mm256_max_epu32 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmp3zaiqxb2.cpp:87:60: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   87 |         result[i] = _mm256_extract_epi32(_mm256_srlv_epi32(v_result, _mm256_set1_epi32(8)), 0);\n      |                                                            ^~~~~~~~\n      |                                                            |\n      |                                                            __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:1223:28: note:   initializing argument 1 of \u2018__m256i _mm256_srlv_epi32(__m256i, __m256i)\u2019\n 1223 | _mm256_srlv_epi32 (__m256i __X, __m256i __Y)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_124_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp4ufpoqs_.cpp:61:1: error: stray \u2018`\u2019 in program\n   61 | ```cpp\n      | ^\n[REDACTED]/tmp4ufpoqs_.cpp:61:2: error: stray \u2018`\u2019 in program\n   61 | ```cpp\n      |  ^\n[REDACTED]/tmp4ufpoqs_.cpp:61:3: error: stray \u2018`\u2019 in program\n   61 | ```cpp\n      |   ^\n[REDACTED]/tmp4ufpoqs_.cpp:61:4: error: \u2018cpp\u2019 does not name a type\n   61 | ```cpp\n      |    ^~~\n"}
{"task_id": "SimdBench_124_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpzgc48bq7.cpp:61:1: error: stray \u2018`\u2019 in program\n   61 | ```c++\n      | ^\n[REDACTED]/tmpzgc48bq7.cpp:61:2: error: stray \u2018`\u2019 in program\n   61 | ```c++\n      |  ^\n[REDACTED]/tmpzgc48bq7.cpp:61:3: error: stray \u2018`\u2019 in program\n   61 | ```c++\n      |   ^\n[REDACTED]/tmpzgc48bq7.cpp:61:4: error: \u2018c\u2019 does not name a type\n   61 | ```c++\n      |    ^\n[REDACTED]/tmpzgc48bq7.cpp: In function \u2018std::vector<int> minPath_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmpzgc48bq7.cpp:155:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  155 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:158:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  158 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:161:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  161 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:164:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  164 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:167:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  167 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:170:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  170 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:173:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  173 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:176:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  176 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:179:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  179 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:182:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  182 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:185:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  185 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:188:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  188 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:191:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  191 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:194:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  194 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:197:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  197 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:200:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  200 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:203:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  203 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:206:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  206 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:209:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  209 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:212:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  212 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:215:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  215 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:218:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  218 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:221:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  221 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:224:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  224 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:227:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  227 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:230:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  230 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:233:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  233 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:236:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  236 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:239:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  239 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:242:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  242 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:245:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  245 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:248:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  248 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:251:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  251 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:254:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  254 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:257:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  257 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:260:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  260 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:263:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  263 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:266:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  266 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:269:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  269 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:272:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  272 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:275:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  275 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:278:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  278 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:281:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  281 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:284:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  284 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:287:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  287 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:290:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  290 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:293:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  293 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:296:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  296 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:299:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  299 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:302:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  302 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:305:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  305 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:308:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  308 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:311:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  311 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:314:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  314 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:317:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  317 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:320:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  320 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:323:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  323 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:326:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  326 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:329:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  329 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:332:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  332 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:335:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  335 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:338:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  338 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:341:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  341 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:344:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  344 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:347:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  347 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:350:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  350 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:353:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  353 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:356:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  356 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:359:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  359 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:362:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  362 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:365:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  365 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:368:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  368 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:371:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  371 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:374:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  374 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:377:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  377 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:380:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  380 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:383:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  383 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:386:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  386 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:389:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  389 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:392:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  392 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:395:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  395 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:398:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  398 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:401:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  401 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:404:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  404 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:407:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  407 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:410:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  410 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:413:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  413 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:416:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  416 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:419:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  419 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:422:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  422 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:425:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  425 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:428:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  428 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:431:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  431 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:434:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  434 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:437:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  437 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:440:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  440 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:443:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  443 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:446:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  446 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:449:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  449 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:452:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  452 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:455:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  455 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:458:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  458 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:461:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  461 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:464:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  464 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:467:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  467 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:470:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  470 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:473:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  473 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:476:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  476 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:479:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  479 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:482:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  482 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:485:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  485 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:488:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  488 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:491:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  491 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:494:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  494 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:497:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  497 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:500:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  500 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:503:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  503 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:506:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  506 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:509:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  509 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:512:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  512 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:515:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  515 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:518:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  518 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:521:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  521 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:524:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  524 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:527:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  527 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:530:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  530 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:533:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  533 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:536:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  536 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:539:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  539 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:542:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  542 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:545:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  545 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:548:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  548 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:551:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  551 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:554:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  554 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:557:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  557 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:560:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  560 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:563:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  563 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:566:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  566 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:569:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  569 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:572:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  572 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:575:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  575 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:578:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  578 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:581:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  581 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:584:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  584 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:587:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  587 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:590:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  590 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:593:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  593 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:596:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  596 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:599:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  599 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:602:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  602 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:605:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  605 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:608:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  608 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:611:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  611 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:614:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  614 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:617:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  617 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:620:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  620 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:623:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  623 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:626:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  626 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:629:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  629 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:632:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  632 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:635:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  635 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:638:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  638 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:641:13: error: redeclaration of \u2018__m256i min_path_subcombinations\u2019\n  641 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:146:13: note: \u2018__m256i min_path_subcombinations\u2019 previously declared here\n  146 |     __m256i min_path_subcombinations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:644:13: error: redeclaration of \u2018__m256i min_path_subpermutations\u2019\n  644 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:149:13: note: \u2018__m256i min_path_subpermutations\u2019 previously declared here\n  149 |     __m256i min_path_subpermutations = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:647:13: error: redeclaration of \u2018__m256i min_path_subbinomial_coefficients\u2019\n  647 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si25\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:152:13: note: \u2018__m256i min_path_subbinomial_coefficients\u2019 previously declared here\n  152 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmpzgc48bq7.cpp:647:49: error: \u2018_mm256_setzero_si25\u2019 was not declared in this scope; did you mean \u2018_mm256_setzero_si256\u2019?\n  647 |     __m256i min_path_subbinomial_coefficients = _mm256_setzero_si25\n      |                                                 ^~~~~~~~~~~~~~~~~~~\n      |                                                 _mm256_setzero_si256\n[REDACTED]/tmpzgc48bq7.cpp:693:9: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  693 | int main() {\n      |         ^~\n[REDACTED]/tmpzgc48bq7.cpp:693:9: note: remove parentheses to default-initialize a variable\n  693 | int main() {\n      |         ^~\n      |         --\n[REDACTED]/tmpzgc48bq7.cpp:693:9: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmpzgc48bq7.cpp:693:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n  693 | int main() {\n      |            ^\n[REDACTED]/tmpzgc48bq7.cpp:697:2: error: expected \u2018}\u2019 at end of input\n  697 | }\n      |  ^\n[REDACTED]/tmpzgc48bq7.cpp:66:81: note: to match this \u2018{\u2019\n   66 | std::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n      |                                                                                 ^\n[REDACTED]/tmpzgc48bq7.cpp:697:2: warning: no return statement in function returning non-void [-Wreturn-type]\n  697 | }\n      |  ^\n"}
{"task_id": "SimdBench_124_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7z16yewp.cpp:61:1: error: stray \u2018`\u2019 in program\n   61 | ```cpp\n      | ^\n[REDACTED]/tmp7z16yewp.cpp:61:2: error: stray \u2018`\u2019 in program\n   61 | ```cpp\n      |  ^\n[REDACTED]/tmp7z16yewp.cpp:61:3: error: stray \u2018`\u2019 in program\n   61 | ```cpp\n      |   ^\n[REDACTED]/tmp7z16yewp.cpp:61:4: error: \u2018cpp\u2019 does not name a type\n   61 | ```cpp\n      |    ^~~\n[REDACTED]/tmp7z16yewp.cpp: In function \u2018std::vector<int> minPath_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmp7z16yewp.cpp:140:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  140 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:143:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  143 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:146:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  146 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:149:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  149 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:152:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  152 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:155:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  155 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:158:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  158 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:161:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  161 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:164:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  164 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:167:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  167 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:170:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  170 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:173:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  173 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:176:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  176 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:179:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  179 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:182:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  182 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:185:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  185 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:188:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  188 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:191:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  191 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:194:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  194 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:197:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  197 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:200:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  200 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:203:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  203 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:206:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  206 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:209:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  209 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:212:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  212 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:215:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  215 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:218:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  218 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:221:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  221 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:224:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  224 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:227:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  227 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:230:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  230 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:233:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  233 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:236:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  236 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:239:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  239 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:242:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  242 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:245:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  245 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:248:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  248 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:251:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  251 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:254:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  254 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:257:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  257 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:260:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  260 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:263:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  263 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:266:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  266 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:269:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  269 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:272:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  272 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:275:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  275 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:278:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  278 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:281:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  281 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:284:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  284 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:287:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  287 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:290:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  290 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:293:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  293 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:296:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  296 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:299:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  299 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:302:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  302 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:305:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  305 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:308:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  308 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:311:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  311 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:314:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  314 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:317:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  317 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:320:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  320 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:323:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  323 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:326:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  326 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:329:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  329 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:332:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  332 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:335:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  335 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:338:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  338 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:341:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  341 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:344:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  344 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:347:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  347 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:350:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  350 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:353:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  353 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:356:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  356 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:359:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  359 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:362:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  362 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:365:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  365 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:368:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  368 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:371:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  371 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:374:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  374 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:377:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  377 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:380:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  380 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:383:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  383 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:386:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  386 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:389:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  389 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:392:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  392 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:395:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  395 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:398:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  398 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:401:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  401 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:404:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  404 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:407:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  407 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:410:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  410 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:413:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  413 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:416:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  416 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:419:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  419 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:422:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  422 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:425:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  425 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:428:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  428 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:431:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  431 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:434:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  434 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:437:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  437 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:440:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  440 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:443:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  443 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:446:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  446 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:449:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  449 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:452:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  452 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:455:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  455 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:458:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  458 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:461:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  461 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:464:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  464 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:467:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  467 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:470:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  470 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:473:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  473 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:476:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  476 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:479:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  479 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:482:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  482 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:485:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  485 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:488:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  488 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:491:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  491 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:494:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  494 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:497:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  497 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:500:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  500 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:503:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  503 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:506:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  506 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:509:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  509 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:512:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  512 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:515:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  515 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:518:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  518 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:521:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  521 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:524:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  524 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:527:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  527 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:530:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  530 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:533:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  533 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:536:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  536 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:539:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  539 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:542:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  542 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:545:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  545 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:548:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  548 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:551:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  551 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:554:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  554 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:557:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  557 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:560:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  560 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:563:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  563 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:566:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  566 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:569:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  569 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:572:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  572 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:575:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  575 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:578:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  578 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:581:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  581 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:584:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  584 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:587:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  587 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:590:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  590 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:593:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  593 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:596:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  596 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:599:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  599 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:602:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  602 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:605:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  605 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:608:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  608 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:611:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  611 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:614:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  614 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:617:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  617 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:620:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  620 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:623:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  623 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:626:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  626 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:629:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  629 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:632:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  632 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:635:13: error: redeclaration of \u2018__m256i min_path_hyperbolic_functions\u2019\n  635 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:131:13: note: \u2018__m256i min_path_hyperbolic_functions\u2019 previously declared here\n  131 |     __m256i min_path_hyperbolic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:638:13: error: redeclaration of \u2018__m256i min_path_exponential_functions\u2019\n  638 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:134:13: note: \u2018__m256i min_path_exponential_functions\u2019 previously declared here\n  134 |     __m256i min_path_exponential_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:641:13: error: redeclaration of \u2018__m256i min_path_logarithmic_functions\u2019\n  641 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:137:13: note: \u2018__m256i min_path_logarithmic_functions\u2019 previously declared here\n  137 |     __m256i min_path_logarithmic_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:644:13: error: redeclaration of \u2018__m256i min_path_trigonometric_functions\u2019\n  644 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:128:13: note: \u2018__m256i min_path_trigonometric_functions\u2019 previously declared here\n  128 |     __m256i min_path_trigonometric_functions = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp7z16yewp.cpp:648:21: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  648 | bool humaneval_check() {\n      |                     ^~\n[REDACTED]/tmp7z16yewp.cpp:648:21: note: remove parentheses to default-initialize a variable\n  648 | bool humaneval_check() {\n      |                     ^~\n      |                     --\n[REDACTED]/tmp7z16yewp.cpp:648:21: note: or replace parentheses with braces to aggregate-initialize a variable\n[REDACTED]/tmp7z16yewp.cpp:648:24: error: a function-definition is not allowed here before \u2018{\u2019 token\n  648 | bool humaneval_check() {\n      |                        ^\n[REDACTED]/tmp7z16yewp.cpp:664:40: error: a function-definition is not allowed here before \u2018{\u2019 token\n  664 | bool correctness_check(int iterations) {\n      |                                        ^\n[REDACTED]/tmp7z16yewp.cpp:693:9: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  693 | int main() {\n      |         ^~\n[REDACTED]/tmp7z16yewp.cpp:693:9: note: remove parentheses to default-initialize a variable\n  693 | int main() {\n      |         ^~\n      |         --\n[REDACTED]/tmp7z16yewp.cpp:693:9: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmp7z16yewp.cpp:693:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n  693 | int main() {\n      |            ^\n[REDACTED]/tmp7z16yewp.cpp:697:2: error: expected \u2018}\u2019 at end of input\n  697 | }\n      |  ^\n[REDACTED]/tmp7z16yewp.cpp:66:82: note: to match this \u2018{\u2019\n   66 | std::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n      |                                                                                  ^\n[REDACTED]/tmp7z16yewp.cpp:697:2: warning: no return statement in function returning non-void [-Wreturn-type]\n  697 | }\n      |  ^\n"}
{"task_id": "SimdBench_124_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_dl6m6ov.cpp:61:1: error: stray \u2018`\u2019 in program\n   61 | ```c++\n      | ^\n[REDACTED]/tmp_dl6m6ov.cpp:61:2: error: stray \u2018`\u2019 in program\n   61 | ```c++\n      |  ^\n[REDACTED]/tmp_dl6m6ov.cpp:61:3: error: stray \u2018`\u2019 in program\n   61 | ```c++\n      |   ^\n[REDACTED]/tmp_dl6m6ov.cpp:61:4: error: \u2018c\u2019 does not name a type\n   61 | ```c++\n      |    ^\n[REDACTED]/tmp_dl6m6ov.cpp: In function \u2018std::vector<int> minPath_simd(const std::vector<std::vector<int> >&, int)\u2019:\n[REDACTED]/tmp_dl6m6ov.cpp:98:13: error: redeclaration of \u2018__m256i next_moves\u2019\n   98 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:101:13: error: redeclaration of \u2018__m256i current_position\u2019\n  101 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:104:13: error: redeclaration of \u2018__m256i current_length\u2019\n  104 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:107:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  107 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:110:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  110 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:113:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  113 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:116:13: error: redeclaration of \u2018__m256i current_position\u2019\n  116 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:119:13: error: redeclaration of \u2018__m256i current_length\u2019\n  119 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:122:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  122 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:125:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  125 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:128:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  128 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:131:13: error: redeclaration of \u2018__m256i current_position\u2019\n  131 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:134:13: error: redeclaration of \u2018__m256i current_length\u2019\n  134 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:137:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  137 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:140:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  140 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:143:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  143 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:146:13: error: redeclaration of \u2018__m256i current_position\u2019\n  146 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:149:13: error: redeclaration of \u2018__m256i current_length\u2019\n  149 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:152:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  152 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:155:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  155 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:158:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  158 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:161:13: error: redeclaration of \u2018__m256i current_position\u2019\n  161 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:164:13: error: redeclaration of \u2018__m256i current_length\u2019\n  164 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:167:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  167 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:170:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  170 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:173:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  173 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:176:13: error: redeclaration of \u2018__m256i current_position\u2019\n  176 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:179:13: error: redeclaration of \u2018__m256i current_length\u2019\n  179 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:182:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  182 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:185:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  185 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:188:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  188 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:191:13: error: redeclaration of \u2018__m256i current_position\u2019\n  191 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:194:13: error: redeclaration of \u2018__m256i current_length\u2019\n  194 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:197:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  197 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:200:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  200 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:203:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  203 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:206:13: error: redeclaration of \u2018__m256i current_position\u2019\n  206 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:209:13: error: redeclaration of \u2018__m256i current_length\u2019\n  209 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:212:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  212 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:215:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  215 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:218:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  218 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:221:13: error: redeclaration of \u2018__m256i current_position\u2019\n  221 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:224:13: error: redeclaration of \u2018__m256i current_length\u2019\n  224 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:227:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  227 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:230:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  230 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:233:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  233 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:236:13: error: redeclaration of \u2018__m256i current_position\u2019\n  236 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:239:13: error: redeclaration of \u2018__m256i current_length\u2019\n  239 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:242:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  242 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:245:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  245 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:248:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  248 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:251:13: error: redeclaration of \u2018__m256i current_position\u2019\n  251 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:254:13: error: redeclaration of \u2018__m256i current_length\u2019\n  254 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:257:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  257 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:260:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  260 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:263:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  263 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:266:13: error: redeclaration of \u2018__m256i current_position\u2019\n  266 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:269:13: error: redeclaration of \u2018__m256i current_length\u2019\n  269 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:272:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  272 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:275:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  275 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:278:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  278 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:281:13: error: redeclaration of \u2018__m256i current_position\u2019\n  281 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:284:13: error: redeclaration of \u2018__m256i current_length\u2019\n  284 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:287:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  287 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:290:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  290 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:293:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  293 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:296:13: error: redeclaration of \u2018__m256i current_position\u2019\n  296 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:299:13: error: redeclaration of \u2018__m256i current_length\u2019\n  299 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:302:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  302 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:305:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  305 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:308:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  308 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:311:13: error: redeclaration of \u2018__m256i current_position\u2019\n  311 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:314:13: error: redeclaration of \u2018__m256i current_length\u2019\n  314 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:317:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  317 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:320:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  320 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:323:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  323 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:326:13: error: redeclaration of \u2018__m256i current_position\u2019\n  326 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:329:13: error: redeclaration of \u2018__m256i current_length\u2019\n  329 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:332:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  332 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:335:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  335 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:338:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  338 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:341:13: error: redeclaration of \u2018__m256i current_position\u2019\n  341 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:344:13: error: redeclaration of \u2018__m256i current_length\u2019\n  344 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:347:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  347 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:350:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  350 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:353:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  353 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:356:13: error: redeclaration of \u2018__m256i current_position\u2019\n  356 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:359:13: error: redeclaration of \u2018__m256i current_length\u2019\n  359 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:362:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  362 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:365:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  365 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:368:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  368 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:371:13: error: redeclaration of \u2018__m256i current_position\u2019\n  371 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:374:13: error: redeclaration of \u2018__m256i current_length\u2019\n  374 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:377:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  377 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:380:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  380 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:383:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  383 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:386:13: error: redeclaration of \u2018__m256i current_position\u2019\n  386 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:389:13: error: redeclaration of \u2018__m256i current_length\u2019\n  389 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:392:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  392 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:395:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  395 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:398:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  398 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:401:13: error: redeclaration of \u2018__m256i current_position\u2019\n  401 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:404:13: error: redeclaration of \u2018__m256i current_length\u2019\n  404 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:407:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  407 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:410:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  410 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:413:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  413 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:416:13: error: redeclaration of \u2018__m256i current_position\u2019\n  416 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:419:13: error: redeclaration of \u2018__m256i current_length\u2019\n  419 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:422:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  422 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:425:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  425 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:428:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  428 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:431:13: error: redeclaration of \u2018__m256i current_position\u2019\n  431 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:434:13: error: redeclaration of \u2018__m256i current_length\u2019\n  434 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:437:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  437 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:440:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  440 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:443:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  443 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:446:13: error: redeclaration of \u2018__m256i current_position\u2019\n  446 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:449:13: error: redeclaration of \u2018__m256i current_length\u2019\n  449 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:452:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  452 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:455:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  455 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:458:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  458 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:461:13: error: redeclaration of \u2018__m256i current_position\u2019\n  461 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:464:13: error: redeclaration of \u2018__m256i current_length\u2019\n  464 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:467:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  467 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:470:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  470 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:473:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  473 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:476:13: error: redeclaration of \u2018__m256i current_position\u2019\n  476 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:479:13: error: redeclaration of \u2018__m256i current_length\u2019\n  479 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:482:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  482 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:485:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  485 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:488:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  488 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:491:13: error: redeclaration of \u2018__m256i current_position\u2019\n  491 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:494:13: error: redeclaration of \u2018__m256i current_length\u2019\n  494 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:497:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  497 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:500:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  500 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:503:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  503 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:506:13: error: redeclaration of \u2018__m256i current_position\u2019\n  506 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:509:13: error: redeclaration of \u2018__m256i current_length\u2019\n  509 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:512:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  512 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:515:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  515 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:518:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  518 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:521:13: error: redeclaration of \u2018__m256i current_position\u2019\n  521 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:524:13: error: redeclaration of \u2018__m256i current_length\u2019\n  524 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:527:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  527 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:530:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  530 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:533:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  533 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:536:13: error: redeclaration of \u2018__m256i current_position\u2019\n  536 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:539:13: error: redeclaration of \u2018__m256i current_length\u2019\n  539 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:542:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  542 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:545:13: error: redeclaration of \u2018__m256i current_path_indices\u2019\n  545 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:95:13: note: \u2018__m256i current_path_indices\u2019 previously declared here\n   95 |     __m256i current_path_indices = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:548:13: error: redeclaration of \u2018__m256i next_moves\u2019\n  548 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:83:13: note: \u2018__m256i next_moves\u2019 previously declared here\n   83 |     __m256i next_moves = _mm256_set_epi32(1, 0, -1, 0, 0, 1, 0, -1);\n      |             ^~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:551:13: error: redeclaration of \u2018__m256i current_position\u2019\n  551 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:86:13: note: \u2018__m256i current_position\u2019 previously declared here\n   86 |     __m256i current_position = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:554:13: error: redeclaration of \u2018__m256i current_length\u2019\n  554 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:89:13: note: \u2018__m256i current_length\u2019 previously declared here\n   89 |     __m256i current_length = _mm256_set_epi32(0, 0, 0, 0, 0, 0, 0, 0);\n      |             ^~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:557:13: error: redeclaration of \u2018__m256i current_path_values\u2019\n  557 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:92:13: note: \u2018__m256i current_path_values\u2019 previously declared here\n   92 |     __m256i current_path_values = _mm256_setzero_si256();\n      |             ^~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_dl6m6ov.cpp:561:1: error: expected initializer before \u2018bool\u2019\n  561 | bool humaneval_check() {\n      | ^~~~\n[REDACTED]/tmp_dl6m6ov.cpp:577:40: error: a function-definition is not allowed here before \u2018{\u2019 token\n  577 | bool correctness_check(int iterations) {\n      |                                        ^\n[REDACTED]/tmp_dl6m6ov.cpp:606:9: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n  606 | int main() {\n      |         ^~\n[REDACTED]/tmp_dl6m6ov.cpp:606:9: note: remove parentheses to default-initialize a variable\n  606 | int main() {\n      |         ^~\n      |         --\n[REDACTED]/tmp_dl6m6ov.cpp:606:9: note: or replace parentheses with braces to value-initialize a variable\n[REDACTED]/tmp_dl6m6ov.cpp:606:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n  606 | int main() {\n      |            ^\n[REDACTED]/tmp_dl6m6ov.cpp:610:2: error: expected \u2018}\u2019 at end of input\n  610 | }\n      |  ^\n[REDACTED]/tmp_dl6m6ov.cpp:66:81: note: to match this \u2018{\u2019\n   66 | std::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n      |                                                                                 ^\n[REDACTED]/tmp_dl6m6ov.cpp:610:2: warning: no return statement in function returning non-void [-Wreturn-type]\n  610 | }\n      |  ^\n"}
{"task_id": "SimdBench_125_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvlz15t8a.cpp: In function \u2018uint64_t digits_simd(uint64_t)\u2019:\n[REDACTED]/tmpvlz15t8a.cpp:33:21: error: \u2018_mm256_set_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set_epi64x\u2019?\n   33 |     __m256i vec_n = _mm256_set_epi64u((int64_t)(n >> 56), (int64_t)(n >> 48), (int64_t)(n >> 40), (int64_t)(n >> 32),\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm256_set_epi64x\n[REDACTED]/tmpvlz15t8a.cpp:41:44: error: too few arguments to function \u2018__m256i _mm256_add_epi64(__m256i, __m256i)\u2019\n   41 |     __m256i sum_odd_bits = _mm256_add_epi64(_mm256_add_epi64(_mm256_add_epi64(_mm256_add_epi64(odd_bits, odd_bits), odd_bits), odd_bits));\n      |                            ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpvlz15t8a.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:126:1: note: declared here\n  126 | _mm256_add_epi64 (__m256i __A, __m256i __B)\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_125_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpc4o_k2bj.cpp: In function \u2018uint64_t digits_simd(uint64_t)\u2019:\n[REDACTED]/tmpc4o_k2bj.cpp:32:38: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   32 |     __m256i n_vec = _mm256_set_epi64x(n & 0xFFFFFFFF, (n >> 32) & 0xFFFFFFFF);\n      |                     ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpc4o_k2bj.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpc4o_k2bj.cpp:34:64: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   34 |     __m256i odd_mask = _mm256_and_si256(mask, _mm256_set_epi64x(1, 3));\n      |                                               ~~~~~~~~~~~~~~~~~^~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpc4o_k2bj.cpp:36:23: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   36 |     uint64_t result = _mm256_reduce_add_epi64(product);\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~\n      |                       _mm512_reduce_add_epi64\n"}
{"task_id": "SimdBench_125_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6t1e5gxl.cpp: In function \u2018uint64_t digits_simd(uint64_t)\u2019:\n[REDACTED]/tmp6t1e5gxl.cpp:35:21: error: \u2018_mm256_set_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set_epi64x\u2019?\n   35 |     __m256i n_vec = _mm256_set_epi64u(n >> 56, n >> 48, n >> 40, n >> 32,\n      |                     ^~~~~~~~~~~~~~~~~\n      |                     _mm256_set_epi64x\n[REDACTED]/tmp6t1e5gxl.cpp:43:48: warning: left shift count >= width of type [-Wshift-count-overflow]\n   43 |     result |= _mm256_extract_epi64(product, 2) << 64;\n      |                                                ^\n[REDACTED]/tmp6t1e5gxl.cpp:44:48: warning: left shift count >= width of type [-Wshift-count-overflow]\n   44 |     result |= _mm256_extract_epi64(product, 3) << 96;\n      |                                                ^\n"}
{"task_id": "SimdBench_125_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgil98582.cpp: In function \u2018uint64_t digits_simd(uint64_t)\u2019:\n[REDACTED]/tmpgil98582.cpp:33:19: error: \u2018_mm256_set_epi64u\u2019 was not declared in this scope; did you mean \u2018_mm256_set_epi64x\u2019?\n   33 |     __m256i vec = _mm256_set_epi64u((int64_t)(n >> 56), (int64_t)(n >> 48), (int64_t)(n >> 40), (int64_t)(n >> 32),\n      |                   ^~~~~~~~~~~~~~~~~\n      |                   _mm256_set_epi64x\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpgil98582.cpp:16:\n[REDACTED]/tmpgil98582.cpp:41:9: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   41 |         _mm256_extract_epi32(odd_digits, 0), _mm256_extract_epi32(odd_digits, 1)),\n      |         ^~~~~~~~~~~~~~~~~~~~\n      |         |\n      |         int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:27: note:   initializing argument 1 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                   ~~~~~~~~^~~\n[REDACTED]/tmpgil98582.cpp:46:23: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   46 |     uint64_t result = _mm256_reduce_add_epi32(sum, 0);\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~\n      |                       _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_125_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpa_o2l_pt.cpp: In function \u2018uint64_t digits_simd(uint64_t)\u2019:\n[REDACTED]/tmpa_o2l_pt.cpp:35:34: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   35 |     __m256i v = _mm256_set_epi64x(n & 0xFFFFFFFF, (n >> 32) & 0xFFFFFFFF);\n      |                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpa_o2l_pt.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpa_o2l_pt.cpp:37:80: error: too few arguments to function \u2018__m256i _mm256_set_epi64x(long long int, long long int, long long int, long long int)\u2019\n   37 |     __m256i result = _mm256_and_si256(mask, _mm256_slli_epi64(_mm256_set_epi64x(1, 1), 5));\n      |                                                               ~~~~~~~~~~~~~~~~~^~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1312:1: note: declared here\n 1312 | _mm256_set_epi64x (long long __A, long long __B, long long __C,\n      | ^~~~~~~~~~~~~~~~~\n[REDACTED]/tmpa_o2l_pt.cpp:39:32: error: could not convert \u2018((i != _mm256_setzero_si256()) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   39 |     for (__m256i i = result; i != _mm256_setzero_si256(); i = _mm256_add_epi64(i, _mm256_extract_epi64(i, 0))) {\n      |                              ~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __vector(4) long int\n[REDACTED]/tmpa_o2l_pt.cpp:39:83: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019\n   39 |     for (__m256i i = result; i != _mm256_setzero_si256(); i = _mm256_add_epi64(i, _mm256_extract_epi64(i, 0))) {\n      |                                                                                   ^~~~~~~~~~~~~~~~~~~~\n      |                                                                                   |\n      |                                                                                   long long int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:126:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi64(__m256i, __m256i)\u2019\n  126 | _mm256_add_epi64 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_126_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpnxpooxfj.cpp: In function \u2018uint64_t sum_squares_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpnxpooxfj.cpp:38:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   38 |         __m256f floats = _mm256_loadu_ps(&lst[i]);\n      |         ^~~~~~~\n      |         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpnxpooxfj.cpp:16:\n[REDACTED]/tmpnxpooxfj.cpp:39:39: error: \u2018floats\u2019 was not declared in this scope; did you mean \u2018float\u2019?\n   39 |         __m256i ints = _mm256_ceil_ps(floats);\n      |                                       ^~~~~~\n[REDACTED]/tmpnxpooxfj.cpp:49:45: error: cannot convert \u2018long long int*\u2019 to \u2018const __m256i_u*\u2019\n   49 |         __m256i square = _mm256_loadu_si256(&squares[i]);\n      |                                             ^~~~~~~~~~~\n      |                                             |\n      |                                             long long int*\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:927:38: note:   initializing argument 1 of \u2018__m256i _mm256_loadu_si256(const __m256i_u*)\u2019\n  927 | _mm256_loadu_si256 (__m256i_u const *__P)\n      |                     ~~~~~~~~~~~~~~~~~^~~\n[REDACTED]/tmpnxpooxfj.cpp:50:16: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   50 |         sum += _mm256_reduce_add_epi32(square);\n      |                ^~~~~~~~~~~~~~~~~~~~~~~\n      |                _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_126_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp93rk8l3h.cpp: In function \u2018uint64_t sum_squares_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmp93rk8l3h.cpp:39:21: error: \u2018_mm256_ceilvf\u2019 was not declared in this scope; did you mean \u2018_mm256_ceil_pd\u2019?\n   39 |         __m256 vc = _mm256_ceilvf(vf);\n      |                     ^~~~~~~~~~~~~\n      |                     _mm256_ceil_pd\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp93rk8l3h.cpp:16:\n[REDACTED]/tmp93rk8l3h.cpp:41:39: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019\n   41 |         vsum = _mm256_add_epi64(vsum, _mm256_extract_epi64(_mm256_castps_si256(vsq), 0));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       long long int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:126:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi64(__m256i, __m256i)\u2019\n  126 | _mm256_add_epi64 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp93rk8l3h.cpp:42:39: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019\n   42 |         vsum = _mm256_add_epi64(vsum, _mm256_extract_epi64(_mm256_castps_si256(vsq), 1));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       long long int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:126:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi64(__m256i, __m256i)\u2019\n  126 | _mm256_add_epi64 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp93rk8l3h.cpp:43:39: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019\n   43 |         vsum = _mm256_add_epi64(vsum, _mm256_extract_epi64(_mm256_castps_si256(vsq), 2));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       long long int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:126:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi64(__m256i, __m256i)\u2019\n  126 | _mm256_add_epi64 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmp93rk8l3h.cpp:44:39: error: cannot convert \u2018long long int\u2019 to \u2018__m256i\u2019\n   44 |         vsum = _mm256_add_epi64(vsum, _mm256_extract_epi64(_mm256_castps_si256(vsq), 3));\n      |                                       ^~~~~~~~~~~~~~~~~~~~\n      |                                       |\n      |                                       long long int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:126:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi64(__m256i, __m256i)\u2019\n  126 | _mm256_add_epi64 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_126_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpr6ax6v2k.cpp: In function \u2018uint64_t sum_squares_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpr6ax6v2k.cpp:36:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   36 |         __m256f floats = _mm256_loadu_ps(&lst[i]);\n      |         ^~~~~~~\n      |         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpr6ax6v2k.cpp:16:\n[REDACTED]/tmpr6ax6v2k.cpp:37:39: error: \u2018floats\u2019 was not declared in this scope; did you mean \u2018float\u2019?\n   37 |         __m256i ints = _mm256_ceil_ps(floats);\n      |                                       ^~~~~~\n[REDACTED]/tmpr6ax6v2k.cpp:43:35: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   43 |     __m256i summed_squared_ints = _mm256_reduce_add_epi32(squared_ints);\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                                   _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_126_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgom8yswa.cpp:43:87: error: macro \"_mm_ceil_ss\" requires 2 arguments, but only 1 given\n   43 |         result += static_cast<uint64_t>(_mm_cvtss_si64(_mm_ceil_ss(_mm_set1_ps(lst[i]))));\n      |                                                                                       ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpgom8yswa.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/smmintrin.h:154: note: macro \"_mm_ceil_ss\" defined here\n  154 | #define _mm_ceil_ss(D, V)  _mm_round_ss ((D), (V), _MM_FROUND_CEIL)\n      | \n[REDACTED]/tmpgom8yswa.cpp: In function \u2018uint64_t sum_squares_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpgom8yswa.cpp:30:5: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |     ^~~~~~~\n      |     __m256i\n[REDACTED]/tmpgom8yswa.cpp:30:15: error: \u2018vec_ptr\u2019 was not declared in this scope\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |               ^~~~~~~\n[REDACTED]/tmpgom8yswa.cpp:30:42: error: \u2018__m256f\u2019 does not name a type; did you mean \u2018__m256i\u2019?\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |                                          ^~~~~~~\n      |                                          __m256i\n[REDACTED]/tmpgom8yswa.cpp:30:49: error: expected \u2018>\u2019 before \u2018*\u2019 token\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |                                                 ^\n[REDACTED]/tmpgom8yswa.cpp:30:49: error: expected \u2018(\u2019 before \u2018*\u2019 token\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |                                                 ^\n      |                                                 (\n[REDACTED]/tmpgom8yswa.cpp:30:50: error: expected primary-expression before \u2018>\u2019 token\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |                                                  ^\n[REDACTED]/tmpgom8yswa.cpp:30:63: error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     __m256f * vec_ptr = reinterpret_cast<__m256f*>(lst.data());\n      |                                                               ^\n      |                                                               )\n[REDACTED]/tmpgom8yswa.cpp:34:16: error: expected \u2018;\u2019 before \u2018x\u2019\n   34 |         __m256f x = _mm256_loadu_ps(vec_ptr + i);\n      |                ^~\n      |                ;\n[REDACTED]/tmpgom8yswa.cpp:35:16: error: expected \u2018;\u2019 before \u2018y\u2019\n   35 |         __m256f y = _mm256_ceil_ps(x); // Ceiling each element\n      |                ^~\n      |                ;\n[REDACTED]/tmpgom8yswa.cpp:36:16: error: expected \u2018;\u2019 before \u2018z\u2019\n   36 |         __m256f z = _mm256_mul_ps(y, y); // Square each element\n      |                ^~\n      |                ;\n[REDACTED]/tmpgom8yswa.cpp:37:16: error: expected \u2018;\u2019 before \u2018w\u2019\n   37 |         __m256f w = _mm256_add_ps(z, z); // Sum squares\n      |                ^~\n      |                ;\n[REDACTED]/tmpgom8yswa.cpp:38:43: error: \u2018w\u2019 was not declared in this scope\n   38 |         result += _mm256_reduce_add_epi64(w); // Reduce to 64-bit integer\n      |                                           ^\n[REDACTED]/tmpgom8yswa.cpp:38:19: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   38 |         result += _mm256_reduce_add_epi64(w); // Reduce to 64-bit integer\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~\n      |                   _mm512_reduce_add_epi64\n[REDACTED]/tmpgom8yswa.cpp:43:56: error: \u2018_mm_ceil_ss\u2019 was not declared in this scope\n   43 |         result += static_cast<uint64_t>(_mm_cvtss_si64(_mm_ceil_ss(_mm_set1_ps(lst[i]))));\n      |                                                        ^~~~~~~~~~~\n"}
{"task_id": "SimdBench_126_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpw9yxu83m.cpp: In function \u2018uint64_t sum_squares_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpw9yxu83m.cpp:37:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   37 |         __m256f floats = _mm256_loadu_ps(&lst[i]);\n      |         ^~~~~~~\n      |         __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpw9yxu83m.cpp:16:\n[REDACTED]/tmpw9yxu83m.cpp:38:39: error: \u2018floats\u2019 was not declared in this scope; did you mean \u2018float\u2019?\n   38 |         __m256i ints = _mm256_ceil_ps(floats);\n      |                                       ^~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39:\n[REDACTED]/tmpw9yxu83m.cpp:44:19: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   44 |         result += _mm_extract_epi32(ceil_ints, i);\n      |                   ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_127_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_127_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp9mnr7s07.cpp: In function \u2018int can_arrange_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp9mnr7s07.cpp:43:44: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   43 |         __m256i mask = _mm256_movemask_epi8(cmp_result);\n      |                        ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                            |\n      |                                            int\n[REDACTED]/tmp9mnr7s07.cpp:44:17: error: could not convert \u2018((mask == (__m256i){4294967295, 4294967295, 4294967295, 4294967295}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   44 |         if(mask == 0xFFFFFFFF) continue; // No non-zero element found\n      |            ~~~~~^~~~~~~~~~~~~\n      |                 |\n      |                 __vector(4) long int\n[REDACTED]/tmp9mnr7s07.cpp:47:33: error: cannot convert \u2018__m256i\u2019 to \u2018unsigned int\u2019\n   47 |         int idx = __builtin_ctz(mask); // Count trailing zeros\n      |                                 ^~~~\n      |                                 |\n      |                                 __m256i\n<built-in>: note:   initializing argument 1 of \u2018int __builtin_ctz(unsigned int)\u2019\n"}
{"task_id": "SimdBench_127_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp8x_jsdx9.cpp: In function \u2018int can_arrange_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp8x_jsdx9.cpp:39:44: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   39 |         __m256i mask = _mm256_movemask_epi8(cmp_result);\n      |                        ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                            |\n      |                                            int\n[REDACTED]/tmp8x_jsdx9.cpp:41:17: error: could not convert \u2018((mask == (__m256i){-1, -1, -1, -1}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   41 |         if(mask == 0xFFFFFFFFFFFFFFFFULL){\n      |            ~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                 |\n      |                 __vector(4) long int\n[REDACTED]/tmp8x_jsdx9.cpp:45:20: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   45 |         prev_vec = _mm256_blendv_epi32(prev_vec, current_vec, mask);\n      |                    ^~~~~~~~~~~~~~~~~~~\n      |                    _mm256_blend_epi32\n"}
{"task_id": "SimdBench_127_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp959yp8ss.cpp: In function \u2018int can_arrange_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp959yp8ss.cpp:46:48: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   46 |         __m256i all_zero = _mm256_movemask_epi8(mask);\n      |                            ~~~~~~~~~~~~~~~~~~~~^~~~~~\n      |                                                |\n      |                                                int\n[REDACTED]/tmp959yp8ss.cpp:47:21: error: could not convert \u2018((all_zero == (__m256i){4294967295, 4294967295, 4294967295, 4294967295}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   47 |         if(all_zero == 0xFFFFFFFF) break;\n      |            ~~~~~~~~~^~~~~~~~~~~~~\n      |                     |\n      |                     __vector(4) long int\n"}
{"task_id": "SimdBench_127_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2ev8m_5x.cpp: In function \u2018int can_arrange_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp2ev8m_5x.cpp:39:44: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   39 |         __m256i mask = _mm256_movemask_epi8(cmp_result);\n      |                        ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                            |\n      |                                            int\n[REDACTED]/tmp2ev8m_5x.cpp:41:17: error: could not convert \u2018((mask == (__m256i){-1, -1, -1, -1}) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   41 |         if(mask == 0xFFFFFFFFFFFFFFFFLL){\n      |            ~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n      |                 |\n      |                 __vector(4) long int\n[REDACTED]/tmp2ev8m_5x.cpp:45:20: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   45 |         prev_vec = _mm256_blendv_epi32(prev_vec, current_vec, mask);\n      |                    ^~~~~~~~~~~~~~~~~~~\n      |                    _mm256_blend_epi32\n"}
{"task_id": "SimdBench_128_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmphzumo6fo.cpp: In function \u2018std::vector<int> largest_smallest_integers_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmphzumo6fo.cpp:33:35: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i vec = _mm256_set_epi32(lst[0], lst[1], lst[2], lst[3]);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmphzumo6fo.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmphzumo6fo.cpp:35:24: error: \u2018_mm256_cmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   35 |     __m256i pos_mask = _mm256_cmpge_epi32(vec, _mm256_setzero_si256());\n      |                        ^~~~~~~~~~~~~~~~~~\n      |                        _mm256_cmpgt_epi32\n[REDACTED]/tmphzumo6fo.cpp:40:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   40 |     _mm_storeu_si128((__m128i*)result, neg_max);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmphzumo6fo.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n[REDACTED]/tmphzumo6fo.cpp:41:46: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   41 |     _mm_storeu_si128((__m128i*)(result + 4), pos_min);\n      |                                              ^~~~~~~\n      |                                              |\n      |                                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_128_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgyicyfh4.cpp: In function \u2018std::vector<int> largest_smallest_integers_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpgyicyfh4.cpp:33:33: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i v = _mm256_set_epi32(0, 0, 0, 0);\n      |                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpgyicyfh4.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpgyicyfh4.cpp:34:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i v_neg = _mm256_set_epi32(-1, -1, -1, -1);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpgyicyfh4.cpp:35:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i v_pos = _mm256_set_epi32(1, 1, 1, 1);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_128_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpxt6rdpaa.cpp: In function \u2018std::vector<int> largest_smallest_integers_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpxt6rdpaa.cpp:39:28: error: \u2018_mm256_cmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   39 |         __m256i pos_mask = _mm256_cmpge_epi32(vec, _mm256_setzero_si256());\n      |                            ^~~~~~~~~~~~~~~~~~\n      |                            _mm256_cmpgt_epi32\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpxt6rdpaa.cpp:16:\n[REDACTED]/tmpxt6rdpaa.cpp:45:58: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   45 |     int max_neg_val = _mm256_extract_epi32(_mm256_max_ps(max_neg), 0);\n      |                                                          ^~~~~~~\n      |                                                          |\n      |                                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:294:23: note:   initializing argument 1 of \u2018__m256 _mm256_max_ps(__m256, __m256)\u2019\n  294 | _mm256_max_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpxt6rdpaa.cpp:46:58: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   46 |     int min_pos_val = _mm256_extract_epi32(_mm256_min_ps(min_pos), 0);\n      |                                                          ^~~~~~~\n      |                                                          |\n      |                                                          __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:306:23: note:   initializing argument 1 of \u2018__m256 _mm256_min_ps(__m256, __m256)\u2019\n  306 | _mm256_min_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n"}
{"task_id": "SimdBench_128_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpq7d1yubg.cpp: In function \u2018std::vector<int> largest_smallest_integers_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpq7d1yubg.cpp:33:33: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i v = _mm256_set_epi32(0, 0, 0, 0);\n      |                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpq7d1yubg.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpq7d1yubg.cpp:40:28: error: \u2018_mm256_cmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   40 |         __m256i pos_mask = _mm256_cmpge_epi32(vec, _mm256_setzero_si256());\n      |                            ^~~~~~~~~~~~~~~~~~\n      |                            _mm256_cmpgt_epi32\n"}
{"task_id": "SimdBench_128_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpovb7nr0q.cpp: In function \u2018std::vector<int> largest_smallest_integers_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpovb7nr0q.cpp:33:35: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i vec = _mm256_set_epi32(lst[0], lst[1], lst[2], lst[3]);\n      |                   ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpovb7nr0q.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpovb7nr0q.cpp:35:24: error: \u2018_mm256_cmpge_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   35 |     __m256i pos_mask = _mm256_cmpge_epi32(vec, _mm256_setzero_si256());\n      |                        ^~~~~~~~~~~~~~~~~~\n      |                        _mm256_cmpgt_epi32\n[REDACTED]/tmpovb7nr0q.cpp:44:40: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   44 |     _mm_storeu_si128((__m128i*)result, max_neg);\n      |                                        ^~~~~~~\n      |                                        |\n      |                                        __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpovb7nr0q.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n[REDACTED]/tmpovb7nr0q.cpp:45:46: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |     _mm_storeu_si128((__m128i*)(result + 4), min_pos);\n      |                                              ^~~~~~~\n      |                                              |\n      |                                              __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_129_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpz29j8k8b.cpp: In function \u2018uint64_t special_factorial_simd(uint64_t)\u2019:\n[REDACTED]/tmpz29j8k8b.cpp:35:14: error: could not convert \u2018((i > _mm256_set1_epi64x(1)) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   35 |     while (i > _mm256_set1_epi64x(1)) {\n      |            ~~^~~~~~~~~~~~~~~~~~~~~~~\n      |              |\n      |              __vector(4) long int\n[REDACTED]/tmpz29j8k8b.cpp:36:24: error: \u2018_mm256_mul_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi64\u2019?\n   36 |         __m256i temp = _mm256_mul_epi64(result, i);\n      |                        ^~~~~~~~~~~~~~~~\n      |                        _mm256_sub_epi64\n[REDACTED]/tmpz29j8k8b.cpp:42:32: error: could not convert \u2018((i != _mm256_set1_epi64x(0)) ? (__vector(4) long int){-1, -1, -1, -1} : (__vector(4) long int){0, 0, 0, 0})\u2019 from \u2018__vector(4) long int\u2019 to \u2018bool\u2019\n   42 |     for (__m256i i = result; i != _mm256_set1_epi64x(0); i = _mm256_srl_epi64(i, 32)) {\n      |                              ~~^~~~~~~~~~~~~~~~~~~~~~~~\n      |                                |\n      |                                __vector(4) long int\n[REDACTED]/tmpz29j8k8b.cpp:42:82: error: cannot convert \u2018int\u2019 to \u2018__m128i\u2019\n   42 |     for (__m256i i = result; i != _mm256_set1_epi64x(0); i = _mm256_srl_epi64(i, 32)) {\n      |                                                                                  ^~\n      |                                                                                  |\n      |                                                                                  int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmpz29j8k8b.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:794:40: note:   initializing argument 2 of \u2018__m256i _mm256_srl_epi64(__m256i, __m128i)\u2019\n  794 | _mm256_srl_epi64 (__m256i __A, __m128i __B)\n      |                                ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_129_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpgehjdt2o.cpp: In function \u2018uint64_t special_factorial_simd(uint64_t)\u2019:\n[REDACTED]/tmpgehjdt2o.cpp:45:15: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   45 |     result += _mm256_reduce_add_epi64(vec_result);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~\n      |               _mm512_reduce_add_epi64\n"}
{"task_id": "SimdBench_129_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpt2hfh32m.cpp: In function \u2018uint64_t special_factorial_simd(uint64_t)\u2019:\n[REDACTED]/tmpt2hfh32m.cpp:42:30: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   42 |     __m256i reduced_result = _mm256_reduce_add_epi64(result);\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~\n      |                              _mm512_reduce_add_epi64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpt2hfh32m.cpp:16:\n[REDACTED]/tmpt2hfh32m.cpp:43:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   43 |     uint64_t final_result = _mm_extract_epi64(reduced_result, 0);\n      |                             ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_129_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpiqtdshe6.cpp: In function \u2018uint64_t special_factorial_simd(uint64_t)\u2019:\n[REDACTED]/tmpiqtdshe6.cpp:46:22: error: \u2018_mm256_split_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_srli_epi64\u2019?\n   46 |     for (__m256i r : _mm256_split_epi64(result, result)) {\n      |                      ^~~~~~~~~~~~~~~~~~\n      |                      _mm256_srli_epi64\n[REDACTED]/tmpiqtdshe6.cpp:47:43: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   47 |         final_result *= _mm_cvtsi128_si64(r);\n      |                                           ^\n      |                                           |\n      |                                           __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpiqtdshe6.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:235:28: note:   initializing argument 1 of \u2018long long int _mm_cvtsi128_si64(__m128i)\u2019\n  235 | _mm_cvtsi128_si64 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_129_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpj9qff4mf.cpp: In function \u2018uint64_t special_factorial_simd(uint64_t)\u2019:\n[REDACTED]/tmpj9qff4mf.cpp:40:18: error: \u2018_mm256_mul_epi64\u2019 was not declared in this scope; did you mean \u2018_mm256_sub_epi64\u2019?\n   40 |         result = _mm256_mul_epi64(result, factor);\n      |                  ^~~~~~~~~~~~~~~~\n      |                  _mm256_sub_epi64\n[REDACTED]/tmpj9qff4mf.cpp:45:30: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   45 |     __m256i reduced_result = _mm256_reduce_add_epi64(result);\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~\n      |                              _mm512_reduce_add_epi64\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:39,\n                 from [REDACTED]/tmpj9qff4mf.cpp:16:\n[REDACTED]/tmpj9qff4mf.cpp:46:29: error: cannot convert a value of type \u2018__m256i\u2019 to vector type \u2018__m128i\u2019 which has different size\n   46 |     uint64_t final_result = _mm_extract_epi64(reduced_result, 0);\n      |                             ^~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_130_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptkkbdz8a.cpp: In function \u2018int sum_squares_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmptkkbdz8a.cpp:38:42: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   38 |         __m256i v_square = _mm256_mul_ps(v, v);\n      |                                          ^\n      |                                          |\n      |                                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmptkkbdz8a.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmptkkbdz8a.cpp:39:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   39 |         __m256i v_cube = _mm256_mul_ps(_mm256_mul_ps(v, v), v);\n      |                                                      ^\n      |                                                      |\n      |                                                      __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmptkkbdz8a.cpp:42:34: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   42 |             vsum = _mm256_add_ps(vsum, v_square);\n      |                                  ^~~~\n      |                                  |\n      |                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmptkkbdz8a.cpp:45:34: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   45 |             vsum = _mm256_add_ps(vsum, v_cube);\n      |                                  ^~~~\n      |                                  |\n      |                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmptkkbdz8a.cpp:59:42: error: \u2018_MM_FMAE\u2019 was not declared in this scope\n   59 |     return _mm256_reduce_add_epi32(vsum, _MM_FMAE);\n      |                                          ^~~~~~~~\n[REDACTED]/tmptkkbdz8a.cpp:59:12: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   59 |     return _mm256_reduce_add_epi32(vsum, _MM_FMAE);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n      |            _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_130_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbwe48tev.cpp: In function \u2018int sum_squares_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpbwe48tev.cpp:37:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 3), _mm256_set_epi32(0));\n      |                                            ~~~~~~~~~~~~~~~~^~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbwe48tev.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpbwe48tev.cpp:37:85: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 3), _mm256_set_epi32(0));\n      |                                                                     ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpbwe48tev.cpp:38:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 4), _mm256_set_epi32(0));\n      |                                            ~~~~~~~~~~~~~~~~^~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpbwe48tev.cpp:38:85: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 4), _mm256_set_epi32(0));\n      |                                                                     ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpbwe48tev.cpp:40:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   40 |         __m256i squared = _mm256_mul_ps(v, v);\n      |                                         ^\n      |                                         |\n      |                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpbwe48tev.cpp:41:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   41 |         __m256i cubed = _mm256_mul_ps(squared, v);\n      |                                       ^~~~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpbwe48tev.cpp:43:51: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   43 |         sum = _mm256_add_ps(sum, _mm256_blendv_ps(cubed, squared, mask4));\n      |                                                   ^~~~~\n      |                                                   |\n      |                                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:227:26: note:   initializing argument 1 of \u2018__m256 _mm256_blendv_ps(__m256, __m256, __m256)\u2019\n  227 | _mm256_blendv_ps (__m256 __X, __m256 __Y, __m256 __M)\n      |                   ~~~~~~~^~~\n[REDACTED]/tmpbwe48tev.cpp:44:51: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   44 |         sum = _mm256_add_ps(sum, _mm256_blendv_ps(v, squared, mask3));\n      |                                                   ^\n      |                                                   |\n      |                                                   __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:227:26: note:   initializing argument 1 of \u2018__m256 _mm256_blendv_ps(__m256, __m256, __m256)\u2019\n  227 | _mm256_blendv_ps (__m256 __X, __m256 __Y, __m256 __M)\n      |                   ~~~~~~~^~~\n"}
{"task_id": "SimdBench_130_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpx7qj704f.cpp: In function \u2018int sum_squares_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmpx7qj704f.cpp:37:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(3), _mm256_srli_epi32(i, 2));\n      |                                            ~~~~~~~~~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpx7qj704f.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpx7qj704f.cpp:37:83: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(3), _mm256_srli_epi32(i, 2));\n      |                                                                                   ^\n      |                                                                                   |\n      |                                                                                   int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:773:28: note:   initializing argument 1 of \u2018__m256i _mm256_srli_epi32(__m256i, int)\u2019\n  773 | _mm256_srli_epi32 (__m256i __A, int __B)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpx7qj704f.cpp:38:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(4), _mm256_srli_epi32(i, 2));\n      |                                            ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpx7qj704f.cpp:38:83: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(4), _mm256_srli_epi32(i, 2));\n      |                                                                                   ^\n      |                                                                                   |\n      |                                                                                   int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:773:28: note:   initializing argument 1 of \u2018__m256i _mm256_srli_epi32(__m256i, int)\u2019\n  773 | _mm256_srli_epi32 (__m256i __A, int __B)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmpx7qj704f.cpp:40:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   40 |         v = _mm256_blendv_epi32(v, _mm256_mul_ps(v, _mm256_set1_ps(2.0f)), mask3);\n      |                                                  ^\n      |                                                  |\n      |                                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpx7qj704f.cpp:40:13: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   40 |         v = _mm256_blendv_epi32(v, _mm256_mul_ps(v, _mm256_set1_ps(2.0f)), mask3);\n      |             ^~~~~~~~~~~~~~~~~~~\n      |             _mm256_blend_epi32\n[REDACTED]/tmpx7qj704f.cpp:41:50: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   41 |         v = _mm256_blendv_epi32(v, _mm256_mul_ps(v, _mm256_set1_ps(3.0f)), mask4);\n      |                                                  ^\n      |                                                  |\n      |                                                  __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmpx7qj704f.cpp:52:54: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   52 |     _mm_storeu_si32(reinterpret_cast<int*>(&result), sum);\n      |                                                      ^~~\n      |                                                      |\n      |                                                      __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpx7qj704f.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:758:37: note:   initializing argument 2 of \u2018void _mm_storeu_si32(void*, __m128i)\u2019\n  758 | _mm_storeu_si32 (void *__P, __m128i __B)\n      |                             ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_130_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmps_liqdhp.cpp: In function \u2018int sum_squares_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmps_liqdhp.cpp:37:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(3), _mm256_srli_epi32(i, 2));\n      |                                            ~~~~~~~~~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmps_liqdhp.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmps_liqdhp.cpp:37:83: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(3), _mm256_srli_epi32(i, 2));\n      |                                                                                   ^\n      |                                                                                   |\n      |                                                                                   int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:773:28: note:   initializing argument 1 of \u2018__m256i _mm256_srli_epi32(__m256i, int)\u2019\n  773 | _mm256_srli_epi32 (__m256i __A, int __B)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:38:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(4), _mm256_srli_epi32(i, 2));\n      |                                            ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmps_liqdhp.cpp:38:83: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(4), _mm256_srli_epi32(i, 2));\n      |                                                                                   ^\n      |                                                                                   |\n      |                                                                                   int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:773:28: note:   initializing argument 1 of \u2018__m256i _mm256_srli_epi32(__m256i, int)\u2019\n  773 | _mm256_srli_epi32 (__m256i __A, int __B)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:40:41: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   40 |         __m256i squared = _mm256_mul_ps(v, v);\n      |                                         ^\n      |                                         |\n      |                                         __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:41:39: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   41 |         __m256i cubed = _mm256_mul_ps(squared, v);\n      |                                       ^~~~~~~\n      |                                       |\n      |                                       __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:43:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   43 |         __m256i result = _mm256_or_ps(mask3 * squared, mask4 * cubed);\n      |                                       ~~~~~~^~~~~~~~~\n      |                                             |\n      |                                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:330:22: note:   initializing argument 1 of \u2018__m256 _mm256_or_ps(__m256, __m256)\u2019\n  330 | _mm256_or_ps (__m256 __A, __m256 __B)\n      |               ~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:44:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   44 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(result, 0));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:45:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   45 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(result, 1));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:46:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   46 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(result, 2));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:47:37: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019\n   47 |         sum = _mm256_add_epi32(sum, _mm256_extract_epi32(result, 3));\n      |                                     ^~~~~~~~~~~~~~~~~~~~\n      |                                     |\n      |                                     int\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:119:40: note:   initializing argument 2 of \u2018__m256i _mm256_add_epi32(__m256i, __m256i)\u2019\n  119 | _mm256_add_epi32 (__m256i __A, __m256i __B)\n      |                                ~~~~~~~~^~~\n[REDACTED]/tmps_liqdhp.cpp:60:12: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   60 |     return _mm256_reduce_add_epi32(sum);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n      |            _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_130_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp818qz_6g.cpp: In function \u2018int sum_squares_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp818qz_6g.cpp:37:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 3), _mm256_set_epi32(0));\n      |                                            ~~~~~~~~~~~~~~~~^~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp818qz_6g.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp818qz_6g.cpp:37:85: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   37 |         __m256i mask3 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 3), _mm256_set_epi32(0));\n      |                                                                     ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp818qz_6g.cpp:38:60: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 4), _mm256_set_epi32(0));\n      |                                            ~~~~~~~~~~~~~~~~^~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp818qz_6g.cpp:38:85: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |         __m256i mask4 = _mm256_cmpeq_epi32(_mm256_set_epi32(i % 4), _mm256_set_epi32(0));\n      |                                                                     ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp818qz_6g.cpp:40:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   40 |         vec = _mm256_mul_ps(vec, _mm256_castsi256_ps(mask3));\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp818qz_6g.cpp:41:48: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   41 |         vec = _mm256_add_ps(vec, _mm256_mul_ps(vec, _mm256_castsi256_ps(mask4)));\n      |                                                ^~~\n      |                                                |\n      |                                                __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:318:23: note:   initializing argument 1 of \u2018__m256 _mm256_mul_ps(__m256, __m256)\u2019\n  318 | _mm256_mul_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp818qz_6g.cpp:43:29: error: cannot convert \u2018__m256i\u2019 to \u2018__m256\u2019\n   43 |         sum = _mm256_add_ps(sum, vec);\n      |                             ^~~\n      |                             |\n      |                             __m256i\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:147:23: note:   initializing argument 1 of \u2018__m256 _mm256_add_ps(__m256, __m256)\u2019\n  147 | _mm256_add_ps (__m256 __A, __m256 __B)\n      |                ~~~~~~~^~~\n[REDACTED]/tmp818qz_6g.cpp:47:26: error: cannot convert \u2018__m256i\u2019 to \u2018__m128\u2019\n   47 |         sum = _mm_add_ps(sum, _mm_set1_ps(lst[i] * (i % 3 == 0 ? i : i % 4 == 0 ? i * i : 1)));\n      |                          ^~~\n      |                          |\n      |                          __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:31,\n                 from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp818qz_6g.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/xmmintrin.h:190:20: note:   initializing argument 1 of \u2018__m128 _mm_add_ps(__m128, __m128)\u2019\n  190 | _mm_add_ps (__m128 __A, __m128 __B)\n      |             ~~~~~~~^~~\n[REDACTED]/tmp818qz_6g.cpp:50:12: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   50 |     return _mm256_reduce_add_ps(sum);\n      |            ^~~~~~~~~~~~~~~~~~~~\n      |            _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_131_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp5z9alrnj.cpp: In function \u2018int specialFilter_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp5z9alrnj.cpp:48:18: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   48 |         count += _mm256_popcnt_u32(_mm256_movemask_epi8(is_odd));\n      |                  ^~~~~~~~~~~~~~~~~\n      |                  _mm_popcnt_u32\n"}
{"task_id": "SimdBench_131_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7dzcoiq7.cpp: In function \u2018int specialFilter_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmp7dzcoiq7.cpp:41:79: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   41 |         mask = _mm256_or_si256(mask, _mm256_cmpgt_epi32(temp, _mm256_set_epi32(10)));\n      |                                                               ~~~~~~~~~~~~~~~~^~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp7dzcoiq7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7dzcoiq7.cpp:50:45: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   50 |     return _mm_popcnt_u32(_mm_movemask_epi8(mask));\n      |                                             ^~~~\n      |                                             |\n      |                                             __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp7dzcoiq7.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1437:28: note:   initializing argument 1 of \u2018int _mm_movemask_epi8(__m128i)\u2019\n 1437 | _mm_movemask_epi8 (__m128i __A)\n      |                    ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_131_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmptiibg0b8.cpp: In function \u2018int specialFilter_simd(const std::vector<int>&)\u2019:\n[REDACTED]/tmptiibg0b8.cpp:73:18: error: \u2018_mm256_popcnt_u32\u2019 was not declared in this scope; did you mean \u2018_mm_popcnt_u32\u2019?\n   73 |         count += _mm256_popcnt_u32(mask);\n      |                  ^~~~~~~~~~~~~~~~~\n      |                  _mm_popcnt_u32\n"}
{"task_id": "SimdBench_131_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpuuihky7n.cpp:29:1: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      | ^\n[REDACTED]/tmpuuihky7n.cpp:29:2: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |  ^\n[REDACTED]/tmpuuihky7n.cpp:29:3: error: stray \u2018`\u2019 in program\n   29 | ```c++\n      |   ^\n[REDACTED]/tmpuuihky7n.cpp:42:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   42 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmpuuihky7n.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:43:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   43 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:44:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   44 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:45:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   45 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:46:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   46 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:47:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   47 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:48:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   48 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:49:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   49 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:50:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   50 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:51:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   51 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:52:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   52 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:53:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   53 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:54:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   54 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:55:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   55 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:56:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   56 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:57:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   57 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:58:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   58 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:59:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   59 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:60:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   60 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:61:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   61 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:62:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   62 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:63:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   63 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:64:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   64 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:65:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   65 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:66:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   66 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:67:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   67 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:68:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   68 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:69:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   69 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:70:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   70 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:71:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   71 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:72:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   72 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:73:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   73 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:74:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   74 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:75:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   75 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:76:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   76 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:77:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   77 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:78:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   78 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:79:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   79 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:80:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   80 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:81:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   81 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:82:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   82 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:83:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   83 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:84:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   84 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:85:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   85 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:86:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   86 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:87:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   87 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:88:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   88 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:89:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   89 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:90:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   90 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:91:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   91 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:92:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   92 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:93:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   93 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:94:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   94 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:95:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   95 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:96:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   96 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:97:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   97 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:98:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   98 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:99:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n   99 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:100:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  100 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:101:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  101 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:102:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  102 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:103:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  103 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:104:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  104 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:105:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  105 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:106:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  106 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:107:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  107 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:108:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  108 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:109:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  109 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:110:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  110 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:111:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  111 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:112:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  112 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:113:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  113 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:114:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  114 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:115:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  115 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:116:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  116 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:117:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  117 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:118:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  118 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:119:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  119 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:120:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  120 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:121:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  121 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:122:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  122 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:123:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  123 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:124:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  124 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:125:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  125 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:126:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  126 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:127:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  127 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:128:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  128 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:129:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  129 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:130:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  130 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:131:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  131 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:132:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  132 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:133:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  133 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:134:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  134 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:135:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  135 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:136:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  136 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:137:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  137 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:138:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  138 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:139:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  139 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:140:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  140 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:141:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  141 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:142:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  142 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:143:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  143 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:144:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  144 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:145:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  145 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:146:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  146 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:147:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  147 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:148:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  148 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:149:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  149 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:150:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  150 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:151:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  151 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:152:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  152 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:153:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  153 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:154:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  154 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:155:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  155 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:156:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  156 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:157:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  157 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:158:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  158 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:159:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  159 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:160:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  160 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:161:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  161 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:162:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  162 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:163:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  163 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:164:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  164 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:165:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  165 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:166:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  166 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:167:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  167 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:168:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  168 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:169:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  169 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:170:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  170 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:171:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  171 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:172:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  172 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:173:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  173 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:174:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  174 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:175:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  175 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:176:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  176 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:177:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  177 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:178:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  178 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:179:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  179 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:180:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  180 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:181:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  181 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:182:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  182 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:183:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  183 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:184:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  184 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:185:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  185 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:186:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  186 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:187:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  187 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:188:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  188 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:189:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  189 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:190:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  190 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:191:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  191 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:192:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  192 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:193:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  193 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:194:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  194 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:195:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  195 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:196:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  196 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:197:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  197 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:198:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  198 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:199:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  199 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:200:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  200 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:201:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  201 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:202:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  202 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:203:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  203 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:204:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  204 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:205:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  205 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:206:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  206 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:207:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  207 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:208:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  208 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:209:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  209 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:210:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  210 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:211:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  211 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:212:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  212 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:213:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  213 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:214:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  214 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:215:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  215 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:216:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  216 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:217:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  217 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:218:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  218 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:219:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  219 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:220:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  220 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:221:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  221 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:222:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  222 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:223:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  223 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:224:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  224 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:225:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  225 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:226:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  226 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:227:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  227 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:228:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  228 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:229:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  229 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:230:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  230 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:231:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  231 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:232:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  232 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:233:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  233 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:234:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  234 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:235:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  235 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:236:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  236 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:237:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  237 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:238:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  238 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:239:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  239 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:240:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  240 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:241:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  241 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:242:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  242 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:243:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  243 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:244:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  244 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:245:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  245 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:246:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  246 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:247:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  247 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:248:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  248 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:249:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  249 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:250:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  250 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:251:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  251 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:252:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  252 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:253:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  253 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:254:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  254 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:255:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  255 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:256:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  256 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:257:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  257 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:258:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  258 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:259:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  259 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:260:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  260 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:261:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  261 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:262:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  262 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:263:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  263 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:264:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  264 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:265:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  265 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:266:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  266 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:267:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  267 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:268:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  268 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:269:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  269 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:270:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  270 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:271:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  271 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:272:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  272 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:273:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  273 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:274:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  274 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:275:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  275 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:276:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  276 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:277:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  277 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:278:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  278 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:279:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  279 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:280:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  280 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:281:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  281 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:282:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  282 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:283:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  283 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:284:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  284 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:285:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  285 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:286:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  286 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:287:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  287 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:288:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  288 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:289:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  289 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:290:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  290 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:291:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  291 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:292:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  292 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:293:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  293 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:294:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  294 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:295:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  295 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:296:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  296 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:297:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  297 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:298:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  298 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:299:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  299 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b0101));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:300:72: error: macro \"_mm_shuffle_epi32\" passed 3 arguments, but takes just 2\n  300 |         mask = _mm_and_si256(mask, _mm_shuffle_epi32(mask, mask, 0b1010));\n      |                                                                        ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:1471: note: macro \"_mm_shuffle_epi32\" defined here\n 1471 | #define _mm_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmpuuihky7n.cpp:336:2: error: unterminated argument list invoking macro \"_mm_shuffle_epi32\"\n  336 | }\n      |  ^\n[REDACTED]/tmpuuihky7n.cpp:29:4: error: \u2018c\u2019 does not name a type\n   29 | ```c++\n      |    ^\n"}
{"task_id": "SimdBench_131_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_132_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpvajg72lg.cpp: In function \u2018uint64_t get_max_triples_simd(uint64_t)\u2019:\n[REDACTED]/tmpvajg72lg.cpp:81:61: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   81 |         __m256i mod = _mm256_mod_epi32(sum, _mm256_set_epi32(3));\n      |                                             ~~~~~~~~~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpvajg72lg.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpvajg72lg.cpp:81:23: error: \u2018_mm256_mod_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_xor_epi32\u2019?\n   81 |         __m256i mod = _mm256_mod_epi32(sum, _mm256_set_epi32(3));\n      |                       ^~~~~~~~~~~~~~~~\n      |                       _mm256_xor_epi32\n[REDACTED]/tmpvajg72lg.cpp:82:64: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   82 |         __m256i mask = _mm256_cmpgt_epi32(mod, _mm256_set_epi32(1));\n      |                                                ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpvajg72lg.cpp:83:69: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   83 |         __m256i count_mask = _mm256_and_si256(mask, _mm256_set_epi32(1));\n      |                                                     ~~~~~~~~~~~~~~~~^~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpvajg72lg.cpp:84:18: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   84 |         count += _mm256_reduce_add_epi32(count_mask);\n      |                  ^~~~~~~~~~~~~~~~~~~~~~~\n      |                  _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_132_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp07v4coiy.cpp: In function \u2018uint64_t get_max_triples_simd(uint64_t)\u2019:\n[REDACTED]/tmp07v4coiy.cpp:79:91: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   79 |         __m256i mod_3_ab = _mm256_and_si256(_mm256_srai_epi32(sum_ab, 2), _mm256_set_epi32(2, 2, 2, 2));\n      |                                                                           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp07v4coiy.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp07v4coiy.cpp:80:91: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   80 |         __m256i mod_3_bc = _mm256_and_si256(_mm256_srai_epi32(sum_bc, 2), _mm256_set_epi32(2, 2, 2, 2));\n      |                                                                           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp07v4coiy.cpp:81:91: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   81 |         __m256i mod_3_ca = _mm256_and_si256(_mm256_srai_epi32(sum_ca, 2), _mm256_set_epi32(2, 2, 2, 2));\n      |                                                                           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp07v4coiy.cpp:83:74: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   83 |         __m256i count_ab = _mm256_cmpneq_epi32(mod_3_ab, _mm256_set_epi32(0, 0, 0, 0));\n      |                                                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp07v4coiy.cpp:83:28: error: \u2018_mm256_cmpneq_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpeq_epi32\u2019?\n   83 |         __m256i count_ab = _mm256_cmpneq_epi32(mod_3_ab, _mm256_set_epi32(0, 0, 0, 0));\n      |                            ^~~~~~~~~~~~~~~~~~~\n      |                            _mm256_cmpeq_epi32\n[REDACTED]/tmp07v4coiy.cpp:84:74: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   84 |         __m256i count_bc = _mm256_cmpneq_epi32(mod_3_bc, _mm256_set_epi32(0, 0, 0, 0));\n      |                                                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp07v4coiy.cpp:85:74: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   85 |         __m256i count_ca = _mm256_cmpneq_epi32(mod_3_ca, _mm256_set_epi32(0, 0, 0, 0));\n      |                                                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp07v4coiy.cpp:95:19: error: cannot convert a value of type \u2018long long int\u2019 to vector type \u2018__m256i\u2019 which has different size\n   95 |         result += _mm256_extract_epi32(a[i], 0);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_132_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2mzvlau2.cpp: In function \u2018uint64_t get_max_triples_simd(uint64_t)\u2019:\n[REDACTED]/tmp2mzvlau2.cpp:67:49: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   67 |         a = _mm256_add_epi32(a, _mm256_set_epi32(i * i - i + 1, i * i - i + 1, i * i - i + 1, i * i - i + 1));\n      |                                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2mzvlau2.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_132_AVX", "passed": false, "result": "logical bug"}
{"task_id": "SimdBench_132_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6h5elymc.cpp: In function \u2018uint64_t get_max_triples_simd(uint64_t)\u2019:\n[REDACTED]/tmp6h5elymc.cpp:68:49: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   68 |         a = _mm256_add_epi32(a, _mm256_set_epi32(val, val, val, val));\n      |                                 ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp6h5elymc.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp6h5elymc.cpp:69:53: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   69 |         sum = _mm256_add_epi32(sum, _mm256_set_epi32(val, val, val, val));\n      |                                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_133_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp__uxoeim.cpp: In function \u2018int x_or_y_simd(int, int, int)\u2019:\n[REDACTED]/tmp__uxoeim.cpp:28:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i n_vec = _mm256_set_epi32(n, n, n, n);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp__uxoeim.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp__uxoeim.cpp:29:62: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   29 |     __m256i mask = _mm256_cmpeq_epi32(n_vec, _mm256_set_epi32(0, 0, 0, 0));\n      |                                              ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp__uxoeim.cpp:30:42: error: \u2018x_vec\u2019 was not declared in this scope; did you mean \u2018n_vec\u2019?\n   30 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                                          ^~~~~\n      |                                          n_vec\n[REDACTED]/tmp__uxoeim.cpp:30:49: error: \u2018y_vec\u2019 was not declared in this scope; did you mean \u2018n_vec\u2019?\n   30 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                                                 ^~~~~\n      |                                                 n_vec\n[REDACTED]/tmp__uxoeim.cpp:30:22: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   30 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                      ^~~~~~~~~~~~~~~~~~~\n      |                      _mm256_blend_epi32\n"}
{"task_id": "SimdBench_133_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpfuyxw8h4.cpp: In function \u2018int x_or_y_simd(int, int, int)\u2019:\n[REDACTED]/tmpfuyxw8h4.cpp:31:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     __m256i n_vec = _mm256_set_epi32(n, n, n, n);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpfuyxw8h4.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpfuyxw8h4.cpp:33:42: error: \u2018x_vec\u2019 was not declared in this scope; did you mean \u2018n_vec\u2019?\n   33 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                                          ^~~~~\n      |                                          n_vec\n[REDACTED]/tmpfuyxw8h4.cpp:33:49: error: \u2018y_vec\u2019 was not declared in this scope; did you mean \u2018n_vec\u2019?\n   33 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                                                 ^~~~~\n      |                                                 n_vec\n[REDACTED]/tmpfuyxw8h4.cpp:33:22: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   33 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                      ^~~~~~~~~~~~~~~~~~~\n      |                      _mm256_blend_epi32\n"}
{"task_id": "SimdBench_133_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp6fckxtwd.cpp: In function \u2018int x_or_y_simd(int, int, int)\u2019:\n[REDACTED]/tmp6fckxtwd.cpp:31:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     __m256i n_vec = _mm256_set_epi32(n, n, n, n);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp6fckxtwd.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp6fckxtwd.cpp:32:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   32 |     __m256i x_vec = _mm256_set_epi32(x, x, x, x);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp6fckxtwd.cpp:33:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i y_vec = _mm256_set_epi32(y, y, y, y);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp6fckxtwd.cpp:37:56: error: \u2018_mm256_cmplt_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   37 |     is_prime_mask = _mm256_andnot_si256(is_prime_mask, _mm256_cmplt_epi32(n_vec, _mm256_set1_epi32(2)));\n      |                                                        ^~~~~~~~~~~~~~~~~~\n      |                                                        _mm256_cmpgt_epi32\n[REDACTED]/tmp6fckxtwd.cpp:45:44: error: cannot convert \u2018__m256i\u2019 to \u2018__m128i\u2019\n   45 |     _mm_storeu_si128((__m128i*)result_int, result);\n      |                                            ^~~~~~\n      |                                            |\n      |                                            __m256i\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp6fckxtwd.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_133_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp7777zfl7.cpp: In function \u2018int x_or_y_simd(int, int, int)\u2019:\n[REDACTED]/tmp7777zfl7.cpp:28:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   28 |     __m256i n_vec = _mm256_set_epi32(n, n, n, n);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp7777zfl7.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7777zfl7.cpp:29:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   29 |     __m256i x_vec = _mm256_set_epi32(x, x, x, x);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp7777zfl7.cpp:30:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   30 |     __m256i y_vec = _mm256_set_epi32(y, y, y, y);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n"}
{"task_id": "SimdBench_133_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpi3cm774a.cpp: In function \u2018int x_or_y_simd(int, int, int)\u2019:\n[REDACTED]/tmpi3cm774a.cpp:31:37: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   31 |     __m256i n_vec = _mm256_set_epi32(n, n, n, n);\n      |                     ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpi3cm774a.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpi3cm774a.cpp:33:42: error: \u2018x_vec\u2019 was not declared in this scope; did you mean \u2018n_vec\u2019?\n   33 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                                          ^~~~~\n      |                                          n_vec\n[REDACTED]/tmpi3cm774a.cpp:33:49: error: \u2018y_vec\u2019 was not declared in this scope; did you mean \u2018n_vec\u2019?\n   33 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                                                 ^~~~~\n      |                                                 n_vec\n[REDACTED]/tmpi3cm774a.cpp:33:22: error: \u2018_mm256_blendv_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_blend_epi32\u2019?\n   33 |     __m256i result = _mm256_blendv_epi32(x_vec, y_vec, mask);\n      |                      ^~~~~~~~~~~~~~~~~~~\n      |                      _mm256_blend_epi32\n"}
{"task_id": "SimdBench_134_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2nb3au0u.cpp: In function \u2018uint64_t double_the_difference_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmp2nb3au0u.cpp:35:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   35 |     __m256i mask = _mm256_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmp2nb3au0u.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp2nb3au0u.cpp:36:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   36 |     __m256i neg_mask = _mm256_set_epi32(0, 0, 0, 0);\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmp2nb3au0u.cpp:40:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   40 |         __m256f vec = _mm256_loadu_ps(&lst[i]);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmp2nb3au0u.cpp:41:16: error: expected \u2018;\u2019 before \u2018abs_vec\u2019\n   41 |         __m256f abs_vec = _mm256_abs_ps(vec);\n      |                ^~~~~~~~\n      |                ;\n[REDACTED]/tmp2nb3au0u.cpp:42:47: error: \u2018abs_vec\u2019 was not declared in this scope\n   42 |         __m256i int_part = _mm256_cvtps_epi32(abs_vec);\n      |                                               ^~~~~~~\n[REDACTED]/tmp2nb3au0u.cpp:44:32: error: \u2018_mm256_cmplt_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_cmpgt_epi32\u2019?\n   44 |         __m256i neg_mask_vec = _mm256_cmplt_epi32(int_part, neg_mask);\n      |                                ^~~~~~~~~~~~~~~~~~\n      |                                _mm256_cmpgt_epi32\n[REDACTED]/tmp2nb3au0u.cpp:45:16: error: expected \u2018;\u2019 before \u2018odd_abs_vec\u2019\n   45 |         __m256f odd_abs_vec = _mm256_and_ps(abs_vec, odd_mask);\n      |                ^~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmp2nb3au0u.cpp:46:16: error: expected \u2018;\u2019 before \u2018neg_odd_abs_vec\u2019\n   46 |         __m256f neg_odd_abs_vec = _mm256_and_ps(abs_vec, neg_mask_vec);\n      |                ^~~~~~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmp2nb3au0u.cpp:47:16: error: expected \u2018;\u2019 before \u2018squared_odd_abs_vec\u2019\n   47 |         __m256f squared_odd_abs_vec = _mm256_mul_ps(odd_abs_vec, odd_abs_vec);\n      |                ^~~~~~~~~~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmp2nb3au0u.cpp:48:16: error: expected \u2018;\u2019 before \u2018squared_neg_odd_abs_vec\u2019\n   48 |         __m256f squared_neg_odd_abs_vec = _mm256_mul_ps(neg_odd_abs_vec, neg_odd_abs_vec);\n      |                ^~~~~~~~~~~~~~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmp2nb3au0u.cpp:49:16: error: expected \u2018;\u2019 before \u2018sum\u2019\n   49 |         __m256f sum = _mm256_add_ps(squared_odd_abs_vec, squared_neg_odd_abs_vec);\n      |                ^~~~\n      |                ;\n[REDACTED]/tmp2nb3au0u.cpp:50:40: error: \u2018sum\u2019 was not declared in this scope\n   50 |         result += _mm256_reduce_add_ps(sum);\n      |                                        ^~~\n[REDACTED]/tmp2nb3au0u.cpp:50:19: error: \u2018_mm256_reduce_add_ps\u2019 was not declared in this scope; did you mean \u2018_mm256_reduce_add_ph\u2019?\n   50 |         result += _mm256_reduce_add_ps(sum);\n      |                   ^~~~~~~~~~~~~~~~~~~~\n      |                   _mm256_reduce_add_ph\n"}
{"task_id": "SimdBench_134_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmprepqtx5f.cpp: In function \u2018uint64_t double_the_difference_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmprepqtx5f.cpp:34:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i mask = _mm256_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmprepqtx5f.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmprepqtx5f.cpp:38:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   38 |         __m256f f = _mm256_loadu_ps(&lst[i]);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmprepqtx5f.cpp:39:64: error: \u2018f\u2019 was not declared in this scope\n   39 |         __m256i i_mask = _mm256_cmpgt_epi32(_mm256_cvtps_epi32(f), mask);\n      |                                                                ^\n[REDACTED]/tmprepqtx5f.cpp:42:16: error: expected \u2018;\u2019 before \u2018f_sqr\u2019\n   42 |         __m256f f_sqr = _mm256_mul_ps(f, f);\n      |                ^~~~~~\n      |                ;\n[REDACTED]/tmprepqtx5f.cpp:43:70: error: \u2018f_sqr\u2019 was not declared in this scope\n   43 |         __m256i s_sum = _mm256_add_epi32(s_mask, _mm256_castps_si256(f_sqr));\n      |                                                                      ^~~~~\n[REDACTED]/tmprepqtx5f.cpp:49:5: error: \u2018_mm256_storeu_si64\u2019 was not declared in this scope; did you mean \u2018_mm256_storeu_epi64\u2019?\n   49 |     _mm256_storeu_si64((__int64_t*)&result, sum);\n      |     ^~~~~~~~~~~~~~~~~~\n      |     _mm256_storeu_epi64\n"}
{"task_id": "SimdBench_134_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpqp54ggel.cpp: In function \u2018uint64_t double_the_difference_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpqp54ggel.cpp:33:36: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   33 |     __m256i mask = _mm256_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n      |                    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpqp54ggel.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqp54ggel.cpp:34:40: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   34 |     __m256i neg_mask = _mm256_set_epi32(0x00000000, 0x00000000, 0x00000000, 0x00000000);\n      |                        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpqp54ggel.cpp:38:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   38 |         __m256f vec = _mm256_loadu_ps(&lst[i]);\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmpqp54ggel.cpp:39:16: error: expected \u2018;\u2019 before \u2018abs_vec\u2019\n   39 |         __m256f abs_vec = _mm256_abs_ps(vec);\n      |                ^~~~~~~~\n      |                ;\n[REDACTED]/tmpqp54ggel.cpp:40:46: error: \u2018abs_vec\u2019 was not declared in this scope\n   40 |         __m256i int_vec = _mm256_cvtps_epi32(abs_vec);\n      |                                              ^~~~~~~\n[REDACTED]/tmpqp54ggel.cpp:43:16: error: expected \u2018;\u2019 before \u2018squared_odd\u2019\n   43 |         __m256f squared_odd = _mm256_mul_ps(neg_masked_odd, neg_masked_odd);\n      |                ^~~~~~~~~~~~\n      |                ;\n[REDACTED]/tmpqp54ggel.cpp:44:49: error: \u2018squared_odd\u2019 was not declared in this scope\n   44 |         __m256 sum_vec = _mm256_add_ps(sum_vec, squared_odd);\n      |                                                 ^~~~~~~~~~~\n[REDACTED]/tmpqp54ggel.cpp:54:56: error: \u2018sum_vec\u2019 was not declared in this scope\n   54 |     return _mm256_reduce_add_epi64(_mm256_castps_si256(sum_vec)) >> 32;\n      |                                                        ^~~~~~~\n[REDACTED]/tmpqp54ggel.cpp:54:12: error: \u2018_mm256_reduce_add_epi64\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi64\u2019?\n   54 |     return _mm256_reduce_add_epi64(_mm256_castps_si256(sum_vec)) >> 32;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n      |            _mm512_reduce_add_epi64\n"}
{"task_id": "SimdBench_134_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp2fidh4ot.cpp: In function \u2018uint64_t double_the_difference_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmp2fidh4ot.cpp:37:9: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   37 |         __m256f f = _mm256_loadu_ps(&lst[i]); // Load 8 floats from the vector into a vector\n      |         ^~~~~~~\n      |         __m256i\n[REDACTED]/tmp2fidh4ot.cpp:38:62: error: \u2018f\u2019 was not declared in this scope\n   38 |         __m256i mask = _mm256_cmpgt_epi32(_mm256_cvtps_epi32(f), _mm256_setzero_si256()); // Create a mask for positive integers\n      |                                                              ^\n[REDACTED]/tmp2fidh4ot.cpp:41:16: error: expected \u2018;\u2019 before \u2018odd_f\u2019\n   41 |         __m256f odd_f = _mm256_mul_ps(f, odd_mask); // Multiply odd integers by themselves\n      |                ^~~~~~\n      |                ;\n[REDACTED]/tmp2fidh4ot.cpp:42:16: error: expected \u2018;\u2019 before \u2018even_f\u2019\n   42 |         __m256f even_f = _mm256_mul_ps(f, even_mask); // Multiply even integers by themselves\n      |                ^~~~~~~\n      |                ;\n[REDACTED]/tmp2fidh4ot.cpp:43:16: error: expected \u2018;\u2019 before \u2018sum_odd\u2019\n   43 |         __m256f sum_odd = _mm256_add_ps(odd_f, even_f); // Add the sums of odd and even integers\n      |                ^~~~~~~~\n      |                ;\n[REDACTED]/tmp2fidh4ot.cpp:44:53: error: \u2018sum_odd\u2019 was not declared in this scope\n   44 |         v = _mm256_add_epi64(v, _mm256_castps_si256(sum_odd)); // Add the sums to the zero vector\n      |                                                     ^~~~~~~\n"}
{"task_id": "SimdBench_134_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpo6odq90k.cpp: In function \u2018uint64_t double_the_difference_simd(const std::vector<float>&)\u2019:\n[REDACTED]/tmpo6odq90k.cpp:38:13: error: \u2018__m256f\u2019 was not declared in this scope; did you mean \u2018__m256i\u2019?\n   38 |             __m256f fnum = _mm256_set1_ps(num);\n      |             ^~~~~~~\n      |             __m256i\n[REDACTED]/tmpo6odq90k.cpp:39:20: error: expected \u2018;\u2019 before \u2018square\u2019\n   39 |             __m256f square = _mm256_mul_ps(fnum, fnum);\n      |                    ^~~~~~~\n      |                    ;\n[REDACTED]/tmpo6odq90k.cpp:40:66: error: \u2018square\u2019 was not declared in this scope\n   40 |             __m256i mask = _mm256_cmpgt_epi32(_mm256_cvtps_epi32(square), _mm256_setzero_si256());\n      |                                                                  ^~~~~~\n[REDACTED]/tmpo6odq90k.cpp:44:56: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   44 |             __m256i odd_square_int = _mm256_cvtepi32_ps(odd_square);\n      |                                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n      |                                                        |\n      |                                                        __m256\n[REDACTED]/tmpo6odq90k.cpp:45:23: error: \u2018_mm256_reduce_add_epi32\u2019 was not declared in this scope; did you mean \u2018_mm512_reduce_add_epi32\u2019?\n   45 |             result += _mm256_reduce_add_epi32(odd_square_int);\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~\n      |                       _mm512_reduce_add_epi32\n"}
{"task_id": "SimdBench_135_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpbedv_bx_.cpp: In function \u2018std::vector<int> compare_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmpbedv_bx_.cpp:37:44: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   37 |     __m256i result_vec = _mm256_cvtepi32_ps(abs_diff_vec);\n      |                          ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpbedv_bx_.cpp:16:\n[REDACTED]/tmpbedv_bx_.cpp:38:27: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   38 |     __m256i result_ints = _mm256_extract_epi32(result_vec, 0);\n      |                           ^~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\n[REDACTED]/tmpbedv_bx_.cpp:40:41: error: request for member \u2018size\u2019 in \u2018result_ints\u2019, which is of non-class type \u2018__m256i\u2019\n   40 |     std::vector<int> result(result_ints.size());\n      |                                         ^~~~\n"}
{"task_id": "SimdBench_135_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmp_fnh5_ql.cpp:43:107: error: macro \"_mm256_shuffle_epi32\" passed 3 arguments, but takes just 2\n   43 |     __m256 sum = _mm256_add_epi32(_mm256_add_epi32(diff_vec, _mm256_shuffle_epi32(diff_vec, diff_vec, 0b10)), _mm256_shuffle_epi32(diff_vec, diff_vec, 0b01));\n      |                                                                                                           ^\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:51,\n                 from [REDACTED]/tmp_fnh5_ql.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:616: note: macro \"_mm256_shuffle_epi32\" defined here\n  616 | #define _mm256_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmp_fnh5_ql.cpp:43:156: error: macro \"_mm256_shuffle_epi32\" passed 3 arguments, but takes just 2\n   43 |     __m256 sum = _mm256_add_epi32(_mm256_add_epi32(diff_vec, _mm256_shuffle_epi32(diff_vec, diff_vec, 0b10)), _mm256_shuffle_epi32(diff_vec, diff_vec, 0b01));\n      |                                                                                                                                                            ^\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:616: note: macro \"_mm256_shuffle_epi32\" defined here\n  616 | #define _mm256_shuffle_epi32(A, N) \\\n      | \n[REDACTED]/tmp_fnh5_ql.cpp: In function \u2018std::vector<int> compare_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmp_fnh5_ql.cpp:40:16: error: \u2018_mm256_sqr_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_xor_epi32\u2019?\n   40 |     diff_vec = _mm256_sqr_epi32(diff_vec);\n      |                ^~~~~~~~~~~~~~~~\n      |                _mm256_xor_epi32\n[REDACTED]/tmp_fnh5_ql.cpp:43:62: error: \u2018_mm256_shuffle_epi32\u2019 was not declared in this scope\n   43 |     __m256 sum = _mm256_add_epi32(_mm256_add_epi32(diff_vec, _mm256_shuffle_epi32(diff_vec, diff_vec, 0b10)), _mm256_shuffle_epi32(diff_vec, diff_vec, 0b01));\n      |                                                              ^~~~~~~~~~~~~~~~~~~~\n[REDACTED]/tmp_fnh5_ql.cpp:44:29: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   44 |     sum = _mm256_hadd_epi32(sum, sum);\n      |                             ^~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:295:28: note:   initializing argument 1 of \u2018__m256i _mm256_hadd_epi32(__m256i, __m256i)\u2019\n  295 | _mm256_hadd_epi32 (__m256i __X, __m256i __Y)\n      |                    ~~~~~~~~^~~\n[REDACTED]/tmp_fnh5_ql.cpp:45:29: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019\n   45 |     sum = _mm256_hadd_epi32(sum, sum);\n      |                             ^~~\n      |                             |\n      |                             __m256\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avx2intrin.h:295:28: note:   initializing argument 1 of \u2018__m256i _mm256_hadd_epi32(__m256i, __m256i)\u2019\n  295 | _mm256_hadd_epi32 (__m256i __X, __m256i __Y)\n      |                    ~~~~~~~~^~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43:\n[REDACTED]/tmp_fnh5_ql.cpp:49:62: error: cannot convert \u2018int\u2019 to \u2018__m128i\u2019\n   49 |     _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[0]), _mm256_extract_epi32(sum, 0));\n      |                                                              ^~~~~~~~~~~~~~~~~~~~\n      |                                                              |\n      |                                                              int\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/pmmintrin.h:31,\n                 from /usr/include/x86_64-linux-gnu/c++/13/bits/opt_random.h:34,\n                 from /usr/include/c++/13/random:52,\n                 from [REDACTED]/utils.hpp:6,\n                 from [REDACTED]/tmp_fnh5_ql.cpp:14:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/emmintrin.h:740:43: note:   initializing argument 2 of \u2018void _mm_storeu_si128(__m128i_u*, __m128i)\u2019\n  740 | _mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n      |                                   ~~~~~~~~^~~\n"}
{"task_id": "SimdBench_135_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpl91w9ql7.cpp: In function \u2018std::vector<int> compare_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmpl91w9ql7.cpp:38:44: error: cannot convert \u2018__m256\u2019 to \u2018__m256i\u2019 in initialization\n   38 |     __m256i result_vec = _mm256_cvtepi32_ps(abs_diff_vec);\n      |                          ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                                            |\n      |                                            __m256\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpl91w9ql7.cpp:16:\n[REDACTED]/tmpl91w9ql7.cpp:39:27: error: cannot convert \u2018int\u2019 to \u2018__m256i\u2019 in initialization\n   39 |     __m256i result_ints = _mm256_extract_epi32(result_vec, 0);\n      |                           ^~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\n"}
{"task_id": "SimdBench_135_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpdb6ojo3a.cpp: In function \u2018std::vector<int> compare_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmpdb6ojo3a.cpp:38:80: error: too few arguments to function \u2018__m256i _mm256_set_epi32(int, int, int, int, int, int, int, int)\u2019\n   38 |     __m256i result_vec = _mm256_permutevar_epi32(abs_diff_vec, _mm256_set_epi32(0, 1, 2, 3));\n      |                                                                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~\nIn file included from /usr/lib/gcc/x86_64-linux-gnu/13/include/immintrin.h:43,\n                 from [REDACTED]/tmpdb6ojo3a.cpp:16:\n/usr/lib/gcc/x86_64-linux-gnu/13/include/avxintrin.h:1274:1: note: declared here\n 1274 | _mm256_set_epi32 (int __A, int __B, int __C, int __D,\n      | ^~~~~~~~~~~~~~~~\n[REDACTED]/tmpdb6ojo3a.cpp:38:26: error: \u2018_mm256_permutevar_epi32\u2019 was not declared in this scope; did you mean \u2018_mm256_permutexvar_epi32\u2019?\n   38 |     __m256i result_vec = _mm256_permutevar_epi32(abs_diff_vec, _mm256_set_epi32(0, 1, 2, 3));\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~\n      |                          _mm256_permutexvar_epi32\n[REDACTED]/tmpdb6ojo3a.cpp:41:5: error: \u2018_mm256_storeu_si128\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si128\u2019?\n   41 |     _mm256_storeu_si128(reinterpret_cast<__m128i*>(&result[0]), result_vec);\n      |     ^~~~~~~~~~~~~~~~~~~\n      |     _mm_storeu_si128\n"}
{"task_id": "SimdBench_135_AVX", "passed": false, "result": "compilation failed: [REDACTED]/tmpk2e4e774.cpp: In function \u2018std::vector<int> compare_simd(const std::vector<int>&, const std::vector<int>&)\u2019:\n[REDACTED]/tmpk2e4e774.cpp:37:9: error: \u2018_mm_storeu_si256\u2019 was not declared in this scope; did you mean \u2018_mm_storeu_si16\u2019?\n   37 |         _mm_storeu_si256(reinterpret_cast<__m256i*>(&diff[i]), diff_vec);\n      |         ^~~~~~~~~~~~~~~~\n      |         _mm_storeu_si16\n"}
